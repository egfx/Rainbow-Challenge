(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _rainbow = require('./my_modules/rainbow');

var _rainbow2 = _interopRequireDefault(_rainbow);

var _utils = require('./my_modules/utils');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var data = require('./resource/resource.json');

var rainbow = {
	image: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=',
	type: 'single' // possible values: 'single' 'double'
};

var jsonMap = (0, _utils.objToStrMap)(data);

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
	for (var _iterator = jsonMap.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
		var _step$value = _slicedToArray(_step.value, 2);

		var key = _step$value[0];
		var value = _step$value[1];

		if (key == rainbow.type) {
			rainbow.image = value[Math.floor(Math.random() * value.length)];
			break;
		}
	}
} catch (err) {
	_didIteratorError = true;
	_iteratorError = err;
} finally {
	try {
		if (!_iteratorNormalCompletion && _iterator.return) {
			_iterator.return();
		}
	} finally {
		if (_didIteratorError) {
			throw _iteratorError;
		}
	}
}

_reactDom2.default.render(_react2.default.createElement(_rainbow2.default, { image: rainbow.image, type: rainbow.type }), document.querySelector('.root'));

},{"./my_modules/rainbow":2,"./my_modules/utils":3,"./resource/resource.json":172,"react":170,"react-dom":5}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var microlight = require('../plugin/microlight.js');

var Rainbow = function (_React$Component) {
    _inherits(Rainbow, _React$Component);

    function Rainbow(props) {
        _classCallCheck(this, Rainbow);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Rainbow).call(this, props));

        _this.state = {
            image: props.image,
            type: props.type
        };
        return _this;
    }

    _createClass(Rainbow, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.turnToAscii();
        }
    }, {
        key: 'turnToAscii',
        value: function turnToAscii() {
            var _this2 = this;

            var image = new Image(),
                canvas = document.getElementById("inputImage"),
                ctx = canvas.getContext("2d"),
                cell = { width: 8, height: 13 },
                chars = {},
                scale = 1;

            canvas.style.display = "none";

            canvas.width = cell.width;
            canvas.height = cell.height;
            ctx.font = cell.height + "px monospace";

            function clear() {
                ctx.fillStyle = "#FFF";
                ctx.fillRect(0, 0, cell.width, cell.height);
            }

            function getCharData(character) {
                if (character == "_") {
                    return;
                }

                clear();
                ctx.fillStyle = "#000";
                ctx.fillText(character, 0, cell.height / 1.2);

                chars[character] = ctx.getImageData(0, 0, cell.width, cell.height).data;
            }

            var characters = "#*+`Â´'.:dbPUVMWA<>Xx ".split("");

            for (var c = 32; c < 127; c++) {
                getCharData(String.fromCharCode(c));
            }

            function getNearest(imageData) {
                var charData = void 0,
                    min = Infinity,
                    best = " ",
                    c = void 0,
                    i = void 0,
                    diff = void 0;

                for (c in chars) {
                    charData = chars[c];
                    diff = 0;

                    for (i = 0; i < charData.length; i += 4) {
                        if (imageData[i + 3]) {
                            diff += Math.abs(imageData[i] > 200 != charData[i] > 200);
                        }
                    }

                    if (diff < min) {
                        min = diff;
                        best = c;
                    }
                }

                if (best == "Q" || best == "M") {
                    return "#";
                }

                return best;
            }

            image.onload = function () {
                var out = "",
                    width = image.width * scale,
                    height = image.height * scale,
                    scaledHeight = height * 0.92,
                    data = void 0,
                    x = void 0,
                    y = void 0;

                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(image, 0, 0, width, scaledHeight);

                for (y = 0; y < scaledHeight; y += cell.height + 2) {
                    for (x = 0; x < width; x += cell.width) {
                        data = ctx.getImageData(x, y, cell.width, cell.height).data;
                        out += getNearest(data);
                    }

                    out += "\n";
                }

                ctx.drawImage(image, 0, 0, width, height);

                var $el = document.getElementById("outputAscii");

                $el.innerText = out;

                _this2.colorTheAscii($el);
            };

            image.src = this.state.image;
        }
    }, {
        key: 'colorTheAscii',
        value: function colorTheAscii($el) {

            var letters = $el.innerHTML.split('');

            var colToHex = function colToHex(c) {
                var color = c < 75 ? c + 75 : c;
                var hex = color.toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            };

            var rgbToHex = function rgbToHex(r, g, b) {
                return "#" + colToHex(r) + colToHex(g) + colToHex(b);
            };

            var getRandomColor = function getRandomColor() {
                return rgbToHex(Math.floor(Math.random() * 255), Math.floor(Math.random() * 255), Math.floor(Math.random() * 255));
            };

            Array.prototype.randomColor = function () {
                var html = '';
                this.map(function (letter) {
                    var color = getRandomColor();
                    html += "<span class=\"microlight\" style=\"color:" + color + "\">" + letter + "</span>";
                });
                return html;
            };

            document.getElementById('outputAscii').innerHTML = letters.randomColor();

            this.makeItSparkle();
        }
    }, {
        key: 'makeItSparkle',
        value: function makeItSparkle() {
            var spans = document.getElementsByTagName('span');
            setInterval(function () {
                var bucket = Array.prototype.slice.call(spans),
                    target = bucket[Math.floor(Math.random() * bucket.length)];
                target.classList.toggle('microlight');
            }, 10);
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(
                'div',
                { id: 'output' },
                _react2.default.createElement('canvas', { id: 'inputImage' }),
                _react2.default.createElement('pre', { id: 'outputAscii' })
            );
        }
    }]);

    return Rainbow;
}(_react2.default.Component);

exports.default = Rainbow;

},{"../plugin/microlight.js":171,"react":170}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.mapToJson = mapToJson;
exports.jsonToMap = jsonToMap;
exports.strMapToObj = strMapToObj;
exports.objToStrMap = objToStrMap;
exports.strMapToJson = strMapToJson;
exports.jsonToStrMap = jsonToStrMap;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* ES6 JSON/MAP utils --
	inspired by http://www.2ality.com/2015/08/es6-map-json.html */

function mapToJson(map) {
    return JSON.stringify([].concat(_toConsumableArray(map)));
}
function jsonToMap(jsonStr) {
    return new Map(JSON.parse(jsonStr));
}
function strMapToObj(strMap) {
    var obj = Object.create(null);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = strMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2);

            var k = _step$value[0];
            var v = _step$value[1];

            // We donât escape the key '__proto__'
            // which can cause problems on older engines
            obj[k] = v;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return obj;
}
function objToStrMap(obj) {
    var strMap = new Map();
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = Object.keys(obj)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var k = _step2.value;

            strMap.set(k, obj[k]);
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return strMap;
}
function strMapToJson(strMap) {
    return JSON.stringify(this.strMapToObj(strMap));
}
function jsonToStrMap(jsonStr) {
    return this.objToStrMap(JSON.parse(jsonStr));
}

},{}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
'use strict';

module.exports = require('react/lib/ReactDOM');

},{"react/lib/ReactDOM":42}],6:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AutoFocusUtils
 */

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var focusNode = require('fbjs/lib/focusNode');

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;
},{"./ReactDOMComponentTree":46,"fbjs/lib/focusNode":152}],7:[function(require,module,exports){
/**
 * Copyright 2013-present Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BeforeInputEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var FallbackCompositionState = require('./FallbackCompositionState');
var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
var SyntheticInputEvent = require('./SyntheticInputEvent');

var keyOf = require('fbjs/lib/keyOf');

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBeforeInput: null }),
      captured: keyOf({ onBeforeInputCapture: null })
    },
    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionEnd: null }),
      captured: keyOf({ onCompositionEndCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionStart: null }),
      captured: keyOf({ onCompositionStartCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionUpdate: null }),
      captured: keyOf({ onCompositionUpdateCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionEnd:
      return getDataFromCustomEvent(nativeEvent);
    case topLevelTypes.topKeyPress:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case topLevelTypes.topTextInput:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  if (currentComposition) {
    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case topLevelTypes.topPaste:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case topLevelTypes.topKeyPress:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case topLevelTypes.topCompositionEnd:
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventConstants":21,"./EventPropagators":25,"./FallbackCompositionState":26,"./SyntheticCompositionEvent":101,"./SyntheticInputEvent":105,"fbjs/lib/ExecutionEnvironment":144,"fbjs/lib/keyOf":162}],8:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],9:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSPropertyOperations
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactInstrumentation = require('./ReactInstrumentation');

var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
var dangerousStyleValue = require('./dangerousStyleValue');
var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
var warning = require('fbjs/lib/warning');

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if (process.env.NODE_ENV !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
  };

  var warnBadVendoredStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
  };

  var warnStyleValueWithSemicolon = function (name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
  };

  var warnStyleValueIsNaN = function (name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
  };

  var checkRenderMessage = function (owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function (name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styleValue, component);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onNativeOperation(component._debugID, 'update styles', styles);
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styles[styleName], component);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;
}).call(this,require('_process'))

},{"./CSSProperty":8,"./ReactInstrumentation":75,"./dangerousStyleValue":118,"_process":4,"fbjs/lib/ExecutionEnvironment":144,"fbjs/lib/camelizeStyleName":146,"fbjs/lib/hyphenateStyleName":157,"fbjs/lib/memoizeStringOnly":164,"fbjs/lib/warning":168}],10:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CallbackQueue
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var invariant = require('fbjs/lib/invariant');

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

_assign(CallbackQueue.prototype, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function (callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function () {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  checkpoint: function () {
    return this._callbacks ? this._callbacks.length : 0;
  },

  rollback: function (len) {
    if (this._callbacks) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function () {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function () {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;
}).call(this,require('_process'))

},{"./PooledClass":30,"_process":4,"fbjs/lib/invariant":158,"object-assign":169}],11:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ChangeEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');
var isEventSupported = require('./isEventSupported');
var isTextInputElement = require('./isTextInputElement');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onChange: null }),
      captured: keyOf({ onChangeCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === topLevelTypes.topChange) {
    return targetInst;
  }
}
function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  // IE10+ fire input events to often, such when a placeholder
  // changes or when an input with a placeholder is focused.
  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 11);
}

/**
 * (For IE <=11) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For IE <=11) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  if (activeElement.attachEvent) {
    activeElement.attachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.addEventListener('propertychange', handlePropertyChange, false);
  }
}

/**
 * (For IE <=11) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;

  if (activeElement.detachEvent) {
    activeElement.detachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
  }

  activeElement = null;
  activeElementInst = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For IE <=11) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetInstForInputEvent(topLevelType, targetInst) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return targetInst;
  }
}

function handleEventsForInputEventIE(topLevelType, target, targetInst) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9-11, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventIE(topLevelType, targetInst) {
  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementInst;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === topLevelTypes.topClick) {
    return targetInst;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"./EventConstants":21,"./EventPluginHub":22,"./EventPropagators":25,"./ReactDOMComponentTree":46,"./ReactUpdates":94,"./SyntheticEvent":103,"./getEventTarget":126,"./isEventSupported":133,"./isTextInputElement":134,"fbjs/lib/ExecutionEnvironment":144,"fbjs/lib/keyOf":162}],12:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMChildrenOperations
 */

'use strict';

var DOMLazyTree = require('./DOMLazyTree');
var Danger = require('./Danger');
var ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getNativeNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onNativeOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== 'production') {
  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onNativeOperation(prevInstance._debugID, 'replace with', markup.toString());
    } else {
      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onNativeOperation(nextInstance._debugID, 'mount', markup.toString());
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    if (process.env.NODE_ENV !== 'production') {
      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onNativeOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });
          }
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onNativeOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });
          }
          break;
        case ReactMultiChildUpdateTypes.SET_MARKUP:
          setInnerHTML(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onNativeOperation(parentNodeDebugID, 'replace children', update.content.toString());
          }
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          setTextContent(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onNativeOperation(parentNodeDebugID, 'replace text', update.content.toString());
          }
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          removeChild(parentNode, update.fromNode);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onNativeOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });
          }
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;
}).call(this,require('_process'))

},{"./DOMLazyTree":13,"./Danger":17,"./ReactDOMComponentTree":46,"./ReactInstrumentation":75,"./ReactMultiChildUpdateTypes":80,"./createMicrosoftUnsafeLocalFunction":117,"./setInnerHTML":138,"./setTextContent":139,"_process":4}],13:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMLazyTree
 */

'use strict';

var DOMNamespaces = require('./DOMNamespaces');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setTextContent = require('./setTextContent');

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    node.innerHTML = tree.html;
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    tree.node.innerHTML = html;
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;
},{"./DOMNamespaces":14,"./createMicrosoftUnsafeLocalFunction":117,"./setTextContent":139}],14:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMNamespaces
 */

'use strict';

var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;
},{}],15:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMProperty
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_SIDE_EFFECTS: 0x2,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };

      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : void 0;
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : void 0;

      if (process.env.NODE_ENV !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if (process.env.NODE_ENV !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\uB7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasSideEffects:
   *   Whether or not setting a value causes side effects such as triggering
   *   resources to be loaded or text selection changes. If true, we read from
   *   the DOM before updating to ensure that the value is only set if it has
   *   changed.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   * @type {Object}
   */
  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],16:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMPropertyOperations
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMInstrumentation = require('./ReactDOMInstrumentation');
var ReactInstrumentation = require('./ReactInstrumentation');

var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
var warning = require('fbjs/lib/warning');

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    if (process.env.NODE_ENV !== 'production') {
      ReactDOMInstrumentation.debugTool.onCreateMarkupForProperty(name, value);
    }
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
        // property type before comparing; only `value` does and is string.
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propName] = value;
        }
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      ReactDOMInstrumentation.debugTool.onSetValueForProperty(node, name, value);
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onNativeOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onNativeOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          // No HAS_SIDE_EFFECTS logic here, only `value` has it and is string.
          node[propName] = false;
        } else {
          if (!propertyInfo.hasSideEffects || '' + node[propName] !== '') {
            node[propName] = '';
          }
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    if (process.env.NODE_ENV !== 'production') {
      ReactDOMInstrumentation.debugTool.onDeleteValueForProperty(node, name);
      ReactInstrumentation.debugTool.onNativeOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
    }
  }

};

module.exports = DOMPropertyOperations;
}).call(this,require('_process'))

},{"./DOMProperty":15,"./ReactDOMComponentTree":46,"./ReactDOMInstrumentation":54,"./ReactInstrumentation":75,"./quoteAttributeValueForBrowser":136,"_process":4,"fbjs/lib/warning":168}],17:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Danger
 */

'use strict';

var DOMLazyTree = require('./DOMLazyTree');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
var emptyFunction = require('fbjs/lib/emptyFunction');
var getMarkupWrap = require('fbjs/lib/getMarkupWrap');
var invariant = require('fbjs/lib/invariant');

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function (markupList) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : void 0;
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : void 0;
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      var resultIndex;
      for (resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
          // This index will be parsed back out below.
          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
      );

      for (var j = 0; j < renderNodes.length; ++j) {
        var renderNode = renderNodes[j];
        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : void 0;

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;
        } else if (process.env.NODE_ENV !== 'production') {
          console.error('Danger: Discarding unexpected node:', renderNode);
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : void 0;

    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : void 0;

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : void 0;
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : void 0;
    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }

};

module.exports = Danger;
}).call(this,require('_process'))

},{"./DOMLazyTree":13,"_process":4,"fbjs/lib/ExecutionEnvironment":144,"fbjs/lib/createNodesFromMarkup":149,"fbjs/lib/emptyFunction":150,"fbjs/lib/getMarkupWrap":154,"fbjs/lib/invariant":158}],18:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultEventPluginOrder
 */

'use strict';

var keyOf = require('fbjs/lib/keyOf');

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

module.exports = DefaultEventPluginOrder;
},{"fbjs/lib/keyOf":162}],19:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DisabledInputUtils
 */

'use strict';

var disableableMouseListenerNames = {
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,

  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
};

/**
 * Implements a native component that does not receive mouse events
 * when `disabled` is set.
 */
var DisabledInputUtils = {
  getNativeProps: function (inst, props) {
    if (!props.disabled) {
      return props;
    }

    // Copy the props, except the mouse listeners
    var nativeProps = {};
    for (var key in props) {
      if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
        nativeProps[key] = props[key];
      }
    }

    return nativeProps;
  }
};

module.exports = DisabledInputUtils;
},{}],20:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EnterLeaveEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');

var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({ onMouseEnter: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  },
  mouseLeave: {
    registrationName: keyOf({ onMouseLeave: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  }
};

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }

};

module.exports = EnterLeaveEventPlugin;
},{"./EventConstants":21,"./EventPropagators":25,"./ReactDOMComponentTree":46,"./SyntheticMouseEvent":107,"fbjs/lib/keyOf":162}],21:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var PropagationPhases = keyMirror({ bubbled: null, captured: null });

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topAbort: null,
  topAnimationEnd: null,
  topAnimationIteration: null,
  topAnimationStart: null,
  topBlur: null,
  topCanPlay: null,
  topCanPlayThrough: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topDurationChange: null,
  topEmptied: null,
  topEncrypted: null,
  topEnded: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topInvalid: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topLoadedData: null,
  topLoadedMetadata: null,
  topLoadStart: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topPause: null,
  topPlay: null,
  topPlaying: null,
  topProgress: null,
  topRateChange: null,
  topReset: null,
  topScroll: null,
  topSeeked: null,
  topSeeking: null,
  topSelectionChange: null,
  topStalled: null,
  topSubmit: null,
  topSuspend: null,
  topTextInput: null,
  topTimeUpdate: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topTransitionEnd: null,
  topVolumeChange: null,
  topWaiting: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;
},{"fbjs/lib/keyMirror":161}],22:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

'use strict';

var EventPluginRegistry = require('./EventPluginRegistry');
var EventPluginUtils = require('./EventPluginUtils');
var ReactErrorUtils = require('./ReactErrorUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var invariant = require('fbjs/lib/invariant');

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : void 0;

    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[inst._rootNodeID] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[inst._rootNodeID];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      delete bankForRegistrationName[inst._rootNodeID];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    for (var registrationName in listenerBank) {
      if (!listenerBank[registrationName][inst._rootNodeID]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][inst._rootNodeID];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
}).call(this,require('_process'))

},{"./EventPluginRegistry":23,"./EventPluginUtils":24,"./ReactErrorUtils":68,"./accumulateInto":114,"./forEachAccumulated":122,"_process":4,"fbjs/lib/invariant":158}],23:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;

  if (process.env.NODE_ENV !== 'production') {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (InjectedEventPluginOrder) {
    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : void 0;
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }

};

module.exports = EventPluginRegistry;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],24:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

'use strict';

var EventConstants = require('./EventConstants');
var ReactErrorUtils = require('./ReactErrorUtils');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
    }
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
}

var validateEventDispatches;
if (process.env.NODE_ENV !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
}).call(this,require('_process'))

},{"./EventConstants":21,"./ReactErrorUtils":68,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168}],25:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var warning = require('fbjs/lib/warning');

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, upwards, event) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
}).call(this,require('_process'))

},{"./EventConstants":21,"./EventPluginHub":22,"./EventPluginUtils":24,"./accumulateInto":114,"./forEachAccumulated":122,"_process":4,"fbjs/lib/warning":168}],26:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FallbackCompositionState
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./PooledClass":30,"./getTextContentAccessor":130,"object-assign":169}],27:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

'use strict';

var DOMProperty = require('./DOMProperty');

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {}
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":15}],28:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule KeyEscapeUtils
 */

'use strict';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {*} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;
},{}],29:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedValueUtils
 */

'use strict';

var ReactPropTypes = require('./ReactPropTypes');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: ReactPropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
}).call(this,require('_process'))

},{"./ReactPropTypeLocations":87,"./ReactPropTypes":88,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168}],30:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],31:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

var _assign = require('object-assign');

var ReactChildren = require('./ReactChildren');
var ReactComponent = require('./ReactComponent');
var ReactClass = require('./ReactClass');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactElementValidator = require('./ReactElementValidator');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var onlyChild = require('./onlyChild');
var warning = require('fbjs/lib/warning');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

if (process.env.NODE_ENV !== 'production') {
  var warned = false;
  __spread = function () {
    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

module.exports = React;
}).call(this,require('_process'))

},{"./ReactChildren":34,"./ReactClass":35,"./ReactComponent":36,"./ReactDOMFactories":50,"./ReactElement":65,"./ReactElementValidator":66,"./ReactPropTypes":88,"./ReactVersion":95,"./onlyChild":135,"_process":4,"fbjs/lib/warning":168,"object-assign":169}],32:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserEventEmitter
 */

'use strict';

var _assign = require('object-assign');

var EventConstants = require('./EventConstants');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
var ViewportMetrics = require('./ViewportMetrics');

var getVendorPrefixedEventName = require('./getVendorPrefixedEventName');
var isEventSupported = require('./isEventSupported');

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = document.createEvent && 'pageX' in document.createEvent('MouseEvent');
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

module.exports = ReactBrowserEventEmitter;
},{"./EventConstants":21,"./EventPluginRegistry":23,"./ReactEventEmitterMixin":69,"./ViewportMetrics":113,"./getVendorPrefixedEventName":131,"./isEventSupported":133,"object-assign":169}],33:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildReconciler
 */

'use strict';

var ReactReconciler = require('./ReactReconciler');

var instantiateReactComponent = require('./instantiateReactComponent');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

function instantiateChild(childInstances, child, name) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', KeyEscapeUtils.unescape(name)) : void 0;
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};
    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, removedNodes, transaction, context) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getNativeNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement);
        nextChildren[name] = nextChildInstance;
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getNativeNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }

};

module.exports = ReactChildReconciler;
}).call(this,require('_process'))

},{"./KeyEscapeUtils":28,"./ReactReconciler":90,"./instantiateReactComponent":132,"./shouldUpdateReactComponent":140,"./traverseAllChildren":141,"_process":4,"fbjs/lib/warning":168}],34:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result;
  var keyPrefix = bookKeeping.keyPrefix;
  var func = bookKeeping.func;
  var context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"./PooledClass":30,"./ReactElement":65,"./traverseAllChildren":141,"fbjs/lib/emptyFunction":150}],35:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */

'use strict';

var _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var keyMirror = require('fbjs/lib/keyMirror');
var keyOf = require('fbjs/lib/keyOf');
var warning = require('fbjs/lib/warning');

var MIXINS_KEY = keyOf({ mixins: null });

/**
 * Policies that describe methods in `ReactClassInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});

var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

// noop
function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.') : invariant(false) : void 0;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    var Constructor = function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : void 0;

      this.state = initialState;
    };
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
}).call(this,require('_process'))

},{"./ReactComponent":36,"./ReactElement":65,"./ReactNoopUpdateQueue":84,"./ReactPropTypeLocationNames":86,"./ReactPropTypeLocations":87,"_process":4,"fbjs/lib/emptyObject":151,"fbjs/lib/invariant":158,"fbjs/lib/keyMirror":161,"fbjs/lib/keyOf":162,"fbjs/lib/warning":168,"object-assign":169}],36:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

'use strict';

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');
var ReactInstrumentation = require('./ReactInstrumentation');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : void 0;
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onSetState();
    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
  }
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
}).call(this,require('_process'))

},{"./ReactInstrumentation":75,"./ReactNoopUpdateQueue":84,"./canDefineProperty":116,"_process":4,"fbjs/lib/emptyObject":151,"fbjs/lib/invariant":158,"fbjs/lib/warning":168}],37:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMIDOperations = require('./ReactDOMIDOperations');

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function (rootNodeID) {}

};

module.exports = ReactComponentBrowserEnvironment;
},{"./DOMChildrenOperations":12,"./ReactDOMIDOperations":52}],38:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentEnvironment
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable environment dependent cleanup hook. (server vs.
   * browser etc). Example: A browser system caches DOM nodes based on component
   * ID and must remove that cache entry when this instance is unmounted.
   */
  unmountIDFromEnvironment: null,

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : void 0;
      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],39:[function(require,module,exports){
(function (process){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentTreeDevtool
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

var tree = {};
var rootIDs = [];

function updateTree(id, update) {
  if (!tree[id]) {
    tree[id] = {
      parentID: null,
      ownerID: null,
      text: null,
      childIDs: [],
      displayName: 'Unknown',
      isMounted: false,
      updateCount: 0
    };
  }
  update(tree[id]);
}

function purgeDeep(id) {
  var item = tree[id];
  if (item) {
    var childIDs = item.childIDs;

    delete tree[id];
    childIDs.forEach(purgeDeep);
  }
}

var ReactComponentTreeDevtool = {
  onSetDisplayName: function (id, displayName) {
    updateTree(id, function (item) {
      return item.displayName = displayName;
    });
  },
  onSetChildren: function (id, nextChildIDs) {
    updateTree(id, function (item) {
      var prevChildIDs = item.childIDs;
      item.childIDs = nextChildIDs;

      nextChildIDs.forEach(function (nextChildID) {
        var nextChild = tree[nextChildID];
        !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected devtool events to fire for the child ' + 'before its parent includes it in onSetChildren().') : invariant(false) : void 0;
        !(nextChild.displayName != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetDisplayName() to fire for the child ' + 'before its parent includes it in onSetChildren().') : invariant(false) : void 0;
        !(nextChild.childIDs != null || nextChild.text != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() or onSetText() to fire for the child ' + 'before its parent includes it in onSetChildren().') : invariant(false) : void 0;
        !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child ' + 'before its parent includes it in onSetChildren().') : invariant(false) : void 0;

        if (prevChildIDs.indexOf(nextChildID) === -1) {
          nextChild.parentID = id;
        }
      });
    });
  },
  onSetOwner: function (id, ownerID) {
    updateTree(id, function (item) {
      return item.ownerID = ownerID;
    });
  },
  onSetText: function (id, text) {
    updateTree(id, function (item) {
      return item.text = text;
    });
  },
  onMountComponent: function (id) {
    updateTree(id, function (item) {
      return item.isMounted = true;
    });
  },
  onMountRootComponent: function (id) {
    rootIDs.push(id);
  },
  onUpdateComponent: function (id) {
    updateTree(id, function (item) {
      return item.updateCount++;
    });
  },
  onUnmountComponent: function (id) {
    updateTree(id, function (item) {
      return item.isMounted = false;
    });
    rootIDs = rootIDs.filter(function (rootID) {
      return rootID !== id;
    });
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeDevtool._preventPurging) {
      // Should only be used for testing.
      return;
    }

    Object.keys(tree).filter(function (id) {
      return !tree[id].isMounted;
    }).forEach(purgeDeep);
  },
  isMounted: function (id) {
    var item = tree[id];
    return item ? item.isMounted : false;
  },
  getChildIDs: function (id) {
    var item = tree[id];
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var item = tree[id];
    return item ? item.displayName : 'Unknown';
  },
  getOwnerID: function (id) {
    var item = tree[id];
    return item ? item.ownerID : null;
  },
  getParentID: function (id) {
    var item = tree[id];
    return item ? item.parentID : null;
  },
  getText: function (id) {
    var item = tree[id];
    return item ? item.text : null;
  },
  getUpdateCount: function (id) {
    var item = tree[id];
    return item ? item.updateCount : 0;
  },
  getRootIDs: function () {
    return rootIDs;
  },
  getRegisteredIDs: function () {
    return Object.keys(tree);
  }
};

module.exports = ReactComponentTreeDevtool;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],40:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

'use strict';

var _assign = require('object-assign');

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactErrorUtils = require('./ReactErrorUtils');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactNodeTypes = require('./ReactNodeTypes');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum(component) {
  var owner = component._currentElement._owner || null;
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || ReactElement.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
  }
}

function invokeComponentDidMountWithTimer() {
  var publicInstance = this._instance;
  if (this._debugID !== 0) {
    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');
  }
  publicInstance.componentDidMount();
  if (this._debugID !== 0) {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');
  }
}

function invokeComponentDidUpdateWithTimer(prevProps, prevState, prevContext) {
  var publicInstance = this._instance;
  if (this._debugID !== 0) {
    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidUpdate');
  }
  publicInstance.componentDidUpdate(prevProps, prevState, prevContext);
  if (this._debugID !== 0) {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidUpdate');
  }
}

function shouldConstruct(Component) {
  return Component.prototype && Component.prototype.isReactComponent;
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = null;
    this._instance = null;
    this._nativeParent = null;
    this._nativeContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} nativeParent
   * @param {?object} nativeContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, nativeParent, nativeContainerInfo, context) {
    this._context = context;
    this._mountOrder = nextMountID++;
    this._nativeParent = nativeParent;
    this._nativeContainerInfo = nativeContainerInfo;

    var publicProps = this._processProps(this._currentElement.props);
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    // Initialize the public class
    var inst = this._constructComponent(publicProps, publicContext);
    var renderedElement;

    // Support functional components
    if (!shouldConstruct(Component) && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || ReactElement.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : invariant(false) : void 0;
      inst = new StatelessComponent(Component);
    }

    if (process.env.NODE_ENV !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = ReactUpdateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if (process.env.NODE_ENV !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, nativeParent, nativeContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, nativeParent, nativeContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function (publicProps, publicContext) {
    if (process.env.NODE_ENV !== 'production') {
      ReactCurrentOwner.current = this;
      try {
        return this._constructComponentWithoutOwner(publicProps, publicContext);
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(publicProps, publicContext);
    }
  },

  _constructComponentWithoutOwner: function (publicProps, publicContext) {
    var Component = this._currentElement.type;
    var instanceOrElement;
    if (shouldConstruct(Component)) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'ctor');
        }
      }
      instanceOrElement = new Component(publicProps, publicContext, ReactUpdateQueue);
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'ctor');
        }
      }
    } else {
      // This can still be an instance in case of factory components
      // but we'll count this as time spent rendering as the more common case.
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
        }
      }
      instanceOrElement = Component(publicProps, publicContext, ReactUpdateQueue);
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
        }
      }
    }
    return instanceOrElement;
  },

  performInitialMountWithErrorHandling: function (renderedElement, nativeParent, nativeContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, nativeParent, nativeContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, nativeParent, nativeContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, nativeParent, nativeContainerInfo, transaction, context) {
    var inst = this._instance;
    if (inst.componentWillMount) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillMount');
        }
      }
      inst.componentWillMount();
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillMount');
        }
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    this._renderedNodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedComponent = this._instantiateReactComponent(renderedElement);

    var markup = ReactReconciler.mountComponent(this._renderedComponent, transaction, nativeParent, nativeContainerInfo, this._processChildContext(context));

    if (process.env.NODE_ENV !== 'production') {
      if (this._debugID !== 0) {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, this._renderedComponent._debugID !== 0 ? [this._renderedComponent._debugID] : []);
      }
    }

    return markup;
  },

  getNativeNode: function () {
    return ReactReconciler.getNativeNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }
    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUnmount');
        }
      }
      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        inst.componentWillUnmount();
      }
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUnmount');
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = null;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
    }
    var childContext = inst.getChildContext && inst.getChildContext();
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onEndProcessingChildContext();
    }
    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : void 0;
      if (process.env.NODE_ENV !== 'production') {
        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function (newProps) {
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.propTypes) {
        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
      }
    }
    return newProps;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function (propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the element
    // validation.
    var componentName = this.getName();
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error;
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : void 0;
          error = propTypes[propName](props, propName, componentName, location);
        } catch (ex) {
          error = ex;
        }
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // top-level render calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);

          if (location === ReactPropTypeLocations.prop) {
            // Preface gives us something to blacklist in warning module
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : void 0;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : void 0;
          }
        }
      }
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    var willReceive = false;
    var nextContext;
    var nextProps;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    // Distinguish between a props update versus a simple state update
    if (prevParentElement === nextParentElement) {
      // Skip checking prop types again -- we don't read inst.props to avoid
      // warning for DOM component props in this upgrade
      nextProps = nextParentElement.props;
    } else {
      nextProps = this._processProps(nextParentElement.props);
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
        }
      }
      inst.componentWillReceiveProps(nextProps, nextContext);
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
        }
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate && inst.shouldComponentUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
        }
      }
      shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
        }
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUpdate');
        }
      }
      inst.componentWillUpdate(nextProps, nextState, nextContext);
      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUpdate');
        }
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(invokeComponentDidUpdateWithTimer.bind(this, prevProps, prevState, prevContext), this);
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();
    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldNativeNode = ReactReconciler.getNativeNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      this._renderedNodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);

      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, transaction, this._nativeParent, this._nativeContainerInfo, this._processChildContext(context));

      if (process.env.NODE_ENV !== 'production') {
        if (this._debugID !== 0) {
          ReactInstrumentation.debugTool.onSetChildren(this._debugID, this._renderedComponent._debugID !== 0 ? [this._renderedComponent._debugID] : []);
        }
      }

      this._replaceNodeWithMarkup(oldNativeNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldNativeNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldNativeNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;

    if (process.env.NODE_ENV !== 'production') {
      if (this._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
      }
    }
    var renderedComponent = inst.render();
    if (process.env.NODE_ENV !== 'production') {
      if (this._debugID !== 0) {
        ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedComponent === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedComponent = null;
      }
    }

    return renderedComponent;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedComponent;
    ReactCurrentOwner.current = this;
    try {
      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactCurrentOwner.current = null;
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : void 0;

    return renderedComponent;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if (process.env.NODE_ENV !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (inst instanceof StatelessComponent) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

var ReactCompositeComponent = {

  Mixin: ReactCompositeComponentMixin

};

module.exports = ReactCompositeComponent;
}).call(this,require('_process'))

},{"./ReactComponentEnvironment":38,"./ReactCurrentOwner":41,"./ReactElement":65,"./ReactErrorUtils":68,"./ReactInstanceMap":74,"./ReactInstrumentation":75,"./ReactNodeTypes":83,"./ReactPropTypeLocationNames":86,"./ReactPropTypeLocations":87,"./ReactReconciler":90,"./ReactUpdateQueue":93,"./shouldUpdateReactComponent":140,"_process":4,"fbjs/lib/emptyObject":151,"fbjs/lib/invariant":158,"fbjs/lib/warning":168,"object-assign":169}],41:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */

var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],42:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactMount = require('./ReactMount');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdates = require('./ReactUpdates');
var ReactVersion = require('./ReactVersion');

var findDOMNode = require('./findDOMNode');
var getNativeComponentFromComposite = require('./getNativeComponentFromComposite');
var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
var warning = require('fbjs/lib/warning');

ReactDefaultInjection.inject();

var React = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
/* eslint-enable camelcase */
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getNativeComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

if (process.env.NODE_ENV !== 'production') {
  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
        break;
      }
    }
  }
}

module.exports = React;
}).call(this,require('_process'))

},{"./ReactDOMComponentTree":46,"./ReactDefaultInjection":64,"./ReactMount":78,"./ReactReconciler":90,"./ReactUpdates":94,"./ReactVersion":95,"./findDOMNode":120,"./getNativeComponentFromComposite":128,"./renderSubtreeIntoContainer":137,"_process":4,"fbjs/lib/ExecutionEnvironment":144,"fbjs/lib/warning":168}],43:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMButton
 */

'use strict';

var DisabledInputUtils = require('./DisabledInputUtils');

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = {
  getNativeProps: DisabledInputUtils.getNativeProps
};

module.exports = ReactDOMButton;
},{"./DisabledInputUtils":19}],44:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 */

/* global hasOwnProperty:true */

'use strict';

var _assign = require('object-assign');

var AutoFocusUtils = require('./AutoFocusUtils');
var CSSPropertyOperations = require('./CSSPropertyOperations');
var DOMLazyTree = require('./DOMLazyTree');
var DOMNamespaces = require('./DOMNamespaces');
var DOMProperty = require('./DOMProperty');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMButton = require('./ReactDOMButton');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMInput = require('./ReactDOMInput');
var ReactDOMOption = require('./ReactDOMOption');
var ReactDOMSelect = require('./ReactDOMSelect');
var ReactDOMTextarea = require('./ReactDOMTextarea');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMultiChild = require('./ReactMultiChild');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');

var emptyFunction = require('fbjs/lib/emptyFunction');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var isEventSupported = require('./isEventSupported');
var keyOf = require('fbjs/lib/keyOf');
var shallowEqual = require('fbjs/lib/shallowEqual');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = keyOf({ style: null });
var HTML = keyOf({ __html: null });
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : invariant(false) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : void 0;
  }
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
  }
  var containerInfo = inst._nativeContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setContentChildForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  setContentChildForInstrumentation = function (contentToUse) {
    var debugID = this._debugID;
    var contentDebugID = debugID + '#text';
    this._contentDebugID = contentDebugID;
    ReactInstrumentation.debugTool.onSetDisplayName(contentDebugID, '#text');
    ReactInstrumentation.debugTool.onSetText(contentDebugID, '' + contentToUse);
    ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
    ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : void 0;
  var node = getNode(inst);
  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
        }
      }

      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

// NOTE: menuitem's close tag should be omitted, but that causes problems.
var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._nativeNode = null;
  this._nativeParent = null;
  this._rootNodeID = null;
  this._domID = null;
  this._nativeContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== 'production') {
    this._ancestorInfo = null;
    this._contentDebugID = null;
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the containing DOM component instance
   * @param {?object} info about the native container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, nativeParent, nativeContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = nativeContainerInfo._idCounter++;
    this._nativeParent = nativeParent;
    this._nativeContainerInfo = nativeContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'iframe':
      case 'object':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'button':
        props = ReactDOMButton.getNativeProps(this, props, nativeParent);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, nativeParent);
        props = ReactDOMInput.getNativeProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, nativeParent);
        props = ReactDOMOption.getNativeProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, nativeParent);
        props = ReactDOMSelect.getNativeProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, nativeParent);
        props = ReactDOMTextarea.getNativeProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (nativeParent != null) {
      namespaceURI = nativeParent._namespaceURI;
      parentTag = nativeParent._tag;
    } else if (nativeContainerInfo._tag) {
      namespaceURI = nativeContainerInfo._namespaceURI;
      parentTag = nativeContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (nativeParent != null) {
        parentInfo = nativeParent._ancestorInfo;
      } else if (nativeContainerInfo._tag) {
        parentInfo = nativeContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = nativeContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else {
          el = ownerDocument.createElement(this._currentElement.type, props.is || null);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._nativeParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'button':
      case 'input':
      case 'select':
      case 'textarea':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._nativeParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
        if (process.env.NODE_ENV !== 'production') {
          setContentChildForInstrumentation.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        if (process.env.NODE_ENV !== 'production') {
          setContentChildForInstrumentation.call(this, contentToUse);
        }
        DOMLazyTree.queueText(lazyTree, contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'button':
        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
        break;
      case 'input':
        ReactDOMInput.updateWrapper(this);
        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    if (this._tag === 'select') {
      // <select> value update needs to occur after <option> children
      // reconciliation
      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        if (process.env.NODE_ENV !== 'production') {
          this._contentDebugID = this._debugID + '#text';
          setContentChildForInstrumentation.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._contentDebugID) {
          ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
          this._contentDebugID = null;
        }
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getNativeNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'iframe':
      case 'object':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : void 0;
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    this._rootNodeID = null;
    this._domID = null;
    this._wrapperState = null;

    if (process.env.NODE_ENV !== 'production') {
      if (this._contentDebugID) {
        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
        this._contentDebugID = null;
      }
    }
  },

  getPublicInstance: function () {
    return getNode(this);
  }

};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
}).call(this,require('_process'))

},{"./AutoFocusUtils":6,"./CSSPropertyOperations":9,"./DOMLazyTree":13,"./DOMNamespaces":14,"./DOMProperty":15,"./DOMPropertyOperations":16,"./EventConstants":21,"./EventPluginHub":22,"./EventPluginRegistry":23,"./ReactBrowserEventEmitter":32,"./ReactComponentBrowserEnvironment":37,"./ReactDOMButton":43,"./ReactDOMComponentFlags":45,"./ReactDOMComponentTree":46,"./ReactDOMInput":53,"./ReactDOMOption":55,"./ReactDOMSelect":56,"./ReactDOMTextarea":59,"./ReactInstrumentation":75,"./ReactMultiChild":79,"./ReactServerRenderingTransaction":92,"./escapeTextContentForBrowser":119,"./isEventSupported":133,"./validateDOMNesting":142,"_process":4,"fbjs/lib/emptyFunction":150,"fbjs/lib/invariant":158,"fbjs/lib/keyOf":162,"fbjs/lib/shallowEqual":167,"fbjs/lib/warning":168,"object-assign":169}],45:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponentFlags
 */

'use strict';

var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;
},{}],46:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponentTree
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');

var invariant = require('fbjs/lib/invariant');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Drill down (through composites and empty components) until we get a native or
 * native text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedNativeOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_nativeNode` on the rendered native/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var nativeInst = getRenderedNativeOrTextFromComponent(inst);
  nativeInst._nativeNode = node;
  node[internalInstanceKey] = nativeInst;
}

function uncacheNode(inst) {
  var node = inst._nativeNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._nativeNode = null;
  }
}

/**
 * Populate `_nativeNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedNativeOrTextFromComponent(childInst)._domID;
    if (childID == null) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : invariant(false) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._nativeNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._nativeNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : invariant(false) : void 0;

  if (inst._nativeNode) {
    return inst._nativeNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._nativeNode) {
    parents.push(inst);
    !inst._nativeParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : invariant(false) : void 0;
    inst = inst._nativeParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._nativeNode);
  }

  return inst._nativeNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
}).call(this,require('_process'))

},{"./DOMProperty":15,"./ReactDOMComponentFlags":45,"_process":4,"fbjs/lib/invariant":158}],47:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMContainerInfo
 */

'use strict';

var validateDOMNesting = require('./validateDOMNesting');

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  if (process.env.NODE_ENV !== 'production') {
    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

module.exports = ReactDOMContainerInfo;
}).call(this,require('_process'))

},{"./validateDOMNesting":142,"_process":4}],48:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMDebugTool
 */

'use strict';

var ReactDOMUnknownPropertyDevtool = require('./ReactDOMUnknownPropertyDevtool');

var warning = require('fbjs/lib/warning');

var eventHandlers = [];
var handlerDoesThrowForEvent = {};

function emitEvent(handlerFunctionName, arg1, arg2, arg3, arg4, arg5) {
  if (process.env.NODE_ENV !== 'production') {
    eventHandlers.forEach(function (handler) {
      try {
        if (handler[handlerFunctionName]) {
          handler[handlerFunctionName](arg1, arg2, arg3, arg4, arg5);
        }
      } catch (e) {
        process.env.NODE_ENV !== 'production' ? warning(!handlerDoesThrowForEvent[handlerFunctionName], 'exception thrown by devtool while handling %s: %s', handlerFunctionName, e.message) : void 0;
        handlerDoesThrowForEvent[handlerFunctionName] = true;
      }
    });
  }
}

var ReactDOMDebugTool = {
  addDevtool: function (devtool) {
    eventHandlers.push(devtool);
  },
  removeDevtool: function (devtool) {
    for (var i = 0; i < eventHandlers.length; i++) {
      if (eventHandlers[i] === devtool) {
        eventHandlers.splice(i, 1);
        i--;
      }
    }
  },
  onCreateMarkupForProperty: function (name, value) {
    emitEvent('onCreateMarkupForProperty', name, value);
  },
  onSetValueForProperty: function (node, name, value) {
    emitEvent('onSetValueForProperty', node, name, value);
  },
  onDeleteValueForProperty: function (node, name) {
    emitEvent('onDeleteValueForProperty', node, name);
  }
};

ReactDOMDebugTool.addDevtool(ReactDOMUnknownPropertyDevtool);

module.exports = ReactDOMDebugTool;
}).call(this,require('_process'))

},{"./ReactDOMUnknownPropertyDevtool":61,"_process":4,"fbjs/lib/warning":168}],49:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMEmptyComponent
 */

'use strict';

var _assign = require('object-assign');

var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._nativeNode = null;
  this._nativeParent = null;
  this._nativeContainerInfo = null;
  this._domID = null;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function (transaction, nativeParent, nativeContainerInfo, context) {
    var domID = nativeContainerInfo._idCounter++;
    this._domID = domID;
    this._nativeParent = nativeParent;
    this._nativeContainerInfo = nativeContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = nativeContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getNativeNode: function () {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;
},{"./DOMLazyTree":13,"./ReactDOMComponentTree":46,"object-assign":169}],50:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFactories
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactElementValidator = require('./ReactElementValidator');

var mapObject = require('fbjs/lib/mapObject');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMFactory(tag) {
  if (process.env.NODE_ENV !== 'production') {
    return ReactElementValidator.createFactory(tag);
  }
  return ReactElement.createFactory(tag);
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = mapObject({
  a: 'a',
  abbr: 'abbr',
  address: 'address',
  area: 'area',
  article: 'article',
  aside: 'aside',
  audio: 'audio',
  b: 'b',
  base: 'base',
  bdi: 'bdi',
  bdo: 'bdo',
  big: 'big',
  blockquote: 'blockquote',
  body: 'body',
  br: 'br',
  button: 'button',
  canvas: 'canvas',
  caption: 'caption',
  cite: 'cite',
  code: 'code',
  col: 'col',
  colgroup: 'colgroup',
  data: 'data',
  datalist: 'datalist',
  dd: 'dd',
  del: 'del',
  details: 'details',
  dfn: 'dfn',
  dialog: 'dialog',
  div: 'div',
  dl: 'dl',
  dt: 'dt',
  em: 'em',
  embed: 'embed',
  fieldset: 'fieldset',
  figcaption: 'figcaption',
  figure: 'figure',
  footer: 'footer',
  form: 'form',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  head: 'head',
  header: 'header',
  hgroup: 'hgroup',
  hr: 'hr',
  html: 'html',
  i: 'i',
  iframe: 'iframe',
  img: 'img',
  input: 'input',
  ins: 'ins',
  kbd: 'kbd',
  keygen: 'keygen',
  label: 'label',
  legend: 'legend',
  li: 'li',
  link: 'link',
  main: 'main',
  map: 'map',
  mark: 'mark',
  menu: 'menu',
  menuitem: 'menuitem',
  meta: 'meta',
  meter: 'meter',
  nav: 'nav',
  noscript: 'noscript',
  object: 'object',
  ol: 'ol',
  optgroup: 'optgroup',
  option: 'option',
  output: 'output',
  p: 'p',
  param: 'param',
  picture: 'picture',
  pre: 'pre',
  progress: 'progress',
  q: 'q',
  rp: 'rp',
  rt: 'rt',
  ruby: 'ruby',
  s: 's',
  samp: 'samp',
  script: 'script',
  section: 'section',
  select: 'select',
  small: 'small',
  source: 'source',
  span: 'span',
  strong: 'strong',
  style: 'style',
  sub: 'sub',
  summary: 'summary',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  textarea: 'textarea',
  tfoot: 'tfoot',
  th: 'th',
  thead: 'thead',
  time: 'time',
  title: 'title',
  tr: 'tr',
  track: 'track',
  u: 'u',
  ul: 'ul',
  'var': 'var',
  video: 'video',
  wbr: 'wbr',

  // SVG
  circle: 'circle',
  clipPath: 'clipPath',
  defs: 'defs',
  ellipse: 'ellipse',
  g: 'g',
  image: 'image',
  line: 'line',
  linearGradient: 'linearGradient',
  mask: 'mask',
  path: 'path',
  pattern: 'pattern',
  polygon: 'polygon',
  polyline: 'polyline',
  radialGradient: 'radialGradient',
  rect: 'rect',
  stop: 'stop',
  svg: 'svg',
  text: 'text',
  tspan: 'tspan'

}, createDOMFactory);

module.exports = ReactDOMFactories;
}).call(this,require('_process'))

},{"./ReactElement":65,"./ReactElementValidator":66,"_process":4,"fbjs/lib/mapObject":163}],51:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFeatureFlags
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: true
};

module.exports = ReactDOMFeatureFlags;
},{}],52:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIDOperations
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;
},{"./DOMChildrenOperations":12,"./ReactDOMComponentTree":46}],53:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInput
 */

'use strict';

var _assign = require('object-assign');

var DisabledInputUtils = require('./DisabledInputUtils');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueNull = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function warnIfValueIsNull(props) {
  if (props != null && props.value === null && !didWarnValueNull) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `input` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.') : void 0;

    didWarnValueNull = true;
  }
}

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getNativeProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var nativeProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined
    }, DisabledInputUtils.getNativeProps(inst, props), {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnValueDefaultValue = true;
      }
      warnIfValueIsNull(props);
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.defaultChecked || false,
      initialValue: defaultValue != null ? defaultValue : null,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };

    if (process.env.NODE_ENV !== 'production') {
      inst._wrapperState.controlled = props.checked !== undefined || props.value !== undefined;
    }
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    if (process.env.NODE_ENV !== 'production') {
      warnIfValueIsNull(props);

      var initialValue = inst._wrapperState.initialChecked || inst._wrapperState.initialValue;
      var defaultValue = props.defaultChecked || props.defaultValue;
      var controlled = props.checked !== undefined || props.value !== undefined;
      var owner = inst._currentElement._owner;

      if ((initialValue || !inst._wrapperState.controlled) && controlled && !didWarnUncontrolledToControlled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && (defaultValue || !controlled) && !didWarnControlledToUncontrolled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
}).call(this,require('_process'))

},{"./DOMPropertyOperations":16,"./DisabledInputUtils":19,"./LinkedValueUtils":29,"./ReactDOMComponentTree":46,"./ReactUpdates":94,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168,"object-assign":169}],54:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInstrumentation
 */

'use strict';

var ReactDOMDebugTool = require('./ReactDOMDebugTool');

module.exports = { debugTool: ReactDOMDebugTool };
},{"./ReactDOMDebugTool":48}],55:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMOption
 */

'use strict';

var _assign = require('object-assign');

var ReactChildren = require('./ReactChildren');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMSelect = require('./ReactDOMSelect');

var warning = require('fbjs/lib/warning');

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, nativeParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (nativeParent != null) {
      var selectParent = nativeParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._nativeParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === '' + props.value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === '' + props.value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getNativeProps: function (inst, props) {
    var nativeProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      nativeProps.selected = inst._wrapperState.selected;
    }

    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    ReactChildren.forEach(props.children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
      }
    });

    if (content) {
      nativeProps.children = content;
    }

    return nativeProps;
  }

};

module.exports = ReactDOMOption;
}).call(this,require('_process'))

},{"./ReactChildren":34,"./ReactDOMComponentTree":46,"./ReactDOMSelect":56,"_process":4,"fbjs/lib/warning":168,"object-assign":169}],56:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelect
 */

'use strict';

var _assign = require('object-assign');

var DisabledInputUtils = require('./DisabledInputUtils');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValueNull = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function warnIfValueIsNull(props) {
  if (props != null && props.value === null && !didWarnValueNull) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `select` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.') : void 0;

    didWarnValueNull = true;
  }
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    if (props.multiple) {
      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    } else {
      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getNativeProps: function (inst, props) {
    return _assign({}, DisabledInputUtils.getNativeProps(inst, props), {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      checkSelectPropTypes(inst, props);
      warnIfValueIsNull(props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;
    if (process.env.NODE_ENV !== 'production') {
      warnIfValueIsNull(props);
    }

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
}).call(this,require('_process'))

},{"./DisabledInputUtils":19,"./LinkedValueUtils":29,"./ReactDOMComponentTree":46,"./ReactUpdates":94,"_process":4,"fbjs/lib/warning":168,"object-assign":169}],57:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelection
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./getNodeForCharacterOffset":129,"./getTextContentAccessor":130,"fbjs/lib/ExecutionEnvironment":144}],58:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextComponent
 */

'use strict';

var _assign = require('object-assign');

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var validateDOMNesting = require('./validateDOMNesting');

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._nativeNode = null;
  this._nativeParent = null;

  // Properties
  this._domID = null;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, nativeParent, nativeContainerInfo, context) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onSetText(this._debugID, this._stringText);

      var parentInfo;
      if (nativeParent != null) {
        parentInfo = nativeParent._ancestorInfo;
      } else if (nativeContainerInfo != null) {
        parentInfo = nativeContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting('#text', this, parentInfo);
      }
    }

    var domID = nativeContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._nativeParent = nativeParent;
    if (transaction.useCreateElement) {
      var ownerDocument = nativeContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getNativeNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);

        if (process.env.NODE_ENV !== 'production') {
          ReactInstrumentation.debugTool.onSetText(this._debugID, nextStringText);
        }
      }
    }
  },

  getNativeNode: function () {
    var nativeNode = this._commentNodes;
    if (nativeNode) {
      return nativeNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : invariant(false) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    nativeNode = [this._nativeNode, this._closingComment];
    this._commentNodes = nativeNode;
    return nativeNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }

});

module.exports = ReactDOMTextComponent;
}).call(this,require('_process'))

},{"./DOMChildrenOperations":12,"./DOMLazyTree":13,"./ReactDOMComponentTree":46,"./ReactInstrumentation":75,"./escapeTextContentForBrowser":119,"./validateDOMNesting":142,"_process":4,"fbjs/lib/invariant":158,"object-assign":169}],59:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextarea
 */

'use strict';

var _assign = require('object-assign');

var DisabledInputUtils = require('./DisabledInputUtils');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValueNull = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

function warnIfValueIsNull(props) {
  if (props != null && props.value === null && !didWarnValueNull) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `textarea` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.') : void 0;

    didWarnValueNull = true;
  }
}

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getNativeProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    var nativeProps = _assign({}, DisabledInputUtils.getNativeProps(inst, props), {
      defaultValue: undefined,
      value: undefined,
      children: inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValDefaultVal = true;
      }
      warnIfValueIsNull(props);
    }

    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
      }
      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue),
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    if (process.env.NODE_ENV !== 'production') {
      warnIfValueIsNull(props);
    }

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
}).call(this,require('_process'))

},{"./DOMPropertyOperations":16,"./DisabledInputUtils":19,"./LinkedValueUtils":29,"./ReactDOMComponentTree":46,"./ReactUpdates":94,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168,"object-assign":169}],60:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTreeTraversal
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_nativeNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : invariant(false) : void 0;
  !('_nativeNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : invariant(false) : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._nativeParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._nativeParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._nativeParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._nativeParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._nativeParent;
    instB = instB._nativeParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_nativeNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : invariant(false) : void 0;
  !('_nativeNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : invariant(false) : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._nativeParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_nativeNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : invariant(false) : void 0;

  return inst._nativeParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._nativeParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], false, arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], true, arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._nativeParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._nativeParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], true, argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], false, argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],61:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMUnknownPropertyDevtool
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginRegistry = require('./EventPluginRegistry');

var warning = require('fbjs/lib/warning');

if (process.env.NODE_ENV !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function (name) {
    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
      return;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : void 0;

    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

    process.env.NODE_ENV !== 'production' ? warning(registrationName == null, 'Unknown event handler property %s. Did you mean `%s`?', name, registrationName) : void 0;
  };
}

var ReactDOMUnknownPropertyDevtool = {
  onCreateMarkupForProperty: function (name, value) {
    warnUnknownProperty(name);
  },
  onSetValueForProperty: function (node, name, value) {
    warnUnknownProperty(name);
  },
  onDeleteValueForProperty: function (node, name) {
    warnUnknownProperty(name);
  }
};

module.exports = ReactDOMUnknownPropertyDevtool;
}).call(this,require('_process'))

},{"./DOMProperty":15,"./EventPluginRegistry":23,"_process":4,"fbjs/lib/warning":168}],62:[function(require,module,exports){
(function (process){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDebugTool
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var performanceNow = require('fbjs/lib/performanceNow');
var warning = require('fbjs/lib/warning');

var eventHandlers = [];
var handlerDoesThrowForEvent = {};

function emitEvent(handlerFunctionName, arg1, arg2, arg3, arg4, arg5) {
  if (process.env.NODE_ENV !== 'production') {
    eventHandlers.forEach(function (handler) {
      try {
        if (handler[handlerFunctionName]) {
          handler[handlerFunctionName](arg1, arg2, arg3, arg4, arg5);
        }
      } catch (e) {
        process.env.NODE_ENV !== 'production' ? warning(!handlerDoesThrowForEvent[handlerFunctionName], 'exception thrown by devtool while handling %s: %s', handlerFunctionName, e.message) : void 0;
        handlerDoesThrowForEvent[handlerFunctionName] = true;
      }
    });
  }
}

var isProfiling = false;
var flushHistory = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = null;
var currentFlushStartTime = null;
var currentTimerDebugID = null;
var currentTimerStartTime = null;
var currentTimerType = null;

function clearHistory() {
  ReactComponentTreeDevtool.purgeUnmountedComponents();
  ReactNativeOperationHistoryDevtool.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeDevtool.getOwnerID(id);
    var parentID = ReactComponentTreeDevtool.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeDevtool.getDisplayName(id),
      text: ReactComponentTreeDevtool.getText(id),
      updateCount: ReactComponentTreeDevtool.getUpdateCount(id),
      childIDs: ReactComponentTreeDevtool.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || ReactComponentTreeDevtool.getOwnerID(parentID),
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  if (process.env.NODE_ENV !== 'production') {
    var previousStartTime = currentFlushStartTime;
    var previousMeasurements = currentFlushMeasurements || [];
    var previousOperations = ReactNativeOperationHistoryDevtool.getHistory();

    if (!isProfiling || currentFlushNesting === 0) {
      currentFlushStartTime = null;
      currentFlushMeasurements = null;
      clearHistory();
      return;
    }

    if (previousMeasurements.length || previousOperations.length) {
      var registeredIDs = ReactComponentTreeDevtool.getRegisteredIDs();
      flushHistory.push({
        duration: performanceNow() - previousStartTime,
        measurements: previousMeasurements || [],
        operations: previousOperations || [],
        treeSnapshot: getTreeSnapshot(registeredIDs)
      });
    }

    clearHistory();
    currentFlushStartTime = performanceNow();
    currentFlushMeasurements = [];
  }
}

function checkDebugID(debugID) {
  process.env.NODE_ENV !== 'production' ? warning(debugID, 'ReactDebugTool: debugID may not be empty.') : void 0;
}

var ReactDebugTool = {
  addDevtool: function (devtool) {
    eventHandlers.push(devtool);
  },
  removeDevtool: function (devtool) {
    for (var i = 0; i < eventHandlers.length; i++) {
      if (eventHandlers[i] === devtool) {
        eventHandlers.splice(i, 1);
        i--;
      }
    }
  },
  beginProfiling: function () {
    if (process.env.NODE_ENV !== 'production') {
      if (isProfiling) {
        return;
      }

      isProfiling = true;
      flushHistory.length = 0;
      resetMeasurements();
    }
  },
  endProfiling: function () {
    if (process.env.NODE_ENV !== 'production') {
      if (!isProfiling) {
        return;
      }

      isProfiling = false;
      resetMeasurements();
    }
  },
  getFlushHistory: function () {
    if (process.env.NODE_ENV !== 'production') {
      return flushHistory;
    }
  },
  onBeginFlush: function () {
    if (process.env.NODE_ENV !== 'production') {
      currentFlushNesting++;
      resetMeasurements();
    }
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    if (process.env.NODE_ENV !== 'production') {
      resetMeasurements();
      currentFlushNesting--;
    }
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    if (process.env.NODE_ENV !== 'production') {
      if (isProfiling && currentFlushNesting > 0) {
        process.env.NODE_ENV !== 'production' ? warning(!currentTimerType, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
        currentTimerStartTime = performanceNow();
        currentTimerDebugID = debugID;
        currentTimerType = timerType;
      }
    }
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    if (process.env.NODE_ENV !== 'production') {
      if (isProfiling && currentFlushNesting > 0) {
        process.env.NODE_ENV !== 'production' ? warning(currentTimerType === timerType, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
        currentFlushMeasurements.push({
          timerType: timerType,
          instanceID: debugID,
          duration: performanceNow() - currentTimerStartTime
        });
        currentTimerStartTime = null;
        currentTimerDebugID = null;
        currentTimerType = null;
      }
    }
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginReconcilerTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginReconcilerTimer', debugID, timerType);
  },
  onEndReconcilerTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onEndReconcilerTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onNativeOperation: function (debugID, type, payload) {
    checkDebugID(debugID);
    emitEvent('onNativeOperation', debugID, type, payload);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetDisplayName: function (debugID, displayName) {
    checkDebugID(debugID);
    emitEvent('onSetDisplayName', debugID, displayName);
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onSetOwner: function (debugID, ownerDebugID) {
    checkDebugID(debugID);
    emitEvent('onSetOwner', debugID, ownerDebugID);
  },
  onSetText: function (debugID, text) {
    checkDebugID(debugID);
    emitEvent('onSetText', debugID, text);
  },
  onMountRootComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onMountRootComponent', debugID);
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onMountComponent', debugID);
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onUpdateComponent', debugID);
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onUnmountComponent', debugID);
  }
};

if (process.env.NODE_ENV !== 'production') {
  var ReactInvalidSetStateWarningDevTool = require('./ReactInvalidSetStateWarningDevTool');
  var ReactNativeOperationHistoryDevtool = require('./ReactNativeOperationHistoryDevtool');
  var ReactComponentTreeDevtool = require('./ReactComponentTreeDevtool');
  ReactDebugTool.addDevtool(ReactInvalidSetStateWarningDevTool);
  ReactDebugTool.addDevtool(ReactComponentTreeDevtool);
  ReactDebugTool.addDevtool(ReactNativeOperationHistoryDevtool);
  var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
  if (/[?&]react_perf\b/.test(url)) {
    ReactDebugTool.beginProfiling();
  }
}

module.exports = ReactDebugTool;
}).call(this,require('_process'))

},{"./ReactComponentTreeDevtool":39,"./ReactInvalidSetStateWarningDevTool":76,"./ReactNativeOperationHistoryDevtool":82,"_process":4,"fbjs/lib/ExecutionEnvironment":144,"fbjs/lib/performanceNow":166,"fbjs/lib/warning":168}],63:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

'use strict';

var _assign = require('object-assign');

var ReactUpdates = require('./ReactUpdates');
var Transaction = require('./Transaction');

var emptyFunction = require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./ReactUpdates":94,"./Transaction":112,"fbjs/lib/emptyFunction":150,"object-assign":169}],64:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultInjection
 */

'use strict';

var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
var ChangeEventPlugin = require('./ChangeEventPlugin');
var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMComponent = require('./ReactDOMComponent');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMEmptyComponent = require('./ReactDOMEmptyComponent');
var ReactDOMTreeTraversal = require('./ReactDOMTreeTraversal');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactEventListener = require('./ReactEventListener');
var ReactInjection = require('./ReactInjection');
var ReactReconcileTransaction = require('./ReactReconcileTransaction');
var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');
var SelectEventPlugin = require('./SelectEventPlugin');
var SimpleEventPlugin = require('./SimpleEventPlugin');

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};
},{"./BeforeInputEventPlugin":7,"./ChangeEventPlugin":11,"./DefaultEventPluginOrder":18,"./EnterLeaveEventPlugin":20,"./HTMLDOMPropertyConfig":27,"./ReactComponentBrowserEnvironment":37,"./ReactDOMComponent":44,"./ReactDOMComponentTree":46,"./ReactDOMEmptyComponent":49,"./ReactDOMTextComponent":58,"./ReactDOMTreeTraversal":60,"./ReactDefaultBatchingStrategy":63,"./ReactEventListener":70,"./ReactInjection":72,"./ReactReconcileTransaction":89,"./SVGDOMPropertyConfig":96,"./SelectEventPlugin":97,"./SimpleEventPlugin":98}],65:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

'use strict';

var _assign = require('object-assign');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var warning = require('fbjs/lib/warning');
var canDefineProperty = require('./canDefineProperty');

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(
      /* eslint-disable no-proto */
      config.__proto__ == null || config.__proto__ === Object.prototype,
      /* eslint-enable no-proto */
      'React.createElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
      ref = !config.hasOwnProperty('ref') || Object.getOwnPropertyDescriptor(config, 'ref').get ? null : config.ref;
      key = !config.hasOwnProperty('key') || Object.getOwnPropertyDescriptor(config, 'key').get ? null : '' + config.key;
    } else {
      ref = config.ref === undefined ? null : config.ref;
      key = config.key === undefined ? null : '' + config.key;
    }
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    // Create dummy `key` and `ref` property to `props` to warn users
    // against its use
    if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
      if (!props.hasOwnProperty('key')) {
        Object.defineProperty(props, 'key', {
          get: function () {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', typeof type === 'function' && 'displayName' in type ? type.displayName : 'Element') : void 0;
            }
            return undefined;
          },
          configurable: true
        });
      }
      if (!props.hasOwnProperty('ref')) {
        Object.defineProperty(props, 'ref', {
          get: function () {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', typeof type === 'function' && 'displayName' in type ? type.displayName : 'Element') : void 0;
            }
            return undefined;
          },
          configurable: true
        });
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(
      /* eslint-disable no-proto */
      config.__proto__ == null || config.__proto__ === Object.prototype,
      /* eslint-enable no-proto */
      'React.cloneElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
    }
    if (config.ref !== undefined) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (config.key !== undefined) {
      key = '' + config.key;
    }
    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":41,"./canDefineProperty":116,"_process":4,"fbjs/lib/warning":168,"object-assign":169}],66:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactCurrentOwner = require('./ReactCurrentOwner');

var canDefineProperty = require('./canDefineProperty');
var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

var loggedTypeFailures = {};

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
  if (addenda === null) {
    // we already showed the warning
    return;
  }
  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : void 0;
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} messageType A key used for de-duping warnings.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 * @returns {?object} A set of addenda to use in the warning message, or null
 * if the warning has already been shown before (and shouldn't be shown again).
 */
function getAddendaForKeyUse(messageType, element, parentType) {
  var addendum = getDeclarationErrorAddendum();
  if (!addendum) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      addendum = ' Check the top-level render call using <' + parentName + '>.';
    }
  }

  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
  if (memoizer[addendum]) {
    return null;
  }
  memoizer[addendum] = true;

  var addenda = {
    parentOrOwner: addendum,
    url: ' See https://fb.me/react-warning-keys for more information.',
    childOwner: null
  };

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  return addenda;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : void 0;
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum();
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : void 0;
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":41,"./ReactElement":65,"./ReactPropTypeLocationNames":86,"./ReactPropTypeLocations":87,"./canDefineProperty":116,"./getIteratorFn":127,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168}],67:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponent
 */

'use strict';

var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;
},{}],68:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactErrorUtils
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {?String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a, b) {
  try {
    return func(a, b);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
    return undefined;
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if (process.env.NODE_ENV !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
      var boundFunc = func.bind(null, a, b);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
}).call(this,require('_process'))

},{"_process":4}],69:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventEmitterMixin
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":22}],70:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 */

'use strict';

var _assign = require('object-assign');

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._nativeParent) {
    inst = inst._nativeParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./PooledClass":30,"./ReactDOMComponentTree":46,"./ReactUpdates":94,"./getEventTarget":126,"fbjs/lib/EventListener":143,"fbjs/lib/ExecutionEnvironment":144,"fbjs/lib/getUnboundedScrollPosition":155,"object-assign":169}],71:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactFeatureFlags
 */

'use strict';

var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;
},{}],72:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInjection
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactClass = require('./ReactClass');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactNativeComponent = require('./ReactNativeComponent');
var ReactUpdates = require('./ReactUpdates');

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  Class: ReactClass.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  NativeComponent: ReactNativeComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":15,"./EventPluginHub":22,"./EventPluginUtils":24,"./ReactBrowserEventEmitter":32,"./ReactClass":35,"./ReactComponentEnvironment":38,"./ReactEmptyComponent":67,"./ReactNativeComponent":81,"./ReactUpdates":94}],73:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInputSelection
 */

'use strict';

var ReactDOMSelection = require('./ReactDOMSelection');

var containsNode = require('fbjs/lib/containsNode');
var focusNode = require('fbjs/lib/focusNode');
var getActiveElement = require('fbjs/lib/getActiveElement');

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":57,"fbjs/lib/containsNode":147,"fbjs/lib/focusNode":152,"fbjs/lib/getActiveElement":153}],74:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceMap
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],75:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstrumentation
 */

'use strict';

var ReactDebugTool = require('./ReactDebugTool');

module.exports = { debugTool: ReactDebugTool };
},{"./ReactDebugTool":62}],76:[function(require,module,exports){
(function (process){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInvalidSetStateWarningDevTool
 */

'use strict';

var warning = require('fbjs/lib/warning');

if (process.env.NODE_ENV !== 'production') {
  var processingChildContext = false;

  var warnInvalidSetState = function () {
    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}

var ReactInvalidSetStateWarningDevTool = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};

module.exports = ReactInvalidSetStateWarningDevTool;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/warning":168}],77:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMarkupChecksum
 */

'use strict';

var adler32 = require('./adler32');

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":115}],78:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMount
 */

'use strict';

var DOMLazyTree = require('./DOMLazyTree');
var DOMProperty = require('./DOMProperty');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMContainerInfo = require('./ReactDOMContainerInfo');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactElement = require('./ReactElement');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var setInnerHTML = require('./setInnerHTML');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context);

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  ReactReconciler.unmountComponent(instance, safely);

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._nativeParent);
  }
}

function getNativeRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevNativeInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevNativeInstance && !prevNativeInstance._nativeParent ? prevNativeInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getNativeRootInstanceInContainer(container);
  return root ? root._nativeContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if (process.env.NODE_ENV !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  // this.props is actually a ReactElement
  return this.props;
};

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by devtools!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onBeginFlush();
    }

    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement);

    if (process.env.NODE_ENV !== 'production') {
      // Mute future events from the top level wrapper.
      // It is an implementation detail that devtools should not know about.
      componentInstance._debugID = 0;
    }

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    if (process.env.NODE_ENV !== 'production') {
      // The instance here is TopLevelWrapper so we report mount for its child.
      ReactInstrumentation.debugTool.onMountRootComponent(componentInstance._renderedComponent._debugID);
      ReactInstrumentation.debugTool.onEndFlush();
    }

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : void 0;

    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : void 0;

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if (process.env.NODE_ENV !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : void 0;

        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }

    if (process.env.NODE_ENV !== 'production') {
      var nativeNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
      if (nativeNode._debugID !== 0) {
        ReactInstrumentation.debugTool.onNativeOperation(nativeNode._debugID, 'mount', markup.toString());
      }
    }
  }
};

module.exports = ReactMount;
}).call(this,require('_process'))

},{"./DOMLazyTree":13,"./DOMProperty":15,"./ReactBrowserEventEmitter":32,"./ReactCurrentOwner":41,"./ReactDOMComponentTree":46,"./ReactDOMContainerInfo":47,"./ReactDOMFeatureFlags":51,"./ReactElement":65,"./ReactFeatureFlags":71,"./ReactInstrumentation":75,"./ReactMarkupChecksum":77,"./ReactReconciler":90,"./ReactUpdateQueue":93,"./ReactUpdates":94,"./instantiateReactComponent":132,"./setInnerHTML":138,"./shouldUpdateReactComponent":140,"_process":4,"fbjs/lib/emptyObject":151,"fbjs/lib/invariant":158,"fbjs/lib/warning":168}],79:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChild
 */

'use strict';

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactReconciler = require('./ReactReconciler');
var ReactChildReconciler = require('./ReactChildReconciler');

var emptyFunction = require('fbjs/lib/emptyFunction');
var flattenChildren = require('./flattenChildren');
var invariant = require('fbjs/lib/invariant');

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getNativeNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: ReactMultiChildUpdateTypes.SET_MARKUP,
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  setChildrenForInstrumentation = function (children) {
    ReactInstrumentation.debugTool.onSetChildren(this._debugID, children ? Object.keys(children).map(function (key) {
      return children[key]._debugID;
    }) : []);
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, removedNodes, transaction, context) {
      var nextChildren;
      if (process.env.NODE_ENV !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements);
          } finally {
            ReactCurrentOwner.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, removedNodes, transaction, context);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, removedNodes, transaction, context);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._nativeContainerInfo, context);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : invariant(false) : void 0;
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : invariant(false) : void 0;
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, lastPlacedNode, nextIndex, transaction, context));
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getNativeNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, afterNode, index, transaction, context) {
      var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._nativeContainerInfo, context);
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }

  }

};

module.exports = ReactMultiChild;
}).call(this,require('_process'))

},{"./ReactChildReconciler":33,"./ReactComponentEnvironment":38,"./ReactCurrentOwner":41,"./ReactInstrumentation":75,"./ReactMultiChildUpdateTypes":80,"./ReactReconciler":90,"./flattenChildren":121,"_process":4,"fbjs/lib/emptyFunction":150,"fbjs/lib/invariant":158}],80:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  SET_MARKUP: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;
},{"fbjs/lib/keyMirror":161}],81:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeComponent
 */

'use strict';

var _assign = require('object-assign');

var invariant = require('fbjs/lib/invariant');

var autoGenerateWrapperClass = null;
var genericComponentClass = null;
// This registry keeps track of wrapper classes around native tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactNativeComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function (componentClasses) {
    _assign(tagToComponentClass, componentClasses);
  }
};

/**
 * Get a composite component wrapper class for a specific tag.
 *
 * @param {ReactElement} element The tag for which to get the class.
 * @return {function} The React class constructor function.
 */
function getComponentClassForElement(element) {
  if (typeof element.type === 'function') {
    return element.type;
  }
  var tag = element.type;
  var componentClass = tagToComponentClass[tag];
  if (componentClass == null) {
    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
  }
  return componentClass;
}

/**
 * Get a native internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactNativeComponent = {
  getComponentClassForElement: getComponentClassForElement,
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactNativeComponentInjection
};

module.exports = ReactNativeComponent;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158,"object-assign":169}],82:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeOperationHistoryDevtool
 */

'use strict';

var history = [];

var ReactNativeOperationHistoryDevtool = {
  onNativeOperation: function (debugID, type, payload) {
    history.push({
      instanceID: debugID,
      type: type,
      payload: payload
    });
  },
  clearHistory: function () {
    if (ReactNativeOperationHistoryDevtool._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function () {
    return history;
  }
};

module.exports = ReactNativeOperationHistoryDevtool;
},{}],83:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNodeTypes
 */

'use strict';

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

var ReactNodeTypes = {
  NATIVE: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (ReactElement.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.NATIVE;
      }
    }
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : invariant(false) : void 0;
  }
};

module.exports = ReactNodeTypes;
}).call(this,require('_process'))

},{"./ReactElement":65,"_process":4,"fbjs/lib/invariant":158}],84:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNoopUpdateQueue
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnTDZ(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnTDZ(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnTDZ(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnTDZ(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/warning":168}],85:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactOwner
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function (object) {
    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],86:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

'use strict';

var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
}).call(this,require('_process'))

},{"_process":4}],87:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;
},{"fbjs/lib/keyMirror":161}],88:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getIteratorFn = require('./getIteratorFn');

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
/*eslint-disable no-self-compare*/
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/*eslint-enable no-self-compare*/

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new Error('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    }
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!ReactElement.isValidElement(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (is(propValue, expectedValues[i])) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new Error('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    }
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return ANONYMOUS;
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
},{"./ReactElement":65,"./ReactPropTypeLocationNames":86,"./getIteratorFn":127,"fbjs/lib/emptyFunction":150}],89:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconcileTransaction
 */

'use strict';

var _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactInputSelection = require('./ReactInputSelection');
var Transaction = require('./Transaction');

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":10,"./PooledClass":30,"./ReactBrowserEventEmitter":32,"./ReactInputSelection":73,"./Transaction":112,"object-assign":169}],90:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconciler
 */

'use strict';

var ReactRef = require('./ReactRef');
var ReactInstrumentation = require('./ReactInstrumentation');

var invariant = require('fbjs/lib/invariant');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing native component instance
   * @param {?object} info about the native container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, nativeParent, nativeContainerInfo, context) {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeginReconcilerTimer(internalInstance._debugID, 'mountComponent');
      }
    }
    var markup = internalInstance.mountComponent(transaction, nativeParent, nativeContainerInfo, context);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onEndReconcilerTimer(internalInstance._debugID, 'mountComponent');
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getNativeNode: function (internalInstance) {
    return internalInstance.getNativeNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeginReconcilerTimer(internalInstance._debugID, 'unmountComponent');
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onEndReconcilerTimer(internalInstance._debugID, 'unmountComponent');
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeginReconcilerTimer(internalInstance._debugID, 'receiveComponent');
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onEndReconcilerTimer(internalInstance._debugID, 'receiveComponent');
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      !(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : invariant(false) : void 0;
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeginReconcilerTimer(internalInstance._debugID, 'performUpdateIfNecessary');
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onEndReconcilerTimer(internalInstance._debugID, 'performUpdateIfNecessary');
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }

};

module.exports = ReactReconciler;
}).call(this,require('_process'))

},{"./ReactInstrumentation":75,"./ReactRef":91,"_process":4,"fbjs/lib/invariant":158}],91:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRef
 */

'use strict';

var ReactOwner = require('./ReactOwner');

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;

  return(
    // This has a few false positives w/r/t empty components.
    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
  );
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":85}],92:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerRenderingTransaction
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');
var Transaction = require('./Transaction');

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./PooledClass":30,"./Transaction":112,"object-assign":169}],93:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdateQueue
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if (process.env.NODE_ENV !== 'production') {
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : void 0;
    }
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, newElement) {
    internalInstance._pendingElement = newElement;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : invariant(false) : void 0;
  }

};

module.exports = ReactUpdateQueue;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":41,"./ReactInstanceMap":74,"./ReactUpdates":94,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168}],94:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdates
 */

'use strict';

var _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactReconciler = require('./ReactReconciler');
var Transaction = require('./Transaction');

var invariant = require('fbjs/lib/invariant');

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.props === component._renderedComponent._currentElement) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onBeginFlush();
  }

  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onEndFlush();
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
}).call(this,require('_process'))

},{"./CallbackQueue":10,"./PooledClass":30,"./ReactFeatureFlags":71,"./ReactInstrumentation":75,"./ReactReconciler":90,"./Transaction":112,"_process":4,"fbjs/lib/invariant":158,"object-assign":169}],95:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactVersion
 */

'use strict';

module.exports = '15.1.0';
},{}],96:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SVGDOMPropertyConfig
 */

'use strict';

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;
},{}],97:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInputSelection = require('./ReactInputSelection');
var SyntheticEvent = require('./SyntheticEvent');

var getActiveElement = require('fbjs/lib/getActiveElement');
var isTextInputElement = require('./isTextInputElement');
var keyOf = require('fbjs/lib/keyOf');
var shallowEqual = require('fbjs/lib/shallowEqual');

var topLevelTypes = EventConstants.topLevelTypes;

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSelect: null }),
      captured: keyOf({ onSelectCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;
var ON_SELECT_KEY = keyOf({ onSelect: null });

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case topLevelTypes.topSelectionChange:
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === ON_SELECT_KEY) {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventConstants":21,"./EventPropagators":25,"./ReactDOMComponentTree":46,"./ReactInputSelection":73,"./SyntheticEvent":103,"./isTextInputElement":134,"fbjs/lib/ExecutionEnvironment":144,"fbjs/lib/getActiveElement":153,"fbjs/lib/keyOf":162,"fbjs/lib/shallowEqual":167}],98:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SimpleEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventListener = require('fbjs/lib/EventListener');
var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticAnimationEvent = require('./SyntheticAnimationEvent');
var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
var SyntheticEvent = require('./SyntheticEvent');
var SyntheticFocusEvent = require('./SyntheticFocusEvent');
var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');
var SyntheticDragEvent = require('./SyntheticDragEvent');
var SyntheticTouchEvent = require('./SyntheticTouchEvent');
var SyntheticTransitionEvent = require('./SyntheticTransitionEvent');
var SyntheticUIEvent = require('./SyntheticUIEvent');
var SyntheticWheelEvent = require('./SyntheticWheelEvent');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getEventCharCode = require('./getEventCharCode');
var invariant = require('fbjs/lib/invariant');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  abort: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onAbort: true }),
      captured: keyOf({ onAbortCapture: true })
    }
  },
  animationEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onAnimationEnd: true }),
      captured: keyOf({ onAnimationEndCapture: true })
    }
  },
  animationIteration: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onAnimationIteration: true }),
      captured: keyOf({ onAnimationIterationCapture: true })
    }
  },
  animationStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onAnimationStart: true }),
      captured: keyOf({ onAnimationStartCapture: true })
    }
  },
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBlur: true }),
      captured: keyOf({ onBlurCapture: true })
    }
  },
  canPlay: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlay: true }),
      captured: keyOf({ onCanPlayCapture: true })
    }
  },
  canPlayThrough: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlayThrough: true }),
      captured: keyOf({ onCanPlayThroughCapture: true })
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onClick: true }),
      captured: keyOf({ onClickCapture: true })
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onContextMenu: true }),
      captured: keyOf({ onContextMenuCapture: true })
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCopy: true }),
      captured: keyOf({ onCopyCapture: true })
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCut: true }),
      captured: keyOf({ onCutCapture: true })
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDoubleClick: true }),
      captured: keyOf({ onDoubleClickCapture: true })
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrag: true }),
      captured: keyOf({ onDragCapture: true })
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnd: true }),
      captured: keyOf({ onDragEndCapture: true })
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnter: true }),
      captured: keyOf({ onDragEnterCapture: true })
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragExit: true }),
      captured: keyOf({ onDragExitCapture: true })
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragLeave: true }),
      captured: keyOf({ onDragLeaveCapture: true })
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragOver: true }),
      captured: keyOf({ onDragOverCapture: true })
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragStart: true }),
      captured: keyOf({ onDragStartCapture: true })
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrop: true }),
      captured: keyOf({ onDropCapture: true })
    }
  },
  durationChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDurationChange: true }),
      captured: keyOf({ onDurationChangeCapture: true })
    }
  },
  emptied: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEmptied: true }),
      captured: keyOf({ onEmptiedCapture: true })
    }
  },
  encrypted: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEncrypted: true }),
      captured: keyOf({ onEncryptedCapture: true })
    }
  },
  ended: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEnded: true }),
      captured: keyOf({ onEndedCapture: true })
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onError: true }),
      captured: keyOf({ onErrorCapture: true })
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onFocus: true }),
      captured: keyOf({ onFocusCapture: true })
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onInput: true }),
      captured: keyOf({ onInputCapture: true })
    }
  },
  invalid: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onInvalid: true }),
      captured: keyOf({ onInvalidCapture: true })
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyDown: true }),
      captured: keyOf({ onKeyDownCapture: true })
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyPress: true }),
      captured: keyOf({ onKeyPressCapture: true })
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyUp: true }),
      captured: keyOf({ onKeyUpCapture: true })
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoad: true }),
      captured: keyOf({ onLoadCapture: true })
    }
  },
  loadedData: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedData: true }),
      captured: keyOf({ onLoadedDataCapture: true })
    }
  },
  loadedMetadata: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedMetadata: true }),
      captured: keyOf({ onLoadedMetadataCapture: true })
    }
  },
  loadStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadStart: true }),
      captured: keyOf({ onLoadStartCapture: true })
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseDown: true }),
      captured: keyOf({ onMouseDownCapture: true })
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseMove: true }),
      captured: keyOf({ onMouseMoveCapture: true })
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOut: true }),
      captured: keyOf({ onMouseOutCapture: true })
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOver: true }),
      captured: keyOf({ onMouseOverCapture: true })
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseUp: true }),
      captured: keyOf({ onMouseUpCapture: true })
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPaste: true }),
      captured: keyOf({ onPasteCapture: true })
    }
  },
  pause: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPause: true }),
      captured: keyOf({ onPauseCapture: true })
    }
  },
  play: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlay: true }),
      captured: keyOf({ onPlayCapture: true })
    }
  },
  playing: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlaying: true }),
      captured: keyOf({ onPlayingCapture: true })
    }
  },
  progress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onProgress: true }),
      captured: keyOf({ onProgressCapture: true })
    }
  },
  rateChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onRateChange: true }),
      captured: keyOf({ onRateChangeCapture: true })
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onReset: true }),
      captured: keyOf({ onResetCapture: true })
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onScroll: true }),
      captured: keyOf({ onScrollCapture: true })
    }
  },
  seeked: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeked: true }),
      captured: keyOf({ onSeekedCapture: true })
    }
  },
  seeking: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeking: true }),
      captured: keyOf({ onSeekingCapture: true })
    }
  },
  stalled: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onStalled: true }),
      captured: keyOf({ onStalledCapture: true })
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSubmit: true }),
      captured: keyOf({ onSubmitCapture: true })
    }
  },
  suspend: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSuspend: true }),
      captured: keyOf({ onSuspendCapture: true })
    }
  },
  timeUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTimeUpdate: true }),
      captured: keyOf({ onTimeUpdateCapture: true })
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchCancel: true }),
      captured: keyOf({ onTouchCancelCapture: true })
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchEnd: true }),
      captured: keyOf({ onTouchEndCapture: true })
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchMove: true }),
      captured: keyOf({ onTouchMoveCapture: true })
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchStart: true }),
      captured: keyOf({ onTouchStartCapture: true })
    }
  },
  transitionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTransitionEnd: true }),
      captured: keyOf({ onTransitionEndCapture: true })
    }
  },
  volumeChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onVolumeChange: true }),
      captured: keyOf({ onVolumeChangeCapture: true })
    }
  },
  waiting: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWaiting: true }),
      captured: keyOf({ onWaitingCapture: true })
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWheel: true }),
      captured: keyOf({ onWheelCapture: true })
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topAbort: eventTypes.abort,
  topAnimationEnd: eventTypes.animationEnd,
  topAnimationIteration: eventTypes.animationIteration,
  topAnimationStart: eventTypes.animationStart,
  topBlur: eventTypes.blur,
  topCanPlay: eventTypes.canPlay,
  topCanPlayThrough: eventTypes.canPlayThrough,
  topClick: eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy: eventTypes.copy,
  topCut: eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag: eventTypes.drag,
  topDragEnd: eventTypes.dragEnd,
  topDragEnter: eventTypes.dragEnter,
  topDragExit: eventTypes.dragExit,
  topDragLeave: eventTypes.dragLeave,
  topDragOver: eventTypes.dragOver,
  topDragStart: eventTypes.dragStart,
  topDrop: eventTypes.drop,
  topDurationChange: eventTypes.durationChange,
  topEmptied: eventTypes.emptied,
  topEncrypted: eventTypes.encrypted,
  topEnded: eventTypes.ended,
  topError: eventTypes.error,
  topFocus: eventTypes.focus,
  topInput: eventTypes.input,
  topInvalid: eventTypes.invalid,
  topKeyDown: eventTypes.keyDown,
  topKeyPress: eventTypes.keyPress,
  topKeyUp: eventTypes.keyUp,
  topLoad: eventTypes.load,
  topLoadedData: eventTypes.loadedData,
  topLoadedMetadata: eventTypes.loadedMetadata,
  topLoadStart: eventTypes.loadStart,
  topMouseDown: eventTypes.mouseDown,
  topMouseMove: eventTypes.mouseMove,
  topMouseOut: eventTypes.mouseOut,
  topMouseOver: eventTypes.mouseOver,
  topMouseUp: eventTypes.mouseUp,
  topPaste: eventTypes.paste,
  topPause: eventTypes.pause,
  topPlay: eventTypes.play,
  topPlaying: eventTypes.playing,
  topProgress: eventTypes.progress,
  topRateChange: eventTypes.rateChange,
  topReset: eventTypes.reset,
  topScroll: eventTypes.scroll,
  topSeeked: eventTypes.seeked,
  topSeeking: eventTypes.seeking,
  topStalled: eventTypes.stalled,
  topSubmit: eventTypes.submit,
  topSuspend: eventTypes.suspend,
  topTimeUpdate: eventTypes.timeUpdate,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd: eventTypes.touchEnd,
  topTouchMove: eventTypes.touchMove,
  topTouchStart: eventTypes.touchStart,
  topTransitionEnd: eventTypes.transitionEnd,
  topVolumeChange: eventTypes.volumeChange,
  topWaiting: eventTypes.waiting,
  topWheel: eventTypes.wheel
};

for (var type in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[type].dependencies = [type];
}

var ON_CLICK_KEY = keyOf({ onClick: null });
var onClickListeners = {};

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topAbort:
      case topLevelTypes.topCanPlay:
      case topLevelTypes.topCanPlayThrough:
      case topLevelTypes.topDurationChange:
      case topLevelTypes.topEmptied:
      case topLevelTypes.topEncrypted:
      case topLevelTypes.topEnded:
      case topLevelTypes.topError:
      case topLevelTypes.topInput:
      case topLevelTypes.topInvalid:
      case topLevelTypes.topLoad:
      case topLevelTypes.topLoadedData:
      case topLevelTypes.topLoadedMetadata:
      case topLevelTypes.topLoadStart:
      case topLevelTypes.topPause:
      case topLevelTypes.topPlay:
      case topLevelTypes.topPlaying:
      case topLevelTypes.topProgress:
      case topLevelTypes.topRateChange:
      case topLevelTypes.topReset:
      case topLevelTypes.topSeeked:
      case topLevelTypes.topSeeking:
      case topLevelTypes.topStalled:
      case topLevelTypes.topSubmit:
      case topLevelTypes.topSuspend:
      case topLevelTypes.topTimeUpdate:
      case topLevelTypes.topVolumeChange:
      case topLevelTypes.topWaiting:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topAnimationEnd:
      case topLevelTypes.topAnimationIteration:
      case topLevelTypes.topAnimationStart:
        EventConstructor = SyntheticAnimationEvent;
        break;
      case topLevelTypes.topTransitionEnd:
        EventConstructor = SyntheticTransitionEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    if (registrationName === ON_CLICK_KEY) {
      var id = inst._rootNodeID;
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[id]) {
        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === ON_CLICK_KEY) {
      var id = inst._rootNodeID;
      onClickListeners[id].remove();
      delete onClickListeners[id];
    }
  }

};

module.exports = SimpleEventPlugin;
}).call(this,require('_process'))

},{"./EventConstants":21,"./EventPropagators":25,"./ReactDOMComponentTree":46,"./SyntheticAnimationEvent":99,"./SyntheticClipboardEvent":100,"./SyntheticDragEvent":102,"./SyntheticEvent":103,"./SyntheticFocusEvent":104,"./SyntheticKeyboardEvent":106,"./SyntheticMouseEvent":107,"./SyntheticTouchEvent":108,"./SyntheticTransitionEvent":109,"./SyntheticUIEvent":110,"./SyntheticWheelEvent":111,"./getEventCharCode":123,"_process":4,"fbjs/lib/EventListener":143,"fbjs/lib/emptyFunction":150,"fbjs/lib/invariant":158,"fbjs/lib/keyOf":162}],99:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticAnimationEvent
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;
},{"./SyntheticEvent":103}],100:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticClipboardEvent
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":103}],101:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticCompositionEvent
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":103}],102:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticDragEvent
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":107}],103:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if (process.env.NODE_ENV !== 'production') {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if (process.env.NODE_ENV !== 'production') {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (process.env.NODE_ENV !== 'production') {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    if (process.env.NODE_ENV !== 'production') {
      var noop = require('fbjs/lib/emptyFunction');
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', noop));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', noop));
    }
  }

});

SyntheticEvent.Interface = EventInterface;

if (process.env.NODE_ENV !== 'production') {
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}
/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}
}).call(this,require('_process'))

},{"./PooledClass":30,"_process":4,"fbjs/lib/emptyFunction":150,"fbjs/lib/warning":168,"object-assign":169}],104:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticFocusEvent
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":110}],105:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticInputEvent
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":103}],106:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticKeyboardEvent
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventCharCode = require('./getEventCharCode');
var getEventKey = require('./getEventKey');
var getEventModifierState = require('./getEventModifierState');

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":110,"./getEventCharCode":123,"./getEventKey":124,"./getEventModifierState":125}],107:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticMouseEvent
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');
var ViewportMetrics = require('./ViewportMetrics');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":110,"./ViewportMetrics":113,"./getEventModifierState":125}],108:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTouchEvent
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":110,"./getEventModifierState":125}],109:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTransitionEvent
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;
},{"./SyntheticEvent":103}],110:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":103,"./getEventTarget":126}],111:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticWheelEvent
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":107}],112:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Transaction
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occurred.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],113:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],114:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : void 0;
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/invariant":158}],115:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adler32
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;
},{}],116:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule canDefineProperty
 */

'use strict';

var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
}).call(this,require('_process'))

},{"_process":4}],117:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createMicrosoftUnsafeLocalFunction
 */

/* globals MSApp */

'use strict';

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;
},{}],118:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule dangerousStyleValue
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var warning = require('fbjs/lib/warning');

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    if (process.env.NODE_ENV !== 'production') {
      if (component) {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
}).call(this,require('_process'))

},{"./CSSProperty":8,"_process":4,"fbjs/lib/warning":168}],119:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule escapeTextContentForBrowser
 */

'use strict';

var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;',
  '"': '&quot;',
  '\'': '&#x27;'
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextContentForBrowser;
},{}],120:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findDOMNode
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstanceMap = require('./ReactInstanceMap');

var getNativeComponentFromComposite = require('./getNativeComponentFromComposite');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getNativeComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : void 0;
  } else {
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : void 0;
  }
}

module.exports = findDOMNode;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":41,"./ReactDOMComponentTree":46,"./ReactInstanceMap":74,"./getNativeComponentFromComposite":128,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168}],121:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule flattenChildren
 */

'use strict';

var KeyEscapeUtils = require('./KeyEscapeUtils');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = result[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', KeyEscapeUtils.unescape(name)) : void 0;
  }
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))

},{"./KeyEscapeUtils":28,"./traverseAllChildren":141,"_process":4,"fbjs/lib/warning":168}],122:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

var forEachAccumulated = function (arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;
},{}],123:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventCharCode
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],124:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventKey
 */

'use strict';

var getEventCharCode = require('./getEventCharCode');

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":123}],125:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventModifierState
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],126:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],127:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getIteratorFn
 */

'use strict';

/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],128:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNativeComponentFromComposite
 */

'use strict';

var ReactNodeTypes = require('./ReactNodeTypes');

function getNativeComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.NATIVE) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getNativeComponentFromComposite;
},{"./ReactNodeTypes":83}],129:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNodeForCharacterOffset
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],130:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentAccessor
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"fbjs/lib/ExecutionEnvironment":144}],131:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getVendorPrefixedEventName
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;
},{"fbjs/lib/ExecutionEnvironment":144}],132:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule instantiateReactComponent
 */

'use strict';

var _assign = require('object-assign');

var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactNativeComponent = require('./ReactNativeComponent');
var ReactInstrumentation = require('./ReactInstrumentation');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};
_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function getDisplayName(instance) {
  var element = instance._currentElement;
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else if (instance.getName) {
    return instance.getName() || 'Unknown';
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

var nextDebugID = 1;

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node) {
  var instance;

  var isEmpty = node === null || node === false;
  if (isEmpty) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : void 0;

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactNativeComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : void 0;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getNativeNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if (process.env.NODE_ENV !== 'production') {
    instance._isOwnerNecessary = false;
    instance._warnedAboutRefsInRender = false;
  }

  if (process.env.NODE_ENV !== 'production') {
    var debugID = isEmpty ? 0 : nextDebugID++;
    instance._debugID = debugID;

    if (debugID !== 0) {
      var displayName = getDisplayName(instance);
      ReactInstrumentation.debugTool.onSetDisplayName(debugID, displayName);
      var owner = node && node._owner;
      if (owner) {
        ReactInstrumentation.debugTool.onSetOwner(debugID, owner._debugID);
      }
    }
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if (process.env.NODE_ENV !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
}).call(this,require('_process'))

},{"./ReactCompositeComponent":40,"./ReactEmptyComponent":67,"./ReactInstrumentation":75,"./ReactNativeComponent":81,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168,"object-assign":169}],133:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"fbjs/lib/ExecutionEnvironment":144}],134:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextInputElement
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
}

module.exports = isTextInputElement;
},{}],135:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
'use strict';

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : void 0;
  return children;
}

module.exports = onlyChild;
}).call(this,require('_process'))

},{"./ReactElement":65,"_process":4,"fbjs/lib/invariant":158}],136:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule quoteAttributeValueForBrowser
 */

'use strict';

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":119}],137:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule renderSubtreeIntoContainer
*/

'use strict';

var ReactMount = require('./ReactMount');

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":78}],138:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setInnerHTML
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  node.innerHTML = html;
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;
},{"./createMicrosoftUnsafeLocalFunction":117,"fbjs/lib/ExecutionEnvironment":144}],139:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setTextContent
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setInnerHTML = require('./setInnerHTML');

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./escapeTextContentForBrowser":119,"./setInnerHTML":138,"fbjs/lib/ExecutionEnvironment":144}],140:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;
},{}],141:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
}).call(this,require('_process'))

},{"./KeyEscapeUtils":28,"./ReactCurrentOwner":41,"./ReactElement":65,"./getIteratorFn":127,"_process":4,"fbjs/lib/invariant":158,"fbjs/lib/warning":168}],142:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule validateDOMNesting
 */

'use strict';

var _assign = require('object-assign');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var validateDOMNesting = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      if (childTag !== '#text') {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>. ' + 'See %s.%s', tagDisplayName, ancestorTag, ownerInfo, info) : void 0;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
      }
    }
  };

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
}).call(this,require('_process'))

},{"_process":4,"fbjs/lib/emptyFunction":150,"fbjs/lib/warning":168,"object-assign":169}],143:[function(require,module,exports){
(function (process){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 */

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
}).call(this,require('_process'))

},{"./emptyFunction":150,"_process":4}],144:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],145:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],146:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var camelize = require('./camelize');

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":145}],147:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = require('./isTextNode');

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;
},{"./isTextNode":160}],148:[function(require,module,exports){
(function (process){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant = require('./invariant');

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return(
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
}).call(this,require('_process'))

},{"./invariant":158,"_process":4}],149:[function(require,module,exports){
(function (process){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = require('./ExecutionEnvironment');

var createArrayFromMixed = require('./createArrayFromMixed');
var getMarkupWrap = require('./getMarkupWrap');
var invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":144,"./createArrayFromMixed":148,"./getMarkupWrap":154,"./invariant":158,"_process":4}],150:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],151:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
}).call(this,require('_process'))

},{"_process":4}],152:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],153:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],154:[function(require,module,exports){
(function (process){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = require('./ExecutionEnvironment');

var invariant = require('./invariant');

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":144,"./invariant":158,"_process":4}],155:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],156:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],157:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var hyphenate = require('./hyphenate');

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":156}],158:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":4}],159:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],160:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode = require('./isNode');

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":159}],161:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 */

'use strict';

var invariant = require('./invariant');

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function keyMirror(obj) {
  var ret = {};
  var key;
  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;
}).call(this,require('_process'))

},{"./invariant":158,"_process":4}],162:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without losing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
var keyOf = function keyOf(oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};

module.exports = keyOf;
},{}],163:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;
},{}],164:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],165:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"./ExecutionEnvironment":144}],166:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var performance = require('./performance');

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;
},{"./performance":165}],167:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],168:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  warning = function warning(condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
}).call(this,require('_process'))

},{"./emptyFunction":150,"_process":4}],169:[function(require,module,exports){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],170:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":31}],171:[function(require,module,exports){
"use strict";

!function (e, t) {
  "function" == typeof define && define.amd ? define(["exports"], t) : t("undefined" != typeof exports ? exports : e.microlight = {});
}(undefined, function (e) {
  var t,
      i = window,
      n = document,
      o = "appendChild",
      r = "test",
      a = ";text-shadow:",
      l = "opacity:.",
      s = " 0px 0px ",
      c = "3px 0px 5",
      d = ")",
      u = n.getElementsByClassName("microlight"),
      f = function f(e) {
    for (e = 0; t = u[e++];) {
      for (var f, p, h, g, m, y = t.textContent, x = 0, b = y[0], w = 1, v = t.innerHTML = "", k = 0, C = /(\d*\, \d*\, \d*)(, ([.\d]*))?/g.exec(i.getComputedStyle(t).color), N = "px rgba(" + C[1] + ",", E = C[3] || 1; p = f, f = 7 > k && "\\" == f ? 1 : w;) {
        if (w = b, b = y[++x], g = v.length > 1, !w || k > 8 && "\n" == w || [/\S/[r](w), 1, 1, !/[$\w]/[r](w), ("/" == f || "\n" == f) && g, '"' == f && g, "'" == f && g, y[x - 4] + p + f == "-->", p + f == "*/"][k]) for (v && (t[o](m = n.createElement("span")).setAttribute("style", ["", l + 6 + a + s + 7 + N + E / 4 + ")," + s + 3 + N + E / 4 + d, a + s + 9 + N + .7 * E + ")," + s + 2 + N + .4 * E + d, l + 7 + a + c + N + E / 5 + "),-" + c + N + E / 5 + d, "font-style:italic;" + l + 5 + a + c + N + E / 4 + "),-" + c + N + E / 4 + d][k ? 3 > k ? 1 : k > 6 ? 4 : k > 3 ? 3 : 2 * /^(a(bstract|lias|nd|rguments|rray|s(m|sert)?|uto)|b(ase|egin|ool(ean)?|reak|yte)|c(ase|atch|har|hecked|lass|lone|ompl|onst|ontinue)|de(bugger|cimal|clare|f(ault|er)?|init|l(egate|ete)?)|do|double|e(cho|ls?if|lse(if)?|nd|nsure|num|vent|x(cept|ec|p(licit|ort)|te(nds|nsion|rn)))|f(allthrough|alse|inal(ly)?|ixed|loat|or(each)?|riend|rom|unc(tion)?)|global|goto|guard|i(f|mp(lements|licit|ort)|n(it|clude(_once)?|line|out|stanceof|t(erface|ernal)?)?|s)|l(ambda|et|ock|ong)|m(icrolight|odule|utable)|NaN|n(amespace|ative|ext|ew|il|ot|ull)|o(bject|perator|r|ut|verride)|p(ackage|arams|rivate|rotected|rotocol|ublic)|r(aise|e(adonly|do|f|gister|peat|quire(_once)?|scue|strict|try|turn))|s(byte|ealed|elf|hort|igned|izeof|tatic|tring|truct|ubscript|uper|ynchronized|witch)|t(emplate|hen|his|hrows?|ransient|rue|ry|ype(alias|def|id|name|of))|u(n(checked|def(ined)?|ion|less|signed|til)|se|sing)|v(ar|irtual|oid|olatile)|w(char_t|hen|here|hile|ith)|xor|yield)$/[r](v) : 0]), m[o](n.createTextNode(v))), h = k && 7 > k ? k : h, v = "", k = 11; ![1, /[\/{}[(\-+*=<>:;|\\.,?!&@~]/[r](w), /[\])]/[r](w), /[$\w]/[r](w), "/" == w && 2 > h && "<" != f, '"' == w, "'" == w, w + b + y[x + 1] + y[x + 2] == "<!--", w + b == "/*", w + b == "//", "#" == w][--k];) {}v += w;
      }
    }
  };e.reset = f, "complete" == n.readyState ? f() : i.addEventListener("load", f, 0);
});

},{}],172:[function(require,module,exports){
module.exports={
"single":
	[
		"data:image/jpeg;base64,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",
		"data:image/gif;base64,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",
		"data:image/jpeg;base64,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QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFIeRQBVu7hLaCSZztjjUuxx0AGTX5p/BbSz+2x+3Z4m+JGo2DyeB/BDCysEuOVknjJCgDkfe3MeejCv0m1Ow/tGxu7SWNjDcRNA+xudhXBx78muP+D/AMEvC3wN8LSeH/CenfYbGSbz5WJy80pABdj34AoA79PujJyadSL0paACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/9k="
	],
"double":
	[
		"data:image/png;base64,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",
		"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAK8Ag0DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwCn4h8JWPjX9ofUtH1Ca4hga1WTdblQ2ViXHUEY/Cuo/wCGcPCv/QU1n/v5F/8AEVVsP+TpdQ/68f8A2kle20AeOf8ADOHhX/oKaz/38i/+Io/4Zw8K/wDQU1n/AL+Rf/EV7HRQB45/wzh4V/6Cms/9/Iv/AIij/hnDwr/0FNZ/7+Rf/EV7HRQB45/wzh4V/wCgprP/AH8i/wDiK8/8e/BS88NSveaQl1faQqAs+4PLGccllCjj3AOO9fUdFAHx74S0PwPqMq2viO91SwlY4S6hkjMJ9mBQlfryPpXrkX7O3hG4iSWHWNWkjcBldJYiGB7ghOa3vGnwg0fxIZL3Tdmmak3JaNf3Up/21HQ+45+teV2WseNfhJqgsrqJvsbNkW8pL28o9Y2H3T9PxFAzuf8AhnDwr/0FNZ/7+Rf/ABFH/DOHhX/oKaz/AN/Iv/iK7Pwd8R9C8YxrFby/ZtQAy9nOQH9yp6MPp+IFdhQI8c/4Zw8K/wDQU1n/AL+Rf/EUf8M4eFf+gprP/fyL/wCIr2OigDxz/hnDwr/0FNZ/7+Rf/EUf8M4eFf8AoKaz/wB/Iv8A4ivY6KAPHP8AhnDwr/0FNZ/7+Rf/ABFH/DOHhX/oKaz/AN/Iv/iK9jooA8c/4Zw8K/8AQU1n/v5F/wDEUf8ADOHhX/oKaz/38i/+Ir2OigDxz/hnDwr/ANBTWf8Av5F/8RR/wzh4V/6Cms/9/Iv/AIivY6KAPBfE37POmWXh+7utDvNSuL+Fd6QzOhEgH3gMKDnHT3rgvhz4J8M+K9Xl0nWL3ULW7dd1qYXQLJj7yEMp+buPofSvrevnn4ueD5/C/iCLxRo+6G2uJg7GLj7PcZzkegbr9cjvQB0f/DOHhX/oKaz/AN/Iv/iKP+GcPCv/AEFNZ/7+Rf8AxFd14A8YQ+M/DUV6NqXkX7q7iH8EgHUex6j/AOtXU0AeOf8ADOHhX/oKaz/38i/+Io/4Zw8K/wDQU1j/AL+Rf/EV7HRQB8geK/AmneFPHx0e6nu20zzInEuV8wwtjJzjGR83btXrY/Zx8KMARqusEHoRJF/8RUPx/wBDD2ml65GnMbNaTEf3W+Zf1DD8a7z4Za5/b3gDTLh33Twx/Zpv95Pl/UYP40AcV/wzh4V/6Cms/wDfyL/4ij/hnDwr/wBBTWf+/kX/AMRXsdGaAPlf4pfDDR/A50safd3032sS7/tDIcbduMYUf3jXZ+HvgD4a1fw5pmozalqyy3VrHM6o8e0FlBOMp05p/wC0N97w/wDS4/8AadeqeCf+RF0H/sHwf+gCgDzr/hnDwr/0FNZ/7+Rf/EUf8M4eFf8AoKaz/wB/Iv8A4ivY6KAPnD4h/B7wx4M8LPqMGoapLdvKkMCSyR7Sx5OQEB4UGofhv8F9L8XeHZNV1S8v4A07RwLAyDKrwScqe+R+Fanx41l73xHp2hQfN9ki81lHeSThR+QH/fVe0+FdGXw94W03SlAzbQKjkd36sf8AvomgDzT/AIZw8K/9BTWf+/kX/wARR/wzh4V/6Cms/wDfyL/4ivY6KAPHP+GcPCv/AEFNZ/7+Rf8AxFQXn7Pfg6ws5ru61nVoreFDJJI0kWFUDJP3K9qrwj41eN2u7oeEtMcsiMpvTHyXf+GIY644JHrgdqAPMPD3gi38W+M10vR/ta2LSljJMVLxwA8sxAAzjtjqQK9j/wCGcPCv/QU1n/v5F/8AEV1Xwv8ABC+D/Doe5Qf2reASXLd0/uxj2Gefcmu5oA8c/wCGcPCv/QU1n/v5F/8AEUf8M4eFf+gprP8A38i/+Ir2OigDxz/hnDwr/wBBTWf+/kX/AMRR/wAM4eFf+gprP/fyL/4ivY6KAPHP+GcPCv8A0FNZ/wC/kX/xFH/DOHhX/oKaz/38i/8AiK9jooA8c/4Zw8K/9BTWf+/kX/xFH/DOHhX/AKCms/8AfyL/AOIr2OigDxz/AIZw8K/9BTWf+/kX/wARR/wzh4V/6Cms/wDfyL/4ivY6KAPHP+GcPCv/AEFNZ/7+Rf8AxFH/AAzh4V/6Cms/9/Iv/iK9glljgieWaRY40BZnc4Cj1JPSvIPGvxvtLESWXhhUu7gZDXsg/dJ/uj+M+/T60AY3iH4MfD3wtYG71bxBq0CHOxPMiLyH0VQmSa8jk0C01bWxZ+G7TUpUkOIYpWWSZ/c7VAH8h616L4e+HXin4hX/APbGu3U9vay8m6uRmWRfSND0HvwPQGvdfDPhDRfCVl9n0q0WNmH7ydvmll/3m7/Tp7UDPI/Dn7OtjPo8cniG9vbfUGJLRWkqFVXsCSh+b1wcVrf8M4eFf+gprP8A38i/+Ir2OigR45/wzh4V/wCgprP/AH8i/wDiKP8AhnDwr/0FNZ/7+Rf/ABFex0UAeOf8M4eFf+gprP8A38i/+Io/4Zw8K/8AQU1n/v5F/wDEV7HRQB42f2cfCoBP9qax/wB/Iv8A4irvwN020Hw4RxCm97ybe+OWwQBn8AK9Wb7p+leafA7/AJJrF/1+XH/odAHPWH/J0uof9eP/ALSSvba8SsP+TpdQ/wCvH/2kle20AFFFFABRRRQAUUUUAFVNS0ux1ixkstRtYrm2kHzRyrkH39j79at0UAeCeMfgneadI2o+E5ZJ40O/7Iz4mjI7xt/F9Dg+5qLwh8Z9S0WYaZ4rhmuYozsM+zFxEfR1ON36H619AVyni/4e6F4xhLXsHk3oXEd5CAJF9Af7w9j+lAzd0nWNO1ywS+0y8iurZ+jxtnB9D3B9jzV6vmTUvDfjP4Uam2o2M7tZ5wbu3BaJx2EqHp+P4GvTfBfxk0nX/LstYCaZqJwAzN+5lP8Assfun2P5mgR6dRQCCMiigAooooAKKKKACiiigAqjrGk2euaTc6ZfxeZbXCFHXv8AUehB5B9RV6igD5i0q91L4Q/EaW2vN0loSEnwOJ4CflkUeo6/UMK+mLa5hvLWK5tpVlglQPG6nIZSMgiuH+KfgceLvD/n2kYOq2QL2+BzIv8AFH+Pb3A9a4r4J+ODFJ/wiWpSEAktYs/G08lov5kfiPSgZ7lRVa/1Cz0uylvL65it7aIZeWVgqgfWvFPF3xzmld7LwpBtUnb9tnTLMf8AYT+rflQI9G+Jcem3XgTVLTULy3tfMhLQNO4XMi/MuM9TkDp614b8PfiW3gfT9RtnsHvFuHWWJBIECPjDZODwRt6DtV/SPhd4x8a3Q1PXbmW0STnz74l5mH+ynYfXH0r1DQvg34T0hVe5tX1K4HV7tsrn2QYX880DPMrj40eNNZmMWk2tvATwFtbZp3/M5/lUf/F4dZOf+J6qt/u24/8AZa+i7WytbGEQ2lvFBEOiRIFA/AVPigD5lu/hn8SdX2Nf209yUzs+036Ptz1xljip4/B3xY0qJFtv7TSONQqJBqCkKB0AG+vpOigLnzb/AMJN8WvD43XS6sYx1NzZiVfz2/1rS0r4+6tbuI9X0i1uQOGa3YxOPwOR/KvoDFZGr+F9C15CuqaVaXWf4pIxuH0Ycj86APnLQdTtPFPxgh1jWLmG0tZbw3P+kOFUBR+7TJ4zwo/A19RI6yIrowZWGQwOQRXkPiH4C6ZdK0ug30tlL2huMyxH2z94frXBibx/8KLoK/mpY7sBW/fWkn0P8J/75NAH05RXnngv4uaN4oaOzvMabqbcCKVsxyn/AGH9fY4P1rur+/ttM0+e+vJlhtoEMkkjdFUdaBHLfEnxrH4N8NtLEynUrnMVoh5+bHLkei9frgd680+DPgqTV9TbxZqqtJDDITbeZyZZs/NIfXBz/wAC+lc8TqXxh+I/HmRWn5i2tlP/AKEc/ix9BX0rp+n22ladb2FlEsVtboI40XoAKBlmiiigQUUUUAFFFFABRRRQAUUVR1XWNP0Owe+1O8itbZOskjY59B6n2HNAF6uQ8Y/EbQvB0ZjuZvtN+RlLOAgv7Fuyj3P4A15f4v8AjRqOsTHTPCkM1tFIdguNmZ5SeyKM7f1P0p/g/wCCl9qci6l4rlkgjc7zaK+ZpD6yN/D9OT7igZz99rXjT4taobG1hb7GrZNtCSsEQ7GRj1P1/AV6n4L+D+keHDHe6ps1PUl5DOv7qI/7Knqfc/hiu90zSrDRrGOy020itbaP7scS4H19z7mrlAgooooAKKKKACiiigAooooARvun6V5p8Df+Saxf9flx/wChV6W33T9K80+Bv/JNYv8Ar8uP/QqAOfsP+TpdQ/68f/aSV7ZXiVh/ydLqH/Xj/wC0kr22gAooooAKKKKACiiigAooooAKKKKAGyRpLG0ciK6MMMrDII9CK8k8a/BKx1LzL3w2Y7G6OWa0b/UyH2/uH9PYV67RQB81aD498WfDfUBo+tWs01rHwbS6OGRfWJ+ePzX6V7r4X8aaJ4vtPO0u6DSKMy28nyyx/VfT3GR71b1/w3pPiawNnq1nHcRfwk8NGfVWHIP0rwnxR8J/EHhC7/tfw1c3F3bwnerwnbcwD3A+8PcfiKBn0XRXiPgv44g7LHxWm0/dF/EnH/bRB0+o/IV7RaXdvfWsdzaTxzwSDckkbBlYeoIoETUUUUAFFFFABRRRQAV87/GbwxH4d8SW3iDTJ1t2vZC7Ro2HjmXnzFHoep9D9a9m8Z+L7HwZoT6hdnfK3yW9uDhpn9B6AdSew/CvBfD/AIf174ueKp9S1K4dLRGAuLgD5Y16iKIHvj8up5PINESyeMvi9rMcLPvgg27jgpb2/H3iO7Hr3PpgV7Z4M+GWh+EI0nWMXmpAfNeTKMg/7A6IPpz710ui6Jp/h/S4tO0y2SC2iHCr1J7knuT3JrQoEFFFFABRRRQAUUUUAFFFFABUdxbw3UDwXESSwyDa8cihlYehB61JRQB4r45+CUUiyah4UAjkHzNp7t8rf9cyfun2PHpivMdW8ZeJrjw9/wAIvqtzMYbabLrMpE3y9I3J5IB5weenPSvriuD+Ifw1svGVq11bhLbWY1/dz44lA6I/qPQ9R9OKBknwu8I23hfwpDIrxTXt8qz3E8bbgcj5VU91AP4kk13FfOHgDx1qHw/1uTw94gSWPThKUkjflrR/7w9UPUgfUe/0bHIk0SSxurxuAyspyGB6EGgQ6iiigAooooAKKKKACgnFYHijxnonhG08/VLsLIwzHbx/NLJ/ur/U4HvXhWveP/FfxH1A6PotrPBay8C0tTl3X1lfjj8l+tAHo/jT4yaT4f8AMstICanqK5UlW/cxH/aYfePsPzFeY6d4e8Z/FjU11C9ncWecC6nBWGMdxEg6/h+JrvfBXwRstO8q98Ssl7dDBW0T/Ux/7398/kPY165HGkUaxxoqIowqqMAD0AoGcr4Q+HmheDoQ1nB598Rh7yYAyH1A7KPYfjmusoooEFFFFABRRRQAUUUUAFFFFABRRRQAjfdP0rzT4Hf8k1i/6/Lj/wBCr0tvun6V5p8Df+Saxf8AX5cf+hUAc9Yf8nS6h/14/wDtJK9trxKw/wCTpdQ/68f/AGkle20AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAHBeNPhVonizzLqFRp+qHn7TCvEh/wCmi9G+vB968fD+NvhBqm0gizkfocyWtx9P7rfk31r6dqC8srXULSS1vLeK4t5RteOVQysPcGgDjPBfxS0TxaEtnf7BqZHNrMw+c/7DdG+nB9q7qvDvGnwPZC9/4Tfp8xsJX5H/AFzc/wAj+dZHhX4ua74Uuv7J8T29xdwQnY3mjbcwfn94fXn3oGfRFFZeheItK8SWC3uk3sdzCfvbThkPoynlT7GtSgQVW1HULbStOuL+8lWK2t4zJI7dlFWa8K+Ofi55rqHwpZMSqbZrsJ1Zj9yP/wBmx6laAOWkfV/jF8Qdqb4bUZ2g8raW4PX3Y/qT6Cvo7RdGsfD+k2+madCIraBdqjufUk9yTyTXN/DPwYnhDwxGkyD+0rrEt23cHsn0UcfXJrtKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDzr4p/D1PFelnUdPiA1m1TKY489Bz5Z9/7p9eO9cl8FvHbxTL4S1SQgc/YXk4KkdYj+pH4j0r3Kvnz4y+En0DXoPFGl7oYbqUGUx8eTcDkMPTdjP1B9aBn0HRXM+A/FKeL/ClrqXyi5A8q5Qfwyr1/A8EexrpqBBRRXDeM/ilofhEPbK/27UwOLWFh8h/226L9OT7UAdndXdvY20lzdTxwQRjc8kjBVUepJ6V4x40+OKr5lj4UQM33Tfypx/2zU9fqfyNce8vjb4v6rsUE2cb9BlLW3+p/ib82+lev+C/hTonhTy7udRqGqLz9omX5Yz/sL0H1OTQM8y8L/CnxB4xvP7X8S3FxaW8x3s853XMw9gfuj3P4CvddA8NaR4YsBZ6TZx28f8TDl5D6sx5J+ta1FAgooooAKKKKACiiigAooooAKKKKACiiigAooooARvun6V5p8Df+Saxf9flx/wChV6W33T9K80+Bv/JNYv8Ar8uP/QqAOesP+TpdQ/68f/aSV7bXiVh/ydLqH/Xj/wC0kr22gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACud8VeCND8YWvl6najz1GIrmP5ZY/o3cexyK6KigD5p1zwP4u+GeonV9IuppbRP+Xy2HKr6Spzx+a/Su88FfGzT9U8uy8RCOwuzhVuV/1Eh9/wC4frx716yQGBBGQeory/xr8GNL1zzL3RCmm6gcsYwv7iU+6j7p9x+VAz0LVtXttI0O71aZ1NvbwNMSD94AZAH14H418+/C3SJ/GnxFn1zUh5iWrm8mJ5DSsfkX8OT/AMBFc3rE3i7wtptz4T1V7mCymKt5EnzIwVsgxt/dz1A49RXuPwX0QaV4BgumUCfUXa5Y452/dQfkM/jQB6JRRRQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsnxLoUHiTw7faRcY2XMRVWP8DdVb8CAa1qKAPnb4N6zP4c8c3Xhy+zGt4WhZCeFuI84/MBh+Ve7a54h0rw5p7XurXkdtCOBuPLn0UDlj7CvAvi9p83hr4kwa1Ynymugl5GwH3ZkOG/kp/GoNE8FeLvidqI1fVrmWKzkP8Ax+XI6rnpEnHH5D60DL/ir4u654puv7J8L29xaQTHYpiG65n+mPuj6c+9a3gz4HvIUv8AxY5AJ3Cwifk/9dHH8h+den+FPA+h+D7Xy9NtR57DEl1L80sn1PYewwK6OgCvZWNrp1pHaWVvFb28Q2pFEoVVHsBViiigQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFACN90/SvNPgd/yTWL/AK/Lj/0KvS2+6fpXmnwO/wCSaxf9flx/6FQBz1h/ydLqH/Xj/wC0kr22vErD/k6XUP8Arx/9pJXttABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRQelAHzr8dLx9Q8c2WmRknyLVFC/7cjH/Ba+gNNsk07S7SxjACW8KRLj0UAf0r548T/8Tb9oFIW5X+0baH6BQmf5GvpGgYUUUUCCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA8k+Pumifwxp2pAfNa3flk/7Lqf6qK6L4Q6idQ+G2mbjl7bfbEk/wBxiB+mKPi/bC4+GWrE9YvLlH4SLXP/AACuC/hDUbcn/VXxI/4Ein+hoGes0UUUCCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAEb7p+leafA7/kmsX/X5cf8AoVelt90/SvNPgd/yTWL/AK/Lj/0KgDzLxX4un8J/H/WNVt7aGd4olhCSuVBBhTnIrX/4aE1b/oDad/3/AHrQt7W3uv2odRjuIIpYzZZKyIGBPlJzg17F/YWkf9Aux/8AAdP8KAPDf+GhNW/6A2nf9/3o/wCGhNW/6A2nf9/3r3L+wtI/6Bdj/wCA6f4Uf2FpH/QLsf8AwHT/AAoGeG/8NCat/wBAbTv+/wC9H/DQmrf9AbTv+/717l/YWkf9Aux/8B0/wo/sLSP+gXY/+A6f4UAeG/8ADQmrf9AbTv8Av+9H/DQmrf8AQG07/v8AvXuX9haR/wBAux/8B0/wo/sLSP8AoF2P/gOn+FAHhv8Aw0Jq3/QG07/v+9H/AA0Jq3/QG07/AL/vXuX9haR/0C7H/wAB0/wo/sLSP+gXY/8AgOn+FAHhv/DQmrf9AbTv+/70f8NCat/0BtO/7/vXuX9haR/0C7H/AMB0/wAKP7C0j/oF2P8A4Dp/hQB4b/w0Jq3/AEBtO/7/AL0f8NCat/0BtO/7/vXuX9haR/0C7H/wHT/Cj+wtI/6Bdj/4Dp/hQB4b/wANCat/0BtO/wC/70f8NCat/wBAbTv+/wC9e5f2FpH/AEC7H/wHT/Cj+wtI/wCgXY/+A6f4UAeG/wDDQmrf9AbTv+/70f8ADQmrf9AbTv8Av+9e5f2FpH/QLsf/AAHT/Cj+wtI/6Bdj/wCA6f4UAeG/8NCat/0BtO/7/vR/w0Jq3/QG07/v+9e5f2FpH/QLsf8AwHT/AAo/sLSP+gXY/wDgOn+FAHhv/DQmrf8AQG07/v8AvR/w0Hq3/QG07/v+9e5f2FpH/QLsf/AdP8KP7C0j/oF2P/gOn+FAHzN4a1h9f+MWmavNGkT3eorIyIcqpIIwDX1T2r5r8VRR6D8eIpIo0ihW+tZlVQFUBgmeB75r6UoBhRRRQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDkPilj/hWevZ/wCff/2Za8D8E/Em88C2l3bWtjbXIuZRITNIylSBjjFe3/GK6Ft8MtTUnmdooh+Mi/0BrnPgbo1nc+Dry6u7OCZpL5gpliViAqKOMj1zQM5z/hoTVv8AoDad/wB/3o/4aE1b/oDad/3/AHr3L+wtI/6Bdj/4Dp/hR/YWkf8AQLsf/AdP8KAPDf8AhoTVv+gNp3/f96P+GhNW/wCgNp3/AH/evcv7C0j/AKBdj/4Dp/hR/YWkf9Aux/8AAdP8KAPDf+GhNW/6A2nf9/3o/wCGhNW/6A2nf9/3r3L+wtI/6Bdj/wCA6f4Uf2FpH/QLsf8AwHT/AAoA8N/4aE1b/oDad/3/AHo/4aE1b/oDad/3/evcv7C0j/oF2P8A4Dp/hR/YWkf9Aux/8B0/woA8N/4aE1b/AKA2nf8Af96P+GhNW/6A2nf9/wB69y/sLSP+gXY/+A6f4Uf2FpH/AEC7H/wHT/CgDw3/AIaE1b/oDad/3/ej/hoTVv8AoDad/wB/3r3L+wtI/wCgXY/+A6f4Uf2FpH/QLsf/AAHT/CgDw3/hoTVv+gNp3/f96P8AhoTVv+gNp3/f969y/sLSP+gXY/8AgOn+FH9haR/0C7H/AMB0/wAKAPDf+GhNW/6A2nf9/wB6P+GhNW/6A2nf9/3r3L+wtI/6Bdj/AOA6f4Uf2FpH/QLsf/AdP8KAPDf+GhNW/wCgNp3/AH/ej/hoTVv+gNp3/f8Aevcv7C0j/oF2P/gOn+FH9haR/wBAux/8B0/woA8N/wCGhNW/6A2nf9/3o/4aE1b/AKA2nf8Af969y/sLSP8AoF2P/gOn+FH9haR/0C7H/wAB0/woA8NP7QerEf8AIG07/v8AvXafApt/wxgb1u5z/wCPV3p0LSMH/iV2P/gOn+FcH8DePhrD/wBfk/8A6FQI5+w/5Ol1D/rx/wDaSV7bXidh/wAnS6h/14/+0kr2ygAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoorL1rxFpHh21+06tqEFpH28xvmb/AHVHJ/AUAeG/Hmwez8X6fqcQI+0WuA3+3Gx/oy17xouoJq2iWOoRkFbm3SYY/wBpQa+d/ij8RtO8aR2tnp9hKkVpKXS6mbazZGCAnYHg8nPA4r0r4Ia6NS8Ef2c75n02UxY7+W3zIf1YfhQM9MooooEFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB498f8AUxFoWlaWGGbi5MzD/ZRcfzb9K634UaadM+G+kIykSTobhh/vsWH6YrxP4x66us+PrmBHBg09BaLzxu6v+px/wGvTfB3xj8OXtrbadfodHmijWJPNbdCQAAMP2/4EB9aBnqdFMimjniWWGRZI3GVdDkEexHWn0CCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAEb7p+leafA3/kmsX/X5cf+hV6W33T9K80+Bv8AyTWL/r8uP/QqAOesP+TpdQ/68f8A2kle214lYf8AJ0uof9eP/tJK9toAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiuZ8TeP8Aw74UUrqN8pucZFrD88p/4COn1OKAOmrD8Q+MNC8LQeZq2oRQuRlYR80j/RByf5V4lr3xj8S+JLn+zvDdpJYrKdqCFfNuX/EDC/gPxqXw98FNd1uf7d4lvGslkO51LebcSfUkkL+JJ9qBkniT446tqchsvDNkbRXO1ZpF8yd/91RkD9TVLRfhL4s8W3f9peIrqWySTlpLtjJcOPZc/L+JH0r2zw34I8P+FYgNL0+NJsYa4k+eVvqx5/AYFdDQBxejfCzwrounTW0dgLiWeJopbm4+eQhhg47L+AFeOeBdRn+HXxQl0rUWKQSSGyuGbgYJzHJ9OQfoxr6Xrxj45+DjcWsXiizjy8CiK9CjrH/C/wCBOD7EelAHs9FeefCXxqPFHhwWV3LnVLBQku48yp0V/wCh9x716HQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsHxn4ji8K+Fb3VXIMkabYEP8cp4Ufnz9Aa3q+cfil4on8b+L7bw9o2Z7a2m8mIIeJ5zwW+g6A/7xoAs/BXwx/b2vX+v6nEtxBAGjHmqGWWaTliQeuFJ/76Fdl4o+B+iapvn0SQ6VcnnywC8DH/AHeq/gce1dv4R8OQeFPDNnpMBDGJcyyAf6yQ8s34n9MVuUAfMbW/xB+FU5eMzR2Iblk/fWr/AFH8P/jpr0Lwv8dNJ1DZBr9udNnPHnpl4Sf5r+OR716w6LIjI6hlYYIIyCK878UfBrw5ru+ewU6VeNzvt1/dsfePp+WKBnf2l5bX9slzaXEU8DjKyROGVvoRU9fMt34Z8ffDK5e8sJJ/sgOWnsyZIWH/AE0jPT8R+Ndn4X+PFrPst/Eln9nc8fa7UFoz7snUfhmgR7PRVPTNW0/WbNbvTbyG6t26SROGH09j7GrlABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAjfdP0rzT4G/8AJNYv+vy4/wDQq9Lb7p+leafA3/kmsX/X5cf+hUAc9Yf8nS6h/wBeP/tJK9trxKw/5Ol1D/rx/wDaSV7bQAUUUUAFFFFABRRRQAUUUUAFFFFABRSEhQSTgDqa4HxR8XfDXh0vBBMdTvV48m1YFVP+0/Qfhk+1AHf1xvij4neGvC2+Ge7+1Xq/8utrh3B/2j0X8TXjV/438d/Ea7fT9Khnjt2OGtrAFQB/00kP9SB7V1Hhf4DKNlx4mvd3f7JaNgfRn6/kB9aBnO6v8UPGXjW8Om6Dby2kcnAgsQXmYf7Unb8MD3rX8M/Am+u3F14nvfs6sdzW1uweVv8Aec8D8M/WvatI0PS9BsxaaVYwWkI/hiXGfcnqT7mtCgDH0Hwtovhm28jSNPhtgR8zgZd/95jya2KKKBBRRRQAVHcW8V1by288ayQyqUdGGQykYINSUUAfMniLR9V+EnjqDUNNLGyZi1q7/dkj/ihf3A4/I19A+FvE+n+LNDh1PT3+VvlkiJ+aJ+6t7j9RzXn3xx8T6dbaCvh4wxXN/dFZfm5+zKDw/sx5A9s15T4c1vxD8O9QstVW1mjtL+MSeTKCI7qLPb0I6g9RkdjyDPrGisPwt4s0rxdpS32mTbsYEsLcPC391h/Xoe1blAgooooAKKKKACiiigAooooAKKKKACiivLfiV8Vrfw6k2kaLIk+rkbZJR8yWv19X9u3f0IBB8XviMujWkvh7SZv+JlOmLiVD/wAe8ZHTPZyPyHPpUHwZ8ANplsvibVISt3OmLOJxgxRn+MjsWHT0H1rxtY9S0fUtM13V9OkuIrmT7WgvASt0A3zZJ659/UHpX1loGt2PiLRbbVNPk32865A7qe6kdiDwaBmlRRRQIKKKKADGa4bxR8KPDXiUvOLf+z71uftFoAuT6sv3W/n713NFAHzVqXw98cfD+8bUdGnmnhXk3Onk7sf7cfUj/voV0Phj48SxlbbxNZbwPlN3aLgj/ej/AMPyr3SuS8T/AA38N+Kt0t5ZCG8I/wCPu2wkn49m/EGgZtaL4h0nxFaC50m/gu4+/lt8y+zL1U/UVp184618JvFvhG7/ALS8P3Mt6kfKy2ZMdwg90/i/An6VoeG/jlqmnSCz8TWRu1Q7WmiXy5k/3kOAT/3yaAPfqKw/D3i/QvFFv5uk6hFOwGWiztkT6oeR/KtygQUUUUAFFFFABRRRQAUUUUAFFFFACN90/SvNPgd/yTWL/r8uP/Q69Lb7p+leafA7/kmsX/X5cf8AoVAHPWB/4ym1D/rx/wDaSV7bXiVh/wAnS6h/14/+0kr22gAooooAKKKKACiiigAoqG6u7extnubqeOCCMZeSRgqqPcmvLfFHxz0jTt8GgwHU7gcec2UgU/Xq34YHvQB6rLLHDG0krqkajLMxwAPUmvN/FHxp8P6Lvt9Lzq12Mj9y2IVPu/f/AIDmvLhH8QfitPuPnSWJbqf3Non0/vH/AL6Nej+F/gdoumbLjXJTqlyOfKwUgU/7vVvxOPagZ5zPrXxA+KVw9vaJM1kThobb91boP9tz978SfpXc+F/gRYWmy48R3RvZBz9ltyUiHsW+836V67b20FpAkFtDHDCgwscahVUewFS0CKthptlpVolpYWsNtbp92OFAqj8BVqiigAooooAKKKKACiiigArnvGfiyz8HeHptSucPL9y3gzzLIeg+ncnsK2r29ttOspry7mSG3gQySSOcBVHU1806rf6t8YPH8VrZh47RSVgVh8tvCD80je54P1wKALXgHwre/Ejxdc67rhaaxjl8y5duBO/aIf7IGM+gwO9e+674b0rxHo7aXqVqslsR8m35TGR0ZD/CRUmg6HZeHNFttL0+PZbwLgZ6se7E9yTya0qAPmbXvCPij4V6wNX0q5leyU4S8iXI25+5MvT8+D2wa9L8F/GTSNeWOz1kx6ZqJwAWb9zKf9lj90+zfma9MkjSaNo5EV0YYZWGQR6EV5N4w+B+nakZLzw7Imn3JyTbOCYHPt3T8Mj2oGetAhgCDkHoRS18xwa74/8AhdcpaXayra5wkF1+9gcD+4wPH4EfSvQtC+PGi3arHrVlcafLxmSMedH9ePmH5GgVj1qisTS/F/h3WgDp2s2VwT/AsoDf98nB/StvNABRRRQAUVHNcQ28ZknlSJB1Z2Cgfia5PV/ih4P0YMJtZhnlX/lla5mY/wDfPA/E0AdhVHVdZ07Q7F73U7yG1t16vK2M+w7k+w5rxTxD8e7uYPD4f01bdTwLi7+ZvqEHA/EmsPS/AXjf4iXkepaxPNDbPyLq+JztP/POPjj8hQM1PGnxk1DXJDpPhWKe3hlby/tAU+fNnsijlc/99fStX4e/BsxvFq/iuIM+d8Wnk5APXMvqf9n889K7/wAIfDvQvB0Ye0g8++Iw95OAZD7Dso9h+Oa62gDnvGPhKy8X+HZdMuAqSAb7eYDmGQDgj27EdxXhngLxTffDbxdc6HritFYyS+XdIeRC/aVf9kjGfUYPavpSvM/i38P/APhJdL/tbTYQdWs0OVUc3EY5K/7w5I/Ed6BHpSOsiK6MGVhkMDkEU6vFfgx8QPNSPwpqsv7xB/oEjn7yjrEfcdvbI7CvaqACiiigAooooAKKKKACud8SeB/D/iuM/wBqaejTYwtzH8kq/Rh1+hyK6KigD568QfBXX9Cn+3+Grxr1YzuRVbyriP6EHDfgQfamaB8ZfEnh25/s/wASWj3yxna4lXyrmP65GG/EfjX0RWNr/hXRPE1t5Or6fDcYGFkIw6f7rDkUDKfhrx74d8Voo02/T7SRlrWb5JV/4Cev1GRXS14J4m+BV/ZObvwxem5VTuW3nYJKv+64wCfrj61laP8AFLxj4LvBpuv2013GnBgvgUmUf7L9x9c/WgD6QorjvC/xN8NeKdkNvefZr1v+XW6wjk/7J6N+BrsaBBRRRQAUUUUAFFFFACN90/SvNPgd/wAk1i/6/Lj/ANDr0tvun6V5p8Df+Saxf9flx/6FQBz1h/ydLqH/AF4/+0kr22vErD/k6XUP+vH/ANpJXttABRRRQAUVm6zr+k+H7Q3WrX8FpF2MjYLeyjqT9K8f8UfHlm32/hmy254F3dr/AOgx/wCJ/CgD2fUdUsNIs3u9Ru4bW3TrJM4Ufr1PtXkvij48WduHt/Ddp9qccfa7kFIx7hfvN+OK4/TvAPjn4hXi6jrE00MLci51AkHH+xH6fgor1rwv8JfDXhsxzvb/ANo3y8+fdgMFP+yn3R+p96BnkFt4d8f/ABQuUu715jaE5We7PlwKP9hB1/AfjXqXhf4MeHdD2XGog6teLzunXESn2j6f99Zr0gADpRQIakaRIqRqFRRgKowAPanUUUAFFFFABRRRQAUUUUAFFFFABRRXmXxc+IH/AAjemf2Pps2NVvE+Z1PNvEeC3sx5A/E9qAOL+LvjmXxBqg8KaKzTWsUoSYxcm4mzgIPUA/mfpXpvw38DReDNBCzKj6pc4e6lHOD2QH0X9Tk1xfwX8AfZ4k8VapD++kX/AECJx91T1kPue3tz3r2igYUUUUCCiimuyohZiAoGST2FAHzv8btQl1fx3Z6LbksbWFI1Uf8APWUg/wAtleiXvwW8J31jDGIJrS5jiVGntZNu9gMbipyCT16V5h4NVvGnxrOpuu6EXUl8e+ETiMfnsr6VoGeC6n+z7fIxbTNbt5h2W6hKEfiuR+grHHww+JWlcWMshUdPsupFR+RIr6SooFc+WNb1D4keFPITV9V1e08/d5W6837tuM4wx9RWja6H8V9ds4bmK51eW2nQSRu+ohAykZB+/muk/aG+/wCH/pcf+yV6p4J/5EXQf+wfB/6AKBnh0XwW8bapJu1G6tY89Wubtpj+gP8AOup0n9n+xj2tq+tTz+sVrGIl/wC+jk/yr2aigVzwn4sfD3RvDfhGyvdEshAYLkJO+4s0iuMAsT6ED867z4Q6v/a3w608M26WzLWj5PPyH5f/AB0rW5410f8At7wZq2mgZeW3Yx/76/Mv6gV5L+z/AKxs1DVtHc4E0a3UYPqvysPyK/lQM94ooooEFFFFAHgHxf8AAsuh6kPFeiq0VvJKHuBFwbebPEgx0BP5N9a9I+GnjqPxnoQFwyLqtqAl1GON3pIB6H9DkeldjeWlvf2c1pdwpNbzIUkjcZDKeCDXzTrWmar8IfH0N5YlntGJe2Zz8s0JPzRP7jp+RoGfTlFZfh7XrLxLoltqunyboJ1zg/eRu6t6EHitSgQUUUUAFFFFABRRRQAUUUUAFZ2r6Fpev2ZtdVsILuE9FlTJX3B6g+4rRooA8P8AFHwG+/ceGb33+yXbf+gyf4j8a5nT/HPjr4dXa6fq0M0sC8C2vwSCP+mcg/oSPavpaquoabY6raPaahaQ3Vu/3o5kDKfzoGcX4X+LnhrxGY4Jpzpt63HkXRAVj/sv0P6H2rvQQRkHINeO+KPgRY3Qe48OXZtJDz9luCXiPsG+8v45rh7fXfH/AMLblbW7SZbMHCw3Q823f/ccdPwI+lAH03RXmvhf40+Hta2W+p50m7PH75sxMfZ+3/AgK9IjkSaNZI3V0YZVlOQR7GgQ6iiigBG+6fpXmnwO/wCSaxf9flx/6FXpbfdP0rzT4G/8k1i/6/Lj/wBCoA56w/5Ol1D/AK8f/aSV7bXz7qfiLT/C/wC0bquqak7rbpZhcRoWZmMSYAHr9ai1/wCM/iLxBcf2f4bs3sllO1PLXzbl/pgYX8AfrQB7b4g8W6H4Yt/N1fUIrckZWLO6R/8AdUcmvHPEvxz1K/c2fhmyNqrnas8yiSZ/91BkD9TVbw/8F/EOv3H2/wAS3j2KyHc4kbzbl/rk4X8SfpXsXhrwJ4e8KRj+zLBBcYw1zL88rf8AAj0+gwKBnimjfCnxf4xvP7S8QXMtmknLTXpMk7D2Tt+OPpXsHhf4a+G/CuyW1sxcXq/8vdz88mfbsv4AV19FAgooooAKKKKACiiigAooooAKKKKACiiigAooqve3ttp1jPe3kyw28CGSSRzgKo6mgDF8aeLbTwd4em1K4w8x+S3gzzLIeg+ncnsBXh3w/wDCt78R/FtzruuFprGObzLl24E8nURD/ZAxn0GB3qrql9q3xg+IEVtaB47RSVgVhxbwA/NIw/vHj8cCvozQtEsvDujW2l6fFst4F2j1Y92J7knk0DNBFVECIoVVGAAMACloooEFFFFABXKfEnWf7D8AatdK22V4TBF/vP8AKPyyT+FdXXiv7QGshLTSdFVv9Y7XUo9lG1f1LflQA39n7Rtltq2ssv32W0iPso3N+pX8q9srkvhpo39ifD/SbZ02zSRfaJf96T5v5ED8K62gAooooA8N/aG+/wCH/pcf+069U8E/8iLoP/YPg/8AQBXlf7Q33/D/ANLj/wBp16p4J/5EXQf+wfB/6AKBm9RRRQID0r5psv8Aihvjr5X+rthfmPnp5M3T8BuH5V9LV8//AB80g2uv6ZrMI2/aYTCzD+/Gcqfyb/x2gaPoCisjwtq413wrpmqA5Nzbo7f72MMPzBrXoEFFFFABWB4w8K2fi/w9Ppl2Nrn54JgOYpB0YfyI7gmt+igD5q8D+Jr/AOGXjG50XW1aOyklEd2h5ETfwyr6jGM+q/SvpNHSWNXRlZGAKspyCD3Brzj4s+AP+Eo0r+09Oizq9mhwq9Z4xyU+o6j8R3rm/gx4/wAhPCmqy4Zc/YJHPJHeI+47fiOwoGe20UUUCCiiigAooooAKKKKACiiigAooooAKiubW3vLd7e5hjmhcYeORQysPcGpaKAPKfFHwO0bUt8+hTHS7g8+UQXgY/Tqv4HHtXnOPiD8Kp+POjsQ3b99aP8A/E/+OmvpymyRpLG0ciK6MMMrDII9CKAPKvC/xy0fUtlvrsJ0y4PHnAl4GP16r+PHvXqNrd297bpcWs8c8LjKSRuGVh7EV554o+C/h7W99xpoOk3ZycwLmJj7p2/4DivLrnw/4/8AhfcvdWTzizBy01oTLAw/20PT8R+NAz6Zb7p+leafA3/kmsX/AF+XH/oVY3hj472d0qW/iO0+ySEY+1WwLxH3K/eX8M1sfAwhvhpCQcg3k+P++qBHn+reFLfxV+0fqmmXs8sVu8SzsYcbiBCnGSOK9z8P+E9D8MW/k6Tp8VuSMNLjMj/7zHk15ZYf8nS6h/14/wDtJK9toAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr59+LnjmXxFqy+FdFLTWsUwSYxcm5mzgIPUA/mfpXafF34gf8I5pn9jabNjVbxPmdTzbxHgt7MeQPxPYVjfBf4f/ZoU8U6pD++kX/QYnH3EP/LQ+57e3PegZ2fw38DReC9BCzKj6pc4e7lHOD2QH+6v6nJrtKKKBBRRRQAUUUUAFfNXjRj40+NQ02MloRcxWI74VOZD+e/8q+iNY1GPSNGvdRmIEdrA8xz32gnFeBfBDTpNW8dXmtXILG1heQsf+espx/LfQM+iEVURVUAKBgAdhTqKKBBRRRQB4b+0N9/w/wDS4/8AadeqeCf+RF0H/sHwf+gCvK/2hvv+H/pcf+069U8E/wDIi6D/ANg+D/0AUDN6iiigQV598ZtH/tT4e3U6rmWwkW6X1wDhv/HWJ/CvQarahZRajp1zYzjMVxE0T/RgQf50AeZfAfWPtnhK60t2y9hcHaM9Ek+Yf+Pbq9Wr5x+Dt5L4e+JVxotydpuEktXB/wCekZJH8m/Ovo6gAooooAKKKKACvAvjD4Ek0i//AOEs0ZGjgkkDXQi4MEueJBjoCevoee9e+1DdWsF7ay2tzEssEyFJI3GQykYINAHGfDLx3H4y0Py7llXVrQBblOm8dpAPQ9/Q/hXc18x+INJ1T4R+PIL/AE4s1mzF7V3+7LH/ABRP7jp+Rr6H8OeILLxPodtqtg+6GZeVJ+aNh1VvcGgDVooooAKKKKACiiigAooooAKKKKACiiigAooooAKQgEYI4paKAOC8U/CXw14j8yeOA6betk+faAKGP+0nQ/ofesz4GRL/AMKyt1bnbdzj/wAer09vun6V5p8Dv+Saxf8AX5cf+h0Ac9Yf8nS6h/14/wDtJK9trxKw/wCTpdQ/68f/AGkle20AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABXO+NPFtp4O8PTajcYeY/JbwZwZZD0H07k9hW1fXttptjPe3kyw20CGSSRzwqjqa+atTvdW+MHj+K2tQ0VquVgVh8tvAD80jf7R4+pwKALXw/8ACl78RvFlzruuFprGObzLl24E8nURj/ZAxn0GB3r6SVVRQqgBQMAAYAFZ+haJZeHdGttL0+Ly7eBNo9WPdie5J5NaNABRRRQAUUUUAFFFFAHm3xu1j+zvATWaNiXUJ0gx32D5m/8AQQPxqL4G6R9g8DvfuuJNQuGkB/2F+Rf5Mfxrh/jrqb6j4xsNGtyWNpAPlH/PWU8D8gv517roOlx6LoGn6ZGAFtbdIuO5AwT+JyaBmjRRRQIKKKKAPDf2hvv+H/pcf+069U8E/wDIi6D/ANg+D/0AV5X+0N9/w/8AS4/9p16p4J/5EXQf+wfB/wCgCgZvUUUUCCiiigD5s+JEMnhD4vprEK7Vkki1BMd+cOPxKn/vqvo+CZLiCOaJg0cih1I7gjIryH4/aP52jaZrCKCbaYwSH/ZcZH/jy/rXW/CjWDrPw7013bdLaqbWQ+6cD/x3bQM7WiiigQUUUUAFFFFAGF4t8L2Xi7w/Ppd4NpYboZgMtFIOjD+o7jIrwXwX4k1D4XeM7nR9aVksnkEd2nUIf4Zl9Rj819xX0vXnPxX8ADxVpH9o6fFnWLNTsA6zx9TGffuPfjvQB6JHIk0SSxOrxuoZWU5DA9CDTq8O+DHj8oyeE9VlI5IsJJDgj1iOfxx+I9K9xoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAEb7p+leafA7/AJJrF/1+XH/oVelt90/SvNPgd/yTWL/r8uP/AEOgDnrD/k6XUP8Arx/9pJXtteJWH/J0uof9eP8A7SSvbaACiiigAooooAKKKKACiiigAooooAKKKKACiivMPi78QP8AhHdMOi6bMBqt4nzup5t4jxu9mPIH4n0oA4v4t+OJvEerr4V0QtNaxTBJfK5NzPnAQeoU/mfpXqHw48Dw+C9ACSqr6nc4e7lHOD2QH+6v6nJri/gx8P8A7LCninVIf38q/wCgxOPuIf8AloR6nt7c969noGFFFFAgooooAKKKKACkJABJOAOpNLXL/EXWf7C8BaveK22UwmGL/ff5R/PP4UAeI+FwfG3xv+3ON8H2uS8OeQI4/uD9Er6WrxD9n7RgI9W1p16lLSI+w+Zv5r+Ve30AwooooAKKKKAPDf2hvv8Ah/6XH/tOvVPBP/Ii6D/2D4P/AEAV5X+0N9/w/wDS4/8AadeqeCf+RF0H/sHwf+gCgZvUUUUCCiiigDnfHmjf294H1bT1XdK9uXi4/jX5l/UV5Z+z9rO241bRXbh1S7iBPcfK380r3U9K+adJ/wCKF+Of2dvkthetBz08qb7v5bl/KgZ9LUUUUCCiiigAooooAKKKKAPBfjH4DfTbw+LNHRkhdw14sfBikzxKMdATjPocHvXffC/x4njHRPIu3UavZqFuF6eYOgkA9+/ofqK7e5t4bu2ltriNZYZVKSIwyGUjBBr5p8S6Lqfwl8dW+o6YzGyZi9o7dHT+KF/XA4+mD1oGfTdFZHhrxFZeKdCt9VsGzFKPmQn5o3H3lb3B/wAe9a9AgooooAKKKKACiiigAooooAKKKKACiiigBG+6fpXmnwN/5JrF/wBflx/6FXpbfdP0rzT4Hf8AJNYv+vy4/wDQqAOesP8Ak6XUP+vH/wBpJXtteJWH/J0uof8AXj/7SSvbaACiiigAooooAKKKKACiiigAooooAKKKr319babYz3t5MkNtAhkkkc8Ko6mgDF8a+LbTwb4el1G4w8x+S2gzzLIeg+ncnsBXh/w+8KXvxF8V3Gva4WmsY5vMuXbgTydRGP8AZAxn0GB3qpqV7q3xg+IEdvaq0VquVhVh8ttAD8zt/tH9Tgdq+jND0Wy8PaNbaXp8Xl28CbV9WPdie5J5NAzQVQihVAAAwAO1LRRQIKKKKACiiigAooooAK8X/aA1ny7DSdGV/wDWyNdSj/ZUbV/Vj+Ve0V81eOHbxp8aBpcbFoluIrBe+FU5kP5l/wAqAR7N8MdG/sT4faVAybZpo/tMv+9J836AgfhXX02NFijWNAAqgBQOwFOoAKKKKACiiigDw39ob7/h/wClx/7Tr1TwT/yIug/9g+D/ANAFeV/tDff8P/S4/wDadeqeCf8AkRdB/wCwfB/6AKBm9RRRQIKKKKACvn349aS1p4k03WYRt+1QeWzD/npGcg/kw/KvoKvPPjRpH9p/D24uEXMthKlyvrtHyt+jE/hQB13hnVl13wzpuqIc/abdJG9mx8w/A5rVryv4Eax9s8H3GmO2ZLC4O0E9I3+Yfrur1SgAooooAKKKKACiiigArE8V+GbLxboE+l3owHG6KUD5opB91h9P1GRW3RQB8z+EPEOo/Czxtc6VrCMtk7iO7QZIH92ZPUY59x7ivpWGWOeFJonV45FDI6nIYHkEH0rz/wCKvgEeLdH+3WMY/tizUmLH/LZOpjP8x7/WuP8Agz4+a3lTwlq0hALEWLycFW7xHP6fiPSgZ7nRRRQIKKKKACiiigAooooAKKKKACiiigBG+6fpXmnwO/5JrF/1+XH/AKFXpbfdP0rzT4G/8k1i/wCvy4/9CoA56w/5Ol1D/rx/9pJXtteJWH/J0uof9eP/ALSSvbaACiiigAooooAKKKKACiiigAooooAK+fPi344m8SaunhXRC01rFMEl8rk3M+cBB6gH8z9K7P4vfED/AIR7TTommzY1S8T53U828R7+zHkD05PpWT8GPh/9kgTxTqkP7+Vf9Bicf6tD/wAtCPU9vbnvQM7P4ceB4fBegBJQj6nc4e7lHPPZAf7q/qcmuzoooEFFFFABRRRQAUUUUAFFFFAFLV9Rj0nRr3UZSPLtYHmbP+yCa8C+CenSaz49vNaucsbWJ5WY8/vZSR/LfXoXxt1j+zvAT2aNiXUJkgx32D5m/RQPxqD4GaObDwTJqDriTUbhpAfVE+Rf1DH8aBnp9FFFAgooooAKKKKAPDf2hvv+H/pcf+069U8E/wDIi6D/ANg+D/0AV5X+0N9/w/8AS4/9p16p4J/5EXQf+wfB/wCgCgZvUUUUCCiiigAqtqNlFqWm3VjMMxXETRP9GBB/nVmigD5x+DV7JoHxHudFuTtNyklswJ/5axkkfyb86+jq+a/iNE/hD4wpq8K7UeWLUFx35w4/Eq3519IwypPCk0TBo3UMrDuCMigbH0UUUCCiiigAooooAKKKKACvCPjL4CaxuW8W6QjJGzhr1I+DG+eJRjpk4z6HB7mvd6jngiureSCeNZIpFKOjDIZSMEEelAHCfC3x6vi/Rfst44Gr2agTjp5q9BIPr0PofqK7+vmXxToWpfCjxzb6lpLN9jZzJaO2SCv8UL+vHHuMHqK+gvC/iSy8V6Db6rYt8kgw8ZPzROPvKfcf4HvQBsUUUUAFFFFABRRRQAUUUUAFFFFACN90/SvNPgd/yTWL/r8uP/Qq9Lb7p+leafA3/kmsX/X5cf8AoVAHPWH/ACdLqH/Xj/7SSvba8SsP+TpdQ/68f/aSV7bQAUUUUAFFFFABRRRQAUUUUAFc5428XWng3w9LqM+152+S2gzzLIeg+g6k+lbd/fW2mWE97eTLDbQIZJJGPCqOtfNWo3mrfGH4gRwWoaK1XKwqw+W2gB+Z2/2jx9TgdqALnw88J3nxE8V3Gv66WmsY5vMuHbgXEnURj/ZAxn0GB3r6QVQihVACgYAHaqGh6LZeHtHttL0+Ly7a3Tao7se7E9yTyTWhQAUUUUAFFFFABRRRQAUUhIAzWPqPizw9pIP2/WrCAjqrzru/LOaANmivP774z+C7PIjv5rsjtbW7n9SAP1rnLz9oHTUyLLQryb0M0qRj9N1AHO/HXVJNR8X2GiwEsbSEfKO8spGB+QX86900DS00Tw/p+mRgbbW3SLjuQOT+ea+Tr7xVcX/jd/EzQwtcm6FykEhLoNuNqnoSBgenSux/4Wh8SdUJ+wxOM9rXTS36kNQM+kc0V83ef8YtT6DXlB9I1gH8hR/whHxY1EZnl1HB/wCe+qY/TfQB9Hs6qMsQB6nioXv7SP791Av1kA/rXzunwa8dXZzcXFquevnXzt/IGrCfAHxHJzLqWlL+Mjf+y0Ae8Pr2kR/f1WxX/euEH9aiPifQB11zTR9buP8AxrxJP2e9WP39Z04fSBzUw/Z6v++vWY+lq3/xVACfHjVdO1NtC+wX9rd+WJ9/kTLJtzsxnB46GvTPBviPQ4fBeiQy6zp0csdjCro10gZSEGQRng15x/wz3djp4ht//ARv/iqa37PV728QWp+to3/xVAHs48R6G33dZ04/S6T/ABqZNY0yT7moWjf7s6n+teHN+z3qP8OuWJ+tsw/rULfs+60Puavph+sTj+hoA9+W7t3+7PEfo4NS5Br51f4DeKYv9VqGlt9JZF/9lqE/CL4gWhzbzxE/9MdRZf54oA+kaM183/8ACH/FvT/9TLqmB/zx1MN+m+k+0/GLTuo15gPWJZh/I0Add8ftHE2jaZrCKN1tMbeQ/wCy4yP/AB5f1rr/AIU6x/bPw70x3bdLbKbWQ+6HA/8AHdprxDX/ABh491HRp9J163uHtZcbvO00owIIIIYKMHIqDwT8StR8C291aQWlvcwzyiUpO7IVbGDjHrx27UAfVVFeKWn7QcDAC88PTL6tBcq36ED+db9l8c/CVzgXAv7Q9/Mt9wH4qTQI9MorlrH4keDtRYLB4hsgx/hmfyj/AOPYrora8tbyPzLW4inT+9E4YfmKAJ6KKKACiiigAooooAxvFPhuy8V6BcaVfL8kgzHIB80Tj7rj3H6jIr5/8Ka9qXwp8cXGmasrfY3cR3ca5IK/wzJ68c+4yOor6Zrz/wCKfgJfF2i/a7JANYs1JhI/5bL1MZ/mPQ/U0Ad5BPFcwRzwyLJFIodHU5DA8gg+lSV4T8GvHrWdwvhLV5GVGYrZPJwY3zzEc9MnOPQ5HpXu1ABRRRQAUUUUAFFFFABRRRQAjfdP0rzT4Hf8k1i/6/Lj/wBDr0tvun6V5d8E5TF8NYMIzZvLj7o/2qAMSw/5Ol1D/rx/9pJXtteJ2H/J0uof9eP/ALSSvbKACiiigAooooAKKKKACiivL/i98QP+Ee006Jps2NUu0+d1PNvEe/sx6D8T6UAcX8WvG83iXWE8K6IWmtYpgknlcm5nzgKPUKfzP0r1L4c+B4fBegCOQI+p3OHu5Rzz2QH+6v6nJrjPgx8P/scCeKNUhxcSr/oMTj/Vof8AloR6kdPb617LQMKKKrX2o2WmW5uL67gtYR1kmkCL+ZoEWaK801v43eF9N3R2H2jVJh08hdsf/fbY/QGvPtQ+NHi/XJza6JZxWhbhUtoTcTfmRj/x2gD6JlljhjMksioi8lmOAPxrkdX+KPg/RyyS6zDPKv8AyztQZj/47x+teORfDv4i+MJFn1Z50jb+PU7k8fSMZI/IV12kfs/2MYVtY1iec94rVBGv5nJ/lQMZq37QNqm5dI0SaX0ku5RGP++Vyf1FcvL8VPiD4kkMWkwmMN0XT7MyH/vo7v6V7LpPwz8IaOVa30S2lkH/AC0uQZm/8ezXUxQxwRiOKNY0HRUGAPwFAHzePAvxQ8TkNqL3oRu9/e7QP+AAn+VbGnfs+374bUdctoPVbaAufzJH8q97ooFc8ssfgN4ZgAN3d6jdsPWVY1P4KM/rXSWfwu8FWOPL0C2kYfxTlpT/AOPE119FAFC10PSbEYtNMsoB/wBMoEX+Qq8AAMDgUtFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAYqpcaVp92MXNjazD0khVv5irdFAHMXnw68H3xJn8O6fk9THF5Z/wDHcVz978EPB10SYYby0J6eTckgfg2a9HooA8Wvv2fLVgTY+IJ09FuLdXH5qRXN3PwQ8X6a5k028s5yOhhnaBz+Y/rX0bRQFz5sP/C3fDHX+2jEn0ukH/oXFWbP46eKdOcRapYWVyR1DxtA/wDh+lfRVVbzTLDUU2Xtlb3Kf3ZolcfqKBnlumfH3RJ8LqWl31mx/ij2zL/Q/pXaaV8RPCWslVtNctPMbpHM3lN9MNis7U/hD4M1Pc39l/ZHP8VpIY/0+7+lcVq37PsbAtpGuMPSK8hDD/vpcfyoA9sV1dQysGU8gg5Bp1fNb+AviV4QYy6W100S/wAWnXW4H/tmcH9DU9l8Z/GWhz/ZtatIbkrwUuoDBL+Yx/KgLH0bRXluj/HXw5elU1K3u9NkPVmXzY/zXn9K9B0rX9I1yES6XqVrdrjJ8mUMR9R1H40CPHPjN4Ca2mbxbpMZVSwN8kfGxu0ox79ffB9a7L4V+Pl8W6N9ivpB/bFmoEuf+WydBIP5H3+td/NFHcQvDMiyRSKVdGGQwPBBHpXzT4u8P6j8K/G1vqukMwsncyWjnJAH8UL+vH5jB6igZ9M0Vi+FfE1l4s0C31WyOFcbZIyfmikH3lP0/UYNbVAgooooAKKKKACiiigBG+6fpXmPwQGfhrD/ANflx/6HXpzfdP0rzD4JFx8NYNgB/wBMuM5/36AMOw/5Ol1D/rx/9pJXtleJWH/J0uof9eP/ALSSvbaACiiigAooooAKKKrX9/baZYT315MsNtAhkkkY8KooAxPG3i608G+HpdQn2yTt8ltATzLJ2H0HUn0rxL4eeErz4h+KrjX9dLTWMc3mXDNwLiXqIx/sgYz6DA71ma3q978UfG2+SdLLTYshHnYKlpbg8uxPG4/qSB2rurv4t+G/B+jw6J4RsTfJbJsWaTKRZ7sT95yTkk8Z9aBntHyRJ2VFH0AFcT4i+LHhXw8XiN79uul48izxIQfdvuj868cNx8RfihIVT7TJYseQn7i1X6n+L/x412/h34CWVuEl8Qag9045Nva5jjHsW+8fwxQBzWr/ABp8Ua7c/Y/D9ktlv4VYUM87fpgfgPxqvY/Crxx4tuBe65O1sG5MuoSmSX8EGcfiRXv+j+H9I0C38jStPt7SPGD5SAFvqep/E1pUAeY6H8DvDOnBX1J7jVJh1EreXH/3yv8AUmvQtO0nTtItxBp1lb2kQGNsMYQfp1q5RQIKKKKACiisfVPFegaKD/aWsWVsw6o8w3f98jn9KANiivNdT+OPhKyJW0N5fsOhhh2qfxfFcjqP7Qd2SRp2hQRDs11cFj+SgfzoA94or5tPxL+JOvsV02KZVbtY6eWx/wACIb+dH/COfFvXgftDauEPUXF6IV/75DD+VA7H0ZPeW1spae4iiA6mRwuPzrHu/G3hey/4+PEGmIR2+0qT+hrxGD4F+K70772+0+Inr5kzyt/6D/Wtm0/Z6kwDdeIkX1EFp/Ut/SgDv5/iz4Htwc69FIfSKKR/5LWZN8cPBsZO2a+l/wBy1P8AXFZNv8ANEXH2jWNRl9doRP6GtOH4GeD4/vjUZf8Afusf+ggUAVZfj34YU/u7HVZP+2SD+bVWf4/6IPuaNqbfUxj/ANmroI/g34Ij66VI/wDv3Up/9mq0nwn8DoP+RfhP+9LIf/ZqAOPP7QWmfw6BfH6yoKQftBadnnw/e/8Af5K7UfC3wSvTw7Z/juP9aU/C/wAFEY/4Ryy/I/40Acav7QOkk/NoeoD6SRn+tTJ8fvD5+/pWqL9FjP8A7NXUn4V+CG6+HbX8Gcf+zVC/wi8Dv/zA0X/dnkH/ALNQBix/Hjwo337bVI/rAp/k1W4vjd4MkI3XF5H/AL9q39M1NJ8F/BL9NOnT/du5P8apy/AvwhJ91tSi/wB26z/MGgDWh+LfgebH/E9RD/00hkX+a1o2/wAQvCFyQIvEem5P96cL/PFcTN8AdCYnyNW1KMdt2xv/AGUVnT/s9xHPkeJJR7S2gP8AJhQB65b67pF3j7NqllNnp5dwjfyNXldXGVYMPUHNfP8AP+z5q6km31nTpPTzIXT+Waov8HvHumtmyuIHI6G2v2jP67aAPpCivm46X8YNHOEbXGVe0dyJx+WTSf8ACxfidovF9HclV6/a9Nx+oUfzoCx9JUV8+2n7QGtRELe6Pp8xHXypHiP5HdXR2X7QGkSEC+0a+t/UxOko/oaBWPX6K4aw+L/gq+AB1f7M5/huYXj/AFxj9a6mw13SdVAOn6nZ3WRnEM6sfyBoA0KKM0UAFFFFABVW902x1KAw31nBdRHqk0YcfkatUUAedaz8FfCWphntYJ9NmPRrWT5c/wC42R+WK891X4HeJNKmNzoeoQ3pXldrG3mH05x+or6HooA+a4PiB8RPBMy2+rpcSRDgR6nCTn6SDk/ma6W4+KnhXxvoU2i+J7K403zgNs6DzkjcdHBA3Ag+3tXtU9vBdQtDcQxyxMMMkihlP1Brgdf+DXhTWA8lrbvplwed9ocLn3Q/L+WKBnjvgjxbL8PfFssT3Md3pUriO5a3fcjr/DKnuAc464yOtfUNvcQ3dtHcW8iywyqHR0OQykZBBr5u8Q/BPxNpG6XTvK1W3HP7n5JQPdD1/Amm+EPihrfgOIaJqOnNcWkTEiCfdFNCD1C57Z5wR+NAH0vRXG+G/if4X8S7IoL4Wt23/Ltd/u3J9j0b8DXZUCCiiigAooooARvun6V5R8HFZvhrbbQT/plz0/369Xb7p+leZ/A7/kmsP/X5cf8AodAHP2H/ACdLqH/Xj/7SSvba8SsP+TpdQ/68f/aSV7bQAUUUUAFFIzKilmICgZJPYV5d4x+NOk6KZLPRFXU75cgyBv3EZ92H3vovHvQB6Ve31rp1pJdXtxFb28Yy8krhVX6k188fFj4kx+J5E0jR5mOkwnfLLgr9oft1/hHb1PPYVStdG8dfFi+W7uZJGsw3E8+Y7eP/AHFH3j9Afc1674T+Efh7w0UuLiP+079efOuVBVT/ALKdB9Tk+9AzxDwv8M/EvioJJBam1sXwftV1lUI9VXq34DHvXtPhj4N+G9C2T3yHVbxed9yv7tT7R9PzzXooAHSigVxqRpEipGqqijAVRgAe1OoooAKKRmVFLMQFAySTwK4fxD8WvCmgF4vtv2+5XjybICTB92+6PzoA7mobq8trGBp7u4ighXrJK4VR+Jr591f42eJ9an+yaBYpZbzhBGhuJz+mB+ANVLX4ZePvGE63etSyQq3PmalMWYfSMZI/Sgdj1HWvjN4R0rckF1LqMw/htEyuf984X8s15/q3x61u8cw6NpdtabuFMuZ5PwAwP0NdZovwH0Cz2vqt5dajIOqg+TH+Q5/WvQdJ8NaJoUYTS9LtLTH8UUQDH6t1P50AfP4074q+NOZv7V+zvz++k+yxY/3eM/ka2NK+AGpTESarrNtbZ5K20Zlb/vo4H6GvfaKAuea6Z8D/AAlZbWulvL9x18+bap/BMV12neDvDekgfYdDsISOjCBS3/fRya3KKBCKqqoVQAB0A7UtFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFGKKKAM+70HSL8EXml2VwD/wA9bdW/mK5u++FHgq+B3aHFCx/it3aIj/vk4/Su0ooA8lv/AIBaDNk2Gqahan0crKv6gH9a5XUPgFrlsxk03VbK5x08xWhb8xuFfQlFAXPmv+wviz4W/wCPY6sYl5xbXAuE/wC+cn+VT2vxp8ZaNJ5OrWltcEcFbq3aCT8xj+VfRtQXVla30XlXdtDcRnqkqBx+RoGeT6X8ftJm2rquk3doe7wMJl/Lg/oa7bSfiN4S1oqtprlqJW/5Zznym+mGxVLVfhN4N1UszaQlrIf47NzF+g4/SuI1f9n6JgzaRrbr6RXkQYf99Lj+VAHtiurqGVgVPIIOQaWvmp/A/wAS/BrGXTGu2iX+LTrnep+sZ5/8dq1p/wAa/FujT/ZtasoLoqcMs8Rt5f04/wDHaAsfRdFeZaN8cvDGobU1BLrTJT1Mqb4/++lz+oFegabrGm6xAJ9Nvra7iP8AFBIHx9cdKBF2iiigArL1nw5o/iG38jVtOt7tOxkT5l+jdR+BrUooA8T8S/ASJg8/hzUCh6i1vPmX6BxyPxB+tclbeJ/iB8MrlLTUEnNqDhYL0GWFh/sSA8fgfwr6ZqG6tLa+t3t7uCKeBxho5UDK31BoC5594X+M3h3XdlvqDHSb1uNs7ZiY+0nT88V6Mrq6hlYMpGQQcgivJvFPwM0rUBJceH5zp1wefIfLwN/VfwyPavPYNU8e/Ci8W3uElWy3YWKbMttJ/uMPun6EH2oGfTlFee+Efi9oHiQx2t239mag3HlTsNjn/YfofocGvQs5oEI33T9K8q+DVybf4aWuFZt15cdBn+OvVW+6fpXlvwVtxP8ADWDJIxeXH/oVAGLYf8nS6h/14/8AtJK9trxKw/5Ol1D/AK8f/aSV7W7rGjO7BVUZJJwAKAHVzXi3x1ong6136jcbrlhmK0iw0sn4dh7nArz7x58aorUy6b4WZJph8r37DMaH/pmP4j7nj61znhH4Ua14uuv7Z8TT3NtbTN5jGUk3Fx78/dHuefQUAZ+r+LfGPxT1JtL0y3lSzY/8edscIF9ZX4z+OB6CvQ/BvwT0zSRHeeIGTUbwYIgA/cRn6dXP149q9F0XQtM8PaeljpVnFbW687UHLH1Y9Sfc1o0ANREjRURQqKMBVGAB6U6iigAoqnqWq2Gj2T3mo3cNrbp96SVwo+nufavHvFfx3RPMtfDFrvPT7bdLhfqqdT/wLH0oA9j1DU7HSbR7rULuG1t06yTOFX8zXlPiX48adab4PD1m19IOPtM+Y4h7gfeb9K4nTvA3jn4i3aajq000Vu3K3N+SAB/0zj9PoAPevV/DPwg8M+H9k08B1O8XnzrsAqD/ALKfdH45PvQM8jCfEX4oSZP2mSxY9T+4tV/+K/8AHjXceHvgJp9uEl1+/ku3HP2e2/dxj2LfeP4Yr2JVCqAoAAGAB2paBGZo/h7SNAt/I0rTre0Tv5SAFvqep/E1p0UUAFFFFABRRQSBQAUVz2q+OvC+iki/1yzjcdY1k3v/AN8rk1xOp/Hrw9bErp9jfXzDoxURKfxbn9KAPV6K+eb/AOPXiC8YxaZpllbE9M7p3/LgfpVL+2Pi54k5gGsrG3QwQC2X88D+dA7H0i8iRqWdgoHdjise98X+HNPB+167p0RHZrlM/lmvCU+Efj/Wn36nPGhPU3t80h/Ibq2LL9nu7ODe6/bx+ot7Yt+pI/lQB6Dd/F3wRag/8TpZmH8MELv+uMfrWPcfHfwpFkQwanOf9mAKP/HmFU7T4A6DGc3eq6lP7IUj/oa2bf4K+CoMb7K5n/663T/0IoA56b9oLTVJ8jQL1x/tzIv8s1Qm/aFf/lj4bUf9dLz/AASvQ4fhd4Jgxt8O2hx/z03P/MmtGLwR4WgGI/Dulr/26p/hQB47J+0Jqefk0SwX/euXP9BUDftAa6T8ul6WB/vuf617rH4d0WIYj0iwT/dtkH9KnXStPUYWxtgPaFf8KAPAf+F/eIv+gdpX5P8A/FUD4/8AiHvpulf+Pj/2avoH7Baf8+sH/fsf4Uh06yY5Npbn6xL/AIUAeCL+0FrI+/pOmH6SuP61Yj/aEv8A/lpoNm3+5dMP/Za9ubRtMf72nWjfWBT/AEqvJ4Y0Cb/WaLpzfW1T/CgDyaL9oUf8tfDRP+5ef4pV2H9oLS2P77Qb5B/sSo3+Fegy+BPCc4/eeHNLP0tUH8hVGX4W+CZvveHbQf7hZP5GgDnYPjx4Vk/1ttqcP1gVv5NWra/GPwTc/e1V4D/02tpB/IGo5/gv4Kmzt0+eH/rndSD+ZNZV18BPDUgzbX+pwH3kRx+q/wBaAOxtPiB4RvSBB4i04k9mnCH/AMexW3b6jZXi7ra7t5h6xyq38jXjV1+z2hB+yeIn9hPag/qGFYlx8BfEtqS9lqOmzEdMM8TfyP8AOgD6Jor5t/4RL4saCM2j6mUH/PrfiQf98lv6Uf8ACwPifoHGoJdlF6/bdP4/76AH86APpKivArD9oLUo2C6jolpPjqbeZoz+R3V1enfHfwzdFVvba/sWPUtGJFH4qc/pQI9SornNM8e+FNXIFlr1k7n+B5PLb8mwa6JWVlDKQVPII6GgBaKKKACqeoaTp2rQGHUbG3u4yMbZ4g4/WrlFAHmutfBDwrqIZ7EXGmTHp5D7kz/utn9CK8+1L4MeLdBnN3od5HeFOVa2lMEw/AnB/wC+q+i6KAPm60+KPjzwjcLaa3C9wq8eVqMJRz9HGM/XmvQtB+OPhvUisWpxz6VMeplG+L/vten4gV6PeWNpqNu1ve20NxC3WOZA6n8DXnev/BHwzqgaTTTNpU55HknfH/3w3T8CKBnodlqFnqVstxY3UNzC3SSGQOp/EVZr5svfhp488FXLXuiTS3CLz52myFXI/wBqM8n/AMerS0H4561pkv2TxFp63gQ4eRF8mdfqp4P6UAfQNFcv4b+IPhrxSFTT9RRblv8Al1n/AHco/A9fwzXUUCCobq0t762ktrqCOeCQYeOVQysPcGpqKAPG/GHwMtLoSXfhiVbWXkmzmYmJvZW6r9DkfSuO0Tx94u+HGoDSNatp57WPj7JdnDKvrFJzx+Y+lfStZeu+HdK8S2BstWso7mHqu4YZD6qw5U/SgCh4X8a6J4wsjLpl0DMq5ltpPllj+q+nuMiuW+Bv/JNYv+vy4/8AQq8+8W/C7XPBNydc8O3VxcWkBMgliO2e3HqcfeX1I/EV33wJJb4YW7E5Jupz/wCPUAcpcavY6F+0lq2o6lcJb2sNhlnb/rknAHcnsBWN4q8e+IPiTqo0PQrW4jsZGwlrH9+cD+KQ9AvfHQd81Q8e6Nc+IPjveafFLFG9zNDbxs4OFzEvJx+Ne/eD/BOk+DNN+z2Ee+4cDz7qQDzJT7+g9AOB+tAzlvAPwi0/w4ItR1gR32qjDKCMxQH/AGQerf7R/ACvTaKKBBRRXI+MfiLong2IpdS/aL8rmOzhILn0LdlHufwBoA6uWWOCJ5ZXVI0BZmY4Cj1J7V5N4w+OGn6b5lp4cjTULkZBunyIE+nd/wAMD3Nef3us+Nfi3qhsrWJvsatk28JKW8Q9ZGP3j9fwFeoeDfg3o2geXd6tt1TUByN6/uYz/sqep92/IUDPMtN8J+N/ihfJqWpTyraE/Ld3eVjUf9Mox1/DA969i8KfCzw54W8udbf7dfrz9quQGIP+yvRf5+9dsAFAAGAKWgQUUUUAFFFFABRXJeIviT4X8Mlo7zUUmuV/5drb95J+OOF/EivKtc+Out6jL9m8P6fHZhzhHkXzpm+ijgfkaAPfbi5gtIGnuZo4YlGWkkYKo+pNcHrfxl8JaTuSC6k1KcfwWablz7ucL+Wa8rtvh98QvHEy3WryTxxNyJdTlIwP9mMcj8hXe6J8B9Cs9smr3lzqMoxlFPkx/kPmP50DOT1b47a/qEht9F023s93ClgZ5fwHA/Q1mjw58UfGx3Xv9o+Q3P8Apk32ePH+5x/6DX0HpPh3RtCiEel6Za2gxjMUQDH6nqfxrToA8L0n9n2YgNq+tpH6x2cOf/Hm/wAK7bTPg34M04AyafJfOP4ruYt/46ML+ld9RQIo2Gi6XpahdP060tQOB5MKp/IVeoooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKMUUUAZOoeF9B1VSL7RrG4z3kt1J/PGa5PUfgv4NvsmGznsWPe2nYD8myK9CooA8N1P9nxsFtL14N6R3kH/ALMp/pXOt4B+JfhQmTS2umjXvp13kH/gBI/lX0pRQFz5wtvi9458OzfZ9Zt0nI4KX1sYX/MY/ka7PSPj3otztTVtNu7Fz/HFiZP0w36GvVrqztr2Ew3VvFPEeqSoHU/ga4rWPhB4O1Ys66cbGVv47J/L/wDHeV/SgZv6N4x8PeIMDS9Xtbhz/wAsw+1/++Tg/pW5Xges/ALUICZdF1aG528rHdJ5bj6MuR+grD/tH4n/AA/O24/tBbVOMTr9pgx/vc4/MUAfTFFeJ6F8f4n2x69pLJ6z2Tbh/wB8Mc/kTXp2g+NPDviVR/Zeq280h6wltkg/4AcGgRvUUUUAFYmveENB8TRFNW0yC4bGBLjbIv0ccj8626KAPCfEnwFuIS1x4b1DzgDlba7O1h/uyDj8wPrWBYePfHfw+u0sNYhnmhXgW+oAnI/2JOp/NhX0rVXUNNsdVtHtdQtIbq3frHMgZT+BoGcX4X+LnhrxHsgmmOm3zceRdEAMf9l+h/Q+1d8CD0rxvxT8CLK5D3Hhu6+ySHn7JcEvEfYN1X8ciuJsvE/jv4X3iWOoRSm0Bwttd5eJh/0zkHT8D+FAH01RXCeEfit4f8UmO2aX+z9Rbj7NcsAGP+w3Rvpwfau7oEZXif8A5FPWf+vGf/0Wa4T4Df8AJLbX/r5m/wDQq7vxP/yKes/9eM//AKLNcJ8Bv+SW2v8A18zf+hUAcTqf/JykX/YQh/8ARK19Ddq+edT/AOTlIv8AsIQ/+iVr6G7UDCo7i4htbeSe4lSKGNSzySMFVQO5J6VleJfFOleE9La+1W4EadI415eVv7qjuf0Hevn7WvEvir4s62NL063dLINuSzjb5EH9+Vuh/Hj0GaBHT+OfjVJMz6Z4S3AE7GvyuWbtiJT/AOhH8B3ql4M+Deoa5KNW8VyT28Ep8z7OWPnzE93J+7n/AL6+leg+BPhZpfhFY7y5232r4ybhl+WI+kYPT/ePJ9uld/QMp6ZpVjo1hHZadaxW1tGPljiXA+vufc81coooEFFFIzKilmICgZJJ4AoAWmySJDG0kjqiKMszHAA9Sa808W/GjQ9DL2ukgarejIJjbEKH3fv9Fz9RXl5k8ffFi6Kr5slju6D9zaR/X+8f++jQB6n4n+NPh7RS9vpu7VrteP3DYiU+79/+Ag15hceKPiD8Srh7TT0uBak4aGxBiiX/AH5CefxP4V6H4X+B2jaaEn12U6pcjnygCkCn6dW/Hj2r1C2tbeyt0t7WCOGFBhY41Cqo9gKBnivhz4B/dm8R6j7m2suPzcj+Q/GvVtC8J6F4bi2aTplvbHGDIFzI31c8n862qKBBRRRQAUUUUAFFYereMfDmh5Gpa1ZwMOqGUM//AHyMn9K4jVPjv4atCy2FrfX7joVQRIfxbn9KAPU6K+e9Q+Pmu3TGLTNKsrbPQuzTP+XA/SqH9ufFrxLzbjVxG3Q29uLdP++sD+dA7H0i8iRqWdgqjqWOBWNe+MPDenZ+167p0RHVWuVz+QOa8Jj+Enj/AFt9+pzpHnqb2+aQ/kN1bNl+z3dHBvdfgj9Rb2xb9WI/lQB3138X/BNrwNY88+kEDv8ArjFY9x8efC0WRBa6nOe2IVUH82qCz+AXh+Pm81PUrg+iskY/9BJ/Wtq2+DHgm3xv06afH/Pa6kOfyIoA5eb9oOyXPkeHbp/eS4Rf5A1nT/tC3X/LHw9br/10vCf5LXpsHw08F2xzH4csT/10Qv8A+hE1pQ+EfDlv/qdB01Ppap/hQB4k/wC0DrhP7vStLUe7u39RUTfHrxS/3NP0ofSKQ/8As9e/x6Tp0P8Aq7C1T/dhUf0qwtvCv3YYx9FFAHzofjj4wbhbTTs+1s5/9mo/4Xf4zHJtbDHvav8A/FV9HbVHYflRgegoA+ch8dfFqnmz0w/WBx/7NUq/H3xKv39N0k/8BkH/ALPX0OY0PVFP1FRtZ2z/AHreI/VAaAPAY/2gtZB/eaRprf7srr/U1eh/aFuOPO8Owt/1zvD/AFSvZ5NE0qX/AFmm2b/71uh/pVOXwd4ZnJMugaY2fW1T/CgDzOL9oOyP+u8O3Sf7lwjfzArTt/j34Zkx59jqkJ7/ALpGH6NXUzfDPwXOcv4csR/uIU/kRWbcfBvwRPnbpckP/XK5kH8yaAG2vxn8FXBAfUZoM/8APa2cfyBratPiF4QvSBB4i04k9nmCH8mxXI3PwG8Lyg/Z7zU7du371XH6r/WsW7/Z7jIJtPEUg9p7UN+oYUAeyW2oWV4M2t3BOPWKVW/kas5r51ufgN4mtCZLLUNOmI6Yd4m/kf51W/4Rj4s+Hx/oraqUX/n2vRKv/fJb+lAH0nRXzaPiX8SdAIXUo5iq9Rfaft/8eAWtvTv2g7oEDUdBhk9WtZyp/wC+WB/nQKx7vRXm2mfG/wAI3pVbp7uwY9fPgLKPxTNdlpfirQdaC/2brFlcluixzLu/7560Aa9FFFABSEAjBHFLRQByWvfDTwp4hLPdaVHDO3/Le1/dP9Tjg/iDXmGvfAXUbVjP4f1NLkKcrDc/u5B9HHBP5V75RQB802/jb4hfD+dLXVUuHgU4EWooXU/7sg5/ImvR/Dnxv8Papsh1VJNKuDxuk+eEn/fHT8QK9KubW3vLd7e5gjmhcYaORQyke4NebeI/gj4d1XdNpTSaTcnnEXzxE+6Hp+BFAz0i2ure9t0uLWeOeFxlZInDKw9iKmr5muvC3xA+Glw93p0k5tVOWmsSZImH+3GRx+I/Guu8L/HmGTZb+JbLyj0+12gLL9WTqPwz9KBHtdFUdL1jTtbs1u9MvYLuBv44nDAex9D7Gr1ABVa/0+z1SzktL61hubeQYaOVAyn8DVmigDxTxf8AAqKTfd+FpxE3U2Nw2VPsjnkfQ5+ormNB+JHivwBfDSNetp7m2i4Ntd5Esa+qOeo+uR6EV9JVkeIPDOkeJ7A2erWUdxH/AAMeHjPqrDkGgZhf8Jloni7wPrM+lXYd1sJjJbv8ssfyH7y/1GR71h/Af/kllp/18zf+hV574y+FOteD2l1TRZ5rvTlVtzxnbNChHIYD7y46kfiBXofwI/5Jda/9fM//AKFQI4jU/wDk5SL/ALCEP/ola9U8d/EPTfBVjtfFzqcq5gtFbk/7TH+Ff1PavE/H+qT6J8Z9Q1S1VGuLWeOSMOMru8lQM/nV7wL8PdT+IGpP4g8QTz/2fJJueVziS7b0X0Xtn8B7Aypovh3xP8W/ED6lqFw6Wattku2X5Ix/zziXoT7dupOev0H4c8M6V4V0tbDSrYRR9Xc8vK395j3P+RWhZWVtp1lDZ2cEcFtCoSOKNcKo9AKsUCCiiigAoqlqur2GiafJfaldxW1tH96SQ4H0HqfYc14V4v8AjJqmvXB0rwpFPbQStsWZVzcTH0QD7v8AP6UAeoeMPiVoPg9Whml+1ajj5bOAgsP949EH159jXi1/4i8b/FW/awsYZBZ5+a1tiUhQesjnr+P4Cuj8HfBG5vGXUPFkrxIx3/Y43zI//XR+30HPuK9t03S7HSLKOy060htbaMYWOJQoH/1/egZ5l4R+CGlaYI7rxBIupXQ58hQRAh+nV/x49q9Uhgit4UhgjSKJBhURQqqPQAdKkooEFFFFABRWRrnijRfDdv52r6jBagj5VZsu30Ucn8BXk/iL4+qN8Ph3TcjoLm94H4ID/Mj6UAe3MyqpZiAAMkk8CuM134qeEdBLRyamt3OvWGzHmtn3I+Ufia8aXS/iT8SWElwbxrNzkNcN9ntwPZeN34A12ehfAKyhCSa7qktww6wWg8tB/wACOSfwxQMydZ+PuozsYtE0mG2DcLJdMZHP0VcD9TWKLT4p+OeZP7TNs/P7xvssOPp8ufyNe9aL4O8PeHlH9l6RawOP+WuzdIfqxyf1rcoA8F0n9n++kxJq+swwZ5MdpGXb/vpsD9DXcaX8F/B2ngGe0nv3H8V1MSP++VwK9CooEZ2naDpGkqBp2mWdrjp5MKqfzAzWjiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAQqGBBGQeoNYeo+C/DWrAi+0OwmJ/i8hQ35jBrdooA801P4HeE73c1p9ssGPTyZt6j8Hz/ADrjNU+AGqQkyaVrFtc45C3EZib/AL6GR/KvfqKAPmr7D8VvBfMX9q+QnP7p/tUWPp82PyFaek/HrWrNxDrGl213t4ZoiYZPxByP5V9BVlat4a0TXUKappVpd5/iliBYfRuo/OgZyWi/Gbwjqu1Li6l06Y/w3aYXP++Mr+eK7u1vLa+t1ntLiKeFukkThlP4ivMNZ+A+gXm59KvLrTpD0Unzo/yPP61wd38L/HvhCdrvRZpJ1XnzNNnKOfqhwT+tAH0lRXztpPxr8UaJOLTXrJL3ZwwlQwTj9MH8RXp3h74ueFNeKRNeHT7luPKvQEyfZ/un86BHd0U1HV1DIwZSMgg5BFOoAK4nxR8LPDXiffM1r9hvW5+02oCkn/aXo34jPvXbUUAfNWq/D/xr8PbxtT0a4nngTk3VjncB/wBNI+eP++hXU+Evjsj+Xa+KLYRn7v222Ulf+Bp1H1GfoK9srh/F3wr8PeKt9x5P2DUG5+1Wygbj/tr0b9D70DOu0/UbLVbKO8sLqK5tpBlZYmDKfxFWq+Y73QfG/wAJ79r60mf7GW5ubfLwSD0kQ9Px/A16Z4M+M+k64Y7PWgmmX7YAct+4kPsx+6fZvzNAj1CikBBGQciloAyvE/8AyKes/wDXjP8A+izXCfAf/kllp/18zf8AoVd34n/5FPWf+vGf/wBFmuE+A/8AySy0/wCvmb/0KgDz/wASafa6t+0G9hex+baz3sKSpnG5fKU44+lfRsMUcEKRQxrHGihURBgKB0AHYV8+an/ycpF/2EIf/RK19DdqBhRRSMyohZ2CqBkknAAoELXD+OfibpPg2NrcEXmqlcpaRt9z0Ln+Ee3U+neuL+IPxm2NLpPhSQM/3JdQAyAemIvU/wC1+WetZ3gT4O3esSLrHiwzRwSHzBaMx82YnndIeqg+n3j3xQM5+003xj8X9a+1TykWkbYMzgrb24/uovdvpz6kV7l4O+H2ieDbcGzh869ZcSXkwBkb2H90ew/HNdLaWlvYWsVraQRwW8S7UjjUKqj0AFTUCCiiigAorF8ReK9F8K2f2nVr1IAR8kY+aSQ+iqOT/KvEvEfxi8Q+Jbr+zPDFrNZRynanlLvuZfpj7v4c+9AHsfibx34f8Jxn+075ftGMraxfPK3/AAEdPqcCvG9e+MviTxFc/wBn+G7R7JJPlQRL5ty/04wv4D8ateF/ghqepyC+8UXb2iSHc0Ebb53/AN5jkL+p+lezaB4V0TwxbeRpGnxWwI+ZwMu/+8x5NAzxDQvgt4j16f7f4ivDYrIdz+Y3nXD/AF5wPxJ+les+HPhr4X8M7ZLXTlnul/5ebr95J+GeF/ACuuooEFFFFABRRRQAUUZrC1Txp4a0bI1DW7GFh/B5oZv++Rk0AbtFeY6l8dPCtpuWzjvr5h0McOxT+LkH9K5PUP2g71iRp+hW0PobmcufyUD+dAHvVFfNv/CzviRrZ26dHIA3QWWnlv1Iaj+yvi/rQPmNriq3USXIgH5ZH8qB2PpBnRFLOwVR1LHAqhP4g0a1z9o1awix/wA9LlF/ma8Aj+DPjnUW3XtxaoT1NxetIf0BrQg/Z81Zjm41rT4/+ucDv/PFAHrk/wAQPCNvnzPEmmcf3bhW/lVGT4reB4zz4htj/uI7fyWuEg/Z7jA/f+JJM+kdoB/Nquxfs/aSP9brmoP/ALqIv9DQB0r/ABi8EJ01Zm/3beQ/0qI/GfwSD/yEZz9LWT/CslPgH4aH39R1Zv8AtpGP/ZKmHwG8Jgc3Oqn/ALeF/wDiKAND/hdHgr/oIT/+Asn+FOHxm8En/mJSj62sn+FZ3/Ch/CX/AD8ar/4EL/8AE0xvgL4VP3bzVV/7bIf/AGSgDaj+L3gd+utqn+9BIP8A2WrMfxR8Ey/d8RWY/wB/cv8AMVyr/AHw8fuarqq/Voz/AOyVUk/Z904/6vX71f8AehQ/4UAehw+O/Cdx/q/Eeln63Sj+ZrRh17SLnHkarYy5/uXCN/I14/P+z1x+58SE/wDXSzH9GrOm/Z81dT+41nTpP+ukLp/LNAHv6SJIu5GDL6qc06vnCT4K+NrE7rS5s3I6eTePGf1UUz/hG/i5pAPkPrBUf88b8Sj8i39KAPpKivm3/hMvivonF2mpbR/z9acHH5hf61atPj14jtW2X+m6fPjrw8LfzP8AKgVj6Iorxux/aB05yo1DQruEd2glWQfkdtdTp3xh8F34AbVGtHP8N1Cyfrgj9aAO7oqjYa1peqqG0/UbS6B5/czK/wDI1eoAKKKKACiiigAooooAztX0DSdetzBqun213HjA82MEj6HqPwry/wAQ/AXTbkPLoF9JZSH/AJYXGZYj7A/eH617DRQB8yNb/EX4XyFkNzHYqeSn7+1Ye4/h/wDHTXdeGfjxp93sg8Q2bWUh4+02+ZIj7kfeX9a9gKhgQQCDwQe9cF4n+EXhnxDvmhgOm3rc+daABSf9pPun9D70DO00/U7HVrRLvT7uG6t3+7JC4ZfzFWq+aNR8EeOfhveNqOkzTS268tc2OSCP+mkZ7fUEe9dd4T+O0E3l2vie2ELHj7bbKSh92TqPqM/QUCPaaKrWGoWeqWcd3YXUVzbyDKyxOGU/iKs0ANdElRkkUMjDDKwyCPQ15P40+Cen6oJL3w4Y7C8OS1s3+okPt/cP049q9aooA+adA8deKvhpqX9j6zazS2cZ5s7g/Mi+sT+n5r9K968M+LdH8W6f9r0q6Em3HmQtxJEfRl7fXoe1S+IvDGk+KdONlq1os0fJR+jxn1VuoNeA+JfAfiT4aakNb0W7mlsozlbuEYeIf3ZV6Y9/unvigZ9AeJ/+RT1n/rxn/wDRZrhPgP8A8kstP+vmb/0Ks7Rfi1ZeJ/CmqaZqwjstXNjMqc4iuD5Z+6T0b/ZP4ZrR+A//ACSy0/6+Zv8A0KgRxOp/8nKRf9hCH/0StfQ3avnnU/8Ak5SL/sIQ/wDola921nWrDw/pU2palcLBbQjLMepPYAdyewoGT39/aaXYzXt9cR29tCu6SWQ4Civnnxr8RtX8faiNA8OwXC2Er7FijGJbr3b0Xvj8T6Cnr/iPxD8W/EsWl6bbulmrbobXdhUA/wCWsp6Z/l0GT19s8C/D/TfBNhiIC41GVcXF2y8t/sr/AHV9u/egDB+Hnwms/DIi1PVxHd6vwyDrHbH/AGfVv9r8vWvTaKKBBRRXM+L/AB1o3gyz83UJt9y4JhtIsGST8Ow9zxQB0VxcQ2tvJPcSpFDGpZ5JGCqo9ST0rxnxr8cI4fMsfCqrK/3Wv5V+Qf7in731PHsa42/1jxj8XdY+xWsLC0Rs/Zo2KwQjs0jdz9fwFeteCfhNo/hby7y8C6jqg586RfkiP+wp6fU8/SgZ5l4c+F3ibxvef2v4hubi0t5vmaa5y08o/wBlT90fXA9BXuPhrwdofhO18nSrJI3IxJO3zSyf7zHn8OntW9RQIKKKKACiiuY8SfEHw34W3JqOoobkf8u0H7yU/wDAR0/HFAHT1Dc3dvZW7T3U8UEK8tJK4VR+JrwXXvjrrOoSm18O6eloHOEklXzpm+ij5R/49WXa/Dv4geN51u9YkmijbkS6nKcgf7MY5H5Cgdj1HW/jP4S0ncltcS6lOONtomVz/vnA/LNee6r8dfEOoym30XTbez3HC5Bnl/AcD9DXX6H8CNAstsmrXVzqUg5KZ8mP8hyfzr0TSvD2j6HEI9L0y1tF6fuYgpP1PU0AfPn/AAj/AMU/GfzXn9peQ/P+lzfZ48f7nH/oNbul/s/XbYbVdchizyUtIS5/76bH8q94ooFc85034J+D7HBuILq/Yf8APxOQPyXArrNP8IeHdKAFjolhAR0Zbdd35kZraooAQAAYAwB2FLRRQAUUUUAFFFFABRRRketABRRRQAUUUUAFFGR60UAFFFFABVS70uwvxi8sra4HpNEr/wAxVuigDkL74XeC9Q3GXQbaNj/Fb7oj/wCOkVyuofAPQJ8mw1K/s2PQMVlUfmAf1r1migD551D4DeIbJjNpep2V0VPGd0En58j9aob/AIseDuT/AGv5CeuLuLH/AI9j9K+laKB3Pn/Svj5q9s4i1fSba628M0DGF/xByP5V3uj/ABo8I6ptS4uZtOlPVbuPC5/31yPzxXW6r4Y0PXEK6npNndZ/ikiBYfRuo/OuB1n4EeHb3c+mXV3p0h6Lu82P8m5/WgD0yzv7TUbcT2V1DcwnpJC4dT+IqxXzfefCfxz4WuDd6JObjbyJNPnMUn4ocZ+mTUmm/GLxh4duRZ67aC82cMl1EYJh+IHP4g0AfRlFee+H/jJ4V1opFc3D6ZctxsuxhCfZx8v54rv4pY5olkikV42GVZTkEexoEPooooAKKKKACuF8W/Cnw94o33CQ/wBn6g3P2m2UDcf9tOjfXg+9d1RQB8x3mieOPhPfte2ksgsi3zXEGXt5B6SIfun6/ga9O8GfGbSdeMdnrITTNQbChmb9zKfZj90+zfma9MkjSWNo5EV0YYZWGQR6EV5L41+CdhqYlvfDZjsbs5LWrf6iQ+39w/p7CgZ62CCMg0tfNfh3x/4o+HGo/wBi65azzWkRw1pcH5419Yn6Ee3K+mK988OeKNJ8VacL3SbpZUHDoeHjPoy9Qf8AIoEbFNdFkRkdQysMEEZBFOooA8O+JXwghht7nXPDaLEkamW4seigDktH6eu3p6eldF8CP+SXWv8A18z/APoVd14n/wCRT1n/AK8Z/wD0Wa4T4D/8kttf+vmb/wBCoA8/8S6jbaR+0DLqN4+y2truKSRsZwBCvaqWq6r4h+MHi+Kyso2jtEJMMDH93bx9DJIR1b/9QpnxB0y41n4y6hploFNxdXEUUe44GTEnU+le+eC/B1h4M0RbK0Aed8Nc3BGGmf19gOw7fnQMd4O8G6Z4M0hbOxTfM+DcXLj55m9T6D0HauioooEFFMlljhieWV1SNAWZ2OAoHUk9hXgvxB+LVzrUzaF4UaUW8jeU91ED5lwTxtjA5Cn16ntgdQDp/iF8YLXQTLpegNFdakMrJOfmitz/AOzN7dB39K4fwf8ADPW/HV6dd8RXFxDZTNvaWU/v7n/dz91ff8hXVfDv4ORWIh1bxPEkt1w0NieUi9C/Zm9ug9+3sgAAwKBlDR9F07QNOjsNMtI7a2j6Ig6n1J6k+55q/RRQIKKKwfE3jHRPCVp5+q3ao7DMcCfNLJ/ur/U8e9AG9XF+LPif4d8Kb4Jbj7Xfj/l0tiGYH/aPRfx59q8j1/4neKvHN6dJ8P21xa28vAgtMtPIPVnH3R9MD1Jrf8JfAktsu/FNz1+b7FbP/wChyf0X86BnO6n8RPG/j68bTdEgmt4X4+z2AJfH+3J1A/75Fbnhr4DXM5W48S3/AJIb5jbWh3Of96Q8fkD9a9q0vR9O0SyWz0yzhtbdeiRIFB9z6n3NXaAMTQfCGg+GYgmk6ZBA2MGXG6Rvq55NbdFFAgooooAKKhubu2soTNdXEUEQ6vK4VR+JriNY+MPg/Sdyx3738oyNlnGXGf8AeOF/WgDvaK8G1b9oC8kymkaLDADwJLuUuf8AvlcD9TWJ/wAJJ8VfFv8Ax5/2mIm4H2O38hB/wPA/nQOx9Hz3MFrH5lxNHCg/ikYKPzNc3qHxH8H6YSLjxBZFh/DDJ5p/Jc14zb/BrxtrT+dqlzbwluS15dNM/wCQz/Ouk0/9n2BQp1DX5W9UtrcKPzYn+VAG9efHTwlb7hbrqF2w6eXb7QfxYisG7/aEgUH7J4dlb0ae6C/oFNdLZfBHwbakGaC8uyOvn3JAP4Lit+0+HXg+xIMHh2wyO8kW8/8Aj2aAPH5/j/r8uVttM0yLPTcXkP8AMVV/4W18Q74/6JCoz08jTmf+ea+hbfStOswBbWFrAB0EUKr/ACFW8AUAfOH/AAk/xev+Y49Ywf8AnnpyqP8A0Cm4+Md138QD8Vj/AMK+kqMD0oA+bv7A+ME/LNrX/Ar5R/7PSjwj8XX6yarx66mo/wDZ6+kMUUBc+bz4Q+Li8+Zqn4aov/xdJ/wjvxfh5Dazx/dv1P8A7PX0jRigLnzaY/jHa858QHH+0sn+NL/wk3xe08Zlj1jA/wCeunK4/wDQK+kcD0ooA+bR8XfiDYH/AEyGNsdftGnsn8sVetv2gdajIF1pGnS46+XI8ZP6mvoMgEYIyPeqN1oek3wIu9Ms58/89YFb+YoA8ps/2gtPfH23QLuL1MMyyD9dtdHY/GrwZeECS8ubQn/n4t2AH4rkVqXnwv8ABd7nzPD9qhP8UO6I/wDjpFc5ffAjwvcAm0udRs37bZRIo/Bhn9aAO507xZ4e1cD7BrVhcE9FSdd35ZzWxkV4HqX7PuoIS2m63az46LcwmM/mM/yrGPhT4peESTYHUTEv/Pjc+ch/4B/9jQB9K0V852Pxq8X6NOINZs4LojhkuITbyfmOP/Ha7nRvjr4cvisep293psh6sy+bGPxXn9KBWPU6KztK17SdcgE2l6jbXaYzmGQMR9R1H41o0AFUdT0fTdZtjb6lY293Ef4Zow2Ppnp+FXqKAPJfEPwI0a9Dy6Hdy6dMeRFJmWI/n8w/M/SvP5dG+Inwxlae1a4WzU5MlsfOt2H+0hHy/iB9a+mqCM0AeMeGPjzazhIPEdkbdjx9qtQXjPuU6j8M161pmr6frVmt3pt5Bd27dJIXDD6H0Psa5TxP8KfDPiXfN9l+wXrc/aLQBcn/AGl+638/evItU8BeNvh3eNqej3E00C8m6sc52/8ATSPnj/voUDPpWivFfCPx1il8u08UW4iY8fbbdSUPu6dR9Rn6CvYrG/tNStI7uxuYri3kGUlicMp/EUCLFFFFABRRRQBi+JPCmkeK9PNnqtqsoHMcq8SRH1Vu38j3rwHxB4P8T/CzVl1jSrqV7JWwl5EOgz9yZemP0Psa+mKZLFHPE8UsayRuCrI4yGB6gg9RQBwHgD4p6f4uVLG9CWWsAf6kn5JveMn/ANBPI969Crwf4hfB+XT2fWvCiOYkPmSWKE74sc7ou5A/u9R29K0fht8X/tTQ6J4nmC3BwkF+/AkPZZPRv9rv3weoM9S8T/8AIp6z/wBeM/8A6LNcJ8Bv+SW2v/XzN/6FXd+J/wDkU9Z/68Z//RZrhPgN/wAkttf+vmb/ANCoEcTqf/JykX/YQh/9ErX0N2r551P/AJOUi/7CEP8A6JWvobtQMKhu7u3sLSW7u5kht4VLySSNhVA6kmi6uoLG0lurqZIYIlLySOcKqjqSa+cvGvjXVfiXr0Og6FDKdPMuIIBw1ww/5aP6KOoB6Dk89AQ/xz8QNU+IOqp4f8PQz/2fI+xIUGHuz6t6L3wfqfb074dfDCz8IwJf3wS61p15l6rAD1VP6t1PsKu/D/4eWPgrTt7bLjVZlH2i5x0/2E9FH69T6DtaACiiigApryJFG0kjBUUEszHAA9Sazdf8Q6Z4Z0uTUNVuVhgXgDqzt/dUdSfavnzxH418S/FDVl0XR7WaOyc/JZxHlxn70rdMe33R7mgDsfHPxtgtDJp/hYpPMPle/cZjT/cH8R9zx9a5jwv8LfEPjW8/tnxHc3FrbTEM0s/zXE49gfuj3P4CvQvAnwi03w2Ir/VvL1DVR8wyMxQH/ZB6n/aP4AV6XQMx/D/hfR/C9iLTSbKOBD99+ryH1Zjya2KKKBBRRUF5e2un2r3V5cRW8EYy8krhVX6k0AT013WNGd2CqoySTgAV5H4o+O2mWW+38PWxv5hx9omykI9wPvN+g964Jbf4ifFGTe5uJLFj1c+Rar9B/F/48aAPXvEPxe8KaFviiuzqN0vHlWY3gH3f7o/M15nqvxo8V69cfY9Asksy5wqwRm4nP44wPwX8a6rw98BtLtQk2vX0l9IOTBBmKIe2fvH9K9P0rQtK0O3EGl6fbWkfpDGFz9T1P40DPn21+GHj7xfOtzrUskCtz5mpTlmH0QZI+nFdxo/wF0S12vq2oXV+46on7lP0y36161RQK5haT4M8N6Hj+ztFs4GHSTywz/8AfTZP61u4oooAKKM1Qvtc0rTFLX+pWdqB/wA9p1T+ZoAv0VxF78W/BNlkHWUnYfw28TyfqBisC7+PfhyLItdP1O4PuiRj9Wz+lAHq1FeG3X7QjAEW3h0D0M13/QL/AFrKm/aA1+TIg0vS4/Tczuf5igLH0PRXze3xp8b3H+otrMf9c7J2/wDZjSf8LR+JUvMcTj/c0s/1FA7H0jRXzLd/FX4i2Ww3dy1sHzt83T0TdjrjK89anj+JHxQeJJk+0vE4BVxpYKsD0IIXmgLH0nRXzd/wtD4lRf6yJz/v6Wf6AUo+NPje3/19tZn/AK6WTr/7MKAsfSFFfPMP7QGvR4E+l6XJjrtZ0P8AM1q2v7QhIAufDufUw3ef0K/1oFY9xoryq0+PfhqXAurHU7Zv+uayD9Gz+ldBZfFnwVfYC63HCx/huI3j/mMUAdrRVKy1jTNTUNYaha3QPeCZX/kau0AFFFFAFW+0yx1OHyb+zt7qL+5PGHH61wmtfBXwlqgZrSCbTJj/ABWr/Ln/AHGyPyxXotFAHzvq3wT8T6LP9r0G+jvShypic284/XH5NVax+KHjrwddLZ65BJcqvHlajEUkx/syDr9fmr6Rqrf6bZapbNbX9pBdQN1jmjDr+RoGcJ4c+M3hjWykN5I+lXTcbLr/AFZPtIOPzxXocciTRrJG6ujDKspyCPY15T4k+BWjX4ebQ7iTTZzyIWzJCfbB+ZfwJ+ledtB8QfhVPvUzR2Abqp860f6j+H/x00AfTlFeU+FPjfpGqbLbXYhpl0ePOBLQMfr1X8ePevU4po54klhkWSNxlXQghh6gjrQIfRRRQBwni/4U6B4p8y4jj/s/UW5+026gBz/tp0b68H3rx240/wAb/CPUjcQyMLJm5ljy9tN7Ov8ACfrg+hr6dqOeCG5geCeJJYnG10dQysPQg9aAPP8AwT8W9H8UGOyvtunao3Aikb93Kf8AYY9/9k8/WvRK8V8cfBGKUSah4UxFJ95tPdvkb/rmx+6fY8e4rB8HfFjWPCd3/YviiG5uLWFvLYyg/aLb2OfvD2PPoT0oGfRFFU9L1Wx1nT4r/TrqO5tZRlJIzkH/AAPsauUCCiiigAryP4nfCePWEm1vw/Cqajy09qowtz6kej/o31r1yigD528I/E+a38Oal4Y8QyOQbOaG0uZc7o22ECJ889eAT06Gu5+A/wDyS21/6+Zv/Qqo/Fz4bRala3HiXSI1S+hQyXcI4E6AcuP9sD8x71e+BH/JLrb/AK+p/wD0KgDidT/5OUi/7CEP/ola+hHdY4y7sFVRksTgAetfPep/8nKRf9hCH/0StaXxi+ITXEsnhPRpCVzsvpY+S7f88Vx+v5etAzG+Ivju88d61H4c8PLJLp/mhEWMc3cnr/uDt+Z7Y9X+Hfw+tfBWl75Qk2rXCj7RcAdP9hPRR+p59MZnwr+HS+FtPGqalEDrNynIPP2dD/AP9o9z+Hbn0mgQUUUUAFct428d6Z4K07zbpvOvJQfs9oh+aQ+p9F9T/M1T+IPxDsvBOn7FC3GqzKfIts9P9t/Rf1PQeo8e8I+DNa+J+uy65rdzMLBpP310eGlI/wCWcY6ADpnoPrQBBYab4p+MPiVrq5l2WsR2vOVIhtl/uIvdvbqepNe/+FvCOk+ENMFnpkGC2DLO/MkrerH+nQVp6Zpdlo2nQ2Gn2yW9rCu1I0HA/wAT796t0AFFFFABTZJEijaSRlRFGWZjgAepNc14v8eaL4Ntd9/P5l04zFaREGR/fH8I9zxXhmpeI/GXxY1RtOsYHWyzn7JASIox2Mr9/wAfwFAHofjD426XpPmWmgImpXa5BnJxAh+vV/w49687tNB8d/FW8W9vJZDZ5+W4ucxwIP8Apmg6/gPqa9L8HfBfSNEEd3rZTVL8YIRh+4jPsp+99W/IV6eqhFCqAABgAdqBnnvhb4PeHPD/AJc93H/al6vPmXKjYp/2Y+n55NehKqooVQAAMADtS0UCCimySJFG0kjqiKMszHAA9zXn3iP4yeGNDLw2krardLxstMbAfeQ8flmgD0OqOp61pmjQGbU9QtrSPGczyhM/TPWvn2/+KnjjxddNZ6FbvbK3Ai0+IyS493I4+oxUul/BbxXr04vNdvY7Mucs1xIZ5z+GcD8WoGd7rHxz8MWBZNPju9SkHQxJ5af99Nj9Aa4TUPjn4n1KYw6RYWtoWPyhUa4l/wAP0r0DRvgj4U04K96lxqco6m4k2pn/AHVx+ua7vTtG0zSIRFp1hbWiAYxDEE/lQB88f2X8WPF2TN/a3lP18+UWseP935f5VoWPwD165YSajqljbE9dgaZ/z4H619C0UBc8isvgBokWDfavqFye4jCRD+RP610Fp8HPBNqBu0t7gjvPcO36ZArvaKBHPWngTwpZAeR4d0xcdzbKx/Mg1rQ6Vp1sMQWFrF/1zhVf5CrdFADVRVGFUAewxTsUUUAeG/tDfe8P/S4/9p16p4J/5EXQf+wfB/6AK8r/AGhvv+H/AKXH/tOvVPBP/Ii6D/2D4P8A0AUDN7FIyKwwwBHuM0tFAipNpWn3IxPY2sv/AF0hVv5ism78CeFL0Hz/AA7pjZ7i2VT+YAroaKAOCvPg34KugdumSW5PeC4df0JIrnr74AaNLk2Os39v6CVUlH8gf1r16igD54vvgL4itGMum6lY3JHTJaF/z5H61S+zfFnwfyn9r+Sn9xhdx4+nzY/SvpSigdz560z47+ILGUQ6xptrd7T820NBJ+XI/Su90f42+FNS2pePcabKev2mPKf99Lkfniu31TQNI1qIx6nptrdqf+e0QYj6HqK4HWvgZ4Zvwz6bJdaZKegjfzIx/wABbn8iKAPRbHUrHU7cT2F5BdQn+OCQOPzFWq+cL/4SeNfC1wb3Q7j7Vs5ElhKYpfxUkZ/AmpdJ+Mnizw7dCy8QWf20JwyXEZgnH44wfxH40AfRVFcR4b+K3hfxGUhF59hu24+z3mEJP+y33T+efau2BBGQcg0CFprxpIjI6qyMMMrDII96dRQB5j4t+C2h635lzpBGlXpycRrmFz7p/D9Vx9DXmMN545+EeoCGVWWyduI3zJazf7p/hP0wfUV9OVXvbG11G0ktL23iuLeUbXjlUMrD3BoA4/wX8UNE8XhLbd9h1Mjm0mYfOf8AYbo306+1dxXhfjX4IyQF9R8JszBTvNg7/Mv/AFzY/wAj+B7VT8F/GLUdDuBpHixJ54I28v7Q6nz4D6OOrAf99fWgZ9AUVXsb+01OyivLG4juLaVdySxtuVh9asUCCuU8Z+ANH8aWmLuPyb1FxDeRAb09j/eX2P4Yrq6KAPmFX8W/BzxFtYbrWZunJt7tR6f3W/Ue4r3vwf410nxnpv2mwkKToB59rIR5kR9/UehHB/StTWdF0/X9Ml07U7ZLi2lHzI3Y9iD1BHqK+d/FPg7XvhbrsWtaNcytYh/3N2oyUz/yzlHQg9PQ+xoGfS9FcT8P/iLYeNbLymC22rRLme2z1/209V/Ud/U9tQIKKKKAMrxP/wAinrP/AF4z/wDos1wnwG/5Jba/9fM3/oVd34n/AORT1n/rxn/9FmuE+A3/ACS21/6+Zv8A0KgDyz4j39zpXxf1S+s5PLuYJY2jfGdreSoz+tdf8GPAJuZF8WatGWUMTYxyc7m7ynPXnOPfJ9KwPFelwa38fJdMui32e5vYY5NpwSvlKSPxxj8a+j4IIra3jggjWOKNQiIowFUDAAoGSUUUUCCuN+IXj608E6TkbJ9TnBFtbZ/8fb0UfqeB7aHjPxdY+DdBk1C7IeU/Jb24OGmfsB7dyewrwjwn4a1b4reLbjVtYmk+wrIDdTjjPpDH6cfkOepoAm8D+CNT+JGuTa9r00zaeZczTscNcMP4E9FHQkdOg56fRtpaW9haRWtrCkNvEoSONBhVA6ACksrK206zhs7SFIbeFAkcaDCqB2FT0AFFFQ3d3b2FpLdXcyQ28Sl5JJGwqgdyaAJiQBk14/8AED4zQaaZdL8MvHcXYysl7w0cR7hezt79B71y/jv4n6l4xvf7A8MR3C2MzeWPKU+ddn0x1Vfbqe+BxXY/D34P2uhiLVPECR3WpDDR2/3orc/yZvfoO3rQM43wf8KtZ8YXX9t+Jp7m3tZm8wmUn7Rc+/P3V9zz6DvXvWkaLp2g6fHYaXaRW1snRIx1PqT1J9zzV+igQUUVxXjP4m6H4PV7dn+2anj5bSFhlf8Afboo/X2oA7KWWOCJpZXVI0G5mY4Cj1J7V5d4s+N2j6SXttDjGqXQ4MuSsCn/AHurfhx71494s8deIvGBMmoTPHYF9qW0IKwgjnB/vN9f0r0v4T/DTRr3w/a+IdYtftc87M0EMpzEqBsAle5OCecjpxQM40J8QfirPkmaSwLdT+5tE/8Aiv8Ax416F4b+BOj2ISbXbl9SmHJhTMcI/L5m/Ej6V6xHGkUapGioijCqowAPYU6gRU0/TLHSbVbbT7OC1gXpHDGEH6VboooAKKKKACiiigAooooAKKKKACiiigDw39ob7/h/6XH/ALTr1TwT/wAiLoP/AGD4P/QBXlf7Q33/AA/9Lj/2nXqngn/kRdB/7B8H/oAoGb1FFFAgooooAKKKKACiiigAooooAKztX0HStetjb6rp9vdxdhKgJX6HqPwrRooA8Y8S/AW0nDz+Hb4279fst0S8Z9g/3h+Oa4y21/x/8LrpLW9SYWYOFgu8ywOP9hwePwP4V9NVBd2dtf2z213bxTwOMNHKgZW+oNAHB+Evi/4f8RmO2vG/su/bgRXDDY5/2X6fgcGvQ85r5Y+K/he18LeMXgsIBDYXMCzxRgkheoYDPbIzj3q74f8AH/iz4fXENjqUMtzYMiultdE8xnkNFJzxj6j6UDsfTVFc54U8caJ4wtfM025xOozLay/LLH9R3HuMiujoEFcb43+HGkeM7dpJFFrqariO8jX5vYOP4l/UdjXZUUAfMVlqXiz4PeITa3MRe0kbc0BYmC5X+8jdm9+o7ivoDwr4u0rxfpYvdNmyVwJoH4khb0YfyPQ1a17w/pviXS5NO1S2WeB+meGQ9mU9iPWvnfXvDniP4SeI4tT024d7Nm2w3QX5XH/POVemf59Rg9AZ9N0VyXgTx7p3jbTd8WINQhA+02jNkr/tL6qfX8DXW0CCobq0t761ltbqFJoJVKSRyLlWB6gipqKAPm/x54C1H4e6tH4g8PzTLp6SBo5VOXtWP8LeqnoCfoff1f4dfES18aaeYZ9kGrwL+/gB4cf309vUdj+Fdpc20N5bSW1xEksMqlHjcZVgeoIr5w8c+DdS+GviK313QpZUsDLm3mHJgf8A55v6gjpnqODz1Bn0pRXKeAvG9p420QXMYWK+hwt1bg/cb1Hqp7H8O1dXQIyvE/8AyKes/wDXjP8A+izXCfAb/kltr/18zf8AoVd34n/5FPWf+vGf/wBFmuE+A3/JLbX/AK+Zv/QqAOJ1P/k5SL/sIQ/+iVr6G7V886n/AMnKRf8AYQh/9ErX0N2oGFU9U1O00bS7jUb6URWtuheRz2A/mewHrVyvnf4r+Mbjxb4ii8L6LumtYJxHtiOftNxnHHqF6D3yewoEZM0ms/GPx+EQNDar90HlbS3B6n1Y/qeOgr6O0TRbHw9pFvpmnQiK2gXao7k92J7knkmsTwB4Mt/Bfh5LQbXvpsSXcw/jf0H+yOg/PvXV0AFFFV76+tdMsZr29nSC2gQvJI5wFAoAZqWpWej6dPf6hcJb2sC7pJHPAH9T7d6+c/Ffi/XPil4gi0XRreUWBf8AcWoOC+P+Wkp6ADr6L7mm+KvFGs/FbxRBpGkQyCxEn+jW54zjrLL6cfkPc17d4G8C6f4J0ryYAJr6UA3N0RzIfQeijsPz5oGVPAPw507wXZiVtt1qsq4muivT/ZT0X9T39K7aiigQVBeXltYWkt1dzxwW8S7pJJGCqo9STWb4l8UaX4U0p9Q1SfYnSONeXlb+6o7n+XevnzVdb8VfF7xAun2MDJZo25LZWxFCv9+Vu59/wAoA6Dxt8Zb3VZm0nwkJYoXby/taofOmJ4xGvVQfX730qXwV8E57tl1LxYzxox3ixV/nfPeRu30HPqRXoPgb4a6T4NhWfAu9VZcSXbr931CD+Efqe5rtHdY42dyAqjJJ7CgZ84fGB4JfF2neGdIt44YLCFIo4IVAUSykHgDvjZX0Ho2nR6RotlpsQAS1gSEY77QBmvnjwUjeNfjSdUdS0K3Mt+3fCrxGPz2flX0rQAUUUUCCiiigAooooAKKKKACiiigAooooAKKKKAPDf2hvv8Ah/6XH/tOvVPBP/Ii6D/2D4P/AEAV5X+0N9/w/wDS4/8AadeqeCf+RF0H/sHwf+gCgZvUUUUCCiiigAooooAKKKKACiiigAooooAKKKKAPIvj5o/2jw7p+rooL2dx5TkD+CQf/FKPzrR+HsGl+OfhXZWGsWsd2LTdatv+8hX7pU9VO0ryK6/xpow1/wAG6rpuMvNbt5f++BuX9QK8i+AGseXqWq6NIcCaNbmNT2ZTtYfkV/KgZneLfhVrfg67/trw1cXNzawnerRHFxb/AFx94e4/EV1HgL40w35i03xQ0dvcnCx3wG2OQ/7Y/hPv0+lex15d8QPhBZeIBLqWhrHZ6ocs8fSK4Pv/AHW9xwe/rQB6grBlDKQQRkEd6WvnDwZ8RtZ8A6idB8RQXD2ETbGhkH72191/vL7dPQ+v0Lp2o2erWEN9YXEdxazLuSSM5BH+e1Ai1Va/0+01Swmsb63juLaZdskUgyGFWaKAPmnxh4O1j4X+IYdb0S4m+weZ/o9yOTET/wAs5PUHpzww969n8A+PbLxtpW9QsGowAC5tc/dP95fVT+nQ1099Y2up2M1lewJPbToUkjcZDA182+KvDesfCjxZb6rpE0hsmcm1nPPHeKT14/Mc9RwDPpqiud8GeL7HxnoSahafJMvyXFuTloX9D6g9Qe4roqBBVTUtNtNX0240++gWa1nQpJGw4IP9fftVuigD5i1Kx1n4PePI7i1dpbVsmF24W5hz8yN/tDj6HBr6L0DXLLxHottqunyb4J1yAeqnupHYg8GqHjPwnaeMfD02m3ICS/ft5scxSDo307Edwa8P+HPii8+H3jC48P61mGzmm8m4VjxBL0WQf7J4yfQg9qBnvnif/kU9Z/68Z/8A0Wa4T4Df8kttf+vmb/0Ku68THPhLWD/04z/+izXC/Ab/AJJba/8AXzN/6FQI4nU/+TlIv+whD/6JWvobtXzzqf8AycpF/wBhCH/0Ste/X17b6bYT3t3II7eCMySOf4VAyTQM4L4ueNj4Y8PfYbKXbqmoApGVPMUfRn+vYe59q5v4I+BxDB/wlV/F+8lBSxRh91Ohk+p6D2z61xenW958XPic81yHSzLeZKP+eNspwqD3PT6sTX0zBDFbQRwQoscUahERRgKAMACgCSiiigQ13SKNpJGVUUEszHAA9TXzj8QvGt78QfEEPh/QFkl08TBIUTg3Un98/wCyOcZ7cn23/jN8QGkkk8J6TITyBfyxnJJ7QjH/AI9+A9a6j4U/DxfC2mjVNShH9s3Schv+XeM/wD3Pc/h2oGbPw/8AAdn4J0cJ8s2pTgG6uQOp/ur6KP16muwoooEFcz408bab4L0r7TeHzbmTIt7VThpW/oo7nt9eKPG3jSw8F6Kby6xJcyZW2tgcNK39FHc9vrivCvDnhzXfi14pn1PVLiRLNX/0i5A4Udooh0zj8upyTyAN0zSfE3xh8USXt5MY7SNtsk+0+Vbp18uNe59vxJr6G8OeGdL8K6Umn6XbiKMcu55eRv7zHuf8irWk6TY6HpsOn6dbpb2sK4RF/mfUnue9XaACuR+Jus/2J8PtVuFfbNLF9ni/3pPl/QEn8K66vEf2gdZAj0nRUbqXu5R7D5V/m35UAS/s/wCjeXZatrLp/rXW1iP+yo3N+pH5V7TXLfDrRv7C8BaTZsu2UwiaX13v8x/nj8K6mgAooooAKKKKACiiigAooooAKKKKACiiigAooooA8N/aG+/4f+lx/wC069U8E/8AIi6D/wBg+D/0AV5X+0N9/wAP/S4/9p16p4J/5EXQf+wfB/6AKBm9RRRQIKKKKACiiigAooooAKKKKACiiigAooooAK+aI/8Aihfjpt/1dsL7b7eTN0/Abh/3zX0vXgfx+0cwaxpesxDH2iJrd2HZkO5T+TH8qBo98orE8IawNf8ACOlapnLXFupf/fAw3/jwNbdAjk/HHgHTPGun7Z1EF/EuLe7RfmT2P95fb8sV4fo2u+JPhD4mk0+/gZ7R23TW2793MvTzIm9ff8D7fTlYHi3whpnjHR2sdQjw65aC4UfPC3qP6joaAL2h65p/iPSYdS0y4Wa2lHBHBU91YdiO4rRr5i07UPEPwd8YyWt1GZbWQgyxA/u7qPoHQnow/Toa+jdF1qw8QaTBqemzia2mXKnuD3BHYjoRQBoVn63otj4g0i40zUYRLbTrhh3B7EHsQeQa0KKAPmAHWvg74+wd01s3Xst3Bn9GH6H2PP0lpGrWeuaTbalp8wltbhN6N/Q+hB4I9RWJ478G23jTw9JZSbY7uPMlrOR/q3x3/wBk9CP8K8a+GHi+68EeJ5vDmt7oLKacxSLIf+Pafpu/3TwD+BoGfRtFFFAgryH42+CRqGm/8JNYxZurRNt2qj/WQ/3vqv8AIn0r16myxpNE8UiK6OCrKwyCD1BoA8f8BeMz4g+GetaTey7tQ07T5VBY8yw+WQre5H3T+HrWl8Bv+SW2v/XzN/6FXk3ifTLv4beOruC0z9lmhkEG7pJbyqVKn6cj6qDXrPwH4+F1sP8Ap6m/9CoA4nU/+TlIv+whD/6JWt/47eLPs9lb+GbaTD3AE92QekYPyqfqRn/gPvXNa9dQ2P7Q7Xdw4SCC8jkkY9lEAJql4Qsp/iX8VZNSv0LWolN5OrcgRqcRx/8AoI+gNAz1z4TeEf8AhGPCUc1xHt1HUMTz56quPkT8Bz9Sa72iigQVwvxP8cr4P8P7LV1Oq3gKWy9dg7yEeg7epx712Gpaja6TptzqF7KIra3jMkjnsB/Wvmuxt9R+L/xIeW43x2hO6TH/AC72ynhB/tHp9ST2oA6T4NeBG1K7/wCEs1ZGeGNybNZOTLJnmU564Oce+T2r3qobS0gsbOG0tYlighQRxxqOFUDAAqagArG8T+JbDwpoc+qag/yJwkan5pXPRV9z+nJrSvLy30+zmu7uZIbeFC8kjnAVRySa+atd1XV/i746hsdPVktFYrbRv92GL+KV/c8Z/ACgBNK03XfjD41lu7yRo7VMefKv3LaLPEaZ7nt+JNfSGkaTZaHpcGnadAsFrAu1EX+Z9SepPeqnhjw3YeFNDg0vT0xHGMu5HzSuert7n/61bFABRRRQAV80+JyfG/xu+wod9v8Aa47MY5Ajj++f0evoXX9UTRPD+oanIQFtbd5ee5A4H4nArwr4FaW+oeL7/WZ8sbSE/Mf+esp5P5BvzoGfQoAAAAwB0ApaKKBBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB4b+0N9/w/8AS4/9p16p4J/5EXQf+wfB/wCgCvK/2hvv+H/pcf8AtOvVPBP/ACIug/8AYPg/9AFAzeooooEFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFcF8YdH/tb4d3rquZbJlu0wOcLw3/AI6W/Ku9qG8to72yntZhmKaNo3HqGGD/ADoA8q+AmsfavDN9pLtl7K43oM/wSc/+hBvzr1uvm74UXMvhf4qTaLcHaJvNsXz/AH0JKn/x0/8AfVfSNAMKKKKAOd8ZeD9P8Z6I9heDZKuWt7gDLQv6j1HqO4rwfwx4h1j4T+MJ9L1WNzZM4F1CvIZe00frx+Y4PI4+mq4r4j+A4PGmi/ugkeq2wLWsx4z6ox/un9Dz60AddZ3lvqFnDeWkyTW8yB45EOQynoRU9fPPwp8cz+FdYfwvrm6GzkmMaedwbWbOCp9FJ/I89zX0NQAV498a/Awv7E+J9Pizc2ybbxFH+siHR/qvf2+lew010WRGR1DKwIKsMgj0NAHmfwc8bnxBoh0a/l3alp6AKzHmaHoG9yOh/A969Or5k8T6Xe/Cn4jwX+mg/ZC5ntQTw8ZOHiP0zj6FTX0do+q2ut6Ra6nZPvt7mMSIfr2PuDkH3FAF2iiigDzP42eGhq/hD+1IY83WmN5uQOTEeHH4cN+BqP4Ef8kvtv8Ar6n/APQq7vxRz4T1n/rxn/8ARZrhPgN/yS21/wCvmb/0KgDyP4r/APJT9b/66R/+ikr2L4K+HP7H8FjUZUxc6o3nEnqIxwg/LLf8Cryzx5pb638a7zS4zhru7ghz6Axpk/gMmvpi2t4rS1htoVCRRII0UdlAwB+VAyWiisTxb4ig8LeGb3Vp8Ewp+6Qn/WSHhV/E/pmgR5J8cPGDXN3F4UsHLLGVkvNnJZzykf4dSPUrXofwz8HL4Q8LRxTIP7RusTXbejY4T6KOPrn1ryj4R+HJ/FfjG58SaoTNFaS+czOM+bctyP8Avn73/fNfRVAwoorh/ih41HhDw0wtnA1O8zFajun96T/gIP5kUCPOvjJ43l1bUh4T0lmkgikC3Xl8mabPEY9QDj6t9K9G+GfgWPwboINwqtqt2A90452+kYPoP1OT6VwHwU8EG7uT4s1JCyIxFkH53v0aU+uOQPfJ7V7tQMKKKKBBRRRQB5h8c9Y+w+CY9PRsSahcKhH+wnzN+oUfjU/wS0f+zvAKXjriXUJnnJ77B8q/oufxrzz42ahLrPj+00W2yzWsSQqo5/eykH+RSvf9J0+LSdIs9OhAEdrCkK49FAH9KBlyiiigQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAeG/tDff8P/AEuP/adeqeCf+RF0H/sHwf8AoAryv9ob7/h/6XH/ALTr1TwT/wAiLoP/AGD4P/QBQM3qKKKBBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB83fFa2l8LfFWHWrcbfOMV8mP76EBh/47/49X0XaXMd7ZwXUJ3RTRrIh9QwyP515V8e9H+0+GrDVkXLWVx5bnH8EnH/AKEF/Ot/4P6x/a3w7sUZsy2Ra0fJ5+X7v/jpWgZ3lFFFAgooooA8d+NHgEX9q/ifTIc3UC/6bGo/1sY/j+qjr6j6VofB3x4df0v+w9Rm3alZJ+7djzPCOAfdl4B9sH1r1FlDqVYAqRggjg181eO/D158NPHNtrGjZis5ZTPaEfdRv44j7YP/AHyfagZ9LUVkeGPENp4o8P2mrWZwky/MhOTG44ZT7g1r0COQ+JHhJfF/hOe2iQG+t/39o3+2B936MMj8vSvN/gZ4sa2vLjwresVWQtNaB+Crj76fjjOPUNXu9fOPxW0K48HePLfxBpY8qK7kFzEyjASdSCw+h4P4mgZ9HUVl+HNct/Efh6y1a24juYg5X+43RlP0IIrUoEZXif8A5FPWf+vGf/0Wa4T4Df8AJLbX/r5m/wDQq7vxP/yKes/9eM//AKLNcJ8Bv+SW2v8A18zf+hUAcTqf/JykX/YQh/8ARK19Ddq+edT/AOTlIv8AsIQ/+iVr6G7UDCvn342+I5dY8SWvhmxzIlowMiIc+ZO/Cr+AIH1Y17d4i1qDw74evtWuMbLWIuF/vN/Cv4nA/GvCPg/os/ijx3c+IdRzKLNjcO5/juHJx+XzH8qAPa/BXhuLwp4UstKQAyou+dx/HK3LH8+B7AV0FFFAiO4nitbeW4nkWOGJC7u3RVAySfwr5mnkvfi78TgkZkSzY4X/AKYWqnk/U5z9WHpXf/HLxb9g0iLw5ayYnvR5lyQfuwg9P+BEfkDWt8HPCH/CP+FxqV1Ft1DUgJW3DlIv4F/Xcfr7UDPQLGyt9NsYLK0iWK3gQRxovRVAwBViiigQUUUUAFNkdYo2kchUUEsT2A606uO+KOs/2L8PdUmR9s08Ytov96Q7f5ZP4UAeN+A428Z/GZtVmUtEs8t+3so4jH5lPyr6Vrxj9n/RhFpuq6y6czSLbRH/AGUGW/Vh+Vez0AwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPDf2hvv+H/pcf8AtOvVPBP/ACIug/8AYPg/9AFeV/tDff8AD/0uP/adeqeCf+RF0H/sHwf+gCgZvUUUUCCiiigAooooAKKKKACiiigAooooAKKKKACiiigDE8YaP/b/AIQ1XTMZee3YR/74GV/UCvHvgDrBg1fVNFkOPtES3CKezIdrD8iPyr3yvmhv+KE+Omf9XbC+z7eTN/hv/wDHaBn0vRRRQIKKKKACsHxj4YtvFvhq60qfCu43QSkf6uQfdb+h9ia3qKAPnT4UeJbnwf4xuPDWrZhgupvIdGPENwOAfo3T/vk19F14X8dPCPkzQeKrJCA5WG829m/gf/2X/vmvQvhn4t/4S3wjBPM4a/tv3F0O5YDhv+BDB+uaBnZVynxG8MDxV4MvLJFBu4h59sf+mijIH4jK/jXV0UCPC/gL4lMdxe+GrhyA+bm2DdiOJF/kfwNe6V80eN7Sb4e/FpNVs0K27zC+hUcAqxxIn57h/wACFfSNndQ31lBd27h4Zo1kjYd1IyDQMoeJ/wDkU9Z/68Z//RZrhPgN/wAkttf+vmb/ANCru/E//Ip6z/14z/8Aos1wnwG/5Jba/wDXzN/6FQI4nU/+TlIv+whD/wCiVr6G7V81eLtWg0H48z6rdK7QWl3FK6x43ECJemSBnn1rtT+0Foe8AaTf7P72+PP5ZoGVfj54i8u1sPD0T8yn7VcAf3V4Qficn/gIruPhf4c/4RvwNZQypturkfarjI53OOB+C7R+FeJ2kh+JvxhindGFpPOJPLfGVt4hnafc4/Nq+nhwKACoLy7hsbKe7uZBHBBG0kjn+FQMk1PXlHxz8S/2d4bh0OB8T6i2ZcHpCpyfzbA/A0CPO/D9pP8AFL4qyXl4jG0Mn2mdT0SBThI/x+Uf99V9NABQAAAB2FecfBjwz/Yng5dRnj23epkTHI5EX8A/LLf8Cr0igAooooAKKKKACvDv2gdZwdJ0VG4G67lXP/AU/wDZ69xr5p8QE+Ofjh9iU77f7YlqMcjyovvn9H/OgEe4fD3Rv7B8CaTZMuJfIEsv++/zN/PH4V01IAAAAMDsKWgAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPDf2hvv+H/AKXH/tOvVPBP/Ii6D/2D4P8A0AV5X+0N9/w/9Lj/ANp16p4J/wCRF0H/ALB8H/oAoGb1FFFAgooooAKKKKACiiigAooooAKKKKACiiigAooooAK8F+P+jmLVNK1mMYE8bW0jDsyncp/It+Ve9Vwvxe0f+1/h3flF3S2ZW7TA/uH5v/HS1AG74M1ga/4O0rUs5ea3XzP98fK36g1u15F8A9Y+0+HdQ0h2BezuPNQE/wAEg/8Aig35167QAUUUUAFFFFAFHWNLttb0e70y8Tdb3MRjcegPce46/hXzx4A1O5+H3xNm0bUX2QTS/Y7knhc5/dyfTJH4NX0rXhnx58M7JbLxLbpjdi1uivr1jb+a/lQM9zorkvhv4m/4SnwVZXkj7ruIfZ7n18xeM/iMH8a62gR5f8cfD/8AaXg9NViTM+mSb2I6+U2Fb8jtP4Gpfglr/wDavgr+zpWzPpknk89fLPzJ/Uf8Br0LUbGHU9NurC4XdDcxNE4x2YYP86+YPA3i4fDnxTqH2pGubYq9tKsLD5mRvlYEnHY/gaBn0n4n/wCRT1n/AK8Z/wD0Wa4T4Df8kttf+vmb/wBCrE1L47aJqWjX9idMvonuLaSJG3RsAWUgZ5HHNbfwH4+F1r/19Tf+hUCMC0tLe9/aR1OK5gini8lmKSoGGfJjxwa9h/sXS9mz+zbPb6eQmP5V5LpIJ/aV1X2gb/0VHXtFAHmPjjwFZaXCfF3hq2Sx1XSz9qMUA2xzovLKVHAJXPI69DXf6Nq9pruj2up2Mgkt7mMOhHbPY+4PB+lXJYknheKVQ0bqVZT0IPBFeN3fwQ1G1uZRoPimezsnYssD7wV9sowB+uM0Aez5r5l1iR/iZ8YhaRMWs2n+zoR0W3jzub8cMf8AgQrp5vAvxO8M280mkeIDqMboyvAJmLEEY4WTIz6YINU/gZb2Nj4q1OHUWNvrKRCGC2mQq+3OZOvfheOuOaBnvkUSQxJFGoSNFCqoHAA4Ap9FFAgooooAKKKKAMzxFqqaH4c1HVHIxa27yjPcgcD8TivDvgRpL3/irUNanBb7JDt3HvJKeT+QP512fx11g2PgyDTUbD6hcBSPVE+Y/rtH41b+Cuj/ANm+AIbp1xLqErXBPfb91f0XP40DPRqKKKBBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAeG/tDff8P/AEuP/adeqeCf+RF0H/sHwf8AoAryv9ob7/h/6XH/ALTr1TwT/wAiLoP/AGD4P/QBQM3qKKKBBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVFc28d3azW0y7opUaNx6gjB/nUtFAHzb8LLiTwr8WJdGuG2iUy2D57spyh/Hb/AOPV9JV83/Fu1l8NfFGHWrYbfPEV6mP76EBv/QR+dfRNndR31jb3cJzFPGsqH1VhkfzoGT0UUUCCiiigArJ8TaHD4j8N3+kTYC3MRVW/ut1VvwIBrWpGIVSWIAAySaAPnn4K63NofjO78O3uYxebkKN/DPHnj8QGH4CvofNfMmu21x4p+Kt5e+BIZ53SZJftEYCoko4L7jwFJGQT154Ndgnwv+IN6PPv/GrxTvyVSeZ8fiCo/IUDO1+JeqXUWi2uh6ZMI9T1u5WyhbOCiH/WP+C8Z96ueHfh54a8OWMcNvplvPMqgPc3EYeRz65PT6Diuf8ABfwtm0HXxrut6zJqt/EpWDduxHkYJyxJJxkDsMmvSqBGfLomkyIRJplk4x0a3Q/0rgvgaMfDSHH/AD+T/wDoVemN90/SvNPgd/yTWH/r8uP/AEOgDF0j/k5TV/8Ar3b/ANFR17NXjejf8nJ6z/17H/0VFXslABRRRQAVwnxF8FHW7Nda0j/R/EWnYmtZ04Mm3nYfX2/LoTXd0GgDG8Ka6niXwvp+rou03EQLp/dccMv4MDWzXFeAoxp2oeKdEUYjs9VaWJf7scyLIB+Zau1oAKKKKACiimTSpBC8shCoilmJ7AcmgD52+M9/LrvxDtdEtjuNtHHbqoOf3spBP80/KvoHS7CPS9KtLCEAR20KQrj0UAf0r52+HsT+MfjG+ryqWjSaXUG9gDiMfmV/KvpSgYUUUUCCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA8N/aG+/wCH/pcf+069U8E/8iLoP/YPg/8AQBXlf7Q33/D/ANLj/wBp16p4J/5EXQf+wfB/6AKBm9RRRQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDyb49aP9q8LWWqouXsbja5x/BIMf+hBa2/g5rH9q/DuzjZsy2LtavzzhTlf/HSPyrpfFmjrr/hPVNLIy1xbuqez4yp/MCvGvgFq7W+uano0p2/aIROins6HDD8mH5UDPfqKKKBBRRRQAVwvxKvL26tNP8K6VIY77XJjC0g/5ZQKMyt+XH4mu6ri7BBqfxa1a6YZXSdPgtY/Z5S0jn64CigDf8PeHdO8MaPDpumwCOGMfM2PmkbuzHuTWrRRQAUUUUAI33T9K80+B3/JNYf+vy4/9Dr0tvun6V5p8Dv+Saw/9flx/wCh0AZGi/8AJyOt/wDXsf8A0XFXsdePaGAf2j9eJ7WvH/fEVew0AFFFFABRRRQB5L4ok8d6F481W88LaN9rttQht2kkeIOu5FK4HzDB/wDrVnn4j/EjRR5uteD/ADLZfvukDpgf7ylgPxFe1UUAcn4L+IWjeNYGFmzQXsa7pbSbG9R6gjhl9x+OK6yvMviH4SXTCPHHh6JbbVtMb7ROkQwtzEPv5A77c89xnPavRrK6S+sbe7i/1c8ayL9GAI/nQBPXGfFTWf7F+HmpyI5Wa5QWsZHq/B/8d3H8K7OvDP2gdZzNpOio33A93KP/AB1P/Z6AL/wA0bydJ1TWXTBuJVt4j/soMn9W/SvZK5vwDo39g+BtJsGXbKsAklGP43+Zv1P6V0lABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAHhv7Q33/AA/9Lj/2nXqngn/kRdB/7B8H/oAryv8AaG+/4f8Apcf+069U8E/8iLoP/YPg/wDQBQM3qKKKBBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFfNF0P8AhBPjp5g/d2wvg/HTyZuv4Dcfyr6Xrwf9oDRvLvtK1qMYEyNaykdivzL+hb8qAR7xRWB4I1j+3/Bek6kWzJLbqJOf41+Vv1BrfoAK8z8V/GGw0jUH0nRLKTWNSVijCIny1YdsgEsR3wPxrd+JGp39h4WFppRK6lqdxHYWzA4KtIeW/BQee1W/B/grSvB2lx21lCrXJUefdMv7yVu/PYeg6CgDzn/hNPi3efvbfwmkUZ6K1qwP/jzg11vwztteZdc1XxHYGzv7+8VjGV2gqsaqCBk8fj613uKKACiiigAooooARvun6V5p8Dv+Saw/9flx/wCh16W33T9K80+B3/JNYf8Ar8uP/Q6AM3QFz+0Z4hPpaf8AskVevV5H4eUn9orxIfSzH/oMNeuUAFFFFABRRRQAUUUUAU9VtftukXtrjPnwSR49dykf1rh/AHxB8PXPhfS9Ou9Tt7PUbW3S2mguX8s7kAU4J4IOK9ErhPEfwk8LeI7qa8e3ls7uYlpJbV9odj3KnKk/hQB3SsroGUgqRkEHINfNOsf8Vz8cvsynzLY3q2/HI8qL7x+h2t+ddzo15ffDL+3/AA9qF613Z22nNqWmTPwcA7SmO3zFeBxzkda5v4C6S154l1LWZxu+yweWrH/npIck/kp/OgZ9BDpRRRQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA8N/aG+/4f+lx/wC069U8E/8AIi6D/wBg+D/0AV5X+0N9/wAP/S4/9p16p4J/5EXQf+wfB/6AKBm9RRRQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAriPi1o39sfDvUdqlprQC7jwP7n3v/HS1dvUVzBHc20tvKA0cqFHB7gjBoA8k+AWsfaNB1LR3cFrWcTRj/YkHP/jyn869Zu721sIDPeXMNvEOskrhFH4mvnP4ZzyeEvi5Jo07bVkeXT3z3IOUP4lR/wB9V2A8KS/FjxFqOr6rqE8WhWdy9pY28OMuEOGfnIGTnnGT7YoGb+peJ9G8S+PfDGk6TeR3z2t1LeTvCd0aBYXUfN0Jyw6V6JXOeGPA2geEQ7aTZ7J5F2vPI5eRh6ZPQewxXR0CCiiigAooooAKKKKAEb7p+leY/Av/AJJun/X7P/6EK9Ob7p+leY/Av/km6/8AX9P/AOhCgCp4cBP7Q/if2sh/KGvWq8o8M/8AJwvir/rxX+UNer0AFFFFABRRRQAUUUUAFFFFAHmnxf8ABOo+KdOsrvRoxLe2hZHi3hTJE2MgE8cFQcH3rgtB8AfFLSbNk0ycaZGz+aYhdopdsAc4BzwB1NfRFFAHm/grxzrDa1/wivjKz+yaztLW820BbkDr04zweRwcHoeK9Irh/ilpwk8Lf23Au3UNElS+t5B1AVgXX6Fc8ewrcsfGHh7UbyOyttZsJLx1BECXClskZx15PtQBuUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB4b+0N9/w/8AS4/9p16p4J/5EXQf+wfB/wCgCvK/2hvv+H/pcf8AtOvVPBP/ACIug/8AYPg/9AFAzeooooEFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRTZJEhjaSV1SNRlmY4AHqTQAksscELzSuqRopZmY4CgckmvFb3xR47+IWoz/8ACFK9jotu5RbpmWPziO5Zgf8AvkDgda6Xx54s0rW/Ck+j6FrNpc3uoXMNhi3mDMokcKxwO2M813mk6Xa6LpVtptlEI7a3QRoo9B3+p6n60AfO+ofDT4kSa2NWlt0uL8yK/wBqhuYwd4wA3bHQc4r3jwfoR8NeE9O0lnDywRfvXHRpGJZj/wB9E1uUUAFFFFABRRRQAUUUUAFFFFACN90/SvMfgX/yTdf+v6f/ANCFenN90/SvMfgX/wAk3X/r+n/9CFAGDF4o0jwr8dPE95rF0beCW3SJGEbPltsRxhQewNdovxh8DN/zGwPrbyj/ANlq5q3wz8H67qk+p6losdxeTkGSUyuCxAAHAbHQCqf/AApzwD/0L0P/AH+k/wDiqAJF+LfgVv8AmYIR9YpB/wCy1IPit4Gbp4jtfxDj+lV/+FOeAf8AoXof+/0n/wAVR/wpzwD/ANC9D/3+k/8AiqALa/FDwS3TxJY/i5H9KkX4k+DG6eJdN/GYCs//AIU54B/6F6L/AL/Sf/FUf8Kc8A/9C9F/3+k/+KoA1V+IXg9+niXS/wDwJUVKvjnwo/3fEmlf+Baf41i/8Kc8A/8AQvRf9/pP/iqX/hTngH/oXof+/wBJ/wDFUAb6+MPDL/d8RaSf+32P/GpB4o8Pt93XdMP0u4/8a5z/AIU74B/6F2H/AL/Sf/FUf8Kd8A/9C7D/AN/pP/iqAOnHiHRG+7q+nn6XKf41IutaW33dSsz9J0/xrlP+FO+Af+hdh/7/AEn/AMVR/wAKd8A/9C7D/wB/pP8A4qgDoNZ/s3WtEvdNk1CBEu4HhLrKpK7hjPWvObr4NeEv7I8qw1eWHUUUGO6e6UjeO5UcAZ9MEetdN/wp3wD/ANC7D/3+k/8AiqP+FO+Af+hdh/7/AEn/AMVQA34d+LpdT0m40zXJ4k1rSpfs1yWkX94B91we+QOvqM967L+0bL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAdh/aNl/wA/cH/f1f8AGj+0bL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAdh/aNl/wA/cH/f1f8AGj+0bL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAdh/aNl/wA/cH/f1f8AGj+0bL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAdh/aNl/wA/cH/f1f8AGj+0bL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAdh/aNl/wA/cH/f1f8AGj+0LL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAdh/aNl/wA/cH/f1f8AGj+0bL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAdh/aNl/wA/cH/f1f8AGj+0bL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAdh/aNl/wA/cH/f1f8AGj+0bL/n7g/7+r/jXH/8Kd8A/wDQuw/9/pP/AIqj/hTvgH/oXYf+/wBJ/wDFUAcF+0DcQTtoHlTRyYFxna4OPuV6h4LvrRPA+hK11AGFhCCDIvHyD3rM/wCFO+Af+hdh/wC/0n/xVH/CnfAP/Quw/wDf6T/4qgDsP7Rsv+fuD/v6v+NH9o2X/P3B/wB/V/xrj/8AhTvgH/oXYf8Av9J/8VR/wp3wD/0LsP8A3+k/+KoA7D+0bL/n7g/7+r/jR/aNl/z9wf8Af1f8a4//AIU74B/6F2H/AL/Sf/FUf8Kd8A/9C7D/AN/pP/iqAOw/tGy/5+4P+/q/40f2jZf8/cH/AH9X/GuP/wCFO+Af+hdh/wC/0n/xVH/CnfAP/Quw/wDf6T/4qgDsP7Rsv+fuD/v6v+NH9o2X/P3B/wB/V/xrj/8AhTvgH/oXYf8Av9J/8VR/wp3wD/0LsP8A3+k/+KoA7D+0bL/n7g/7+r/jR/aNl/z9wf8Af1f8a4//AIU74B/6F2H/AL/Sf/FUf8Kd8A/9C7D/AN/pP/iqAOw/tGy/5+4P+/q/40f2jZf8/cH/AH9X/GuP/wCFO+Af+hdh/wC/0n/xVH/CnfAP/Quw/wDf6T/4qgDsP7Rsv+fuD/v6v+NH9o2X/P3B/wB/V/xrj/8AhTvgH/oXYf8Av9J/8VR/wp3wD/0LsP8A3+k/+KoA7D+0bL/n7g/7+r/jR/aNl/z9wf8Af1f8a4//AIU74B/6F2H/AL/Sf/FUf8Kd8A/9C7D/AN/pP/iqAOw/tGy/5+4P+/q/415h4xubj4geLB4N0+/FvpFmqzarcow+cn7sY9fp0z1+7W//AMKd8A/9C7D/AN/pP/iqVPg/4DRty+H4gfUTSf8AxVAGXbfCXwnpurabqNhezwzWU6ykPcCQS7ecHPTnHT8q9COpWK/evLcfWVf8a5Q/CXwMeugRH/ttJ/8AFUn/AAqLwJ/0L0H/AH9k/wDiqAOobWtLX72pWY+s6f41GfEWiL97WNPH1uU/xrm/+FReA/8AoXoP+/sn/wAVR/wqLwH/ANC9B/39k/8AiqAOgPijw+vXXdMH1u4/8aibxj4ZXr4h0r/wMj/xrE/4VH4E/wChfh/7+yf/ABVL/wAKk8C/9C/F/wB/ZP8A4qgDVbx14UXr4j0v/wACk/xqE/EPwevXxJpv4TiqH/CpfA3/AEAIv+/0n/xVL/wqXwN/0AYv+/0n/wAVQBaPxK8GL18R2H4SZqM/FDwUP+Zis/wLH+lQ/wDCpfA//QBj/wC/0n/xVH/CpfA//QBj/wC/0n/xVADz8VfBA/5mC3/BHP8A7LUbfFrwOv8AzHUP0gl/+Jpf+FS+Bv8AoAxf9/pP/iqP+FS+Bv8AoARf9/pP/iqAIX+MHggD/kMMfpay/wDxNZPwKIb4bIR0N7Of1Fbn/CpfA3/QAi/7/Sf/ABVdDofh7S/DemjT9ItFtrUO0gjDM3zHqckk0Af/2Q==",
		"data:image/jpeg;base64,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"
	]
}
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAuanN4IiwibXlfbW9kdWxlc1xccmFpbmJvdy5qc3giLCJteV9tb2R1bGVzXFx1dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRE9NTGF6eVRyZWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0Rhbmdlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0Rpc2FibGVkSW5wdXRVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRQbHVnaW5IdWIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvTGlua2VkVmFsdWVVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZURldnRvb2wuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET00uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NQnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnRUcmVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUNvbnRhaW5lckluZm8uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRGVidWdUb29sLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUVtcHR5Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUluc3RydW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5RGV2dG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWJ1Z1Rvb2wuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEZlYXR1cmVGbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbmplY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SW5zdHJ1bWVudGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdEZXZUb29sLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE1vdW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROYXRpdmVPcGVyYXRpb25IaXN0b3J5RGV2dG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSZWYuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvVHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2FkbGVyMzIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRUYXJnZXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldE5hdGl2ZUNvbXBvbmVudEZyb21Db21wb3NpdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3NldFRleHRDb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2tleU1pcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIva2V5T2YuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL21hcE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL3BlcmZvcm1hbmNlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIiwicGx1Z2luXFxtaWNyb2xpZ2h0LmpzIiwicmVzb3VyY2UvcmVzb3VyY2UuanNvbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUNBQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUksT0FBTyxRQUFRLDBCQUFSLENBQVg7O0FBRUEsSUFBSSxVQUFVO0FBQ1YsUUFBTyw0REFERztBQUVWLE9BQU0sUTtBQUZJLENBQWQ7O0FBS0EsSUFBSSxVQUFVLHdCQUFZLElBQVosQ0FBZDs7Ozs7OztBQUVBLHNCQUF5QixRQUFRLE9BQVIsRUFBekIsOEhBQTRDO0FBQUE7O0FBQUEsTUFBbEMsR0FBa0M7QUFBQSxNQUE3QixLQUE2Qjs7QUFDM0MsTUFBRyxPQUFPLFFBQVEsSUFBbEIsRUFBdUI7QUFDdEIsV0FBUSxLQUFSLEdBQWdCLE1BQU0sS0FBSyxLQUFMLENBQVcsS0FBSyxNQUFMLEtBQWdCLE1BQU0sTUFBakMsQ0FBTixDQUFoQjtBQUNBO0FBQ0E7QUFDRDs7Ozs7Ozs7Ozs7Ozs7OztBQUVELG1CQUFTLE1BQVQsQ0FDQyxtREFBUyxPQUFPLFFBQVEsS0FBeEIsRUFBK0IsTUFBTSxRQUFRLElBQTdDLEdBREQsRUFFQyxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsQ0FGRDs7Ozs7Ozs7Ozs7QUNyQkE7Ozs7Ozs7Ozs7OztBQUVBLElBQUksYUFBYSxRQUFRLHlCQUFSLENBQWpCOztJQUVxQixPO2NB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNudEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3A3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QWpCLENBQUwsQ0FBenFDLEdBQW9zQyxJQUFFLEtBQUcsSUFBRSxDQUFMLEdBQU8sQ0FBUCxHQUFTLENBQS9zQyxFQUFpdEMsSUFBRSxFQUFudEMsRUFBc3RDLElBQUUsRUFBNXRDLEVBQSt0QyxDQUFDLENBQUMsQ0FBRCxFQUFHLDhCQUE4QixDQUE5QixFQUFpQyxDQUFqQyxDQUFILEVBQXVDLFFBQVEsQ0FBUixFQUFXLENBQVgsQ0FBdkMsRUFBcUQsUUFBUSxDQUFSLEVBQVcsQ0FBWCxDQUFyRCxFQUFtRSxPQUFLLENBQUwsSUFBUSxJQUFFLENBQVYsSUFBYSxPQUFLLENBQXJGLEVBQXVGLE9BQUssQ0FBNUYsRUFBOEYsT0FBSyxDQUFuRyxFQUFxRyxJQUFFLENBQUYsR0FBSSxFQUFFLElBQUUsQ0FBSixDQUFKLEdBQVcsRUFBRSxJQUFFLENBQUosQ0FBWCxJQUFtQixNQUF4SCxFQUErSCxJQUFFLENBQUYsSUFBSyxJQUFwSSxFQUF5SSxJQUFFLENBQUYsSUFBSyxJQUE5SSxFQUFtSixPQUFLLENBQXhKLEVBQTJKLEVBQUUsQ0FBN0osQ0FBaHVDLEtBQWs0QyxLQUFHLENBQUg7QUFBSztBQUFydkQ7QUFBc3ZELEdBQWw2RCxDQUFtNkQsRUFBRSxLQUFGLEdBQVEsQ0FBUixFQUFVLGNBQVksRUFBRSxVQUFkLEdBQXlCLEdBQXpCLEdBQTZCLEVBQUUsZ0JBQUYsQ0FBbUIsTUFBbkIsRUFBMEIsQ0FBMUIsRUFBNEIsQ0FBNUIsQ0FBdkM7QUFBc0UsQ0FBNW5FLENBQUQ7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiaW1wb3J0IFJhaW5ib3cgZnJvbSAnLi9teV9tb2R1bGVzL3JhaW5ib3cnO1xyXG5pbXBvcnQge2pzb25Ub01hcCwgb2JqVG9TdHJNYXB9IGZyb20gJy4vbXlfbW9kdWxlcy91dGlscyc7XHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5cclxubGV0IGRhdGEgPSByZXF1aXJlKCcuL3Jlc291cmNlL3Jlc291cmNlLmpzb24nKTtcclxuXHJcbmxldCByYWluYm93ID0ge1xyXG4gICAgaW1hZ2U6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JyxcclxuICAgIHR5cGU6ICdzaW5nbGUnIC8vIHBvc3NpYmxlIHZhbHVlczogJ3NpbmdsZScgJ2RvdWJsZSdcclxufTtcclxuXHJcbmxldCBqc29uTWFwID0gb2JqVG9TdHJNYXAoZGF0YSk7XHJcblxyXG5mb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YganNvbk1hcC5lbnRyaWVzKCkpIHtcclxuXHRpZihrZXkgPT0gcmFpbmJvdy50eXBlKXtcclxuXHRcdHJhaW5ib3cuaW1hZ2UgPSB2YWx1ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YWx1ZS5sZW5ndGgpXTtcclxuXHRcdGJyZWFrO1xyXG5cdH1cclxufVxyXG5cclxuUmVhY3RET00ucmVuZGVyKFxyXG5cdDxSYWluYm93IGltYWdlPXtyYWluYm93LmltYWdlfSB0eXBlPXtyYWluYm93LnR5cGV9IC8+LCBcclxuXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucm9vdCcpXHJcbik7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmxldCBtaWNyb2xpZ2h0ID0gcmVxdWlyZSgnLi4vcGx1Z2luL21pY3JvbGlnaHQuanMnKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhaW5ib3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBpbWFnZTogcHJvcHMuaW1hZ2UsXHJcbiAgICAgICAgICAgIHR5cGU6IHByb3BzLnR5cGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCl7XHJcbiAgICAgICAgdGhpcy50dXJuVG9Bc2NpaSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHR1cm5Ub0FzY2lpKCkge1xyXG4gICAgICAgIGxldCBpbWFnZSA9IG5ldyBJbWFnZSgpLFxyXG4gICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dEltYWdlXCIpLFxyXG4gICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcclxuICAgICAgICAgIGNlbGwgPSB7IHdpZHRoOiA4LCBoZWlnaHQ6IDEzIH0sXHJcbiAgICAgICAgICBjaGFycyA9IHt9LFxyXG4gICAgICAgICAgc2NhbGUgPSAxO1xyXG5cclxuICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cclxuICAgICAgICBjYW52YXMud2lkdGggPSBjZWxsLndpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjZWxsLmhlaWdodDtcclxuICAgICAgICBjdHguZm9udCA9IGNlbGwuaGVpZ2h0ICsgXCJweCBtb25vc3BhY2VcIjtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2xlYXIoKXtcclxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNGRkZcIjtcclxuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRDaGFyRGF0YShjaGFyYWN0ZXIpe1xyXG4gICAgICAgICAgaWYgKGNoYXJhY3RlciA9PSBcIl9cIil7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMDAwXCI7XHJcbiAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCAwLCBjZWxsLmhlaWdodC8xLjIpO1xyXG5cclxuICAgICAgICAgIGNoYXJzW2NoYXJhY3Rlcl0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNlbGwud2lkdGgsIGNlbGwuaGVpZ2h0KS5kYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNoYXJhY3RlcnMgPSBcIiMqK2DCtCcuOmRiUFVWTVdBPD5YeCBcIi5zcGxpdChcIlwiKVxyXG5cclxuICAgICAgICBmb3IgKGxldCBjID0gMzI7IGMgPCAxMjc7IGMrKyl7XHJcbiAgICAgICAgICBnZXRDaGFyRGF0YShTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldE5lYXJlc3QoaW1hZ2VEYXRhKXtcclxuICAgICAgICAgIGxldCBjaGFyRGF0YSxcclxuICAgICAgICAgICAgbWluID0gSW5maW5pdHksXHJcbiAgICAgICAgICAgIGJlc3QgPSBcIiBcIixcclxuICAgICAgICAgICAgYywgaSwgZGlmZjtcclxuXHJcbiAgICAgICAgICBmb3IgKGMgaW4gY2hhcnMpe1xyXG4gICAgICAgICAgICBjaGFyRGF0YSA9IGNoYXJzW2NdO1xyXG4gICAgICAgICAgICBkaWZmID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGFyRGF0YS5sZW5ndGg7IGkgKz0gNCl7XHJcbiAgICAgICAgICAgICAgaWYgKGltYWdlRGF0YVtpKzNdKXtcclxuICAgICAgICAgICAgICAgIGRpZmYgKz0gTWF0aC5hYnMoaW1hZ2VEYXRhW2ldID4gMjAwICE9IGNoYXJEYXRhW2ldID4gMjAwKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkaWZmIDwgbWluKXtcclxuICAgICAgICAgICAgICBtaW4gPSBkaWZmO1xyXG4gICAgICAgICAgICAgIGJlc3QgPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGJlc3QgPT0gXCJRXCIgfHwgYmVzdCA9PSBcIk1cIil7IHJldHVybiBcIiNcIjsgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBiZXN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgbGV0IG91dCA9IFwiXCIsXHJcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGggKiBzY2FsZSxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogc2NhbGUsXHJcbiAgICAgICAgICAgIHNjYWxlZEhlaWdodCA9IGhlaWdodCAqIDAuOTIsXHJcbiAgICAgICAgICAgIGRhdGEsIHgsIHk7XHJcblxyXG4gICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIHNjYWxlZEhlaWdodCk7XHJcblxyXG4gICAgICAgICAgZm9yICh5ID0gMDsgeSA8IHNjYWxlZEhlaWdodDsgeSArPSBjZWxsLmhlaWdodCArIDIpe1xyXG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHggKz0gY2VsbC53aWR0aCl7XHJcbiAgICAgICAgICAgICAgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoeCwgeSwgY2VsbC53aWR0aCwgY2VsbC5oZWlnaHQpLmRhdGE7XHJcbiAgICAgICAgICAgICAgb3V0ICs9IGdldE5lYXJlc3QoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG91dCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICAgIGxldCAkZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dEFzY2lpXCIpXHJcblxyXG4gICAgICAgICAgJGVsLmlubmVyVGV4dCA9IG91dDtcclxuXHJcbiAgICAgICAgICB0aGlzLmNvbG9yVGhlQXNjaWkoJGVsKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaW1hZ2Uuc3JjID0gdGhpcy5zdGF0ZS5pbWFnZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29sb3JUaGVBc2NpaSgkZWwpIHtcclxuXHJcbiAgICAgICAgbGV0IGxldHRlcnMgPSAkZWwuaW5uZXJIVE1MLnNwbGl0KCcnKTtcclxuIFxyXG4gICAgICAgIGNvbnN0IGNvbFRvSGV4ID0gKGMpID0+IHtcclxuICAgICAgICAgIGxldCBjb2xvciA9IChjIDwgNzUpID8gYyArIDc1IDogY1xyXG4gICAgICAgICAgbGV0IGhleCA9IGNvbG9yLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyBcIjBcIiArIGhleCA6IGhleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJnYlRvSGV4ID0gKHIsZyxiKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gXCIjXCIgKyBjb2xUb0hleChyKSArIGNvbFRvSGV4KGcpICsgY29sVG9IZXgoYik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBnZXRSYW5kb21Db2xvciA9ICgpID0+IHtcclxuICAgICAgICAgIHJldHVybiByZ2JUb0hleChcclxuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KSxcclxuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KSxcclxuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBBcnJheS5wcm90b3R5cGUucmFuZG9tQ29sb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGxldCBodG1sID0gJyc7XHJcbiAgICAgICAgICB0aGlzLm1hcCggKGxldHRlcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBnZXRSYW5kb21Db2xvcigpO1xyXG4gICAgICAgICAgICBodG1sICs9XHJcbiAgICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz1cXFwibWljcm9saWdodFxcXCIgc3R5bGU9XFxcImNvbG9yOlwiICsgY29sb3IgKyBcIlxcXCI+XCJcclxuICAgICAgICAgICAgICArIGxldHRlciArXHJcbiAgICAgICAgICAgICAgXCI8L3NwYW4+XCI7XHJcbiAgICAgICAgICB9KSBcclxuICAgICAgICAgIHJldHVybiBodG1sO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvdXRwdXRBc2NpaScpLmlubmVySFRNTCA9IGxldHRlcnMucmFuZG9tQ29sb3IoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tYWtlSXRTcGFya2xlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFrZUl0U3BhcmtsZSgpIHtcclxuICAgICAgICBsZXQgc3BhbnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3BhbicpXHJcbiAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYnVja2V0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc3BhbnMpLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gYnVja2V0W01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJ1Y2tldC5sZW5ndGgpXTtcclxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ21pY3JvbGlnaHQnKTtcclxuICAgICAgICB9LCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgaWQ9XCJvdXRwdXRcIj5cclxuICAgICAgICAgICAgICAgIDxjYW52YXMgaWQ9XCJpbnB1dEltYWdlXCI+PC9jYW52YXM+XHJcbiAgICAgICAgICAgICAgICA8cHJlIGlkPVwib3V0cHV0QXNjaWlcIj48L3ByZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59IiwiLyogRVM2IEpTT04vTUFQIHV0aWxzIC0tXHJcblx0aW5zcGlyZWQgYnkgaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTUvMDgvZXM2LW1hcC1qc29uLmh0bWwgKi9cclxuXHRcclxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvSnNvbihtYXApIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoWy4uLm1hcF0pO1xyXG4gICAgfVxyXG5leHBvcnQgZnVuY3Rpb24ganNvblRvTWFwKGpzb25TdHIpIHtcclxuICAgIHJldHVybiBuZXcgTWFwKEpTT04ucGFyc2UoanNvblN0cikpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdHJNYXBUb09iaihzdHJNYXApIHtcclxuICAgIGxldCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgZm9yIChsZXQgW2ssdl0gb2Ygc3RyTWFwKSB7XHJcbiAgICAgICAgLy8gV2UgZG9u4oCZdCBlc2NhcGUgdGhlIGtleSAnX19wcm90b19fJ1xyXG4gICAgICAgIC8vIHdoaWNoIGNhbiBjYXVzZSBwcm9ibGVtcyBvbiBvbGRlciBlbmdpbmVzXHJcbiAgICAgICAgb2JqW2tdID0gdjtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG9ialRvU3RyTWFwKG9iaikge1xyXG4gICAgbGV0IHN0ck1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGZvciAobGV0IGsgb2YgT2JqZWN0LmtleXMob2JqKSkge1xyXG4gICAgICAgIHN0ck1hcC5zZXQoaywgb2JqW2tdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHJNYXA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHN0ck1hcFRvSnNvbihzdHJNYXApIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnN0ck1hcFRvT2JqKHN0ck1hcCkpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBqc29uVG9TdHJNYXAoanNvblN0cikge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqVG9TdHJNYXAoSlNPTi5wYXJzZShqc29uU3RyKSk7XHJcbn0iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RET00nKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0ge1xuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIGZvY3VzTm9kZShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQsIHRvcExldmVsVHlwZXMudG9wUGFzdGVdXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZSwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZChuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCB8fCBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogTW9zdCBzdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1bnNldCBieSBkb2luZyAuc3R5bGVbcHJvcF0gPSAnJyBidXQgSUU4XG4gKiBkb2Vzbid0IGxpa2UgZG9pbmcgdGhhdCB3aXRoIHNob3J0aGFuZCBwcm9wZXJ0aWVzIHNvIGZvciB0aGUgcHJvcGVydGllcyB0aGF0XG4gKiBJRTggYnJlYWtzIG9uLCB3aGljaCBhcmUgbGlzdGVkIGhlcmUsIHdlIGluc3RlYWQgdW5zZXQgZWFjaCBvZiB0aGVcbiAqIGluZGl2aWR1YWwgcHJvcGVydGllcy4gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzg1LlxuICogVGhlIDQtdmFsdWUgJ2Nsb2NrJyBwcm9wZXJ0aWVzIGxpa2UgbWFyZ2luLCBwYWRkaW5nLCBib3JkZXItd2lkdGggc2VlbSB0b1xuICogYmVoYXZlIHdpdGhvdXQgYW55IHByb2JsZW1zLiBDdXJpb3VzbHksIGxpc3Qtc3R5bGUgd29ya3MgdG9vIHdpdGhvdXQgYW55XG4gKiBzcGVjaWFsIHByb2RkaW5nLlxuICovXG52YXIgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zID0ge1xuICBiYWNrZ3JvdW5kOiB7XG4gICAgYmFja2dyb3VuZEF0dGFjaG1lbnQ6IHRydWUsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZVxuICB9LFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IHtcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWVcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgYm9yZGVyV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyTGVmdENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgYm9yZGVyUmlnaHRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyVG9wOiB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyVG9wU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcbiAgfSxcbiAgZm9udDoge1xuICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgIGZvbnRTaXplOiB0cnVlLFxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgb3V0bGluZVdpZHRoOiB0cnVlLFxuICAgIG91dGxpbmVTdHlsZTogdHJ1ZSxcbiAgICBvdXRsaW5lQ29sb3I6IHRydWVcbiAgfVxufTtcblxudmFyIENTU1Byb3BlcnR5ID0ge1xuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlPcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xudmFyIGRhbmdlcm91c1N0eWxlVmFsdWUgPSByZXF1aXJlKCcuL2Rhbmdlcm91c1N0eWxlVmFsdWUnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoJ2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbn0pO1xuXG52YXIgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSBmYWxzZTtcbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgdGVtcFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHRyeSB7XG4gICAgLy8gSUU4IHRocm93cyBcIkludmFsaWQgYXJndW1lbnQuXCIgaWYgcmVzZXR0aW5nIHNob3J0aGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgIHRlbXBTdHlsZS5mb250ID0gJyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IHRydWU7XG4gIH1cbiAgLy8gSUU4IG9ubHkgc3VwcG9ydHMgYWNjZXNzaW5nIGNzc0Zsb2F0IChzdGFuZGFyZCkgYXMgc3R5bGVGbG9hdFxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmNzc0Zsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uJXMgJyArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lciksIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciBjaGVja1JlbmRlck1lc3NhZ2UgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgICB2YXIgb3duZXI7XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICB9XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTmF0aXZlT3BlcmF0aW9uKGNvbXBvbmVudC5fZGVidWdJRCwgJ3VwZGF0ZSBzdHlsZXMnLCBzdHlsZXMpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgY29tcG9uZW50KTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcgfHwgc3R5bGVOYW1lID09PSAnY3NzRmxvYXQnKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnICYmIENTU1Byb3BlcnR5LnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHByb3BlcnR5IHRoYXQgSUU4IHdvbid0IGxpa2UgdW5zZXR0aW5nLCBzbyB1bnNldCBlYWNoXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xuICAgICAgICAgICAgc3R5bGVbaW5kaXZpZHVhbFN0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDYWxsYmFja1F1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrUXVldWUoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbn1cblxuX2Fzc2lnbihDYWxsYmFja1F1ZXVlLnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LFxuXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzID8gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA6IDA7XG4gIH0sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uIChsZW4pIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID0gbGVuO1xuICAgICAgdGhpcy5fY29udGV4dHMubGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxiYWNrUXVldWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENoYW5nZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2hhbmdlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DaGFuZ2VDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLCB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbnZhciBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gU2VlIGBoYW5kbGVDaGFuZ2VgIGNvbW1lbnQgYmVsb3dcbiAgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gaXNFdmVudFN1cHBvcnRlZCgnY2hhbmdlJykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDgpO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIC8vIElFMTArIGZpcmUgaW5wdXQgZXZlbnRzIHRvIG9mdGVuLCBzdWNoIHdoZW4gYSBwbGFjZWhvbGRlclxuICAvLyBjaGFuZ2VzIG9yIHdoZW4gYW4gaW5wdXQgd2l0aCBhIHBsYWNlaG9sZGVyIGlzIGZvY3VzZWQuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDExKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICAvLyBOb3QgZ3VhcmRlZCBpbiBhIGNhbkRlZmluZVByb3BlcnR5IGNoZWNrOiBJRTggc3VwcG9ydHMgZGVmaW5lUHJvcGVydHkgb25seVxuICAvLyBvbiBET00gZWxlbWVudHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGlmIChhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuXG4gIGlmIChhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOS0xMSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJbnN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01DaGlsZHJlbk9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcblxuZnVuY3Rpb24gZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIG5vZGUpIHtcbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB0ZXh0IGNvbXBvbmVudHMsIHdoaWNoIHJldHVybiBbb3BlbiwgY2xvc2VdIGNvbW1lbnRzXG4gIC8vIGZyb20gZ2V0TmF0aXZlTm9kZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZVsxXTtcbiAgfVxuICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgaW5zZXJ0Q2hpbGRBdCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBXZSByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiAoVXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsIGJyb3dzZXJzIHNvXG4gIC8vIHdlIGFyZSBjYXJlZnVsIHRvIHVzZSBgbnVsbGAuKVxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xufSk7XG5cbmZ1bmN0aW9uIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGVbMF0sIGNoaWxkTm9kZVsxXSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgdmFyIGNsb3NpbmdDb21tZW50ID0gY2hpbGROb2RlWzFdO1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZVswXTtcbiAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvc2luZ0NvbW1lbnQpO1xuICB9XG4gIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCByZWZlcmVuY2VOb2RlKSB7XG4gIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIG5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIHN0YXJ0Tm9kZSwgY2xvc2luZ0NvbW1lbnQpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIC8vIFRoZSBjbG9zaW5nIGNvbW1lbnQgaXMgcmVtb3ZlZCBieSBSZWFjdE11bHRpQ2hpbGQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZURlbGltaXRlZFRleHQob3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCBzdHJpbmdUZXh0KSB7XG4gIHZhciBwYXJlbnROb2RlID0gb3BlbmluZ0NvbW1lbnQucGFyZW50Tm9kZTtcbiAgdmFyIG5vZGVBZnRlckNvbW1lbnQgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5vZGVBZnRlckNvbW1lbnQgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHRleHQgbm9kZXMgYmV0d2VlbiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBjb21tZW50czsgaW5zZXJ0XG4gICAgLy8gYSBuZXcgb25lIGlmIHN0cmluZ1RleHQgaXNuJ3QgZW1wdHkuXG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nVGV4dCksIG5vZGVBZnRlckNvbW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIG9wZW5pbmcgY29tbWVudCwgYW5kXG4gICAgICAvLyByZW1vdmUgYWxsIGZvbGxvd2luZyBub2RlcyB1cCB1bnRpbCB0aGUgY2xvc2luZyBjb21tZW50LlxuICAgICAgc2V0VGV4dENvbnRlbnQobm9kZUFmdGVyQ29tbWVudCwgc3RyaW5nVGV4dCk7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG5vZGVBZnRlckNvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTmF0aXZlT3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG9wZW5pbmdDb21tZW50KS5fZGVidWdJRCwgJ3JlcGxhY2UgdGV4dCcsIHN0cmluZ1RleHQpO1xuICB9XG59XG5cbnZhciBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRDaGlsZCwgbWFya3VwKTtcbiAgICBpZiAocHJldkluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25OYXRpdmVPcGVyYXRpb24ocHJldkluc3RhbmNlLl9kZWJ1Z0lELCAncmVwbGFjZSB3aXRoJywgbWFya3VwLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobWFya3VwLm5vZGUpO1xuICAgICAgaWYgKG5leHRJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25OYXRpdmVPcGVyYXRpb24obmV4dEluc3RhbmNlLl9kZWJ1Z0lELCAnbW91bnQnLCBtYXJrdXAudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcblxuICByZXBsYWNlRGVsaW1pdGVkVGV4dDogcmVwbGFjZURlbGltaXRlZFRleHQsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuIFRoZVxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgdXBkYXRlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZURlYnVnSUQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShwYXJlbnROb2RlKS5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHVwZGF0ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50LCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25OYXRpdmVPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdpbnNlcnQgY2hpbGQnLCB7IHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4LCBjb250ZW50OiB1cGRhdGUuY29udGVudC50b1N0cmluZygpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk5hdGl2ZU9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ21vdmUgY2hpbGQnLCB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCwgdG9JbmRleDogdXBkYXRlLnRvSW5kZXggfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlNFVF9NQVJLVVA6XG4gICAgICAgICAgc2V0SW5uZXJIVE1MKHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTmF0aXZlT3BlcmF0aW9uKHBhcmVudE5vZGVEZWJ1Z0lELCAncmVwbGFjZSBjaGlsZHJlbicsIHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQ6XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25OYXRpdmVPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIHRleHQnLCB1cGRhdGUuY29udGVudC50b1N0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREU6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTmF0aXZlT3BlcmF0aW9uKHBhcmVudE5vZGVEZWJ1Z0lELCAncmVtb3ZlIGNoaWxkJywgeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXggfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUNoaWxkcmVuT3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NTGF6eVRyZWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbi8qKlxuICogSW4gSUUgKDgtMTEpIGFuZCBFZGdlLCBhcHBlbmRpbmcgbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBpcyBkcmFtYXRpY2FsbHlcbiAqIGZhc3RlciB0aGFuIGFwcGVuZGluZyBhIGZ1bGwgc3VidHJlZSwgc28gd2UgZXNzZW50aWFsbHkgcXVldWUgdXAgdGhlXG4gKiAuYXBwZW5kQ2hpbGQgY2FsbHMgaGVyZSBhbmQgYXBwbHkgdGhlbSBzbyBlYWNoIG5vZGUgaXMgYWRkZWQgdG8gaXRzIHBhcmVudFxuICogYmVmb3JlIGFueSBjaGlsZHJlbiBhcmUgYWRkZWQuXG4gKlxuICogSW4gb3RoZXIgYnJvd3NlcnMsIGRvaW5nIHNvIGlzIHNsb3dlciBvciBuZXV0cmFsIGNvbXBhcmVkIHRvIHRoZSBvdGhlciBvcmRlclxuICogKGluIEZpcmVmb3gsIHR3aWNlIGFzIHNsb3cpIHNvIHdlIG9ubHkgZG8gdGhpcyBpbnZlcnNpb24gaW4gSUUuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zcGljeWovaW5uZXJodG1sLXZzLWNyZWF0ZWVsZW1lbnQtdnMtY2xvbmVub2RlLlxuICovXG52YXIgZW5hYmxlTGF6eSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnICYmIC9cXGJFZGdlXFwvXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5mdW5jdGlvbiBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSkge1xuICBpZiAoIWVuYWJsZUxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5vZGUgPSB0cmVlLm5vZGU7XG4gIHZhciBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnNlcnRUcmVlQmVmb3JlKG5vZGUsIGNoaWxkcmVuW2ldLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHJlZS5odG1sICE9IG51bGwpIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHRyZWUuaHRtbDtcbiAgfSBlbHNlIGlmICh0cmVlLnRleHQgIT0gbnVsbCkge1xuICAgIHNldFRleHRDb250ZW50KG5vZGUsIHRyZWUudGV4dCk7XG4gIH1cbn1cblxudmFyIGluc2VydFRyZWVCZWZvcmUgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChwYXJlbnROb2RlLCB0cmVlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZW4ndCBhY3R1YWxseSBwYXJ0IG9mIHRoZSBET00gYWZ0ZXIgaW5zZXJ0aW9uIHNvXG4gIC8vIGFwcGVuZGluZyBjaGlsZHJlbiB3b24ndCB1cGRhdGUgdGhlIERPTS4gV2UgbmVlZCB0byBlbnN1cmUgdGhlIGZyYWdtZW50XG4gIC8vIGlzIHByb3Blcmx5IHBvcHVsYXRlZCBmaXJzdCwgYnJlYWtpbmcgb3V0IG9mIG91ciBsYXp5IGFwcHJvYWNoIGZvciBqdXN0XG4gIC8vIHRoaXMgbGV2ZWwuIEFsc28sIHNvbWUgPG9iamVjdD4gcGx1Z2lucyAobGlrZSBGbGFzaCBQbGF5ZXIpIHdpbGwgcmVhZFxuICAvLyA8cGFyYW0+IG5vZGVzIGltbWVkaWF0ZWx5IHVwb24gaW5zZXJ0aW9uIGludG8gdGhlIERPTSwgc28gPG9iamVjdD5cbiAgLy8gbXVzdCBhbHNvIGJlIHBvcHVsYXRlZCBwcmlvciB0byBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICBpZiAodHJlZS5ub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgfHwgdHJlZS5ub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSAmJiB0cmVlLm5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgJiYgKHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCB0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpKSB7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGROb2RlLCBuZXdUcmVlKSB7XG4gIG9sZE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3VHJlZS5ub2RlLCBvbGROb2RlKTtcbiAgaW5zZXJ0VHJlZUNoaWxkcmVuKG5ld1RyZWUpO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUNoaWxkKHBhcmVudFRyZWUsIGNoaWxkVHJlZSkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHBhcmVudFRyZWUuY2hpbGRyZW4ucHVzaChjaGlsZFRyZWUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudFRyZWUubm9kZS5hcHBlbmRDaGlsZChjaGlsZFRyZWUubm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVIVE1MKHRyZWUsIGh0bWwpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLmh0bWwgPSBodG1sO1xuICB9IGVsc2Uge1xuICAgIHRyZWUubm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlVGV4dCh0cmVlLCB0ZXh0KSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS50ZXh0ID0gdGV4dDtcbiAgfSBlbHNlIHtcbiAgICBzZXRUZXh0Q29udGVudCh0cmVlLm5vZGUsIHRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5ub2RlLm5vZGVOYW1lO1xufVxuXG5mdW5jdGlvbiBET01MYXp5VHJlZShub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgaHRtbDogbnVsbCxcbiAgICB0ZXh0OiBudWxsLFxuICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICB9O1xufVxuXG5ET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlID0gaW5zZXJ0VHJlZUJlZm9yZTtcbkRPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlID0gcmVwbGFjZUNoaWxkV2l0aFRyZWU7XG5ET01MYXp5VHJlZS5xdWV1ZUNoaWxkID0gcXVldWVDaGlsZDtcbkRPTUxhenlUcmVlLnF1ZXVlSFRNTCA9IHF1ZXVlSFRNTDtcbkRPTUxhenlUcmVlLnF1ZXVlVGV4dCA9IHF1ZXVlVGV4dDtcblxubW9kdWxlLmV4cG9ydHMgPSBET01MYXp5VHJlZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NTmFtZXNwYWNlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgxLFxuICBIQVNfU0lERV9FRkZFQ1RTOiAweDIsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnICsgJ1xcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5ICcgKyAnaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgJyArICdpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzU2lkZUVmZmVjdHM6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUyksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcblxuICAgICAgIShwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5IHx8ICFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBQcm9wZXJ0aWVzIHRoYXQgaGF2ZSBzaWRlIGVmZmVjdHMgbXVzdCB1c2UgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yICcgKyAnbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lID0gRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBET01Qcm9wZXJ0eSBleHBvcnRzIGxvb2t1cCBvYmplY3RzIHRoYXQgY2FuIGJlIHVzZWQgbGlrZSBmdW5jdGlvbnM6XG4gKlxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2lkJ11cbiAqICAgdHJ1ZVxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2Zvb2JhciddXG4gKiAgIHVuZGVmaW5lZFxuICpcbiAqIEFsdGhvdWdoIHRoaXMgbWF5IGJlIGNvbmZ1c2luZywgaXQgcGVyZm9ybXMgYmV0dGVyIGluIGdlbmVyYWwuXG4gKlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktZXhpc3RzXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1taXNzaW5nXG4gKi9cbnZhciBET01Qcm9wZXJ0eSA9IHtcblxuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG4gIFJPT1RfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0cm9vdCcsXG5cbiAgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUixcbiAgQVRUUklCVVRFX05BTUVfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdUI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNTaWRlRWZmZWN0czpcbiAgICogICBXaGV0aGVyIG9yIG5vdCBzZXR0aW5nIGEgdmFsdWUgY2F1c2VzIHNpZGUgZWZmZWN0cyBzdWNoIGFzIHRyaWdnZXJpbmdcbiAgICogICByZXNvdXJjZXMgdG8gYmUgbG9hZGVkIG9yIHRleHQgc2VsZWN0aW9uIGNoYW5nZXMuIElmIHRydWUsIHdlIHJlYWQgZnJvbVxuICAgKiAgIHRoZSBET00gYmVmb3JlIHVwZGF0aW5nIHRvIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBpZiBpdCBoYXNcbiAgICogICBjaGFuZ2VkLlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NSW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTUluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIGNyZWF0ZU1hcmt1cEZvclJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9yUm9vdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FLCAnJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdERPTUluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25DcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIC8vIE11c3QgZXhwbGljaXRseSBjYXN0IHZhbHVlcyBmb3IgSEFTX1NJREVfRUZGRUNUUy1wcm9wZXJ0aWVzIHRvIHRoZVxuICAgICAgICAvLyBwcm9wZXJ0eSB0eXBlIGJlZm9yZSBjb21wYXJpbmc7IG9ubHkgYHZhbHVlYCBkb2VzIGFuZCBpcyBzdHJpbmcuXG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzIHx8ICcnICsgbm9kZVtwcm9wTmFtZV0gIT09ICcnICsgdmFsdWUpIHtcbiAgICAgICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RET01JbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTmF0aXZlT3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25OYXRpdmVPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICd1cGRhdGUgYXR0cmlidXRlJywgcGF5bG9hZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgLy8gTm8gSEFTX1NJREVfRUZGRUNUUyBsb2dpYyBoZXJlLCBvbmx5IGB2YWx1ZWAgaGFzIGl0IGFuZCBpcyBzdHJpbmcuXG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cyB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSAnJykge1xuICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RET01JbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk5hdGl2ZU9wZXJhdGlvbihSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCwgJ3JlbW92ZSBhdHRyaWJ1dGUnLCBuYW1lKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERhbmdlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIE9QRU5fVEFHX05BTUVfRVhQID0gL14oPFteIFxcLz5dKykvO1xudmFyIFJFU1VMVF9JTkRFWF9BVFRSID0gJ2RhdGEtZGFuZ2VyLWluZGV4JztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBmcm9tIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBOT1RFOiBFeHRyYWN0aW5nIHRoZSBgbm9kZU5hbWVgIGRvZXMgbm90IHJlcXVpcmUgYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hcbiAqIGJlY2F1c2Ugd2UgbWFrZSBhc3N1bXB0aW9ucyBhYm91dCBSZWFjdC1nZW5lcmF0ZWQgbWFya3VwIChpLmUuIHRoZXJlIGFyZSBub1xuICogc3BhY2VzIHN1cnJvdW5kaW5nIHRoZSBvcGVuaW5nIHRhZyBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZXh0cmFjdC1ub2RlbmFtZVxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgcmV0dXJuIG1hcmt1cC5zdWJzdHJpbmcoMSwgbWFya3VwLmluZGV4T2YoJyAnKSk7XG59XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgbWFya3VwIGludG8gYW4gYXJyYXkgb2Ygbm9kZXMuIFRoZSBtYXJrdXAgaXMgZXhwZWN0ZWQgdG8gcmVuZGVyXG4gICAqIGludG8gYSBsaXN0IG9mIHJvb3Qgbm9kZXMuIEFsc28sIHRoZSBsZW5ndGggb2YgYHJlc3VsdExpc3RgIGFuZFxuICAgKiBgbWFya3VwTGlzdGAgc2hvdWxkIGJlIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncyB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnQ+fSBMaXN0IG9mIHJlbmRlcmVkIG5vZGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVuZGVyTWFya3VwOiBmdW5jdGlvbiAobWFya3VwTGlzdCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgJyArICd0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5ICcgKyAnYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArICdSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vZGVOYW1lO1xuICAgIHZhciBtYXJrdXBCeU5vZGVOYW1lID0ge307XG4gICAgLy8gR3JvdXAgbWFya3VwIGJ5IGBub2RlTmFtZWAgaWYgYSB3cmFwIGlzIG5lY2Vzc2FyeSwgZWxzZSBieSAnKicuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrdXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAhbWFya3VwTGlzdFtpXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cExpc3RbaV0pO1xuICAgICAgbm9kZU5hbWUgPSBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSA/IG5vZGVOYW1lIDogJyonO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSB8fCBbXTtcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdW2ldID0gbWFya3VwTGlzdFtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdExpc3QgPSBbXTtcbiAgICB2YXIgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9IDA7XG4gICAgZm9yIChub2RlTmFtZSBpbiBtYXJrdXBCeU5vZGVOYW1lKSB7XG4gICAgICBpZiAoIW1hcmt1cEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmt1cExpc3RCeU5vZGVOYW1lID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV07XG5cbiAgICAgIC8vIFRoaXMgZm9yLWluIGxvb3Agc2tpcHMgdGhlIGhvbGVzIG9mIHRoZSBzcGFyc2UgYXJyYXkuIFRoZSBvcmRlciBvZlxuICAgICAgLy8gaXRlcmF0aW9uIHNob3VsZCBmb2xsb3cgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQsIHdoaWNoIGhhcHBlbnMgdG8gbWF0Y2hcbiAgICAgIC8vIG51bWVyaWNhbCBpbmRleCBvcmRlciwgYnV0IHdlIGRvbid0IHJlbHkgb24gdGhhdC5cbiAgICAgIHZhciByZXN1bHRJbmRleDtcbiAgICAgIGZvciAocmVzdWx0SW5kZXggaW4gbWFya3VwTGlzdEJ5Tm9kZU5hbWUpIHtcbiAgICAgICAgaWYgKG1hcmt1cExpc3RCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSkge1xuICAgICAgICAgIHZhciBtYXJrdXAgPSBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAvLyBQdXNoIHRoZSByZXF1ZXN0ZWQgbWFya3VwIHdpdGggYW4gYWRkaXRpb25hbCBSRVNVTFRfSU5ERVhfQVRUUlxuICAgICAgICAgIC8vIGF0dHJpYnV0ZS4gIElmIHRoZSBtYXJrdXAgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIDwgY2hhcmFjdGVyLCBpdFxuICAgICAgICAgIC8vIHdpbGwgYmUgZGlzY2FyZGVkIGJlbG93ICh3aXRoIGFuIGFwcHJvcHJpYXRlIGNvbnNvbGUuZXJyb3IpLlxuICAgICAgICAgIG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XSA9IG1hcmt1cC5yZXBsYWNlKE9QRU5fVEFHX05BTUVfRVhQLFxuICAgICAgICAgIC8vIFRoaXMgaW5kZXggd2lsbCBiZSBwYXJzZWQgYmFjayBvdXQgYmVsb3cuXG4gICAgICAgICAgJyQxICcgKyBSRVNVTFRfSU5ERVhfQVRUUiArICc9XCInICsgcmVzdWx0SW5kZXggKyAnXCIgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGVhY2ggZ3JvdXAgb2YgbWFya3VwIHdpdGggc2ltaWxhciB3cmFwcGluZyBgbm9kZU5hbWVgLlxuICAgICAgdmFyIHJlbmRlck5vZGVzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cExpc3RCeU5vZGVOYW1lLmpvaW4oJycpLCBlbXB0eUZ1bmN0aW9uIC8vIERvIG5vdGhpbmcgc3BlY2lhbCB3aXRoIDxzY3JpcHQ+IHRhZ3MuXG4gICAgICApO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbmRlck5vZGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciByZW5kZXJOb2RlID0gcmVuZGVyTm9kZXNbal07XG4gICAgICAgIGlmIChyZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZSAmJiByZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUikpIHtcblxuICAgICAgICAgIHJlc3VsdEluZGV4ID0gK3JlbmRlck5vZGUuZ2V0QXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcbiAgICAgICAgICByZW5kZXJOb2RlLnJlbW92ZUF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG5cbiAgICAgICAgICAhIXJlc3VsdExpc3QuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogQXNzaWduaW5nIHRvIGFuIGFscmVhZHktb2NjdXBpZWQgcmVzdWx0IGluZGV4LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgICAgIHJlc3VsdExpc3RbcmVzdWx0SW5kZXhdID0gcmVuZGVyTm9kZTtcblxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHJlc3VsdExpc3QubGVuZ3RoIGFuZCBtYXJrdXBMaXN0Lmxlbmd0aCB3aGVuXG4gICAgICAgICAgLy8gd2UncmUgZG9uZS5cbiAgICAgICAgICByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhbmdlcjogRGlzY2FyZGluZyB1bmV4cGVjdGVkIG5vZGU6JywgcmVuZGVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHRob3VnaCByZXN1bHRMaXN0IHdhcyBwb3B1bGF0ZWQgb3V0IG9mIG9yZGVyLCBpdCBzaG91bGQgbm93IGJlIGEgZGVuc2VcbiAgICAvLyBhcnJheS5cbiAgICAhKHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPT09IHJlc3VsdExpc3QubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IERpZCBub3QgYXNzaWduIHRvIGV2ZXJ5IGluZGV4IG9mIHJlc3VsdExpc3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgIShyZXN1bHRMaXN0Lmxlbmd0aCA9PT0gbWFya3VwTGlzdC5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogRXhwZWN0ZWQgbWFya3VwIHRvIHJlbmRlciAlcyBub2RlcywgYnV0IHJlbmRlcmVkICVzLicsIG1hcmt1cExpc3QubGVuZ3RoLCByZXN1bHRMaXN0Lmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIHJlc3VsdExpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgJyArICd3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSAnICsgJ2dsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlICcgKyAnUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIShvbGRDaGlsZC5ub2RlTmFtZSAhPT0gJ0hUTUwnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVwbGFjZSBtYXJrdXAgb2YgdGhlICcgKyAnPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSAnICsgJ2FuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlICcgKyAnc2VydmVyIHJlbmRlcmluZy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZENoaWxkLCBtYXJrdXApO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IFtrZXlPZih7IFJlc3BvbmRlckV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNpbXBsZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFRhcEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEVudGVyTGVhdmVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBDaGFuZ2VFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTZWxlY3RFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBudWxsIH0pXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGlzYWJsZWRJbnB1dFV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGlzYWJsZWFibGVNb3VzZUxpc3RlbmVyTmFtZXMgPSB7XG4gIG9uQ2xpY2s6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2s6IHRydWUsXG4gIG9uTW91c2VEb3duOiB0cnVlLFxuICBvbk1vdXNlTW92ZTogdHJ1ZSxcbiAgb25Nb3VzZVVwOiB0cnVlLFxuXG4gIG9uQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VVcENhcHR1cmU6IHRydWVcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIG5hdGl2ZSBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG5cbiAgICAvLyBDb3B5IHRoZSBwcm9wcywgZXhjZXB0IHRoZSBtb3VzZSBsaXN0ZW5lcnNcbiAgICB2YXIgbmF0aXZlUHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghZGlzYWJsZWFibGVNb3VzZUxpc3RlbmVyTmFtZXNba2V5XSAmJiBwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIG5hdGl2ZVByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXNhYmxlZElucHV0VXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEVudGVyTGVhdmVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUVudGVyOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlTGVhdmU6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJiB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuICAgICAgZnJvbSA9IG51bGw7XG4gICAgICB0byA9IHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3IoeyBidWJibGVkOiBudWxsLCBjYXB0dXJlZDogbnVsbCB9KTtcblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IGtleU1pcnJvcih7XG4gIHRvcEFib3J0OiBudWxsLFxuICB0b3BBbmltYXRpb25FbmQ6IG51bGwsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogbnVsbCxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcEJsdXI6IG51bGwsXG4gIHRvcENhblBsYXk6IG51bGwsXG4gIHRvcENhblBsYXlUaHJvdWdoOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BFbXB0aWVkOiBudWxsLFxuICB0b3BFbmNyeXB0ZWQ6IG51bGwsXG4gIHRvcEVuZGVkOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BJbnZhbGlkOiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcExvYWRlZERhdGE6IG51bGwsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBudWxsLFxuICB0b3BMb2FkU3RhcnQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUGF1c2U6IG51bGwsXG4gIHRvcFBsYXk6IG51bGwsXG4gIHRvcFBsYXlpbmc6IG51bGwsXG4gIHRvcFByb2dyZXNzOiBudWxsLFxuICB0b3BSYXRlQ2hhbmdlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWVrZWQ6IG51bGwsXG4gIHRvcFNlZWtpbmc6IG51bGwsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wU3RhbGxlZDogbnVsbCxcbiAgdG9wU3VibWl0OiBudWxsLFxuICB0b3BTdXNwZW5kOiBudWxsLFxuICB0b3BUZXh0SW5wdXQ6IG51bGwsXG4gIHRvcFRpbWVVcGRhdGU6IG51bGwsXG4gIHRvcFRvdWNoQ2FuY2VsOiBudWxsLFxuICB0b3BUb3VjaEVuZDogbnVsbCxcbiAgdG9wVG91Y2hNb3ZlOiBudWxsLFxuICB0b3BUb3VjaFN0YXJ0OiBudWxsLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBudWxsLFxuICB0b3BWb2x1bWVDaGFuZ2U6IG51bGwsXG4gIHRvcFdhaXRpbmc6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG5cbiAgfSxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaW5zdC5fcm9vdE5vZGVJRF0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2luc3QuX3Jvb3ROb2RlSURdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbmV2ZXIgYmUgbnVsbCAtLSB3aGVuIGlzIGl0P1xuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2luc3QuX3Jvb3ROb2RlSURdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2luc3QuX3Jvb3ROb2RlSURdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2luc3QuX3Jvb3ROb2RlSURdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nICcgKyAnYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblJlZ2lzdHJ5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghRXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYEV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IEV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiAnICsgJ3RoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIVBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgICcgKyAnbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHtcblxuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICAgKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gICAqIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAgICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24gKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgICEhRXZlbnRQbHVnaW5PcmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gJyArICdvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBFdmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24gKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IFBsdWdpbk1vZHVsZSkge1xuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zICcgKyAndXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVdIHx8IG51bGw7XG4gICAgfVxuICAgIGZvciAodmFyIHBoYXNlIGluIGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAoIWRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW5Nb2R1bGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRFdmVudFBsdWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAobmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnMubGVuZ3RoID0gMDtcblxuICAgIHZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcykge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG4gICAgICBmb3IgKHZhciBsb3dlckNhc2VkTmFtZSBpbiBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICAgIGlmIChwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgICAgIGRlbGV0ZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luUmVnaXN0cnk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBDb21wb25lbnRUcmVlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGluc3RhbmNlc1xuICogICBhbmQgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIENvbXBvbmVudFRyZWU7XG52YXIgVHJlZVRyYXZlcnNhbDtcbnZhciBpbmplY3Rpb24gPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIENvbXBvbmVudFRyZWUgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIGluamVjdFRyZWVUcmF2ZXJzYWw6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIFRyZWVUcmF2ZXJzYWwgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuaXNBbmNlc3RvciAmJiBJbmplY3RlZC5nZXRMb3dlc3RDb21tb25BbmNlc3RvciwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdFRyZWVUcmF2ZXJzYWwoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBpc0FuY2VzdG9yIG9yIGdldExvd2VzdENvbW1vbkFuY2VzdG9yLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmUgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTtcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0O1xufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCh0eXBlLCBsaXN0ZW5lciwgZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2UgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0gRXZlbnRDb25zdGFudHMuUHJvcGFnYXRpb25QaGFzZXM7XG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gRXZlbnRQbHVnaW5VdGlscy5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbl9hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gdGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gdGhpcy5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEhUTUxET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xuXG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NJREVfRUZGRUNUUyA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKG5ldyBSZWdFeHAoJ14oZGF0YXxhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykpLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogMCxcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGFjY2Vzc0tleTogMCxcbiAgICBhY3Rpb246IDAsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogMCxcbiAgICBhbHQ6IDAsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogMCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IDAsXG4gICAgY2VsbFNwYWNpbmc6IDAsXG4gICAgY2hhclNldDogMCxcbiAgICBjaGFsbGVuZ2U6IDAsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjaXRlOiAwLFxuICAgIGNsYXNzSUQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IDAsXG4gICAgY29udGVudDogMCxcbiAgICBjb250ZW50RWRpdGFibGU6IDAsXG4gICAgY29udGV4dE1lbnU6IDAsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogMCxcbiAgICBjcm9zc09yaWdpbjogMCxcbiAgICBkYXRhOiAwLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IDAsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiAwLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IDAsXG4gICAgZW5jVHlwZTogMCxcbiAgICBmb3JtOiAwLFxuICAgIGZvcm1BY3Rpb246IDAsXG4gICAgZm9ybUVuY1R5cGU6IDAsXG4gICAgZm9ybU1ldGhvZDogMCxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogMCxcbiAgICBmcmFtZUJvcmRlcjogMCxcbiAgICBoZWFkZXJzOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IDAsXG4gICAgaHJlZjogMCxcbiAgICBocmVmTGFuZzogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICBpY29uOiAwLFxuICAgIGlkOiAwLFxuICAgIGlucHV0TW9kZTogMCxcbiAgICBpbnRlZ3JpdHk6IDAsXG4gICAgaXM6IDAsXG4gICAga2V5UGFyYW1zOiAwLFxuICAgIGtleVR5cGU6IDAsXG4gICAga2luZDogMCxcbiAgICBsYWJlbDogMCxcbiAgICBsYW5nOiAwLFxuICAgIGxpc3Q6IDAsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiAwLFxuICAgIG1hbmlmZXN0OiAwLFxuICAgIG1hcmdpbkhlaWdodDogMCxcbiAgICBtYXJnaW5XaWR0aDogMCxcbiAgICBtYXg6IDAsXG4gICAgbWF4TGVuZ3RoOiAwLFxuICAgIG1lZGlhOiAwLFxuICAgIG1lZGlhR3JvdXA6IDAsXG4gICAgbWV0aG9kOiAwLFxuICAgIG1pbjogMCxcbiAgICBtaW5MZW5ndGg6IDAsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IDAsXG4gICAgbm9uY2U6IDAsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogMCxcbiAgICBwYXR0ZXJuOiAwLFxuICAgIHBsYWNlaG9sZGVyOiAwLFxuICAgIHBvc3RlcjogMCxcbiAgICBwcmVsb2FkOiAwLFxuICAgIHByb2ZpbGU6IDAsXG4gICAgcmFkaW9Hcm91cDogMCxcbiAgICByZWFkT25seTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVsOiAwLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogMCxcbiAgICByb3dzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzYW5kYm94OiAwLFxuICAgIHNjb3BlOiAwLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2Nyb2xsaW5nOiAwLFxuICAgIHNlYW1sZXNzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzaGFwZTogMCxcbiAgICBzaXplOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzaXplczogMCxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiAwLFxuICAgIHNyYzogMCxcbiAgICBzcmNEb2M6IDAsXG4gICAgc3JjTGFuZzogMCxcbiAgICBzcmNTZXQ6IDAsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IDAsXG4gICAgc3R5bGU6IDAsXG4gICAgc3VtbWFyeTogMCxcbiAgICB0YWJJbmRleDogMCxcbiAgICB0YXJnZXQ6IDAsXG4gICAgdGl0bGU6IDAsXG4gICAgLy8gU2V0dGluZyAudHlwZSB0aHJvd3Mgb24gbm9uLTxpbnB1dD4gdGFnc1xuICAgIHR5cGU6IDAsXG4gICAgdXNlTWFwOiAwLFxuICAgIHZhbHVlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19TSURFX0VGRkVDVFMsXG4gICAgd2lkdGg6IDAsXG4gICAgd21vZGU6IDAsXG4gICAgd3JhcDogMCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiAwLFxuICAgIGRhdGF0eXBlOiAwLFxuICAgIGlubGlzdDogMCxcbiAgICBwcmVmaXg6IDAsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IDAsXG4gICAgcmVzb3VyY2U6IDAsXG4gICAgJ3R5cGVvZic6IDAsXG4gICAgdm9jYWI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXG4gICAgLy8ga2V5Ym9hcmQgaGludHMuXG4gICAgYXV0b0NhcGl0YWxpemU6IDAsXG4gICAgYXV0b0NvcnJlY3Q6IDAsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IDAsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiAwLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiAwLFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IDAsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiAwLFxuICAgIGl0ZW1SZWY6IDAsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiAwXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBLZXlFc2NhcGVVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7Kn0ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVW5lc2NhcGUgYW5kIHVud3JhcCBrZXkgZm9yIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIHVuZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdW5lc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoa2V5KSB7XG4gIHZhciB1bmVzY2FwZVJlZ2V4ID0gLyg9MHw9MikvZztcbiAgdmFyIHVuZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPTAnOiAnPScsXG4gICAgJz0yJzogJzonXG4gIH07XG4gIHZhciBrZXlTdWJzdHJpbmcgPSBrZXlbMF0gPT09ICcuJyAmJiBrZXlbMV0gPT09ICckJyA/IGtleS5zdWJzdHJpbmcoMikgOiBrZXkuc3Vic3RyaW5nKDEpO1xuXG4gIHJldHVybiAoJycgKyBrZXlTdWJzdHJpbmcpLnJlcGxhY2UodW5lc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xufVxuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSB7XG4gIGVzY2FwZTogZXNjYXBlLFxuICB1bmVzY2FwZTogdW5lc2NhcGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5RXNjYXBlVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcykge1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZExpbmsgPT0gbnVsbCB8fCBpbnB1dFByb3BzLnZhbHVlTGluayA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlICcgKyAnY2hlY2tlZExpbmssIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluayBhbmQgdmljZSB2ZXJzYS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50ICcgKyAndG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgY2hlY2tlZCBwcm9wZXJ0eSBvciBvbkNoYW5nZSBldmVudC4gJyArICdJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byAnICsgJ3VzZSBjaGVja2VkTGluaycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn1cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIG9uQ2hhbmdlOiBSZWFjdFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBmb3JtIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIHZhbHVlIHByb3Agb3IgbGluay5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IGNoZWNrZWQgc3RhdHVzIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSBjaGVja2VkIHByb3BcbiAgICogICAgICAgICAgICAgb3IgbGluay5cbiAgICovXG4gIGdldENoZWNrZWQ6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgY2hhbmdlIGV2ZW50IHRvIGhhbmRsZVxuICAgKi9cbiAgZXhlY3V0ZU9uQ2hhbmdlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcywgZXZlbnQpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsucmVxdWVzdENoYW5nZShldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsucmVxdWVzdENoYW5nZShldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5vbkNoYW5nZS5jYWxsKHVuZGVmaW5lZCwgZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRWYWx1ZVV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcyAob3B0aW9uYWwpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBfX3NwcmVhZCA9IF9hc3NpZ247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmVkLCAnUmVhY3QuX19zcHJlYWQgaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLiBVc2UgJyArICdPYmplY3QuYXNzaWduIGRpcmVjdGx5IG9yIGFub3RoZXIgaGVscGVyIGZ1bmN0aW9uIHdpdGggc2ltaWxhciAnICsgJ3NlbWFudGljcy4gWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byB5b3VyIGNvbXBpbGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXNwcmVhZC1kZXByZWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuICAgIHdhcm5lZCA9IHRydWU7XG4gICAgcmV0dXJuIF9hc3NpZ24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgdG9BcnJheTogUmVhY3RDaGlsZHJlbi50b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gRGVwcmVjYXRlZCBob29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcuXG4gIF9fc3ByZWFkOiBfX3NwcmVhZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50RW1pdHRlck1peGluJyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lID0gcmVxdWlyZSgnLi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZScpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcbiAqICAgIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBoYXNFdmVudFBhZ2VYWTtcbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IGZhbHNlO1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8vIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZSB0cmFwIGF0IGFcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXG52YXIgdG9wRXZlbnRNYXBwaW5nID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xuICpcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gX2Fzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xuXG4gIC8qKlxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcbiAgICovXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgKlxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gICAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gICAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICAgKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICpcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8IGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wQmx1cl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wRm9jdXNdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiAncGFnZVgnIGluIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgfVxuICAgIGlmICghaGFzRXZlbnRQYWdlWFkgJiYgIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIGtleVVuaXF1ZSA9IGNoaWxkSW5zdGFuY2VzW25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoa2V5VW5pcXVlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSkpIDogdm9pZCAwO1xuICB9XG4gIGlmIChjaGlsZCAhPSBudWxsICYmIGtleVVuaXF1ZSkge1xuICAgIGNoaWxkSW5zdGFuY2VzW25hbWVdID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFjdENoaWxkUmVjb25jaWxlciBwcm92aWRlcyBoZWxwZXJzIGZvciBpbml0aWFsaXppbmcgb3IgdXBkYXRpbmcgYSBzZXQgb2ZcbiAqIGNoaWxkcmVuLiBJdHMgb3V0cHV0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGl0IG9udG8gUmVhY3RNdWx0aUNoaWxkIHdoaWNoXG4gKiBkb2VzIGRpZmZlZCByZW9yZGVyaW5nIGFuZCBpbnNlcnRpb24uXG4gKi9cbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkTm9kZXMgTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBpbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgcmV0dXJuIGNoaWxkSW5zdGFuY2VzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiBhbmQgcmV0dXJucyBhIG5ldyBzZXQgb2YgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDaGlsZHJlbiBGbGF0IGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIG5ldyBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIHZhciBwcmV2Q2hpbGQ7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0TmF0aXZlTm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50KTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldE5hdGl2ZU5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCwgc2FmZWx5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkUmVjb25jaWxlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQ7XG4gIHZhciBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXg7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgTUlYSU5TX0tFWSA9IGtleU9mKHsgbWl4aW5zOiBudWxsIH0pO1xuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gKi9cbnZhciBTcGVjUG9saWN5ID0ga2V5TWlycm9yKHtcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgb25seSBvbmNlIGJ5IHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIG9yIG1peGluLlxuICAgKi9cbiAgREVGSU5FX09OQ0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIGJ5IGJvdGggdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gYW5kIG1peGlucy5cbiAgICogU3Vic2VxdWVudCBkZWZpbml0aW9ucyB3aWxsIGJlIGNoYWluZWQuIFRoZXNlIG1ldGhvZHMgbXVzdCByZXR1cm4gdm9pZC5cbiAgICovXG4gIERFRklORV9NQU5ZOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgb3ZlcnJpZGluZyB0aGUgYmFzZSBjbGFzcy5cbiAgICovXG4gIE9WRVJSSURFX0JBU0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBzaW1pbGFyIHRvIERFRklORV9NQU5ZLCBleGNlcHQgd2UgYXNzdW1lIHRoZXkgcmV0dXJuXG4gICAqIG9iamVjdHMuIFdlIHRyeSB0byBtZXJnZSB0aGUga2V5cyBvZiB0aGUgcmV0dXJuIHZhbHVlcyBvZiBhbGwgdGhlIG1peGVkIGluXG4gICAqIGZ1bmN0aW9ucy4gSWYgdGhlcmUgaXMgYSBrZXkgY29uZmxpY3Qgd2UgdGhyb3cuXG4gICAqL1xuICBERUZJTkVfTUFOWV9NRVJHRUQ6IG51bGxcbn0pO1xuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgbmF0aXZlIGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQG5vc2lkZWVmZmVjdHNcbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuLy8gbm9vcFxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSAnICsgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgKyAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArICd0byBhIG1peGluLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICsgJ3VzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhICcgKyAncmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIGF1dG9CaW5kUGFpcnMgPSBwcm90by5fX3JlYWN0QXV0b0JpbmRQYWlycztcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBhdXRvQmluZFBhaXJzLnB1c2gobmFtZSwgcHJvcGVydHkpO1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICsgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAhIWlzUmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkICcgKyAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgKyAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICsgJ2NvbnN0cnVjdG9yLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgISFpc0luaGVyaXRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgKyAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgJyArICdkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgKyAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgJyArICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgKyAnd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xuICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gKi9cbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5fYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xuICovXG52YXIgUmVhY3RDbGFzcyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kUGFpcnMubGVuZ3RoKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9O1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENsYXNzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhICcgKyAnZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRTdGF0ZSgpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XG4gIH1cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGFsbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSByZWNvbmNpbGVyIHRoYXQgcmVxdWlyZXMga25vd2xlZGdlIG9mXG4gKiB0aGUgYnJvd3NlciBjb250ZXh0LiBUT0RPOiBUaGVzZSBjYWxsZXJzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIGF2b2lkIHRoZVxuICogbmVlZCBmb3IgdGhpcyBpbmplY3Rpb24uXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHtcblxuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMsXG5cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgLyoqXG4gICAqIElmIGEgcGFydGljdWxhciBlbnZpcm9ubWVudCByZXF1aXJlcyB0aGF0IHNvbWUgcmVzb3VyY2VzIGJlIGNsZWFuZWQgdXAsXG4gICAqIHNwZWNpZnkgdGhpcyBpbiB0aGUgaW5qZWN0ZWQgTWl4aW4uIEluIHRoZSBET00sIHdlIHdvdWxkIGxpa2VseSB3YW50IHRvXG4gICAqIHB1cmdlIGFueSBjYWNoZWQgbm9kZSBJRCBsb29rdXBzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBmdW5jdGlvbiAocm9vdE5vZGVJRCkge31cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgaW5qZWN0ZWQgPSBmYWxzZTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSB7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY2xlYW51cCBob29rLiAoc2VydmVyIHZzLlxuICAgKiBicm93c2VyIGV0YykuIEV4YW1wbGU6IEEgYnJvd3NlciBzeXN0ZW0gY2FjaGVzIERPTSBub2RlcyBiYXNlZCBvbiBjb21wb25lbnRcbiAgICogSUQgYW5kIG11c3QgcmVtb3ZlIHRoYXQgY2FjaGUgZW50cnkgd2hlbiB0aGlzIGluc3RhbmNlIGlzIHVubW91bnRlZC5cbiAgICovXG4gIHVubW91bnRJREZyb21FbnZpcm9ubWVudDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCA9IGVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFRyZWVEZXZ0b29sXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciB0cmVlID0ge307XG52YXIgcm9vdElEcyA9IFtdO1xuXG5mdW5jdGlvbiB1cGRhdGVUcmVlKGlkLCB1cGRhdGUpIHtcbiAgaWYgKCF0cmVlW2lkXSkge1xuICAgIHRyZWVbaWRdID0ge1xuICAgICAgcGFyZW50SUQ6IG51bGwsXG4gICAgICBvd25lcklEOiBudWxsLFxuICAgICAgdGV4dDogbnVsbCxcbiAgICAgIGNoaWxkSURzOiBbXSxcbiAgICAgIGRpc3BsYXlOYW1lOiAnVW5rbm93bicsXG4gICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgdXBkYXRlQ291bnQ6IDBcbiAgICB9O1xuICB9XG4gIHVwZGF0ZSh0cmVlW2lkXSk7XG59XG5cbmZ1bmN0aW9uIHB1cmdlRGVlcChpZCkge1xuICB2YXIgaXRlbSA9IHRyZWVbaWRdO1xuICBpZiAoaXRlbSkge1xuICAgIHZhciBjaGlsZElEcyA9IGl0ZW0uY2hpbGRJRHM7XG5cbiAgICBkZWxldGUgdHJlZVtpZF07XG4gICAgY2hpbGRJRHMuZm9yRWFjaChwdXJnZURlZXApO1xuICB9XG59XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVEZXZ0b29sID0ge1xuICBvblNldERpc3BsYXlOYW1lOiBmdW5jdGlvbiAoaWQsIGRpc3BsYXlOYW1lKSB7XG4gICAgdXBkYXRlVHJlZShpZCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgfSk7XG4gIH0sXG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChpZCwgbmV4dENoaWxkSURzKSB7XG4gICAgdXBkYXRlVHJlZShpZCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRJRHMgPSBpdGVtLmNoaWxkSURzO1xuICAgICAgaXRlbS5jaGlsZElEcyA9IG5leHRDaGlsZElEcztcblxuICAgICAgbmV4dENoaWxkSURzLmZvckVhY2goZnVuY3Rpb24gKG5leHRDaGlsZElEKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSB0cmVlW25leHRDaGlsZElEXTtcbiAgICAgICAgIW5leHRDaGlsZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBkZXZ0b29sIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgY2hpbGQgJyArICdiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICAhKG5leHRDaGlsZC5kaXNwbGF5TmFtZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldERpc3BsYXlOYW1lKCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkICcgKyAnYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgIShuZXh0Q2hpbGQuY2hpbGRJRHMgIT0gbnVsbCB8fCBuZXh0Q2hpbGQudGV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldENoaWxkcmVuKCkgb3Igb25TZXRUZXh0KCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkICcgKyAnYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgIW5leHRDaGlsZC5pc01vdW50ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25Nb3VudENvbXBvbmVudCgpIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCAnICsgJ2JlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByZXZDaGlsZElEcy5pbmRleE9mKG5leHRDaGlsZElEKSA9PT0gLTEpIHtcbiAgICAgICAgICBuZXh0Q2hpbGQucGFyZW50SUQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIG9uU2V0T3duZXI6IGZ1bmN0aW9uIChpZCwgb3duZXJJRCkge1xuICAgIHVwZGF0ZVRyZWUoaWQsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5vd25lcklEID0gb3duZXJJRDtcbiAgICB9KTtcbiAgfSxcbiAgb25TZXRUZXh0OiBmdW5jdGlvbiAoaWQsIHRleHQpIHtcbiAgICB1cGRhdGVUcmVlKGlkLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0udGV4dCA9IHRleHQ7XG4gICAgfSk7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHVwZGF0ZVRyZWUoaWQsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIH0pO1xuICB9LFxuICBvbk1vdW50Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEcy5wdXNoKGlkKTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHVwZGF0ZVRyZWUoaWQsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS51cGRhdGVDb3VudCsrO1xuICAgIH0pO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHVwZGF0ZVRyZWUoaWQsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICByb290SURzID0gcm9vdElEcy5maWx0ZXIoZnVuY3Rpb24gKHJvb3RJRCkge1xuICAgICAgcmV0dXJuIHJvb3RJRCAhPT0gaWQ7XG4gICAgfSk7XG4gIH0sXG4gIHB1cmdlVW5tb3VudGVkQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdENvbXBvbmVudFRyZWVEZXZ0b29sLl9wcmV2ZW50UHVyZ2luZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyh0cmVlKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gIXRyZWVbaWRdLmlzTW91bnRlZDtcbiAgICB9KS5mb3JFYWNoKHB1cmdlRGVlcCk7XG4gIH0sXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSB0cmVlW2lkXTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNNb3VudGVkIDogZmFsc2U7XG4gIH0sXG4gIGdldENoaWxkSURzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IHRyZWVbaWRdO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xuICB9LFxuICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSB0cmVlW2lkXTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZGlzcGxheU5hbWUgOiAnVW5rbm93bic7XG4gIH0sXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gdHJlZVtpZF07XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLm93bmVySUQgOiBudWxsO1xuICB9LFxuICBnZXRQYXJlbnRJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSB0cmVlW2lkXTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IHRyZWVbaWRdO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS50ZXh0IDogbnVsbDtcbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gdHJlZVtpZF07XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcbiAgfSxcbiAgZ2V0Um9vdElEczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByb290SURzO1xuICB9LFxuICBnZXRSZWdpc3RlcmVkSURzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRyZWUpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50VHJlZURldnRvb2w7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSB7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpIHt9XG5TdGF0ZWxlc3NDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENvbXBvbmVudCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICB2YXIgZWxlbWVudCA9IENvbXBvbmVudCh0aGlzLnByb3BzLCB0aGlzLmNvbnRleHQsIHRoaXMudXBkYXRlcik7XG4gIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuZnVuY3Rpb24gd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNvbXBvbmVudERpZE1vdW50V2l0aFRpbWVyKCkge1xuICB2YXIgcHVibGljSW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xuICB9XG4gIHB1YmxpY0luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ29tcG9uZW50RGlkVXBkYXRlV2l0aFRpbWVyKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCkge1xuICB2YXIgcHVibGljSW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgfVxuICBwdWJsaWNJbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KTtcbiAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tIFRoZSBMaWZlLUN5Y2xlIG9mIGEgQ29tcG9zaXRlIENvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAtIGNvbnN0cnVjdG9yOiBJbml0aWFsaXphdGlvbiBvZiBzdGF0ZS4gVGhlIGluc3RhbmNlIGlzIG5vdyByZXRhaW5lZC5cbiAqICAgLSBjb21wb25lbnRXaWxsTW91bnRcbiAqICAgLSByZW5kZXJcbiAqICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnNdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlcl1cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudERpZE1vdW50XVxuICogICAgIC0gY29tcG9uZW50RGlkTW91bnRcbiAqXG4gKiAgICAgICBVcGRhdGUgUGhhc2VzOlxuICogICAgICAgLSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChvbmx5IGNhbGxlZCBpZiBwYXJlbnQgdXBkYXRlZClcbiAqICAgICAgIC0gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gKiAgICAgICAgIC0gY29tcG9uZW50V2lsbFVwZGF0ZVxuICogICAgICAgICAgIC0gcmVuZGVyXG4gKiAgICAgICAgICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnMgb3IgcmVjZWl2ZSBwcm9wcyBwaGFzZXNdXG4gKiAgICAgICAgIC0gY29tcG9uZW50RGlkVXBkYXRlXG4gKlxuICogICAgIC0gY29tcG9uZW50V2lsbFVubW91bnRcbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxVbm1vdW50XVxuICogICAtIFtjaGlsZHJlbiBkZXN0cm95ZWRdXG4gKiAtIChkZXN0cm95ZWQpOiBUaGUgaW5zdGFuY2UgaXMgbm93IGJsYW5rLCByZWxlYXNlZCBieSBSZWFjdCBhbmQgcmVhZHkgZm9yIEdDLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBBbiBpbmNyZW1lbnRpbmcgSUQgYXNzaWduZWQgdG8gZWFjaCBjb21wb25lbnQgd2hlbiBpdCBpcyBtb3VudGVkLiBUaGlzIGlzXG4gKiB1c2VkIHRvIGVuZm9yY2UgdGhlIG9yZGVyIGluIHdoaWNoIGBSZWFjdFVwZGF0ZXNgIHVwZGF0ZXMgZGlydHkgY29tcG9uZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbmV4dE1vdW50SUQgPSAxO1xuXG4vKipcbiAqIEBsZW5kcyB7UmVhY3RDb21wb3NpdGVDb21wb25lbnQucHJvdG90eXBlfVxuICovXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiA9IHtcblxuICAvKipcbiAgICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIGNvbXBvc2l0ZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX25hdGl2ZVBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fbmF0aXZlQ29udGFpbmVySW5mbyA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIC8vIENvbXBvbmVudFdpbGxVbm1vdW50IHNoYWxsIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICB0aGlzLl9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5hdGl2ZVBhcmVudFxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5hdGl2ZUNvbnRhaW5lckluZm9cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIG5hdGl2ZVBhcmVudCwgbmF0aXZlQ29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX25hdGl2ZVBhcmVudCA9IG5hdGl2ZVBhcmVudDtcbiAgICB0aGlzLl9uYXRpdmVDb250YWluZXJJbmZvID0gbmF0aXZlQ29udGFpbmVySW5mbztcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyh0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChjb250ZXh0KTtcblxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGluc3QgPSB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQpO1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICAvLyBTdXBwb3J0IGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAgIGlmICghc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkgJiYgKGluc3QgPT0gbnVsbCB8fCBpbnN0LnJlbmRlciA9PSBudWxsKSkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdDtcbiAgICAgIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgcmVuZGVyZWRFbGVtZW50KTtcbiAgICAgICEoaW5zdCA9PT0gbnVsbCB8fCBpbnN0ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IFJlYWN0VXBkYXRlUXVldWU7XG5cbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3Q7XG5cbiAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSBiYWNrIHRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIFJlYWN0SW5zdGFuY2VNYXAuc2V0KGluc3QsIHRoaXMpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFNpbmNlIHBsYWluIEpTIGNsYXNzZXMgYXJlIGRlZmluZWQgd2l0aG91dCBhbnkgc3BlY2lhbCBpbml0aWFsaXphdGlvblxuICAgICAgLy8gbG9naWMsIHdlIGNhbiBub3QgY2F0Y2ggY29tbW9uIGVycm9ycyBlYXJseS4gVGhlcmVmb3JlLCB3ZSBoYXZlIHRvXG4gICAgICAvLyBjYXRjaCB0aGVtIGhlcmUsIGF0IGluaXRpYWxpemF0aW9uIHRpbWUsIGluc3RlYWQuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdC5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdC5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LnByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuY29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSAnICsgJ3N0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIG1hcmt1cDtcbiAgICBpZiAoaW5zdC51bnN0YWJsZV9oYW5kbGVFcnJvcikge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmcocmVuZGVyZWRFbGVtZW50LCBuYXRpdmVQYXJlbnQsIG5hdGl2ZUNvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgbmF0aXZlUGFyZW50LCBuYXRpdmVDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW52b2tlQ29tcG9uZW50RGlkTW91bnRXaXRoVGltZXIsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyOiBmdW5jdGlvbiAocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdGFuY2VPckVsZW1lbnQ7XG4gICAgaWYgKHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdGFuY2VPckVsZW1lbnQgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCBSZWFjdFVwZGF0ZVF1ZXVlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGNhbiBzdGlsbCBiZSBhbiBpbnN0YW5jZSBpbiBjYXNlIG9mIGZhY3RvcnkgY29tcG9uZW50c1xuICAgICAgLy8gYnV0IHdlJ2xsIGNvdW50IHRoaXMgYXMgdGltZSBzcGVudCByZW5kZXJpbmcgYXMgdGhlIG1vcmUgY29tbW9uIGNhc2UuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0YW5jZU9yRWxlbWVudCA9IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgUmVhY3RVcGRhdGVRdWV1ZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VPckVsZW1lbnQ7XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nOiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBuYXRpdmVQYXJlbnQsIG5hdGl2ZUNvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcmt1cDtcbiAgICB2YXIgY2hlY2twb2ludCA9IHRyYW5zYWN0aW9uLmNoZWNrcG9pbnQoKTtcbiAgICB0cnkge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgbmF0aXZlUGFyZW50LCBuYXRpdmVDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUm9sbCBiYWNrIHRvIGNoZWNrcG9pbnQsIGhhbmRsZSBlcnJvciAod2hpY2ggbWF5IGFkZCBpdGVtcyB0byB0aGUgdHJhbnNhY3Rpb24pLCBhbmQgdGFrZSBhIG5ldyBjaGVja3BvaW50XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnVuc3RhYmxlX2hhbmRsZUVycm9yKGUpO1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZSh0aGlzLl9pbnN0YW5jZS5wcm9wcywgdGhpcy5faW5zdGFuY2UuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KHRydWUpO1xuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG5cbiAgICAgIC8vIFRyeSBhZ2FpbiAtIHdlJ3ZlIGluZm9ybWVkIHRoZSBjb21wb25lbnQgYWJvdXQgdGhlIGVycm9yLCBzbyB0aGV5IGNhbiByZW5kZXIgYW4gZXJyb3IgbWVzc2FnZSB0aGlzIHRpbWUuXG4gICAgICAvLyBJZiB0aGlzIHRocm93cyBhZ2FpbiwgdGhlIGVycm9yIHdpbGwgYnViYmxlIHVwIChhbmQgY2FuIGJlIGNhdWdodCBieSBhIGhpZ2hlciBlcnJvciBib3VuZGFyeSkuXG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBuYXRpdmVQYXJlbnQsIG5hdGl2ZUNvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50OiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBuYXRpdmVQYXJlbnQsIG5hdGl2ZUNvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShyZW5kZXJlZEVsZW1lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQpO1xuXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgdHJhbnNhY3Rpb24sIG5hdGl2ZVBhcmVudCwgbmF0aXZlQ29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQuX2RlYnVnSUQgIT09IDAgPyBbdGhpcy5fcmVuZGVyZWRDb21wb25lbnQuX2RlYnVnSURdIDogW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgZ2V0TmF0aXZlTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIuZ2V0TmF0aXZlTm9kZSh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCAmJiAhaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIGluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gdHJ1ZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNhZmVseSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpICsgJy5jb21wb25lbnRXaWxsVW5tb3VudCgpJztcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQoaW5zdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICB9XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0ICYmIGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBwcm9wcyBieSBzZXR0aW5nIGRlZmF1bHQgdmFsdWVzIGZvciB1bnNwZWNpZmllZCBwcm9wcyBhbmRcbiAgICogYXNzZXJ0aW5nIHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZC4gRG9lcyBub3QgbXV0YXRlIGl0cyBhcmd1bWVudDsgcmV0dXJuc1xuICAgKiBhIG5ldyBwcm9wcyBvYmplY3Qgd2l0aCBkZWZhdWx0cyBtZXJnZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc1Byb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LnByb3BUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQucHJvcFR5cGVzLCBuZXdQcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1Byb3BzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wVHlwZXMgTWFwIG9mIHByb3AgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gICAgLy8gVE9ETzogU3RvcCB2YWxpZGF0aW5nIHByb3AgdHlwZXMgaGVyZSBhbmQgb25seSB1c2UgdGhlIGVsZW1lbnRcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHZhciBjb21wb25lbnROYW1lID0gdGhpcy5nZXROYW1lKCk7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgICEodHlwZW9mIHByb3BUeXBlc1twcm9wTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5ICcgKyAnZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAvLyBXZSBtYXkgd2FudCB0byBleHRlbmQgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBlcnJvcnMgaW5cbiAgICAgICAgICAvLyB0b3AtbGV2ZWwgcmVuZGVyIGNhbGxzLCBzbyBJJ20gYWJzdHJhY3RpbmcgaXQgYXdheSBpbnRvXG4gICAgICAgICAgLy8gYSBmdW5jdGlvbiB0byBtaW5pbWl6ZSByZWZhY3RvcmluZyBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKHRoaXMpO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uID09PSBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApIHtcbiAgICAgICAgICAgIC8vIFByZWZhY2UgZ2l2ZXMgdXMgc29tZXRoaW5nIHRvIGJsYWNrbGlzdCBpbiB3YXJuaW5nIG1vZHVsZVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBDb250ZXh0IFR5cGVzOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciB3aWxsUmVjZWl2ZSA9IGZhbHNlO1xuICAgIHZhciBuZXh0Q29udGV4dDtcbiAgICB2YXIgbmV4dFByb3BzO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGEgcHJvcHMgdXBkYXRlIHZlcnN1cyBhIHNpbXBsZSBzdGF0ZSB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgPT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICAvLyBTa2lwIGNoZWNraW5nIHByb3AgdHlwZXMgYWdhaW4gLS0gd2UgZG9uJ3QgcmVhZCBpbnN0LnByb3BzIHRvIGF2b2lkXG4gICAgICAvLyB3YXJuaW5nIGZvciBET00gY29tcG9uZW50IHByb3BzIGluIHRoaXMgdXBncmFkZVxuICAgICAgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyhuZXh0UGFyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgIC8vIF9wZW5kaW5nU3RhdGVRdWV1ZSB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueSBzdGF0ZSB1cGRhdGVzIGdldHNcbiAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG4gICAgaWYgKHdpbGxSZWNlaXZlICYmIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgJiYgaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGludm9rZUNvbXBvbmVudERpZFVwZGF0ZVdpdGhUaW1lci5iaW5kKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGROYXRpdmVOb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldE5hdGl2ZU5vZGUocHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShuZXh0UmVuZGVyZWRFbGVtZW50KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0UmVuZGVyZWRFbGVtZW50KTtcblxuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9uYXRpdmVQYXJlbnQsIHRoaXMuX25hdGl2ZUNvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50Ll9kZWJ1Z0lEICE9PSAwID8gW3RoaXMuX3JlbmRlcmVkQ29tcG9uZW50Ll9kZWJ1Z0lEXSA6IFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkTmF0aXZlTm9kZSwgbmV4dE1hcmt1cCwgcHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRkZW4gaW4gc2hhbGxvdyByZW5kZXJpbmcuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGROYXRpdmVOb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGROYXRpdmVOb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmIChyZW5kZXJlZENvbXBvbmVudCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZENvbXBvbmVudDtcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgICEoXG4gICAgLy8gVE9ETzogQW4gYGlzVmFsaWROb2RlYCBmdW5jdGlvbiB3b3VsZCBwcm9iYWJseSBiZSBtb3JlIGFwcHJvcHJpYXRlXG4gICAgcmVuZGVyZWRDb21wb25lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRDb21wb25lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExhemlseSBhbGxvY2F0ZXMgdGhlIHJlZnMgb2JqZWN0IGFuZCBzdG9yZXMgYGNvbXBvbmVudGAgYXMgYHJlZmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgUmVmZXJlbmNlIG5hbWUuXG4gICAqIEBwYXJhbSB7Y29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHN0b3JlIGFzIGByZWZgLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF0dGFjaFJlZjogZnVuY3Rpb24gKHJlZiwgY29tcG9uZW50KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgIShpbnN0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzICcgKyAnKFNlZSByZWYgXCIlc1wiIGluICVzIGNyZWF0ZWQgYnkgJXMpLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJywgcmVmLCBjb21wb25lbnROYW1lLCB0aGlzLmdldE5hbWUoKSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgIHJlZnNbcmVmXSA9IHB1YmxpY0NvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhIHJlZmVyZW5jZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0YWNoUmVmOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHJlZnMgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkucmVmcztcbiAgICBkZWxldGUgcmVmc1tyZWZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSBpdFxuICAgKiBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvciBudWxsLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLm5hbWUgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWNseSBhY2Nlc3NpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50IC0gaS5lLiB3aGF0XG4gICAqIGlzIGV4cG9zZWQgYnkgcmVmcyBhbmQgcmV0dXJuZWQgYnkgcmVuZGVyLiBDYW4gYmUgbnVsbCBmb3Igc3RhdGVsZXNzXG4gICAqIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSB0aGUgcHVibGljIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKGluc3QgaW5zdGFuY2VvZiBTdGF0ZWxlc3NDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfSxcblxuICAvLyBTdHViXG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBudWxsXG5cbn07XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGdldE5hdGl2ZUNvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldE5hdGl2ZUNvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vcmVuZGVyU3VidHJlZUludG9Db250YWluZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciBSZWFjdCA9IHtcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuICByZW5kZXI6IFJlYWN0TW91bnQucmVuZGVyLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG59O1xuXG4vLyBJbmplY3QgdGhlIHJ1bnRpbWUgaW50byBhIGRldnRvb2xzIGdsb2JhbCBob29rIHJlZ2FyZGxlc3Mgb2YgYnJvd3Nlci5cbi8vIEFsbG93cyBmb3IgZGVidWdnaW5nIHdoZW4gdGhlIGhvb2sgaXMgaW5qZWN0ZWQgb24gdGhlIHBhZ2UuXG4vKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xuICAgIENvbXBvbmVudFRyZWU6IHtcbiAgICAgIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICAvLyBpbnN0IGlzIGFuIGludGVybmFsIGluc3RhbmNlIChidXQgY291bGQgYmUgYSBjb21wb3NpdGUpXG4gICAgICAgIGlmIChpbnN0Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgICAgIGluc3QgPSBnZXROYXRpdmVDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBNb3VudDogUmVhY3RNb3VudCxcbiAgICBSZWNvbmNpbGVyOiBSZWFjdFJlY29uY2lsZXJcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRldnRvb2xzIGlzIG5vdCBpbnN0YWxsZWRcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IGhhdmUgdGhlIGlzc3VlIHdpdGggZGV2dG9vbHMgbG9hZGVkIG92ZXIgZmlsZTovL1xuICAgICAgICB2YXIgc2hvd0ZpbGVVcmxNZXNzYWdlID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArIChzaG93RmlsZVVybE1lc3NhZ2UgPyAnYW5kIHVzZSBhbiBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBhIGZpbGU6IFVSTCkgJyA6ICcnKSArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRlc3RGdW5jID0gZnVuY3Rpb24gdGVzdEZuKCkge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoKHRlc3RGdW5jLm5hbWUgfHwgdGVzdEZ1bmMudG9TdHJpbmcoKSkuaW5kZXhPZigndGVzdEZuJykgIT09IC0xLCAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhIG1pbmlmaWVkIGNvcHkgb2YgdGhlIGRldmVsb3BtZW50IGJ1aWxkICcgKyAnb2YgUmVhY3QuIFdoZW4gZGVwbG95aW5nIFJlYWN0IGFwcHMgdG8gcHJvZHVjdGlvbiwgbWFrZSBzdXJlIHRvIHVzZSAnICsgJ3RoZSBwcm9kdWN0aW9uIGJ1aWxkIHdoaWNoIHNraXBzIGRldmVsb3BtZW50IHdhcm5pbmdzIGFuZCBpcyBmYXN0ZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtbWluaWZpY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcbiAgICB2YXIgaWVDb21wYXRpYmlsaXR5TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgIC8vIHNoaW1zXG4gICAgQXJyYXkuaXNBcnJheSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIEFycmF5LnByb3RvdHlwZS5tYXAsIERhdGUubm93LCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgT2JqZWN0LmtleXMsIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsIFN0cmluZy5wcm90b3R5cGUudHJpbV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09uZSBvciBtb3JlIEVTNSBzaGltcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUJ1dHRvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxidXR0b24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NQnV0dG9uID0ge1xuICBnZXROYXRpdmVQcm9wczogRGlzYWJsZWRJbnB1dFV0aWxzLmdldE5hdGl2ZVByb3BzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQnV0dG9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHJlcXVpcmUoJy4vQXV0b0ZvY3VzVXRpbHMnKTtcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQnV0dG9uID0gcmVxdWlyZSgnLi9SZWFjdERPTUJ1dHRvbicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW5wdXQnKTtcbnZhciBSZWFjdERPTU9wdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01PcHRpb24nKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRhcmVhJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG52YXIgZGVsZXRlTGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcjtcbnZhciBnZXROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2U7XG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBTVFlMRSA9IGtleU9mKHsgc3R5bGU6IG51bGwgfSk7XG52YXIgSFRNTCA9IGtleU9mKHsgX19odG1sOiBudWxsIH0pO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbFxufTtcblxuLy8gTm9kZSB0eXBlIGZvciBkb2N1bWVudCBmcmFnbWVudHMgKE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkuXG52YXIgRE9DX0ZSQUdNRU5UX1RZUEUgPSAxMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBmcmllbmRseVN0cmluZ2lmeShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAoZnJpZW5kbHlTdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHZhciBrZXlFc2NhcGVkID0gL15bYS16JF9dW1xcdyRfXSokL2kudGVzdChrZXkpID8ga2V5IDogSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgICBwYWlycy5wdXNoKGtleUVzY2FwZWQgKyAnOiAnICsgZnJpZW5kbHlTdHJpbmdpZnkob2JqW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIHBhaXJzLmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnW2Z1bmN0aW9uIG9iamVjdF0nO1xuICB9XG4gIC8vIERpZmZlcnMgZnJvbSBKU09OLnN0cmluZ2lmeSBpbiB0aGF0IHVuZGVmaW5lZCBiZWNhdXNlIHVuZGVmaW5lZCBhbmQgdGhhdFxuICAvLyBpbmYgYW5kIG5hbiBkb24ndCBiZWNvbWUgbnVsbFxuICByZXR1cm4gU3RyaW5nKG9iaik7XG59XG5cbnZhciBzdHlsZU11dGF0aW9uV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUoc3R5bGUxLCBzdHlsZTIsIGNvbXBvbmVudCkge1xuICBpZiAoc3R5bGUxID09IG51bGwgfHwgc3R5bGUyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNoYWxsb3dFcXVhbChzdHlsZTEsIHN0eWxlMikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5fdGFnO1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVyKSB7XG4gICAgb3duZXJOYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvd25lck5hbWUgKyAnfCcgKyBjb21wb25lbnROYW1lO1xuXG4gIGlmIChzdHlsZU11dGF0aW9uV2FybmluZy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0eWxlTXV0YXRpb25XYXJuaW5nW2hhc2hdID0gdHJ1ZTtcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2Alc2Agd2FzIHBhc3NlZCBhIHN0eWxlIG9iamVjdCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gbXV0YXRlZC4gJyArICdNdXRhdGluZyBgc3R5bGVgIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIGNsb25pbmcgaXQgYmVmb3JlaGFuZC4gQ2hlY2sgJyArICd0aGUgYHJlbmRlcmAgJXMuIFByZXZpb3VzIHN0eWxlOiAlcy4gTXV0YXRlZCBzdHlsZTogJXMuJywgY29tcG9uZW50TmFtZSwgb3duZXIgPyAnb2YgYCcgKyBvd25lck5hbWUgKyAnYCcgOiAndXNpbmcgPCcgKyBjb21wb25lbnROYW1lICsgJz4nLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTEpLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTIpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHMoY29tcG9uZW50LCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBub3QgaGF2ZSBgY2hpbGRyZW5gIG9yICcgKyAndXNlIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuICcgKyAnUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuaW5uZXJIVE1MID09IG51bGwsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5vbkZvY3VzSW4gPT0gbnVsbCAmJiBwcm9wcy5vbkZvY3VzT3V0ID09IG51bGwsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpIDogdm9pZCAwO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgKyAnbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiAnICsgJ3VzaW5nIEpTWC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBjb250YWluZXJJbmZvID0gaW5zdC5fbmF0aXZlQ29udGFpbmVySW5mbztcbiAgdmFyIGlzRG9jdW1lbnRGcmFnbWVudCA9IGNvbnRhaW5lckluZm8uX25vZGUgJiYgY29udGFpbmVySW5mby5fbm9kZS5ub2RlVHlwZSA9PT0gRE9DX0ZSQUdNRU5UX1RZUEU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50RnJhZ21lbnQgPyBjb250YWluZXJJbmZvLl9ub2RlIDogY29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGluc3Q6IGluc3QsXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHB1dExpc3RlbmVyKCkge1xuICB2YXIgbGlzdGVuZXJUb1B1dCA9IHRoaXM7XG4gIEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaW5zdCwgbGlzdGVuZXJUb1B1dC5yZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lclRvUHV0Lmxpc3RlbmVyKTtcbn1cblxuZnVuY3Rpb24gb3B0aW9uUG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NT3B0aW9uLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbnZhciBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24gPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNvbnRlbnRUb1VzZSkge1xuICAgIHZhciBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICB2YXIgY29udGVudERlYnVnSUQgPSBkZWJ1Z0lEICsgJyN0ZXh0JztcbiAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IGNvbnRlbnREZWJ1Z0lEO1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldERpc3BsYXlOYW1lKGNvbnRlbnREZWJ1Z0lELCAnI3RleHQnKTtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRUZXh0KGNvbnRlbnREZWJ1Z0lELCAnJyArIGNvbnRlbnRUb1VzZSk7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIFtjb250ZW50RGVidWdJRF0pO1xuICB9O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudHNMb2NhbCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICAvLyBJZiBhIGNvbXBvbmVudCByZW5kZXJzIHRvIG51bGwgb3IgaWYgYW5vdGhlciBjb21wb25lbnQgZmF0YWxzIGFuZCBjYXVzZXNcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXG4gICFpbnN0Ll9yb290Tm9kZUlEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGUgPSBnZXROb2RlKGluc3QpO1xuICAhbm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmFwQnViYmxlZEV2ZW50KC4uLik6IFJlcXVpcmVzIG5vZGUgdG8gYmUgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcblxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycy5wdXNoKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXNbZXZlbnRdLCBtZWRpYUV2ZW50c1tldmVudF0sIG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFJlc2V0LCAncmVzZXQnLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQsICdzdWJtaXQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wSW52YWxpZCwgJ2ludmFsaWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlU2VsZWN0V3JhcHBlcigpIHtcbiAgUmVhY3RET01TZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIodGhpcyk7XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gICdtZW51aXRlbSc6IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XG59XG5cbnZhciBnbG9iYWxJZENvdW50ZXIgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX25hdGl2ZU5vZGUgPSBudWxsO1xuICB0aGlzLl9uYXRpdmVQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgdGhpcy5fZG9tSUQgPSBudWxsO1xuICB0aGlzLl9uYXRpdmVDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcbiAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fZmxhZ3MgPSAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IG51bGw7XG4gICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBudWxsO1xuICB9XG59XG5cblJlYWN0RE9NQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1JlYWN0RE9NQ29tcG9uZW50JztcblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/UmVhY3RET01Db21wb25lbnR9IHRoZSBjb250YWluaW5nIERPTSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBuYXRpdmUgY29udGFpbmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIG5hdGl2ZVBhcmVudCwgbmF0aXZlQ29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBnbG9iYWxJZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IG5hdGl2ZUNvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX25hdGl2ZVBhcmVudCA9IG5hdGl2ZVBhcmVudDtcbiAgICB0aGlzLl9uYXRpdmVDb250YWluZXJJbmZvID0gbmF0aXZlQ29udGFpbmVySW5mbztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgbmF0aXZlUGFyZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBuYXRpdmVQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgbmF0aXZlUGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBuYXRpdmVQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBuYXRpdmVQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcblxuICAgIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG4gICAgdmFyIG5hbWVzcGFjZVVSSTtcbiAgICB2YXIgcGFyZW50VGFnO1xuICAgIGlmIChuYXRpdmVQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgbmFtZXNwYWNlVVJJID0gbmF0aXZlUGFyZW50Ll9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBuYXRpdmVQYXJlbnQuX3RhZztcbiAgICB9IGVsc2UgaWYgKG5hdGl2ZUNvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gbmF0aXZlQ29udGFpbmVySW5mby5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gbmF0aXZlQ29udGFpbmVySW5mby5fdGFnO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09IG51bGwgfHwgbmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiBwYXJlbnRUYWcgPT09ICdmb3JlaWdub2JqZWN0Jykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5odG1sO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzdmcnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuc3ZnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90YWcgPT09ICdtYXRoJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLm1hdGhtbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKG5hdGl2ZVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBuYXRpdmVQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAobmF0aXZlQ29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBuYXRpdmVDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEluZm8sIHRoaXMuX3RhZywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gbmF0aXZlQ29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBlbDtcbiAgICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5fdGFnID09PSAnc2NyaXB0Jykge1xuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwnICsgdHlwZSArICc+PC8nICsgdHlwZSArICc+JztcbiAgICAgICAgICBlbCA9IGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSwgcHJvcHMuaXMgfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgZWwpO1xuICAgICAgdGhpcy5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2RlcztcbiAgICAgIGlmICghdGhpcy5fbmF0aXZlUGFyZW50KSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JSb290KGVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobnVsbCwgcHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG9wdGlvblBvc3RNb3VudCwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBwcm9wcy5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BWYWx1ZSA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya3VwID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyAhPSBudWxsICYmIGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgcHJvcHMpKSB7XG4gICAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAgIC8vIGJ5dGVzLlxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX25hdGl2ZVBhcmVudCkge1xuICAgICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gICAgfVxuICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fZG9tSUQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXG4gICAqL1xuICBfY3JlYXRlQ29udGVudE1hcmt1cDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciByZXQgPSAnJztcblxuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSkge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVIVE1MKGxhenlUcmVlLCBpbm5lckhUTUwuX19odG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlVGV4dChsYXp5VHJlZSwgY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91bnRJbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBtb3VudEltYWdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgbmV4dCBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIG5hdGl2ZSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCkge1xuICAgIHZhciBsYXN0UHJvcHMgPSBwcmV2RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIsIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgcHJvcGVydGllcyBieSBkZXRlY3RpbmcgZGlmZmVyZW5jZXMgaW4gcHJvcGVydHkgdmFsdWVzIGFuZFxuICAgKiB1cGRhdGluZyB0aGUgRE9NIGFzIG5lY2Vzc2FyeS4gVGhpcyBmdW5jdGlvbiBpcyBwcm9iYWJseSB0aGUgc2luZ2xlIG1vc3RcbiAgICogY3JpdGljYWwgcGF0aCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgd2hldGhlciBjaGVja2luZyBmb3IgY2hhbmdlZCB2YWx1ZXMgaW4gbWVtb3J5IGFjdHVhbGx5XG4gICAqICAgICAgIGltcHJvdmVzIHBlcmZvcm1hbmNlIChlc3BlY2lhbGx5IHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cykuXG4gICAqIFRPRE86IEJlbmNobWFyayB0aGUgZWZmZWN0cyBvZiBwdXR0aW5nIHRoaXMgYXQgdGhlIHRvcCBzaW5jZSA5OSUgb2YgcHJvcHNcbiAgICogICAgICAgZG8gbm90IGNoYW5nZSBmb3IgYSBnaXZlbiByZWNvbmNpbGlhdGlvbi5cbiAgICogVE9ETzogQmVuY2htYXJrIGFyZWFzIHRoYXQgY2FuIGJlIGltcHJvdmVkIHdpdGggY2FjaGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHk7XG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobGFzdFByb3BzW3Byb3BLZXldKSB7XG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXG4gICAgICAgICAgLy8gbGlzdGVuZXIgKGUuZy4sIG9uQ2xpY2s9e251bGx9KVxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgbmV4dFByb3AsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbmV4dFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZ2V0Tm9kZSh0aGlzKTtcbiAgICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKGdldE5vZGUodGhpcyksIHN0eWxlVXBkYXRlcywgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBuZXh0UHJvcHMuY2hpbGRyZW5dID8gbmV4dFByb3BzLmNoaWxkcmVuIDogbnVsbDtcblxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IHRoaXMuX2RlYnVnSUQgKyAnI3RleHQnO1xuICAgICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudERlYnVnSUQpIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29tcG9uZW50KHRoaXMuX2NvbnRlbnREZWJ1Z0lEKTtcbiAgICAgICAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0TmF0aXZlTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fd3JhcHBlclN0YXRlLmxpc3RlbmVycztcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgJyArICdpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCAnICsgJzxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhICcgKyAnc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgJyArICdlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oc2FmZWx5KTtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gICAgRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMpO1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9kb21JRCA9IG51bGw7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fY29udGVudERlYnVnSUQpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudCh0aGlzLl9jb250ZW50RGVidWdJRCk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcbiAgfVxuXG59O1xuXG5fYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0ge1xuICBoYXNDYWNoZWRDaGlsZE5vZGVzOiAxIDw8IDBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRGbGFnczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRUcmVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRGbGFncycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuLyoqXG4gKiBEcmlsbCBkb3duICh0aHJvdWdoIGNvbXBvc2l0ZXMgYW5kIGVtcHR5IGNvbXBvbmVudHMpIHVudGlsIHdlIGdldCBhIG5hdGl2ZSBvclxuICogbmF0aXZlIHRleHQgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgcHJldHR5IHBvbHltb3JwaGljIGJ1dCB1bmF2b2lkYWJsZSB3aXRoIHRoZSBjdXJyZW50IHN0cnVjdHVyZSB3ZSBoYXZlXG4gKiBmb3IgYF9yZW5kZXJlZENoaWxkcmVuYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVuZGVyZWROYXRpdmVPclRleHRGcm9tQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICB2YXIgcmVuZGVyZWQ7XG4gIHdoaWxlIChyZW5kZXJlZCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQgPSByZW5kZXJlZDtcbiAgfVxuICByZXR1cm4gY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfbmF0aXZlTm9kZWAgb24gdGhlIHJlbmRlcmVkIG5hdGl2ZS90ZXh0IGNvbXBvbmVudCB3aXRoIHRoZSBnaXZlblxuICogRE9NIG5vZGUuIFRoZSBwYXNzZWQgYGluc3RgIGNhbiBiZSBhIGNvbXBvc2l0ZS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVOb2RlKGluc3QsIG5vZGUpIHtcbiAgdmFyIG5hdGl2ZUluc3QgPSBnZXRSZW5kZXJlZE5hdGl2ZU9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIG5hdGl2ZUluc3QuX25hdGl2ZU5vZGUgPSBub2RlO1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gbmF0aXZlSW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX25hdGl2ZU5vZGU7XG4gIGlmIChub2RlKSB7XG4gICAgZGVsZXRlIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gICAgaW5zdC5fbmF0aXZlTm9kZSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSBgX25hdGl2ZU5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZE5hdGl2ZU9yVGV4dEZyb21Db21wb25lbnQoY2hpbGRJbnN0KS5fZG9tSUQ7XG4gICAgaWYgKGNoaWxkSUQgPT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgY3VycmVudGx5IHVubW91bnRpbmcgdGhpcyBjaGlsZCBpbiBSZWFjdE11bHRpQ2hpbGQ7IHNraXAgaXQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gV2UgYXNzdW1lIHRoZSBjaGlsZCBub2RlcyBhcmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNoaWxkIGluc3RhbmNlcy5cbiAgICBmb3IgKDsgY2hpbGROb2RlICE9PSBudWxsOyBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgJiYgY2hpbGROb2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpID09PSBTdHJpbmcoY2hpbGRJRCkgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA4ICYmIGNoaWxkTm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtdGV4dDogJyArIGNoaWxkSUQgKyAnICcgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA4ICYmIGNoaWxkTm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtZW1wdHk6ICcgKyBjaGlsZElEICsgJyAnKSB7XG4gICAgICAgIHByZWNhY2hlTm9kZShjaGlsZEluc3QsIGNoaWxkTm9kZSk7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIERPTSBjaGlsZHJlbiB3aXRob3V0IGZpbmRpbmcgYW4gSUQgbWF0Y2guXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIGVsZW1lbnQgd2l0aCBJRCAlcy4nLCBjaGlsZElEKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbiAgaW5zdC5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0O1xuICB2YXIgaW5zdDtcbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0Ll9uYXRpdmVOb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgIShpbnN0Ll9uYXRpdmVOb2RlICE9PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIGlmIChpbnN0Ll9uYXRpdmVOb2RlKSB7XG4gICAgcmV0dXJuIGluc3QuX25hdGl2ZU5vZGU7XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgRE9NIG5vZGUgd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghaW5zdC5fbmF0aXZlTm9kZSkge1xuICAgIHBhcmVudHMucHVzaChpbnN0KTtcbiAgICAhaW5zdC5fbmF0aXZlUGFyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0IERPTSB0cmVlIHJvb3Qgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbm9kZSByZWZlcmVuY2UuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGluc3QgPSBpbnN0Ll9uYXRpdmVQYXJlbnQ7XG4gIH1cblxuICAvLyBOb3cgcGFyZW50cyBjb250YWlucyBlYWNoIGFuY2VzdG9yIHRoYXQgZG9lcyAqbm90KiBoYXZlIGEgY2FjaGVkIG5hdGl2ZVxuICAvLyBub2RlLCBhbmQgYGluc3RgIGlzIHRoZSBkZWVwZXN0IGFuY2VzdG9yIHRoYXQgZG9lcy5cbiAgZm9yICg7IHBhcmVudHMubGVuZ3RoOyBpbnN0ID0gcGFyZW50cy5wb3AoKSkge1xuICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBpbnN0Ll9uYXRpdmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0Ll9uYXRpdmVOb2RlO1xufVxuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0ge1xuICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG4gIHByZWNhY2hlQ2hpbGROb2RlczogcHJlY2FjaGVDaGlsZE5vZGVzLFxuICBwcmVjYWNoZU5vZGU6IHByZWNhY2hlTm9kZSxcbiAgdW5jYWNoZU5vZGU6IHVuY2FjaGVOb2RlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db250YWluZXJJbmZvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xuXG5mdW5jdGlvbiBSZWFjdERPTUNvbnRhaW5lckluZm8odG9wTGV2ZWxXcmFwcGVyLCBub2RlKSB7XG4gIHZhciBpbmZvID0ge1xuICAgIF90b3BMZXZlbFdyYXBwZXI6IHRvcExldmVsV3JhcHBlcixcbiAgICBfaWRDb3VudGVyOiAxLFxuICAgIF9vd25lckRvY3VtZW50OiBub2RlID8gbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSA/IG5vZGUgOiBub2RlLm93bmVyRG9jdW1lbnQgOiBudWxsLFxuICAgIF9ub2RlOiBub2RlLFxuICAgIF90YWc6IG5vZGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsLFxuICAgIF9uYW1lc3BhY2VVUkk6IG5vZGUgPyBub2RlLm5hbWVzcGFjZVVSSSA6IG51bGxcbiAgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpbmZvLl9hbmNlc3RvckluZm8gPSBub2RlID8gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgaW5mby5fdGFnLCBudWxsKSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db250YWluZXJJbmZvOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTURlYnVnVG9vbFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5RGV2dG9vbCA9IHJlcXVpcmUoJy4vUmVhY3RET01Vbmtub3duUHJvcGVydHlEZXZ0b29sJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZXZlbnRIYW5kbGVycyA9IFtdO1xudmFyIGhhbmRsZXJEb2VzVGhyb3dGb3JFdmVudCA9IHt9O1xuXG5mdW5jdGlvbiBlbWl0RXZlbnQoaGFuZGxlckZ1bmN0aW9uTmFtZSwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXJbaGFuZGxlckZ1bmN0aW9uTmFtZV0pIHtcbiAgICAgICAgICBoYW5kbGVyW2hhbmRsZXJGdW5jdGlvbk5hbWVdKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFoYW5kbGVyRG9lc1Rocm93Rm9yRXZlbnRbaGFuZGxlckZ1bmN0aW9uTmFtZV0sICdleGNlcHRpb24gdGhyb3duIGJ5IGRldnRvb2wgd2hpbGUgaGFuZGxpbmcgJXM6ICVzJywgaGFuZGxlckZ1bmN0aW9uTmFtZSwgZS5tZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgaGFuZGxlckRvZXNUaHJvd0ZvckV2ZW50W2hhbmRsZXJGdW5jdGlvbk5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01EZWJ1Z1Rvb2wgPSB7XG4gIGFkZERldnRvb2w6IGZ1bmN0aW9uIChkZXZ0b29sKSB7XG4gICAgZXZlbnRIYW5kbGVycy5wdXNoKGRldnRvb2wpO1xuICB9LFxuICByZW1vdmVEZXZ0b29sOiBmdW5jdGlvbiAoZGV2dG9vbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50SGFuZGxlcnNbaV0gPT09IGRldnRvb2wpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG9uQ3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGVtaXRFdmVudCgnb25DcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eScsIG5hbWUsIHZhbHVlKTtcbiAgfSxcbiAgb25TZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBlbWl0RXZlbnQoJ29uU2V0VmFsdWVGb3JQcm9wZXJ0eScsIG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgfSxcbiAgb25EZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIGVtaXRFdmVudCgnb25EZWxldGVWYWx1ZUZvclByb3BlcnR5Jywgbm9kZSwgbmFtZSk7XG4gIH1cbn07XG5cblJlYWN0RE9NRGVidWdUb29sLmFkZERldnRvb2woUmVhY3RET01Vbmtub3duUHJvcGVydHlEZXZ0b29sKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTURlYnVnVG9vbDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01FbXB0eUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAvLyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCB1c2VzIHRoaXM6XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX25hdGl2ZU5vZGUgPSBudWxsO1xuICB0aGlzLl9uYXRpdmVQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9uYXRpdmVDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fZG9tSUQgPSBudWxsO1xufTtcbl9hc3NpZ24oUmVhY3RET01FbXB0eUNvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgbmF0aXZlUGFyZW50LCBuYXRpdmVDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbUlEID0gbmF0aXZlQ29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9uYXRpdmVQYXJlbnQgPSBuYXRpdmVQYXJlbnQ7XG4gICAgdGhpcy5fbmF0aXZlQ29udGFpbmVySW5mbyA9IG5hdGl2ZUNvbnRhaW5lckluZm87XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gJyByZWFjdC1lbXB0eTogJyArIHRoaXMuX2RvbUlEICsgJyAnO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5hdGl2ZUNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChub2RlVmFsdWUpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBub2RlKTtcbiAgICAgIHJldHVybiBET01MYXp5VHJlZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaW5zZXJ0IGEgY29tbWVudCBub2RlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvblxuICAgICAgICAvLyB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuXG4gICAgICAgIC8vIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPCEtLScgKyBub2RlVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBnZXROYXRpdmVOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICB9LFxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUVtcHR5Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZhY3Rvcmllc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcblxudmFyIG1hcE9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL21hcE9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgKGUuZy4gYGRpdmApLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NRmFjdG9yeSh0YWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3RvcnkodGFnKTtcbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkodGFnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gbWFwT2JqZWN0KHtcbiAgYTogJ2EnLFxuICBhYmJyOiAnYWJicicsXG4gIGFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgYXJlYTogJ2FyZWEnLFxuICBhcnRpY2xlOiAnYXJ0aWNsZScsXG4gIGFzaWRlOiAnYXNpZGUnLFxuICBhdWRpbzogJ2F1ZGlvJyxcbiAgYjogJ2InLFxuICBiYXNlOiAnYmFzZScsXG4gIGJkaTogJ2JkaScsXG4gIGJkbzogJ2JkbycsXG4gIGJpZzogJ2JpZycsXG4gIGJsb2NrcXVvdGU6ICdibG9ja3F1b3RlJyxcbiAgYm9keTogJ2JvZHknLFxuICBicjogJ2JyJyxcbiAgYnV0dG9uOiAnYnV0dG9uJyxcbiAgY2FudmFzOiAnY2FudmFzJyxcbiAgY2FwdGlvbjogJ2NhcHRpb24nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNvZGU6ICdjb2RlJyxcbiAgY29sOiAnY29sJyxcbiAgY29sZ3JvdXA6ICdjb2xncm91cCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0YWxpc3Q6ICdkYXRhbGlzdCcsXG4gIGRkOiAnZGQnLFxuICBkZWw6ICdkZWwnLFxuICBkZXRhaWxzOiAnZGV0YWlscycsXG4gIGRmbjogJ2RmbicsXG4gIGRpYWxvZzogJ2RpYWxvZycsXG4gIGRpdjogJ2RpdicsXG4gIGRsOiAnZGwnLFxuICBkdDogJ2R0JyxcbiAgZW06ICdlbScsXG4gIGVtYmVkOiAnZW1iZWQnLFxuICBmaWVsZHNldDogJ2ZpZWxkc2V0JyxcbiAgZmlnY2FwdGlvbjogJ2ZpZ2NhcHRpb24nLFxuICBmaWd1cmU6ICdmaWd1cmUnLFxuICBmb290ZXI6ICdmb290ZXInLFxuICBmb3JtOiAnZm9ybScsXG4gIGgxOiAnaDEnLFxuICBoMjogJ2gyJyxcbiAgaDM6ICdoMycsXG4gIGg0OiAnaDQnLFxuICBoNTogJ2g1JyxcbiAgaDY6ICdoNicsXG4gIGhlYWQ6ICdoZWFkJyxcbiAgaGVhZGVyOiAnaGVhZGVyJyxcbiAgaGdyb3VwOiAnaGdyb3VwJyxcbiAgaHI6ICdocicsXG4gIGh0bWw6ICdodG1sJyxcbiAgaTogJ2knLFxuICBpZnJhbWU6ICdpZnJhbWUnLFxuICBpbWc6ICdpbWcnLFxuICBpbnB1dDogJ2lucHV0JyxcbiAgaW5zOiAnaW5zJyxcbiAga2JkOiAna2JkJyxcbiAga2V5Z2VuOiAna2V5Z2VuJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxlZ2VuZDogJ2xlZ2VuZCcsXG4gIGxpOiAnbGknLFxuICBsaW5rOiAnbGluaycsXG4gIG1haW46ICdtYWluJyxcbiAgbWFwOiAnbWFwJyxcbiAgbWFyazogJ21hcmsnLFxuICBtZW51OiAnbWVudScsXG4gIG1lbnVpdGVtOiAnbWVudWl0ZW0nLFxuICBtZXRhOiAnbWV0YScsXG4gIG1ldGVyOiAnbWV0ZXInLFxuICBuYXY6ICduYXYnLFxuICBub3NjcmlwdDogJ25vc2NyaXB0JyxcbiAgb2JqZWN0OiAnb2JqZWN0JyxcbiAgb2w6ICdvbCcsXG4gIG9wdGdyb3VwOiAnb3B0Z3JvdXAnLFxuICBvcHRpb246ICdvcHRpb24nLFxuICBvdXRwdXQ6ICdvdXRwdXQnLFxuICBwOiAncCcsXG4gIHBhcmFtOiAncGFyYW0nLFxuICBwaWN0dXJlOiAncGljdHVyZScsXG4gIHByZTogJ3ByZScsXG4gIHByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICBxOiAncScsXG4gIHJwOiAncnAnLFxuICBydDogJ3J0JyxcbiAgcnVieTogJ3J1YnknLFxuICBzOiAncycsXG4gIHNhbXA6ICdzYW1wJyxcbiAgc2NyaXB0OiAnc2NyaXB0JyxcbiAgc2VjdGlvbjogJ3NlY3Rpb24nLFxuICBzZWxlY3Q6ICdzZWxlY3QnLFxuICBzbWFsbDogJ3NtYWxsJyxcbiAgc291cmNlOiAnc291cmNlJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzdHJvbmc6ICdzdHJvbmcnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3ViOiAnc3ViJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICBzdXA6ICdzdXAnLFxuICB0YWJsZTogJ3RhYmxlJyxcbiAgdGJvZHk6ICd0Ym9keScsXG4gIHRkOiAndGQnLFxuICB0ZXh0YXJlYTogJ3RleHRhcmVhJyxcbiAgdGZvb3Q6ICd0Zm9vdCcsXG4gIHRoOiAndGgnLFxuICB0aGVhZDogJ3RoZWFkJyxcbiAgdGltZTogJ3RpbWUnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHI6ICd0cicsXG4gIHRyYWNrOiAndHJhY2snLFxuICB1OiAndScsXG4gIHVsOiAndWwnLFxuICAndmFyJzogJ3ZhcicsXG4gIHZpZGVvOiAndmlkZW8nLFxuICB3YnI6ICd3YnInLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6ICdjaXJjbGUnLFxuICBjbGlwUGF0aDogJ2NsaXBQYXRoJyxcbiAgZGVmczogJ2RlZnMnLFxuICBlbGxpcHNlOiAnZWxsaXBzZScsXG4gIGc6ICdnJyxcbiAgaW1hZ2U6ICdpbWFnZScsXG4gIGxpbmU6ICdsaW5lJyxcbiAgbGluZWFyR3JhZGllbnQ6ICdsaW5lYXJHcmFkaWVudCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgcGF0aDogJ3BhdGgnLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBvbHlnb246ICdwb2x5Z29uJyxcbiAgcG9seWxpbmU6ICdwb2x5bGluZScsXG4gIHJhZGlhbEdyYWRpZW50OiAncmFkaWFsR3JhZGllbnQnLFxuICByZWN0OiAncmVjdCcsXG4gIHN0b3A6ICdzdG9wJyxcbiAgc3ZnOiAnc3ZnJyxcbiAgdGV4dDogJ3RleHQnLFxuICB0c3BhbjogJ3RzcGFuJ1xuXG59LCBjcmVhdGVET01GYWN0b3J5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GZWF0dXJlRmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcbiAgdXNlQ3JlYXRlRWxlbWVudDogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZlYXR1cmVGbGFnczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JRE9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudEluc3QsIHVwZGF0ZXMpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHBhcmVudEluc3QpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyhub2RlLCB1cGRhdGVzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JbnB1dFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWRMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuSWZWYWx1ZUlzTnVsbChwcm9wcykge1xuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGBpbnB1dGAgc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIHRoZSBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nKSA6IHZvaWQgMDtcblxuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xudmFyIFJlYWN0RE9NSW5wdXQgPSB7XG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgbmF0aXZlUHJvcHMgPSBfYXNzaWduKHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnR5cGUgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzIChzZXR0aW5nIC52YWx1ZVxuICAgICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgICAgdHlwZTogdW5kZWZpbmVkXG4gICAgfSwgRGlzYWJsZWRJbnB1dFV0aWxzLmdldE5hdGl2ZVByb3BzKGluc3QsIHByb3BzKSwge1xuICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdhcm5JZlZhbHVlSXNOdWxsKHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCB8fCBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogZGVmYXVsdFZhbHVlICE9IG51bGwgPyBkZWZhdWx0VmFsdWUgOiBudWxsLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgPSBwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgfHwgcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuSWZWYWx1ZUlzTnVsbChwcm9wcyk7XG5cbiAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQgfHwgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0Q2hlY2tlZCB8fCBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICB2YXIgY29udHJvbGxlZCA9IHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCB8fCBwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAoKGluaXRpYWxWYWx1ZSB8fCAhaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQpICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgKGRlZmF1bHRWYWx1ZSB8fCAhY29udHJvbGxlZCkgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCksICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcbiAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgJyArICdzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIG90aGVySW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUluc3RydW1lbnRhdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRGVidWdUb29sID0gcmVxdWlyZSgnLi9SZWFjdERPTURlYnVnVG9vbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBSZWFjdERPTURlYnVnVG9vbCB9OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTU9wdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NT3B0aW9uID0ge1xuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgbmF0aXZlUGFyZW50KSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJ1xuICAgIHZhciBzZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgaWYgKG5hdGl2ZVBhcmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gbmF0aXZlUGFyZW50O1xuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50Ll90YWcgPT09ICdvcHRncm91cCcpIHtcbiAgICAgICAgc2VsZWN0UGFyZW50ID0gc2VsZWN0UGFyZW50Ll9uYXRpdmVQYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RQYXJlbnQgIT0gbnVsbCAmJiBzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgc2VsZWN0VmFsdWUgPSBSZWFjdERPTVNlbGVjdC5nZXRTZWxlY3RWYWx1ZUNvbnRleHQoc2VsZWN0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgaXMgbnVsbCAoZS5nLiwgbm8gc3BlY2lmaWVkIHZhbHVlIG9yIGFmdGVyIGluaXRpYWwgbW91bnQpXG4gICAgLy8gb3IgbWlzc2luZyAoZS5nLiwgZm9yIDxkYXRhbGlzdD4pLCB3ZSBkb24ndCBjaGFuZ2UgcHJvcHMuc2VsZWN0ZWRcbiAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtpXSA9PT0gJycgKyBwcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09ICcnICsgcHJvcHMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgcHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgdmFyIG5hdGl2ZVByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBuYXRpdmVQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9ICcnO1xuXG4gICAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gICAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICBSZWFjdENoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBuYXRpdmVQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQgJiYgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gd2FybklmVmFsdWVJc051bGwocHJvcHMpIHtcbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgc2VsZWN0YCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgdGhlIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIG93bmVyKTtcblxuICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHNlbGVjdGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gaW5zdFxuICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBsZVxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGluc3QsIG11bHRpcGxlLCBwcm9wVmFsdWUpIHtcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGk7XG4gIHZhciBvcHRpb25zID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHJldHVybiBfYXNzaWduKHt9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0TmF0aXZlUHJvcHMoaW5zdCwgcHJvcHMpLCB7XG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKTtcbiAgICAgIHdhcm5JZlZhbHVlSXNOdWxsKHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIHdhc011bHRpcGxlOiBCb29sZWFuKHByb3BzLm11bHRpcGxlKVxuICAgIH07XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBnZXRTZWxlY3RWYWx1ZUNvbnRleHQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gUmVhY3RET01PcHRpb24gbG9va3MgYXQgdGhpcyBpbml0aWFsIHZhbHVlIHNvIHRoZSBpbml0aWFsIGdlbmVyYXRlZFxuICAgIC8vIG1hcmt1cCBoYXMgY29ycmVjdCBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICByZXR1cm4gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgfSxcblxuICBwb3N0VXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybklmVmFsdWVJc051bGwocHJvcHMpO1xuICAgIH1cblxuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoaXMgdmFsdWUgZG93blxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd2FzTXVsdGlwbGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSBCb29sZWFuKHByb3BzLm11bHRpcGxlKSkge1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICB9XG4gIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmIChvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxuLyoqXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxuICpcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgc28gdGhhdCB0aGV5XG4gKiBjYW4gdW5kZXJnbyB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgLy8gVE9ETzogVGhpcyBpcyByZWFsbHkgYSBSZWFjdFRleHQgKFJlYWN0Tm9kZSksIG5vdCBhIFJlYWN0RWxlbWVudFxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IHRleHQ7XG4gIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9uYXRpdmVOb2RlID0gbnVsbDtcbiAgdGhpcy5fbmF0aXZlUGFyZW50ID0gbnVsbDtcblxuICAvLyBQcm9wZXJ0aWVzXG4gIHRoaXMuX2RvbUlEID0gbnVsbDtcbiAgdGhpcy5fbW91bnRJbmRleCA9IDA7XG4gIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgdGhpcy5fY29tbWVudE5vZGVzID0gbnVsbDtcbn07XG5cbl9hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBtYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLiBUaGlzIG5vZGUgaXMgbm90IGludGVuZGVkIHRvIGhhdmVcbiAgICogYW55IGZlYXR1cmVzIGJlc2lkZXMgY29udGFpbmluZyB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgbmF0aXZlUGFyZW50LCBuYXRpdmVDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldFRleHQodGhpcy5fZGVidWdJRCwgdGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKG5hdGl2ZVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBuYXRpdmVQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAobmF0aXZlQ29udGFpbmVySW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBuYXRpdmVDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcoJyN0ZXh0JywgdGhpcywgcGFyZW50SW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRvbUlEID0gbmF0aXZlQ29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdmFyIG9wZW5pbmdWYWx1ZSA9ICcgcmVhY3QtdGV4dDogJyArIGRvbUlEICsgJyAnO1xuICAgIHZhciBjbG9zaW5nVmFsdWUgPSAnIC9yZWFjdC10ZXh0ICc7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9uYXRpdmVQYXJlbnQgPSBuYXRpdmVQYXJlbnQ7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gbmF0aXZlQ29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChvcGVuaW5nVmFsdWUpO1xuICAgICAgdmFyIGNsb3NpbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGNsb3NpbmdWYWx1ZSk7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvcGVuaW5nQ29tbWVudCkpO1xuICAgICAgaWYgKHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9zdHJpbmdUZXh0KSkpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUoY2xvc2luZ0NvbW1lbnQpKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgb3BlbmluZ0NvbW1lbnQpO1xuICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBjbG9zaW5nQ29tbWVudDtcbiAgICAgIHJldHVybiBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgYmV0d2VlbiBjb21tZW50IG5vZGVzIGZvciB0aGUgcmVhc29ucyBzdGF0ZWRcbiAgICAgICAgLy8gYWJvdmUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlclxuICAgICAgICAvLyAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8IS0tJyArIG9wZW5pbmdWYWx1ZSArICctLT4nICsgZXNjYXBlZFRleHQgKyAnPCEtLScgKyBjbG9zaW5nVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBjb21tZW50Tm9kZXMgPSB0aGlzLmdldE5hdGl2ZU5vZGUoKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnJlcGxhY2VEZWxpbWl0ZWRUZXh0KGNvbW1lbnROb2Rlc1swXSwgY29tbWVudE5vZGVzWzFdLCBuZXh0U3RyaW5nVGV4dCk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRUZXh0KHRoaXMuX2RlYnVnSUQsIG5leHRTdHJpbmdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXROYXRpdmVOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5hdGl2ZU5vZGUgPSB0aGlzLl9jb21tZW50Tm9kZXM7XG4gICAgaWYgKG5hdGl2ZU5vZGUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVOb2RlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Nsb3NpbmdDb21tZW50KSB7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICAgIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAhKG5vZGUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBjbG9zaW5nIGNvbW1lbnQgZm9yIHRleHQgY29tcG9uZW50ICVzJywgdGhpcy5fZG9tSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgL3JlYWN0LXRleHQgJykge1xuICAgICAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgbmF0aXZlTm9kZSA9IFt0aGlzLl9uYXRpdmVOb2RlLCB0aGlzLl9jbG9zaW5nQ29tbWVudF07XG4gICAgdGhpcy5fY29tbWVudE5vZGVzID0gbmF0aXZlTm9kZTtcbiAgICByZXR1cm4gbmF0aXZlTm9kZTtcbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0YXJlYVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlZhbHVlSXNOdWxsKHByb3BzKSB7XG4gIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYHRleHRhcmVhYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgdGhlIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gICAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC5cbiAgICB2YXIgbmF0aXZlUHJvcHMgPSBfYXNzaWduKHt9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0TmF0aXZlUHJvcHMoaW5zdCwgcHJvcHMpLCB7XG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBjaGlsZHJlbjogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgdGV4dGFyZWFgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICB3YXJuSWZWYWx1ZUlzTnVsbChwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAvLyBXZSBzYXZlIHRoZSBpbml0aWFsIHZhbHVlIHNvIHRoYXQgYFJlYWN0RE9NQ29tcG9uZW50YCBkb2Vzbid0IHVwZGF0ZVxuICAgICAgLy8gYHRleHRDb250ZW50YCAodW5uZWNlc3Nhcnkgc2luY2Ugd2UgdXBkYXRlIHZhbHVlKS5cbiAgICAgIC8vIFRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQnc1xuICAgICAgLy8gZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgICAgaW5pdGlhbFZhbHVlOiAnJyArICh2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBkZWZhdWx0VmFsdWUpLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuSWZWYWx1ZUlzTnVsbChwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRyZWVUcmF2ZXJzYWxcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX25hdGl2ZU5vZGUnIGluIGluc3RBKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgISgnX25hdGl2ZU5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICB2YXIgZGVwdGhBID0gMDtcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gdGVtcEEuX25hdGl2ZVBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5fbmF0aXZlUGFyZW50KSB7XG4gICAgZGVwdGhCKys7XG4gIH1cblxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XG4gICAgaW5zdEEgPSBpbnN0QS5fbmF0aXZlUGFyZW50O1xuICAgIGRlcHRoQS0tO1xuICB9XG5cbiAgLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIGluc3RCID0gaW5zdEIuX25hdGl2ZVBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9uYXRpdmVQYXJlbnQ7XG4gICAgaW5zdEIgPSBpbnN0Qi5fbmF0aXZlUGFyZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cbmZ1bmN0aW9uIGlzQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19uYXRpdmVOb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICEoJ19uYXRpdmVOb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX25hdGl2ZVBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgdGhlIHBhc3NlZC1pbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xuICAhKCdfbmF0aXZlTm9kZScgaW4gaW5zdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0UGFyZW50SW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9uYXRpdmVQYXJlbnQ7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGluc3QuX25hdGl2ZVBhcmVudDtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgZmFsc2UsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCB0cnVlLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX25hdGl2ZVBhcmVudDtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0byAmJiB0byAhPT0gY29tbW9uKSB7XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gdG8uX25hdGl2ZVBhcmVudDtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sIHRydWUsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAoaSA9IHBhdGhUby5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW2ldLCBmYWxzZSwgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVW5rbm93blByb3BlcnR5RGV2dG9vbFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciByZWFjdFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICAgIGtleTogdHJ1ZSxcbiAgICByZWY6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgd2FyblVua25vd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlYWN0UHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcmVhY3RQcm9wc1tuYW1lXSB8fCB3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAvLyBGb3Igbm93LCBvbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgc3VnZ2VzdGVkIGNvcnJlY3Rpb24uIFRoaXMgcHJldmVudHNcbiAgICAvLyBsb2dnaW5nIHRvbyBtdWNoIHdoZW4gdXNpbmcgdHJhbnNmZXJQcm9wc1RvLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHN0YW5kYXJkTmFtZSA9PSBudWxsLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhyZWdpc3RyYXRpb25OYW1lID09IG51bGwsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlEZXZ0b29sID0ge1xuICBvbkNyZWF0ZU1hcmt1cEZvclByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICB9LFxuICBvblNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gIH0sXG4gIG9uRGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5RGV2dG9vbDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWJ1Z1Rvb2xcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGV2ZW50SGFuZGxlcnMgPSBbXTtcbnZhciBoYW5kbGVyRG9lc1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gZW1pdEV2ZW50KGhhbmRsZXJGdW5jdGlvbk5hbWUsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyW2hhbmRsZXJGdW5jdGlvbk5hbWVdKSB7XG4gICAgICAgICAgaGFuZGxlcltoYW5kbGVyRnVuY3Rpb25OYW1lXShhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaGFuZGxlckRvZXNUaHJvd0ZvckV2ZW50W2hhbmRsZXJGdW5jdGlvbk5hbWVdLCAnZXhjZXB0aW9uIHRocm93biBieSBkZXZ0b29sIHdoaWxlIGhhbmRsaW5nICVzOiAlcycsIGhhbmRsZXJGdW5jdGlvbk5hbWUsIGUubWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICAgIGhhbmRsZXJEb2VzVGhyb3dGb3JFdmVudFtoYW5kbGVyRnVuY3Rpb25OYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIGlzUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZmx1c2hIaXN0b3J5ID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gbnVsbDtcbnZhciBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBudWxsO1xudmFyIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xudmFyIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGNsZWFySGlzdG9yeSgpIHtcbiAgUmVhY3RDb21wb25lbnRUcmVlRGV2dG9vbC5wdXJnZVVubW91bnRlZENvbXBvbmVudHMoKTtcbiAgUmVhY3ROYXRpdmVPcGVyYXRpb25IaXN0b3J5RGV2dG9vbC5jbGVhckhpc3RvcnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xuICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlRGV2dG9vbC5nZXRPd25lcklEKGlkKTtcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVEZXZ0b29sLmdldFBhcmVudElEKGlkKTtcbiAgICB0cmVlW2lkXSA9IHtcbiAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVEZXZ0b29sLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZURldnRvb2wuZ2V0VGV4dChpZCksXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlRGV2dG9vbC5nZXRVcGRhdGVDb3VudChpZCksXG4gICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlRGV2dG9vbC5nZXRDaGlsZElEcyhpZCksXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgUmVhY3RDb21wb25lbnRUcmVlRGV2dG9vbC5nZXRPd25lcklEKHBhcmVudElEKSxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRFxuICAgIH07XG4gICAgcmV0dXJuIHRyZWU7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRNZWFzdXJlbWVudHMoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICAgIHZhciBwcmV2aW91c01lYXN1cmVtZW50cyA9IGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyB8fCBbXTtcbiAgICB2YXIgcHJldmlvdXNPcGVyYXRpb25zID0gUmVhY3ROYXRpdmVPcGVyYXRpb25IaXN0b3J5RGV2dG9vbC5nZXRIaXN0b3J5KCk7XG5cbiAgICBpZiAoIWlzUHJvZmlsaW5nIHx8IGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICAgIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IG51bGw7XG4gICAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBudWxsO1xuICAgICAgY2xlYXJIaXN0b3J5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzTWVhc3VyZW1lbnRzLmxlbmd0aCB8fCBwcmV2aW91c09wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVnaXN0ZXJlZElEcyA9IFJlYWN0Q29tcG9uZW50VHJlZURldnRvb2wuZ2V0UmVnaXN0ZXJlZElEcygpO1xuICAgICAgZmx1c2hIaXN0b3J5LnB1c2goe1xuICAgICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIHByZXZpb3VzU3RhcnRUaW1lLFxuICAgICAgICBtZWFzdXJlbWVudHM6IHByZXZpb3VzTWVhc3VyZW1lbnRzIHx8IFtdLFxuICAgICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXG4gICAgICAgIHRyZWVTbmFwc2hvdDogZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGVhckhpc3RvcnkoKTtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGVidWdJRChkZWJ1Z0lEKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRlYnVnSUQsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xufVxuXG52YXIgUmVhY3REZWJ1Z1Rvb2wgPSB7XG4gIGFkZERldnRvb2w6IGZ1bmN0aW9uIChkZXZ0b29sKSB7XG4gICAgZXZlbnRIYW5kbGVycy5wdXNoKGRldnRvb2wpO1xuICB9LFxuICByZW1vdmVEZXZ0b29sOiBmdW5jdGlvbiAoZGV2dG9vbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50SGFuZGxlcnNbaV0gPT09IGRldnRvb2wpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZ2luUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICAgIGZsdXNoSGlzdG9yeS5sZW5ndGggPSAwO1xuICAgICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICB9XG4gIH0sXG4gIGVuZFByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWlzUHJvZmlsaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgfVxuICB9LFxuICBnZXRGbHVzaEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuIGZsdXNoSGlzdG9yeTtcbiAgICB9XG4gIH0sXG4gIG9uQmVnaW5GbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjdXJyZW50Rmx1c2hOZXN0aW5nKys7XG4gICAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIH1cbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5GbHVzaCcpO1xuICB9LFxuICBvbkVuZEZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBjdXJyZW50Rmx1c2hOZXN0aW5nLS07XG4gICAgfVxuICAgIGVtaXRFdmVudCgnb25FbmRGbHVzaCcpO1xuICB9LFxuICBvbkJlZ2luTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNQcm9maWxpbmcgJiYgY3VycmVudEZsdXNoTmVzdGluZyA+IDApIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWN1cnJlbnRUaW1lclR5cGUsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdEaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdGFydCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgICAgICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgICAgICAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG9uRW5kTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Byb2ZpbGluZyAmJiBjdXJyZW50Rmx1c2hOZXN0aW5nID4gMCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjdXJyZW50VGltZXJUeXBlID09PSB0aW1lclR5cGUsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdXZSBkaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdG9wIHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWcgaW4gUmVhY3QuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICAgICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgICAgIHRpbWVyVHlwZTogdGltZXJUeXBlLFxuICAgICAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBjdXJyZW50VGltZXJTdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICAgICAgICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZW1pdEV2ZW50KCdvbkVuZExpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25CZWdpblJlY29uY2lsZXJUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5SZWNvbmNpbGVyVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkVuZFJlY29uY2lsZXJUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kUmVjb25jaWxlclRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uTmF0aXZlT3BlcmF0aW9uOiBmdW5jdGlvbiAoZGVidWdJRCwgdHlwZSwgcGF5bG9hZCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uTmF0aXZlT3BlcmF0aW9uJywgZGVidWdJRCwgdHlwZSwgcGF5bG9hZCk7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uU2V0U3RhdGUnKTtcbiAgfSxcbiAgb25TZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGRlYnVnSUQsIGRpc3BsYXlOYW1lKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25TZXREaXNwbGF5TmFtZScsIGRlYnVnSUQsIGRpc3BsYXlOYW1lKTtcbiAgfSxcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblNldENoaWxkcmVuJywgZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gIH0sXG4gIG9uU2V0T3duZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCBvd25lckRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblNldE93bmVyJywgZGVidWdJRCwgb3duZXJEZWJ1Z0lEKTtcbiAgfSxcbiAgb25TZXRUZXh0OiBmdW5jdGlvbiAoZGVidWdJRCwgdGV4dCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uU2V0VGV4dCcsIGRlYnVnSUQsIHRleHQpO1xuICB9LFxuICBvbk1vdW50Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbk1vdW50Um9vdENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25VcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nRGV2VG9vbCA9IHJlcXVpcmUoJy4vUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nRGV2VG9vbCcpO1xuICB2YXIgUmVhY3ROYXRpdmVPcGVyYXRpb25IaXN0b3J5RGV2dG9vbCA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVPcGVyYXRpb25IaXN0b3J5RGV2dG9vbCcpO1xuICB2YXIgUmVhY3RDb21wb25lbnRUcmVlRGV2dG9vbCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlRGV2dG9vbCcpO1xuICBSZWFjdERlYnVnVG9vbC5hZGREZXZ0b29sKFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0RldlRvb2wpO1xuICBSZWFjdERlYnVnVG9vbC5hZGREZXZ0b29sKFJlYWN0Q29tcG9uZW50VHJlZURldnRvb2wpO1xuICBSZWFjdERlYnVnVG9vbC5hZGREZXZ0b29sKFJlYWN0TmF0aXZlT3BlcmF0aW9uSGlzdG9yeURldnRvb2wpO1xuICB2YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuICBpZiAoL1s/Jl1yZWFjdF9wZXJmXFxiLy50ZXN0KHVybCkpIHtcbiAgICBSZWFjdERlYnVnVG9vbC5iZWdpblByb2ZpbGluZygpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWJ1Z1Rvb2w7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuX2Fzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgY2FsbGJhY2soYSwgYiwgYywgZCwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luJyk7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0NoYW5nZUV2ZW50UGx1Z2luJyk7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKCcuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyJyk7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9FbnRlckxlYXZlRXZlbnRQbHVnaW4nKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01FbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NVHJlZVRyYXZlcnNhbCA9IHJlcXVpcmUoJy4vUmVhY3RET01UcmVlVHJhdmVyc2FsJyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50TGlzdGVuZXInKTtcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbmplY3Rpb24nKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uJyk7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL1NWR0RPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NlbGVjdEV2ZW50UGx1Z2luJyk7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NpbXBsZUV2ZW50UGx1Z2luJyk7XG5cbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXG4gICAgLy8gdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlciBwYWNrYWdlLiBUaGV5IHNob3VsZCBiZSBidWlsdCBpbmRlcGVuZGVudGx5XG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcblxuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFJlYWN0RXZlbnRMaXN0ZW5lcik7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0Q29tcG9uZW50VHJlZShSZWFjdERPTUNvbXBvbmVudFRyZWUpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdFRyZWVUcmF2ZXJzYWwoUmVhY3RET01UcmVlVHJhdmVyc2FsKTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRW1wdHlDb21wb25lbnQuaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5KGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBuZXcgUmVhY3RET01FbXB0eUNvbXBvbmVudChpbnN0YW50aWF0ZSk7XG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgZWxlbWVudC5fc2VsZiA9IHNlbGY7XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoLi4uKTogRXhwZWN0ZWQgcHJvcHMgYXJndW1lbnQgdG8gYmUgYSBwbGFpbiBvYmplY3QuICcgKyAnUHJvcGVydGllcyBkZWZpbmVkIGluIGl0cyBwcm90b3R5cGUgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLicpIDogdm9pZCAwO1xuICAgICAgcmVmID0gIWNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgncmVmJykgfHwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQgPyBudWxsIDogY29uZmlnLnJlZjtcbiAgICAgIGtleSA9ICFjb25maWcuaGFzT3duUHJvcGVydHkoJ2tleScpIHx8IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0ID8gbnVsbCA6ICcnICsgY29uZmlnLmtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmID0gY29uZmlnLnJlZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5yZWY7XG4gICAgICBrZXkgPSBjb25maWcua2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBjb25maWcua2V5O1xuICAgIH1cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gQ3JlYXRlIGR1bW15IGBrZXlgIGFuZCBgcmVmYCBwcm9wZXJ0eSB0byBgcHJvcHNgIHRvIHdhcm4gdXNlcnNcbiAgICAvLyBhZ2FpbnN0IGl0cyB1c2VcbiAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAnZGlzcGxheU5hbWUnIGluIHR5cGUgPyB0eXBlLmRpc3BsYXlOYW1lIDogJ0VsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdyZWYnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAnZGlzcGxheU5hbWUnIGluIHR5cGUgPyB0eXBlLmRpc3BsYXlOYW1lIDogJ0VsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2xvbmVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBFeHBlY3RlZCBwcm9wcyBhcmd1bWVudCB0byBiZSBhIHBsYWluIG9iamVjdC4gJyArICdQcm9wZXJ0aWVzIGRlZmluZWQgaW4gaXRzIHByb3RvdHlwZSBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChjb25maWcucmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRWYWxpZGF0b3JcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBhZGRlbmRhID0gZ2V0QWRkZW5kYUZvcktleVVzZSgndW5pcXVlS2V5JywgZWxlbWVudCwgcGFyZW50VHlwZSk7XG4gIGlmIChhZGRlbmRhID09PSBudWxsKSB7XG4gICAgLy8gd2UgYWxyZWFkeSBzaG93ZWQgdGhlIHdhcm5pbmdcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMlcycsIGFkZGVuZGEucGFyZW50T3JPd25lciB8fCAnJywgYWRkZW5kYS5jaGlsZE93bmVyIHx8ICcnLCBhZGRlbmRhLnVybCB8fCAnJykgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogU2hhcmVkIHdhcm5pbmcgYW5kIG1vbml0b3JpbmcgY29kZSBmb3IgdGhlIGtleSB3YXJuaW5ncy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlVHlwZSBBIGtleSB1c2VkIGZvciBkZS1kdXBpbmcgd2FybmluZ3MuXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBDb21wb25lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqIEByZXR1cm5zIHs/b2JqZWN0fSBBIHNldCBvZiBhZGRlbmRhIHRvIHVzZSBpbiB0aGUgd2FybmluZyBtZXNzYWdlLCBvciBudWxsXG4gKiBpZiB0aGUgd2FybmluZyBoYXMgYWxyZWFkeSBiZWVuIHNob3duIGJlZm9yZSAoYW5kIHNob3VsZG4ndCBiZSBzaG93biBhZ2FpbikuXG4gKi9cbmZ1bmN0aW9uIGdldEFkZGVuZGFGb3JLZXlVc2UobWVzc2FnZVR5cGUsIGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gIGlmICghYWRkZW5kdW0pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgYWRkZW5kdW0gPSAnIENoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZVR5cGVdIHx8IChvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZVR5cGVdID0ge30pO1xuICBpZiAobWVtb2l6ZXJbYWRkZW5kdW1dKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbWVtb2l6ZXJbYWRkZW5kdW1dID0gdHJ1ZTtcblxuICB2YXIgYWRkZW5kYSA9IHtcbiAgICBwYXJlbnRPck93bmVyOiBhZGRlbmR1bSxcbiAgICB1cmw6ICcgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgY2hpbGRPd25lcjogbnVsbFxuICB9O1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGFkZGVuZGEuY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJztcbiAgfVxuXG4gIHJldHVybiBhZGRlbmRhO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyBwcm92aWRlIGltcGxpY2l0IGtleXMuXG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgcHJvcFR5cGVzW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1Byb3BUeXBlcyhuYW1lLCBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcblxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWRUeXBlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBzaG91bGQgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgYm9vbGVhbiwgb3IgJyArICdudW1iZXIuIEl0IHNob3VsZCBiZSBhIHN0cmluZyAoZm9yIERPTSBlbGVtZW50cykgb3IgYSBSZWFjdENsYXNzICcgKyAnKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlDb21wb25lbnRGYWN0b3J5O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5OiBmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGVtcHR5Q29tcG9uZW50RmFjdG9yeSA9IGZhY3Rvcnk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBlbXB0eUNvbXBvbmVudEZhY3RvcnkoaW5zdGFudGlhdGUpO1xuICB9XG59O1xuXG5SZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbiA9IFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFcnJvclV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICpcbiAqIEBwYXJhbSB7P1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGEgRmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYyhhLCBiKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgY2F1Z2h0RXJyb3IgPSB4O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XG4gICAqIGhhbmRsZXIgYXJlIHN1cmUgdG8gYmUgcmV0aHJvd24gYnkgcmV0aHJvd0NhdWdodEVycm9yLlxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKipcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBhLCBiKSB7XG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEsIGIpO1xuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50RW1pdHRlck1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cyA9IEV2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudExpc3RlbmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24nKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50KGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QuX25hdGl2ZVBhcmVudCkge1xuICAgIGluc3QgPSBpbnN0Ll9uYXRpdmVQYXJlbnQ7XG4gIH1cbiAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIHZhciBjb250YWluZXIgPSByb290Tm9kZS5wYXJlbnROb2RlO1xuICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgdGhpcy50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgdGhpcy5hbmNlc3RvcnMgPSBbXTtcbn1cbl9hc3NpZ24oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIH1cbn0pO1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZywgUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBhbmNlc3RvciAmJiBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVNb25pdG9yKGNiKSB7XG4gIHZhciBzY3JvbGxQb3NpdGlvbiA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHdpbmRvdyk7XG4gIGNiKHNjcm9sbFBvc2l0aW9uKTtcbn1cblxudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHtcbiAgX2VuYWJsZWQ6IHRydWUsXG4gIF9oYW5kbGVUb3BMZXZlbDogbnVsbCxcblxuICBXSU5ET1dfSEFORExFOiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyB3aW5kb3cgOiBudWxsLFxuXG4gIHNldEhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0sXG5cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCFSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRMaXN0ZW5lcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RGZWF0dXJlRmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFnczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVDb21wb25lbnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIENsYXNzOiBSZWFjdENsYXNzLmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpblV0aWxzOiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBOYXRpdmVDb21wb25lbnQ6IFJlYWN0TmF0aXZlQ29tcG9uZW50LmluamVjdGlvbixcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnB1dFNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdGlvbicpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG5cbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgfSxcblxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgLy8gSUU4IGlucHV0LlxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgc2VsZWN0aW9uIHBlciBkb2N1bWVudCBpbiBJRSwgc28gaXQgbXVzdFxuICAgICAgLy8gYmUgaW4gb3VyIGVsZW1lbnQuXG4gICAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xuICAgICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IC1yYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgIGVuZDogLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0gUmVhY3RET01TZWxlY3Rpb24uZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gICAqIHRoZSBpbnB1dC5cbiAgICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCwgb2Zmc2V0cykge1xuICAgIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlTWFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdHJ1bWVudGF0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWJ1Z1Rvb2w6IFJlYWN0RGVidWdUb29sIH07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0RldlRvb2xcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSW52YWxpZFNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFwcm9jZXNzaW5nQ2hpbGRDb250ZXh0LCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0RldlRvb2wgPSB7XG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IHRydWU7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgfSxcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHdhcm5JbnZhbGlkU2V0U3RhdGUoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdEZXZUb29sOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1hcmt1cENoZWNrc3VtXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG52YXIgQ09NTUVOVF9TVEFSVCA9IC9ePFxcIVxcLVxcLS87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MsIGNvbW1lbnRzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcbiAgICBpZiAoQ09NTUVOVF9TVEFSVC50ZXN0KG1hcmt1cCkpIHtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1vdW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NQ29udGFpbmVySW5mbyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db250YWluZXJJbmZvJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZSgnLi9SZWFjdE1hcmt1cENoZWNrc3VtJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgUk9PVF9BVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcbiAqL1xuZnVuY3Rpb24gZmlyc3REaWZmZXJlbmNlSW5kZXgoc3RyaW5nMSwgc3RyaW5nMikge1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xuICAgIGlmIChzdHJpbmcxLmNoYXJBdChpKSAhPT0gc3RyaW5nMi5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxuICogYSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcbn1cblxuLyoqXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50SW50b05vZGUod3JhcHBlckluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgbWFya2VyTmFtZTtcbiAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgIHZhciB3cmFwcGVkRWxlbWVudCA9IHdyYXBwZXJJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHR5cGUgPSB3cmFwcGVkRWxlbWVudC50eXBlO1xuICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgbW91bnQ6ICcgKyAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZSA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lKTtcbiAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gIH1cblxuICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHdyYXBwZXJJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIG51bGwsIFJlYWN0RE9NQ29udGFpbmVySW5mbyh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciksIGNvbnRleHQpO1xuXG4gIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgd3JhcHBlckluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fdG9wTGV2ZWxXcmFwcGVyID0gd3JhcHBlckluc3RhbmNlO1xuICBSZWFjdE1vdW50Ll9tb3VudEltYWdlSW50b05vZGUobWFya3VwLCBjb250YWluZXIsIHdyYXBwZXJJbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBCYXRjaGVkIG1vdW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogdXNlQ3JlYXRlRWxlbWVudCAqL1xuICAhc2hvdWxkUmV1c2VNYXJrdXAgJiYgUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudCk7XG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHVubW91bnQgZnJvbS5cbiAqIEBmaW5hbFxuICogQGludGVybmFsXG4gKiBAc2VlIHtSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGV9XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRGcm9tTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLCBzYWZlbHkpIHtcbiAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQoaW5zdGFuY2UsIHNhZmVseSk7XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBoYXMgYSBkaXJlY3QgUmVhY3QtcmVuZGVyZWQgY2hpbGQgdGhhdCBpc1xuICogbm90IGEgUmVhY3Qgcm9vdCBlbGVtZW50LiBVc2VmdWwgZm9yIHdhcm5pbmcgaW4gYHJlbmRlcmAsXG4gKiBgdW5tb3VudENvbXBvbmVudEF0Tm9kZWAsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBjb250YWlucyBhIGRpcmVjdCBjaGlsZCB0aGF0IHdhc1xuICogcmVuZGVyZWQgYnkgUmVhY3QgYnV0IGlzIG5vdCBhIHJvb3QgZWxlbWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICBpZiAocm9vdEVsKSB7XG4gICAgdmFyIGluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICAgIHJldHVybiAhIShpbnN0ICYmIGluc3QuX25hdGl2ZVBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmF0aXZlUm9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgdmFyIHByZXZOYXRpdmVJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICByZXR1cm4gcHJldk5hdGl2ZUluc3RhbmNlICYmICFwcmV2TmF0aXZlSW5zdGFuY2UuX25hdGl2ZVBhcmVudCA/IHByZXZOYXRpdmVJbnN0YW5jZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdCA9IGdldE5hdGl2ZVJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290ID8gcm9vdC5fbmF0aXZlQ29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdElEID0gdG9wTGV2ZWxSb290Q291bnRlcisrO1xufTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhpcy5wcm9wcyBpcyBhY3R1YWxseSBhIFJlYWN0RWxlbWVudFxuICByZXR1cm4gdGhpcy5wcm9wcztcbn07XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xuICogcmVwcmVzZW50YXRpdmUgRE9NIGVsZW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvIGEgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqICAgUmVhY3RNb3VudC5yZW5kZXIoXG4gKiAgICAgY29tcG9uZW50LFxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxuICogICApO1xuICpcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiAgICAgPGRpdiBkYXRhLXJlYWN0aWQ9XCIuM1wiPiAgICAgICAgICAgICAgPC0tIFJlbmRlcmVkIHJlYWN0Um9vdCBvZiBSZWFjdFxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxuICovXG52YXIgUmVhY3RNb3VudCA9IHtcblxuICBUb3BMZXZlbFdyYXBwZXI6IFRvcExldmVsV3JhcHBlcixcblxuICAvKipcbiAgICogVXNlZCBieSBkZXZ0b29scy4gVGhlIGtleXMgYXJlIG5vdCBpbXBvcnRhbnQuXG4gICAqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgcmVuZGVyQ2FsbGJhY2spIHtcbiAgICByZW5kZXJDYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwcmV2Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSBhbHJlYWR5IGluIHRoZSBET01cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uIEhvb2tlZCBieSBkZXZ0b29scyFcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2goKTtcbiAgICB9XG5cbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIE11dGUgZnV0dXJlIGV2ZW50cyBmcm9tIHRoZSB0b3AgbGV2ZWwgd3JhcHBlci5cbiAgICAgIC8vIEl0IGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCB0aGF0IGRldnRvb2xzIHNob3VsZCBub3Qga25vdyBhYm91dC5cbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9kZWJ1Z0lEID0gMDtcbiAgICB9XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIHZhciB3cmFwcGVySUQgPSBjb21wb25lbnRJbnN0YW5jZS5faW5zdGFuY2Uucm9vdElEO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbd3JhcHBlcklEXSA9IGNvbXBvbmVudEluc3RhbmNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoZSBpbnN0YW5jZSBoZXJlIGlzIFRvcExldmVsV3JhcHBlciBzbyB3ZSByZXBvcnQgbW91bnQgZm9yIGl0cyBjaGlsZC5cbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Um9vdENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX2RlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgJ1JlYWN0RE9NLnJlbmRlcicpO1xuICAgICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NLnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDpcbiAgICAvLyBDaGVjayBpZiBpdCBxdWFja3MgbGlrZSBhbiBlbGVtZW50XG4gICAgbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBuZXh0V3JhcHBlZEVsZW1lbnQgPSBSZWFjdEVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBuZXh0RWxlbWVudCk7XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZXcmFwcGVkRWxlbWVudCA9IHByZXZDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldldyYXBwZWRFbGVtZW50LnByb3BzO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgdmFyIHB1YmxpY0luc3QgPSBwcmV2Q29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgdXBkYXRlZENhbGxiYWNrID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocHVibGljSW5zdCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0TW91bnQuX3VwZGF0ZVJvb3RDb21wb25lbnQocHJldkNvbXBvbmVudCwgbmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHBhcmVudENvbXBvbmVudCAhPSBudWxsID8gcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIDogZW1wdHlPYmplY3QpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20udW5tb3VudGNvbXBvbmVudGF0bm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgaWYgKCFwcmV2Q29tcG9uZW50KSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBiZWluZyB1bm1vdW50ZWQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgaXNuJ3QgYVxuICAgICAgLy8gcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgY29udGFpbmVyLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50ICcgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtwcmV2Q29tcG9uZW50Ll9pbnN0YW5jZS5yb290SURdO1xuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIHByZXZDb21wb25lbnQsIGNvbnRhaW5lciwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF9tb3VudEltYWdlSW50b05vZGU6IGZ1bmN0aW9uIChtYXJrdXAsIGNvbnRhaW5lciwgaW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbikge1xuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIHJvb3RFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcblxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FLCBjaGVja3N1bSk7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRNYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgLy8gYmVjYXVzZSByb290TWFya3VwIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBET00sIHZhcmlvdXMgbm9ybWFsaXphdGlvbnNcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgb2NjdXJyZWQgd2hpY2ggd2lsbCBub3QgYmUgcHJlc2VudCBpbiBgbWFya3VwYC4gSGVyZSxcbiAgICAgICAgICAvLyBpbnNlcnQgbWFya3VwIGludG8gYSA8ZGl2PiBvciA8aWZyYW1lPiBkZXBlbmRpbmcgb24gdGhlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIHR5cGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBub3JtYWxpemF0aW9ucyBiZWZvcmUgY29tcGFyaW5nLlxuICAgICAgICAgIHZhciBub3JtYWxpemVyO1xuICAgICAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3JtYWxpemVyLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmlubmVySFRNTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LndyaXRlKG1hcmt1cCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG5vcm1hbGl6ZWRNYXJrdXAsIHJvb3RNYXJrdXApO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG5vcm1hbGl6ZWRNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCkgKyAnXFxuIChzZXJ2ZXIpICcgKyByb290TWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApO1xuXG4gICAgICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyAnICsgJ3NlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5ICcgKyAnbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uICcgKyAndGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSAnICsgJ21ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvICcgKyAnY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3UgJyArICdzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzICcgKyAnYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGU6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0ICcgKyAneW91IGRpZG5cXCd0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBXZSBjYW5cXCd0IGRvIHRoaXMgJyArICd3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiAnICsgJ1NlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKGNvbnRhaW5lciwgbWFya3VwLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG5hdGl2ZU5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICBpZiAobmF0aXZlTm9kZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25OYXRpdmVPcGVyYXRpb24obmF0aXZlTm9kZS5fZGVidWdJRCwgJ21vdW50JywgbWFya3VwLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkUmVjb25jaWxlcicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZUluc2VydE1hcmt1cChtYXJrdXAsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUCxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFNvdXJjZSBpbmRleCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZU1vdmUoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IFJlYWN0UmVjb25jaWxlci5nZXROYXRpdmVOb2RlKGNoaWxkKSxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IG5vZGUsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlNFVF9NQVJLVVAsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVGV4dENvbnRlbnQodGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVCxcbiAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBQdXNoIGFuIHVwZGF0ZSwgaWYgYW55LCBvbnRvIHRoZSBxdWV1ZS4gQ3JlYXRlcyBhIG5ldyBxdWV1ZSBpZiBub25lIGlzXG4gKiBwYXNzZWQgYW5kIGFsd2F5cyByZXR1cm5zIHRoZSBxdWV1ZS4gTXV0YXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWUocXVldWUsIHVwZGF0ZSkge1xuICBpZiAodXBkYXRlKSB7XG4gICAgcXVldWUgPSBxdWV1ZSB8fCBbXTtcbiAgICBxdWV1ZS5wdXNoKHVwZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoaW5zdCwgdXBkYXRlUXVldWUpIHtcbiAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzKGluc3QsIHVwZGF0ZVF1ZXVlKTtcbn1cblxudmFyIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgY2hpbGRyZW4gPyBPYmplY3Qua2V5cyhjaGlsZHJlbikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltrZXldLl9kZWJ1Z0lEO1xuICAgIH0pIDogW10pO1xuICB9O1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIF9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIF9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyk7XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX25hdGl2ZUNvbnRhaW5lckluZm8sIGNvbnRleHQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlVGV4dENvbnRlbnQobmV4dENvbnRlbnQpXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRNYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVNYXJrdXA6IGZ1bmN0aW9uIChuZXh0TWFya3VwKSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVNldE1hcmt1cChuZXh0TWFya3VwKV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSG9vayB1c2VkIGJ5IFJlYWN0IEFSVFxuICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciByZW1vdmVkTm9kZXMgPSB7fTtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gbnVsbDtcbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0UGxhY2VkTm9kZSA9IG51bGw7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgbGFzdEluZGV4KSk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgLy8gVGhlIGByZW1vdmVkTm9kZXNgIGxvb3AgYmVsb3cgd2lsbCBhY3R1YWxseSByZW1vdmUgdGhlIGNoaWxkLlxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl9tb3VudENoaWxkQXRJbmRleChuZXh0Q2hpbGQsIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIGxhc3RQbGFjZWROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldE5hdGl2ZU5vZGUobmV4dENoaWxkKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiByZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0sIHJlbW92ZWROb2Rlc1tuYW1lXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcykge1xuICAgICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLiBJdCBkb2VzIG5vdCBhY3R1YWxseSBwZXJmb3JtIGFueVxuICAgICAqIGJhY2tlbmQgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm4gbWFrZU1vdmUoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSkge1xuICAgICAgcmV0dXJuIG1ha2VJbnNlcnRNYXJrdXAobW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHJldHVybiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDaGlsZEF0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5fbmF0aXZlQ29udGFpbmVySW5mbywgY29udGV4dCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxuLyoqXG4gKiBXaGVuIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYXJlIHVwZGF0ZWQsIGEgc2VyaWVzIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9uXG4gKiBvYmplY3RzIGFyZSBjcmVhdGVkIGluIG9yZGVyIHRvIGJhdGNoIGFuZCBzZXJpYWxpemUgdGhlIHJlcXVpcmVkIGNoYW5nZXMuXG4gKlxuICogRW51bWVyYXRlcyBhbGwgdGhlIHBvc3NpYmxlIHR5cGVzIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0ga2V5TWlycm9yKHtcbiAgSU5TRVJUX01BUktVUDogbnVsbCxcbiAgTU9WRV9FWElTVElORzogbnVsbCxcbiAgUkVNT1ZFX05PREU6IG51bGwsXG4gIFNFVF9NQVJLVVA6IG51bGwsXG4gIFRFWFRfQ09OVEVOVDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TmF0aXZlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzID0gbnVsbDtcbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIG5hdGl2ZSB0YWdzLlxudmFyIHRhZ1RvQ29tcG9uZW50Q2xhc3MgPSB7fTtcbnZhciB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBudWxsO1xuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGtleWVkIG9iamVjdCB3aXRoIGNsYXNzZXMgYXMgdmFsdWVzLiBFYWNoIGtleSByZXByZXNlbnRzIGFcbiAgLy8gdGFnLiBUaGF0IHBhcnRpY3VsYXIgdGFnIHdpbGwgdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmUuXG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgX2Fzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBjb21wb3NpdGUgY29tcG9uZW50IHdyYXBwZXIgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSB0YWcgZm9yIHdoaWNoIHRvIGdldCB0aGUgY2xhc3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIFJlYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH1cbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gdGFnVG9Db21wb25lbnRDbGFzc1t0YWddO1xuICBpZiAoY29tcG9uZW50Q2xhc3MgPT0gbnVsbCkge1xuICAgIHRhZ1RvQ29tcG9uZW50Q2xhc3NbdGFnXSA9IGNvbXBvbmVudENsYXNzID0gYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzKHRhZyk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudENsYXNzO1xufVxuXG4vKipcbiAqIEdldCBhIG5hdGl2ZSBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSB7XG4gIGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudDogZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50LFxuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdE5hdGl2ZUNvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROYXRpdmVPcGVyYXRpb25IaXN0b3J5RGV2dG9vbFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhpc3RvcnkgPSBbXTtcblxudmFyIFJlYWN0TmF0aXZlT3BlcmF0aW9uSGlzdG9yeURldnRvb2wgPSB7XG4gIG9uTmF0aXZlT3BlcmF0aW9uOiBmdW5jdGlvbiAoZGVidWdJRCwgdHlwZSwgcGF5bG9hZCkge1xuICAgIGhpc3RvcnkucHVzaCh7XG4gICAgICBpbnN0YW5jZUlEOiBkZWJ1Z0lELFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICB9KTtcbiAgfSxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0TmF0aXZlT3BlcmF0aW9uSGlzdG9yeURldnRvb2wuX3ByZXZlbnRDbGVhcmluZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGlzdG9yeSA9IFtdO1xuICB9LFxuICBnZXRIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhpc3Rvcnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROYXRpdmVPcGVyYXRpb25IaXN0b3J5RGV2dG9vbDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb2RlVHlwZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHtcbiAgTkFUSVZFOiAwLFxuICBDT01QT1NJVEU6IDEsXG4gIEVNUFRZOiAyLFxuXG4gIGdldFR5cGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5FTVBUWTtcbiAgICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5OQVRJVkU7XG4gICAgICB9XG4gICAgfVxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIG5vZGU6ICVzJywgbm9kZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9kZVR5cGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5URFoocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvciAmJiBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmVhY3RPd25lcnMgYXJlIGNhcGFibGUgb2Ygc3RvcmluZyByZWZlcmVuY2VzIHRvIG93bmVkIGNvbXBvbmVudHMuXG4gKlxuICogQWxsIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9iZWluZy8vIHJlZmVyZW5jZWQgYnkgb3duZXIgY29tcG9uZW50cywgYnV0XG4gKiBvbmx5IFJlYWN0T3duZXIgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL3JlZmVyZW5jaW5nLy8gb3duZWQgY29tcG9uZW50cy5cbiAqIFRoZSBuYW1lZCByZWZlcmVuY2UgaXMga25vd24gYXMgYSBcInJlZlwiLlxuICpcbiAqIFJlZnMgYXJlIGF2YWlsYWJsZSB3aGVuIG1vdW50ZWQgYW5kIHVwZGF0ZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PlxuICogICAgICAgICAgIDxDdXN0b21Db21wb25lbnQgcmVmPVwiY3VzdG9tXCIgLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5oYW5kbGVDbGljaygpO1xuICogICAgIH0sXG4gKiAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5pbml0aWFsaXplKCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBSZWZzIHNob3VsZCByYXJlbHkgYmUgdXNlZC4gV2hlbiByZWZzIGFyZSB1c2VkLCB0aGV5IHNob3VsZCBvbmx5IGJlIGRvbmUgdG9cbiAqIGNvbnRyb2wgZGF0YSB0aGF0IGlzIG5vdCBoYW5kbGVkIGJ5IFJlYWN0J3MgZGF0YSBmbG93LlxuICpcbiAqIEBjbGFzcyBSZWFjdE93bmVyXG4gKi9cbnZhciBSZWFjdE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNWYWxpZE93bmVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LmF0dGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqZWN0LmRldGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQgYnkgcmVmIHRvIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBieSB3aGljaCB0byByZWZlciB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWRkQ29tcG9uZW50QXNSZWZUbyguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgJyArICdiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAnICsgJyhkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0ICcgKyAnYmUgcmVtb3ZpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAnICsgJyhkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIG93bmVyUHVibGljSW5zdGFuY2UgPSBvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAncyBvd25lciBpcyBzdGlsbCBhbGl2ZSBhbmQgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWZcbiAgICAvLyBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lclB1YmxpY0luc3RhbmNlICYmIG93bmVyUHVibGljSW5zdGFuY2UucmVmc1tyZWZdID09PSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSkge1xuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RPd25lcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSBrZXlNaXJyb3Ioe1xuICBwcm9wOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBjaGlsZENvbnRleHQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbi8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdSZXF1aXJlZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHdhcyBub3Qgc3BlY2lmaWVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gQU5PTllNT1VTO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuLyoqXG4gKiBDdXJyZW50bHk6XG4gKiAtIFRoZSBvcmRlciB0aGF0IHRoZXNlIGFyZSBsaXN0ZWQgaW4gdGhlIHRyYW5zYWN0aW9uIGlzIGNyaXRpY2FsOlxuICogLSBTdXBwcmVzc2VzIGV2ZW50cy5cbiAqIC0gUmVzdG9yZXMgc2VsZWN0aW9uIHJhbmdlLlxuICpcbiAqIEZ1dHVyZTpcbiAqIC0gUmVzdG9yZSBkb2N1bWVudC9vdmVyZmxvdyBzY3JvbGwgcG9zaXRpb25zIHRoYXQgd2VyZSB1bmludGVudGlvbmFsbHlcbiAqICAgbW9kaWZpZWQgdmlhIERPTSBpbnNlcnRpb25zIGFib3ZlIHRoZSB0b3Agdmlld3BvcnQgYm91bmRhcnkuXG4gKiAtIEltcGxlbWVudC9pbnRlZ3JhdGUgd2l0aCBjdXN0b21pemVkIGNvbnN0cmFpbnQgYmFzZWQgbGF5b3V0IHN5c3RlbSBhbmQga2VlcFxuICogICB0cmFjayBvZiB3aGljaCBkaW1lbnNpb25zIG11c3QgYmUgcmVtZWFzdXJlZC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5mdW5jdGlvbiBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKHVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdgKSwgYnV0IHNlcnZlci1zaWRlIHVzZXNcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcbiAgLy8gYFJlYWN0VGV4dENvbXBvbmVudGAgY2hlY2tzIGl0IGluIGBtb3VudENvbXBvbmVudGAuYFxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IHVzZUNyZWF0ZUVsZW1lbnQ7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqICAgVE9ETzogY29udmVydCB0byBhcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXRlIC0tIGlmIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGlzIG1ldGhvZCBpc1xuICAgKiBwYXNzZWQgdG8gYHJvbGxiYWNrYCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVzZXQgdG8gdGhhdCBzdGF0ZS5cbiAgICovXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZWFjdE1vdW50UmVhZHkgaXMgdGhlIG91ciBvbmx5IHN0YXRlZnVsIHdyYXBwZXJcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHkuY2hlY2twb2ludCgpO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbl9hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHRoZSBjb250YWluaW5nIG5hdGl2ZSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBuYXRpdmUgY29udGFpbmVyXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIG5hdGl2ZVBhcmVudCwgbmF0aXZlQ29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpblJlY29uY2lsZXJUaW1lcihpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCAnbW91bnRDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQodHJhbnNhY3Rpb24sIG5hdGl2ZVBhcmVudCwgbmF0aXZlQ29udGFpbmVySW5mbywgY29udGV4dCk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kUmVjb25jaWxlclRpbWVyKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsICdtb3VudENvbXBvbmVudCcpO1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgKiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cC5cbiAgICovXG4gIGdldE5hdGl2ZU5vZGU6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuZ2V0TmF0aXZlTm9kZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgc2FmZWx5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luUmVjb25jaWxlclRpbWVyKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsICd1bm1vdW50Q29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgIGludGVybmFsSW5zdGFuY2UudW5tb3VudENvbXBvbmVudChzYWZlbHkpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRSZWNvbmNpbGVyVGltZXIoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgJ3VubW91bnRDb21wb25lbnQnKTtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luUmVjb25jaWxlclRpbWVyKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsICdyZWNlaXZlQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kUmVjb25jaWxlclRpbWVyKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsICdyZWNlaXZlQ29tcG9uZW50Jyk7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgIT09IHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50J3MgZW5xdWV1ZWQgYmF0Y2ggbnVtYmVyIHNob3VsZCBhbHdheXMgYmUgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGJhdGNoIG9yIHRoZSBmb2xsb3dpbmcgb25lLlxuICAgICAgIShpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09PSB1cGRhdGVCYXRjaE51bWJlciArIDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogVW5leHBlY3RlZCBiYXRjaCBudW1iZXIgKGN1cnJlbnQgJXMsICcgKyAncGVuZGluZyAlcyknLCB1cGRhdGVCYXRjaE51bWJlciwgaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luUmVjb25jaWxlclRpbWVyKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsICdwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnknKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRSZWNvbmNpbGVyVGltZXIoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgJ3BlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeScpO1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlZlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0T3duZXInKTtcblxudmFyIFJlYWN0UmVmID0ge307XG5cbmZ1bmN0aW9uIGF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cblJlYWN0UmVmLmF0dGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuXG4gIHJldHVybihcbiAgICAvLyBUaGlzIGhhcyBhIGZldyBmYWxzZSBwb3NpdGl2ZXMgdy9yL3QgZW1wdHkgY29tcG9uZW50cy5cbiAgICBwcmV2RW1wdHkgfHwgbmV4dEVtcHR5IHx8IG5leHRFbGVtZW50Ll9vd25lciAhPT0gcHJldkVsZW1lbnQuX293bmVyIHx8IG5leHRFbGVtZW50LnJlZiAhPT0gcHJldkVsZW1lbnQucmVmXG4gICk7XG59O1xuXG5SZWFjdFJlZi5kZXRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlZjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW107XG5cbnZhciBub29wQ2FsbGJhY2tRdWV1ZSA9IHtcbiAgZW5xdWV1ZTogZnVuY3Rpb24gKCkge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm9vcENhbGxiYWNrUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxufTtcblxuX2Fzc2lnbihSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHZhciBkaXNwbGF5TmFtZSA9IGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCB0eXBlO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYga2V5cy5sZW5ndGggPCAyMCkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZSArICcgKGtleXM6ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBPbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgY2FsbGVyTmFtZS4gT3RoZXJ3aXNlIHdlIHNob3VsZCBiZSBzaWxlbnQuXG4gICAgICAvLyBXZSdyZSBwcm9iYWJseSBjYWxsaW5nIGZyb20gZW5xdWV1ZUNhbGxiYWNrLiBXZSBkb24ndCB3YW50IHRvIHdhcm5cbiAgICAgIC8vIHRoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSB3YXJuZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGxpZmVjeWNsZSBtZXRob2QuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY2FsbGVyTmFtZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzICcgKyAnc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yICcgKyAnc2lkZS1lZmZlY3RzIGFyZSBhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gJyArICdgY29tcG9uZW50V2lsbE1vdW50YC4nLCBjYWxsZXJOYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsbGVyTmFtZSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSB8fCAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwYXJ0aWFsU3RhdGUpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlRWxlbWVudEludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV3RWxlbWVudCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV3RWxlbWVudDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIHZhbGlkYXRlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICEoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgdXBkYXRlQmF0Y2hOdW1iZXIgPSAwO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyAnICsgJ3N0cmF0ZWd5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovdHJ1ZSk7XG59XG5cbl9hc3NpZ24oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uTWl4aW4ucGVyZm9ybS5jYWxsKHRoaXMsIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSwgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgbWV0aG9kLCBzY29wZSwgYSk7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG4gIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBtb3VudCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnRPcmRlckNvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAhKGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvICcgKyAnbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnRPcmRlckNvbXBhcmF0b3IpO1xuXG4gIC8vIEFueSB1cGRhdGVzIGVucXVldWVkIHdoaWxlIHJlY29uY2lsaW5nIG11c3QgYmUgcGVyZm9ybWVkIGFmdGVyIHRoaXMgZW50aXJlXG4gIC8vIGJhdGNoLiBPdGhlcndpc2UsIGlmIGRpcnR5Q29tcG9uZW50cyBpcyBbQSwgQl0gd2hlcmUgQSBoYXMgY2hpbGRyZW4gQiBhbmRcbiAgLy8gQywgQiBjb3VsZCB1cGRhdGUgdHdpY2UgaW4gYSBzaW5nbGUgYmF0Y2ggaWYgQydzIHJlbmRlciBlbnF1ZXVlcyBhbiB1cGRhdGVcbiAgLy8gdG8gQiAoc2luY2UgQiB3b3VsZCBoYXZlIGFscmVhZHkgdXBkYXRlZCwgd2Ugc2hvdWxkIHNraXAgaXQsIGFuZCB0aGUgb25seVxuICAvLyB3YXkgd2UgY2FuIGtub3cgdG8gZG8gc28gaXMgYnkgY2hlY2tpbmcgdGhlIGJhdGNoIGNvdW50ZXIpLlxuICB1cGRhdGVCYXRjaE51bWJlcisrO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaXQgd2lsbCBzdGlsbFxuICAgIC8vIGJlIGhlcmUsIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCBoYXMgY2xlYXJlZCBpdHMgX3BlbmRpbmdDYWxsYmFja3MgYW5kXG4gICAgLy8gdGhhdCBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaXMgYSBub29wLlxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG5cbiAgICAvLyBJZiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaGFwcGVucyB0byBlbnF1ZXVlIGFueSBuZXcgdXBkYXRlcywgd2VcbiAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgIC8vIHN0YXNoIHRoZSBjYWxsYmFja3MgZmlyc3RcbiAgICB2YXIgY2FsbGJhY2tzID0gY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzO1xuICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICB2YXIgbWFya2VyTmFtZTtcbiAgICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgICB2YXIgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAvLyBEdWNrIHR5cGUgVG9wTGV2ZWxXcmFwcGVyLiBUaGlzIGlzIHByb2JhYmx5IGFsd2F5cyB0cnVlLlxuICAgICAgaWYgKGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQucHJvcHMgPT09IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgdXBkYXRlOiAnICsgbmFtZWRDb21wb25lbnQuZ2V0TmFtZSgpO1xuICAgICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpO1xuXG4gICAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2goKTtcbiAgfVxuXG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFByb3BzLCBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICBpZiAoY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsKSB7XG4gICAgY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9IHVwZGF0ZUJhdGNoTnVtYmVyICsgMTtcbiAgfVxufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmUnICsgJ3VwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RWZXJzaW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcxNS4xLjAnOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vLyBXZSB1c2UgYXR0cmlidXRlcyBmb3IgZXZlcnl0aGluZyBTVkcgc28gbGV0J3MgYXZvaWQgc29tZSBkdXBsaWNhdGlvbiBhbmQgcnVuXG4vLyBjb2RlIGluc3RlYWQuXG4vLyBUaGUgZm9sbG93aW5nIGFyZSBhbGwgc3BlY2lmaWVkIGluIHRoZSBIVE1MIGNvbmZpZyBhbHJlYWR5IHNvIHdlIGV4Y2x1ZGUgaGVyZS5cbi8vIC0gY2xhc3MgKGFzIGNsYXNzTmFtZSlcbi8vIC0gY29sb3Jcbi8vIC0gaGVpZ2h0XG4vLyAtIGlkXG4vLyAtIGxhbmdcbi8vIC0gbWF4XG4vLyAtIG1lZGlhXG4vLyAtIG1ldGhvZFxuLy8gLSBtaW5cbi8vIC0gbmFtZVxuLy8gLSBzdHlsZVxuLy8gLSB0YXJnZXRcbi8vIC0gdHlwZVxuLy8gLSB3aWR0aFxudmFyIEFUVFJTID0ge1xuICBhY2NlbnRIZWlnaHQ6ICdhY2NlbnQtaGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogMCxcbiAgYWRkaXRpdmU6IDAsXG4gIGFsaWdubWVudEJhc2VsaW5lOiAnYWxpZ25tZW50LWJhc2VsaW5lJyxcbiAgYWxsb3dSZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogMCxcbiAgYW1wbGl0dWRlOiAwLFxuICBhcmFiaWNGb3JtOiAnYXJhYmljLWZvcm0nLFxuICBhc2NlbnQ6IDAsXG4gIGF0dHJpYnV0ZU5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRlVHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogMCxcbiAgYmFzZUZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlUHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmFzZWxpbmVTaGlmdDogJ2Jhc2VsaW5lLXNoaWZ0JyxcbiAgYmJveDogMCxcbiAgYmVnaW46IDAsXG4gIGJpYXM6IDAsXG4gIGJ5OiAwLFxuICBjYWxjTW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwSGVpZ2h0OiAnY2FwLWhlaWdodCcsXG4gIGNsaXA6IDAsXG4gIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgY2xpcFJ1bGU6ICdjbGlwLXJ1bGUnLFxuICBjbGlwUGF0aFVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbjogJ2NvbG9yLWludGVycG9sYXRpb24nLFxuICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgY29sb3JQcm9maWxlOiAnY29sb3ItcHJvZmlsZScsXG4gIGNvbG9yUmVuZGVyaW5nOiAnY29sb3ItcmVuZGVyaW5nJyxcbiAgY29udGVudFNjcmlwdFR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRTdHlsZVR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAwLFxuICBjeDogMCxcbiAgY3k6IDAsXG4gIGQ6IDAsXG4gIGRlY2VsZXJhdGU6IDAsXG4gIGRlc2NlbnQ6IDAsXG4gIGRpZmZ1c2VDb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogMCxcbiAgZGlzcGxheTogMCxcbiAgZGl2aXNvcjogMCxcbiAgZG9taW5hbnRCYXNlbGluZTogJ2RvbWluYW50LWJhc2VsaW5lJyxcbiAgZHVyOiAwLFxuICBkeDogMCxcbiAgZHk6IDAsXG4gIGVkZ2VNb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246IDAsXG4gIGVuYWJsZUJhY2tncm91bmQ6ICdlbmFibGUtYmFja2dyb3VuZCcsXG4gIGVuZDogMCxcbiAgZXhwb25lbnQ6IDAsXG4gIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogMCxcbiAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICBmaWxsUnVsZTogJ2ZpbGwtcnVsZScsXG4gIGZpbHRlcjogMCxcbiAgZmlsdGVyUmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVyVW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kQ29sb3I6ICdmbG9vZC1jb2xvcicsXG4gIGZsb29kT3BhY2l0eTogJ2Zsb29kLW9wYWNpdHknLFxuICBmb2N1c2FibGU6IDAsXG4gIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gIGZvbnRTaXplOiAnZm9udC1zaXplJyxcbiAgZm9udFNpemVBZGp1c3Q6ICdmb250LXNpemUtYWRqdXN0JyxcbiAgZm9udFN0cmV0Y2g6ICdmb250LXN0cmV0Y2gnLFxuICBmb250U3R5bGU6ICdmb250LXN0eWxlJyxcbiAgZm9udFZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxuICBmb250V2VpZ2h0OiAnZm9udC13ZWlnaHQnLFxuICBmb3JtYXQ6IDAsXG4gIGZyb206IDAsXG4gIGZ4OiAwLFxuICBmeTogMCxcbiAgZzE6IDAsXG4gIGcyOiAwLFxuICBnbHlwaE5hbWU6ICdnbHlwaC1uYW1lJyxcbiAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6ICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLFxuICBnbHlwaFJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogMCxcbiAgaG9yaXpBZHZYOiAnaG9yaXotYWR2LXgnLFxuICBob3Jpek9yaWdpblg6ICdob3Jpei1vcmlnaW4teCcsXG4gIGlkZW9ncmFwaGljOiAwLFxuICBpbWFnZVJlbmRlcmluZzogJ2ltYWdlLXJlbmRlcmluZycsXG4gICdpbic6IDAsXG4gIGluMjogMCxcbiAgaW50ZXJjZXB0OiAwLFxuICBrOiAwLFxuICBrMTogMCxcbiAgazI6IDAsXG4gIGszOiAwLFxuICBrNDogMCxcbiAga2VybmVsTWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsVW5pdExlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAwLFxuICBrZXlQb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlTcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleVRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhBZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJTcGFjaW5nOiAnbGV0dGVyLXNwYWNpbmcnLFxuICBsaWdodGluZ0NvbG9yOiAnbGlnaHRpbmctY29sb3InLFxuICBsaW1pdGluZ0NvbmVBbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6IDAsXG4gIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgbWFya2VyU3RhcnQ6ICdtYXJrZXItc3RhcnQnLFxuICBtYXJrZXJIZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJVbml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2VyV2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6IDAsXG4gIG1hc2tDb250ZW50VW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza1VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAwLFxuICBtb2RlOiAwLFxuICBudW1PY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogMCxcbiAgb3BhY2l0eTogMCxcbiAgb3BlcmF0b3I6IDAsXG4gIG9yZGVyOiAwLFxuICBvcmllbnQ6IDAsXG4gIG9yaWVudGF0aW9uOiAwLFxuICBvcmlnaW46IDAsXG4gIG92ZXJmbG93OiAwLFxuICBvdmVybGluZVBvc2l0aW9uOiAnb3ZlcmxpbmUtcG9zaXRpb24nLFxuICBvdmVybGluZVRoaWNrbmVzczogJ292ZXJsaW5lLXRoaWNrbmVzcycsXG4gIHBhaW50T3JkZXI6ICdwYWludC1vcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UtMScsXG4gIHBhdGhMZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJuVHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJFdmVudHM6ICdwb2ludGVyLWV2ZW50cycsXG4gIHBvaW50czogMCxcbiAgcG9pbnRzQXRYOiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzQXRZOiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzQXRaOiAncG9pbnRzQXRaJyxcbiAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZVVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICByOiAwLFxuICByYWRpdXM6IDAsXG4gIHJlZlg6ICdyZWZYJyxcbiAgcmVmWTogJ3JlZlknLFxuICByZW5kZXJpbmdJbnRlbnQ6ICdyZW5kZXJpbmctaW50ZW50JyxcbiAgcmVwZWF0Q291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdER1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkRXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkRmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzdGFydDogMCxcbiAgcmVzdWx0OiAwLFxuICByb3RhdGU6IDAsXG4gIHJ4OiAwLFxuICByeTogMCxcbiAgc2NhbGU6IDAsXG4gIHNlZWQ6IDAsXG4gIHNoYXBlUmVuZGVyaW5nOiAnc2hhcGUtcmVuZGVyaW5nJyxcbiAgc2xvcGU6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIHNwZWN1bGFyQ29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJFeHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogMCxcbiAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRPZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZERldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAwLFxuICBzdGVtdjogMCxcbiAgc3RpdGNoVGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3BDb2xvcjogJ3N0b3AtY29sb3InLFxuICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLFxuICBzdHJpbmc6IDAsXG4gIHN0cm9rZTogMCxcbiAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gIHN0cm9rZURhc2hvZmZzZXQ6ICdzdHJva2UtZGFzaG9mZnNldCcsXG4gIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gIHN0cm9rZUxpbmVqb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICBzdXJmYWNlU2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1MYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGVWYWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldFg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0WTogJ3RhcmdldFknLFxuICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICB0ZXh0RGVjb3JhdGlvbjogJ3RleHQtZGVjb3JhdGlvbicsXG4gIHRleHRSZW5kZXJpbmc6ICd0ZXh0LXJlbmRlcmluZycsXG4gIHRleHRMZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdG86IDAsXG4gIHRyYW5zZm9ybTogMCxcbiAgdTE6IDAsXG4gIHUyOiAwLFxuICB1bmRlcmxpbmVQb3NpdGlvbjogJ3VuZGVybGluZS1wb3NpdGlvbicsXG4gIHVuZGVybGluZVRoaWNrbmVzczogJ3VuZGVybGluZS10aGlja25lc3MnLFxuICB1bmljb2RlOiAwLFxuICB1bmljb2RlQmlkaTogJ3VuaWNvZGUtYmlkaScsXG4gIHVuaWNvZGVSYW5nZTogJ3VuaWNvZGUtcmFuZ2UnLFxuICB1bml0c1BlckVtOiAndW5pdHMtcGVyLWVtJyxcbiAgdkFscGhhYmV0aWM6ICd2LWFscGhhYmV0aWMnLFxuICB2SGFuZ2luZzogJ3YtaGFuZ2luZycsXG4gIHZJZGVvZ3JhcGhpYzogJ3YtaWRlb2dyYXBoaWMnLFxuICB2TWF0aGVtYXRpY2FsOiAndi1tYXRoZW1hdGljYWwnLFxuICB2YWx1ZXM6IDAsXG4gIHZlY3RvckVmZmVjdDogJ3ZlY3Rvci1lZmZlY3QnLFxuICB2ZXJzaW9uOiAwLFxuICB2ZXJ0QWR2WTogJ3ZlcnQtYWR2LXknLFxuICB2ZXJ0T3JpZ2luWDogJ3ZlcnQtb3JpZ2luLXgnLFxuICB2ZXJ0T3JpZ2luWTogJ3ZlcnQtb3JpZ2luLXknLFxuICB2aWV3Qm94OiAndmlld0JveCcsXG4gIHZpZXdUYXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogMCxcbiAgd2lkdGhzOiAwLFxuICB3b3JkU3BhY2luZzogJ3dvcmQtc3BhY2luZycsXG4gIHdyaXRpbmdNb2RlOiAnd3JpdGluZy1tb2RlJyxcbiAgeDogMCxcbiAgeEhlaWdodDogJ3gtaGVpZ2h0JyxcbiAgeDE6IDAsXG4gIHgyOiAwLFxuICB4Q2hhbm5lbFNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhsaW5rQWN0dWF0ZTogJ3hsaW5rOmFjdHVhdGUnLFxuICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgeGxpbmtIcmVmOiAneGxpbms6aHJlZicsXG4gIHhsaW5rUm9sZTogJ3hsaW5rOnJvbGUnLFxuICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgeGxpbmtUaXRsZTogJ3hsaW5rOnRpdGxlJyxcbiAgeGxpbmtUeXBlOiAneGxpbms6dHlwZScsXG4gIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gIHhtbExhbmc6ICd4bWw6bGFuZycsXG4gIHhtbFNwYWNlOiAneG1sOnNwYWNlJyxcbiAgeTogMCxcbiAgeTE6IDAsXG4gIHkyOiAwLFxuICB5Q2hhbm5lbFNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6IDAsXG4gIHpvb21BbmRQYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7fSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge31cbn07XG5cbk9iamVjdC5rZXlzKEFUVFJTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1trZXldID0gMDtcbiAgaWYgKEFUVFJTW2tleV0pIHtcbiAgICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1trZXldID0gQVRUUlNba2V5XTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlbGVjdEV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2VsZWN0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51LCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vLyBUcmFjayB3aGV0aGVyIGEgbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbi8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxudmFyIGhhc0xpc3RlbmVyID0gZmFsc2U7XG52YXIgT05fU0VMRUNUX0tFWSA9IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSk7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2U6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fU0VMRUNUX0tFWSkge1xuICAgICAgaGFzTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2ltcGxlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNBbmltYXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0ZvY3VzRXZlbnQnKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRHJhZ0V2ZW50Jyk7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVG91Y2hFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVHJhbnNpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1doZWVsRXZlbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYWJvcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFib3J0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BYm9ydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQW5pbWF0aW9uRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25FbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25JdGVyYXRpb246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvbkl0ZXJhdGlvbjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQW5pbWF0aW9uSXRlcmF0aW9uQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYW5pbWF0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvblN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25TdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGJsdXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJsdXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJsdXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DYW5QbGF5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheVRocm91Z2g6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5VGhyb3VnaENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29weToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29weTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29weUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkb3VibGVDbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbnRlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VudGVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0V4aXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFeGl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRXhpdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnTGVhdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ092ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ1N0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyb3A6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyb3BDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkdXJhdGlvbkNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW1wdGllZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW1wdGllZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW1wdGllZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuY3J5cHRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5jcnlwdGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbmRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5kZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuZGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVycm9yOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FcnJvckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGZvY3VzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Gb2N1czogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRm9jdXNDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW5wdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbklucHV0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgaW52YWxpZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW52YWxpZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW52YWxpZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5UHJlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVByZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5VXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWREYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkTWV0YWRhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlRG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU91dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXN0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGFzdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXVzZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGF1c2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhdXNlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXlpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXlpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwcm9ncmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUHJvZ3Jlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblByb2dyZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmF0ZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SZXNldDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmVzZXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNjcm9sbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Nyb2xsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2VkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVrZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdGFsbGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdGFsbGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdGFsbGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VibWl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdWJtaXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1Ym1pdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1c3BlbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1c3BlbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1c3BlbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0aW1lVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hDYW5jZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaEVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRyYW5zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRyYW5zaXRpb25FbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRyYW5zaXRpb25FbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQW5pbWF0aW9uRW5kOiBldmVudFR5cGVzLmFuaW1hdGlvbkVuZCxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBldmVudFR5cGVzLmFuaW1hdGlvbkl0ZXJhdGlvbixcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGV2ZW50VHlwZXMuYW5pbWF0aW9uU3RhcnQsXG4gIHRvcEJsdXI6IGV2ZW50VHlwZXMuYmx1cixcbiAgdG9wQ2FuUGxheTogZXZlbnRUeXBlcy5jYW5QbGF5LFxuICB0b3BDYW5QbGF5VGhyb3VnaDogZXZlbnRUeXBlcy5jYW5QbGF5VGhyb3VnaCxcbiAgdG9wQ2xpY2s6IGV2ZW50VHlwZXMuY2xpY2ssXG4gIHRvcENvbnRleHRNZW51OiBldmVudFR5cGVzLmNvbnRleHRNZW51LFxuICB0b3BDb3B5OiBldmVudFR5cGVzLmNvcHksXG4gIHRvcEN1dDogZXZlbnRUeXBlcy5jdXQsXG4gIHRvcERvdWJsZUNsaWNrOiBldmVudFR5cGVzLmRvdWJsZUNsaWNrLFxuICB0b3BEcmFnOiBldmVudFR5cGVzLmRyYWcsXG4gIHRvcERyYWdFbmQ6IGV2ZW50VHlwZXMuZHJhZ0VuZCxcbiAgdG9wRHJhZ0VudGVyOiBldmVudFR5cGVzLmRyYWdFbnRlcixcbiAgdG9wRHJhZ0V4aXQ6IGV2ZW50VHlwZXMuZHJhZ0V4aXQsXG4gIHRvcERyYWdMZWF2ZTogZXZlbnRUeXBlcy5kcmFnTGVhdmUsXG4gIHRvcERyYWdPdmVyOiBldmVudFR5cGVzLmRyYWdPdmVyLFxuICB0b3BEcmFnU3RhcnQ6IGV2ZW50VHlwZXMuZHJhZ1N0YXJ0LFxuICB0b3BEcm9wOiBldmVudFR5cGVzLmRyb3AsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBldmVudFR5cGVzLmR1cmF0aW9uQ2hhbmdlLFxuICB0b3BFbXB0aWVkOiBldmVudFR5cGVzLmVtcHRpZWQsXG4gIHRvcEVuY3J5cHRlZDogZXZlbnRUeXBlcy5lbmNyeXB0ZWQsXG4gIHRvcEVuZGVkOiBldmVudFR5cGVzLmVuZGVkLFxuICB0b3BFcnJvcjogZXZlbnRUeXBlcy5lcnJvcixcbiAgdG9wRm9jdXM6IGV2ZW50VHlwZXMuZm9jdXMsXG4gIHRvcElucHV0OiBldmVudFR5cGVzLmlucHV0LFxuICB0b3BJbnZhbGlkOiBldmVudFR5cGVzLmludmFsaWQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BUcmFuc2l0aW9uRW5kOiBldmVudFR5cGVzLnRyYW5zaXRpb25FbmQsXG4gIHRvcFZvbHVtZUNoYW5nZTogZXZlbnRUeXBlcy52b2x1bWVDaGFuZ2UsXG4gIHRvcFdhaXRpbmc6IGV2ZW50VHlwZXMud2FpdGluZyxcbiAgdG9wV2hlZWw6IGV2ZW50VHlwZXMud2hlZWxcbn07XG5cbmZvciAodmFyIHR5cGUgaW4gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnKSB7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0eXBlXS5kZXBlbmRlbmNpZXMgPSBbdHlwZV07XG59XG5cbnZhciBPTl9DTElDS19LRVkgPSBrZXlPZih7IG9uQ2xpY2s6IG51bGwgfSk7XG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBYm9ydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDYW5QbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXlUaHJvdWdoOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcER1cmF0aW9uQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVtcHRpZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5jcnlwdGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVuZGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVycm9yOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcElucHV0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEludmFsaWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWREYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZE1ldGFkYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXVzZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXlpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUHJvZ3Jlc3M6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmF0ZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSZXNldDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVrZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2luZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdGFsbGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdXNwZW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRpbWVVcGRhdGU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVm9sdW1lQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdhaXRpbmc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERvdWJsZUNsaWNrOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VudGVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFeGl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdMZWF2ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJvcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBbmltYXRpb25FbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQW5pbWF0aW9uSXRlcmF0aW9uOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFuaW1hdGlvblN0YXJ0OlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRyYW5zaXRpb25FbmQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29weTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICFFdmVudENvbnN0cnVjdG9yID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLCB0b3BMZXZlbFR5cGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gICAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAgIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICB2YXIgaWQgPSBpbnN0Ll9yb290Tm9kZUlEO1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBpZCA9IGluc3QuX3Jvb3ROb2RlSUQ7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2lkXTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQW5pbWF0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGRlbGV0ZSB0aGlzLnByZXZlbnREZWZhdWx0O1xuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbm9vcCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIG5vb3ApKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgbm9vcCkpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuICcgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAgKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAgKlxuICAqIEBwYXJhbSB7b2JqZWN0fSBTeW50aGV0aWNFdmVudFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5pbmdDb25kaXRpb24sICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzLCAnICsgJ3lvdVxcJ3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gJyArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNJbnB1dEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNLZXlib2FyZEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGdldEV2ZW50S2V5ID0gcmVxdWlyZSgnLi9nZXRFdmVudEtleScpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljTW91c2VFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVG91Y2hFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1doZWVsRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljV2hlZWxFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVHJhbnNhY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxuICpcbiAqIFRyYW5zYWN0aW9uYWwgcGx1Z2luIEFQSTpcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcbiAqICAgd2hlbiB0aGUgd3JhcHBlZCBwcm9jZXNzIGlzIGNvbXBsZXRlZCwgb3IgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xuICogdGhhdCBpbXBsZW1lbnQgYGluaXRpYWxpemVgIGFuZCBgY2xvc2VgLlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICovXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgJyArICdpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG52YXIgVHJhbnNhY3Rpb24gPSB7XG5cbiAgTWl4aW46IE1peGluLFxuXG4gIC8qKlxuICAgKiBUb2tlbiB0byBsb29rIGZvciB0byBkZXRlcm1pbmUgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAqL1xuICBPQlNFUlZFRF9FUlJPUjoge31cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVmlld3BvcnRNZXRyaWNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFjY3VtdWxhdGVJbnRvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICpcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgdmFyIGN1cnJlbnRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjdXJyZW50KTtcbiAgdmFyIG5leHRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXh0KTtcblxuICBpZiAoY3VycmVudElzQXJyYXkgJiYgbmV4dElzQXJyYXkpIHtcbiAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoY3VycmVudElzQXJyYXkpIHtcbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAobmV4dElzQXJyYXkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTU9EID0gNjU1MjE7XG5cbi8vIGFkbGVyMzIgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgYW5kIGlzIG9ubHkgdXNlZCB0byBzYW5pdHkgY2hlY2sgdGhhdFxuLy8gbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIG1hdGNoZXMgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gKGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgU2hlZXRKUyB2ZXJzaW9uKSBoYXMgYmVlbiBvcHRpbWl6ZWRcbi8vIGZvciBvdXIgdXNlIGNhc2UsIGF0IHRoZSBleHBlbnNlIG9mIGNvbmZvcm1pbmcgdG8gdGhlIGFkbGVyMzIgc3BlY2lmaWNhdGlvblxuLy8gZm9yIG5vbi1hc2NpaSBpbnB1dHMuXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgdmFyIG0gPSBsICYgfjB4MztcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgdmFyIG4gPSBNYXRoLm1pbihpICsgNDA5NiwgbSk7XG4gICAgZm9yICg7IGkgPCBuOyBpICs9IDQpIHtcbiAgICAgIGIgKz0gKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAyKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICB9XG4gICAgYSAlPSBNT0Q7XG4gICAgYiAlPSBNT0Q7XG4gIH1cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBiICs9IGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIGEgJT0gTU9EO1xuICBiICU9IE1PRDtcbiAgcmV0dXJuIGEgfCBiIDw8IDE2O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGFuZ2Vyb3VzU3R5bGVWYWx1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcbnZhciBzdHlsZVdhcm5pbmdzID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVTQ0FQRV9MT09LVVAgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJz4nOiAnJmd0OycsXG4gICc8JzogJyZsdDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgJ1xcJyc6ICcmI3gyNzsnXG59O1xuXG52YXIgRVNDQVBFX1JFR0VYID0gL1smPjxcIiddL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZXIobWF0Y2gpIHtcbiAgcmV0dXJuIEVTQ0FQRV9MT09LVVBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgZXNjYXBlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmaW5kRE9NTm9kZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZ2V0TmF0aXZlQ29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0TmF0aXZlQ29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBlbGVtZW50LlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5maW5kZG9tbm9kZVxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG5cbiAgdmFyIGluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIGluc3QgPSBnZXROYXRpdmVDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgIHJldHVybiBpbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkgOiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGtleVVuaXF1ZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcbiAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcbiAqIGNoaWxkcmVuIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG5cbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSBmdW5jdGlvbiAoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRLZXlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgJ0VzYyc6ICdFc2NhcGUnLFxuICAnU3BhY2ViYXInOiAnICcsXG4gICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICdVcCc6ICdBcnJvd1VwJyxcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAnRGVsJzogJ0RlbGV0ZScsXG4gICdXaW4nOiAnT1MnLFxuICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgJ01velByaW50YWJsZUtleSc6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICdBbHQnOiAnYWx0S2V5JyxcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXG4gICdNZXRhJzogJ21ldGFLZXknLFxuICAnU2hpZnQnOiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50TW9kaWZpZXJTdGF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEl0ZXJhdG9yRm5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0TmF0aXZlQ29tcG9uZW50RnJvbUNvbXBvc2l0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xuXG5mdW5jdGlvbiBnZXROYXRpdmVDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpIHtcbiAgdmFyIHR5cGU7XG5cbiAgd2hpbGUgKCh0eXBlID0gaW5zdC5fcmVuZGVyZWROb2RlVHlwZSkgPT09IFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURSkge1xuICAgIGluc3QgPSBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5OQVRJVkUpIHtcbiAgICByZXR1cm4gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZUNvbXBvbmVudEZyb21Db21wb3NpdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0TmF0aXZlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBUbyBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5LCB3ZSBjcmVhdGUgdGhlIGZpbmFsIGNsYXNzIGluIHRoaXMgbW9kdWxlXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5jb25zdHJ1Y3QoZWxlbWVudCk7XG59O1xuX2Fzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShpbnN0YW5jZSkge1xuICB2YXIgZWxlbWVudCA9IGluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2UgaWYgKGluc3RhbmNlLmdldE5hbWUpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZ2V0TmFtZSgpIHx8ICdVbmtub3duJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIG5leHREZWJ1Z0lEID0gMTtcblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0Tm9kZSwgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZSBtb3VudGVkLlxuICpcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgdmFyIGlzRW1wdHkgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIGluc3RhbmNlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5jcmVhdGUoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpICcgKyAnb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoZWxlbWVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldE5hdGl2ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicsICdPbmx5IFJlYWN0IENvbXBvbmVudHMgY2FuIGJlIG1vdW50ZWQuJykgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2lzT3duZXJOZWNlc3NhcnkgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGRlYnVnSUQgPSBpc0VtcHR5ID8gMCA6IG5leHREZWJ1Z0lEKys7XG4gICAgaW5zdGFuY2UuX2RlYnVnSUQgPSBkZWJ1Z0lEO1xuXG4gICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKGluc3RhbmNlKTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldERpc3BsYXlOYW1lKGRlYnVnSUQsIGRpc3BsYXlOYW1lKTtcbiAgICAgIHZhciBvd25lciA9IG5vZGUgJiYgbm9kZS5fb3duZXI7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0T3duZXIoZGVidWdJRCwgb3duZXIuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNFdmVudFN1cHBvcnRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG5cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIHN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbmx5Q2hpbGRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ29ubHlDaGlsZCBtdXN0IGJlIHBhc3NlZCBhIGNoaWxkcmVuIHdpdGggZXhhY3RseSBvbmUgY2hpbGQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRJbm5lckhUTUxcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xufSk7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldFRleHRDb250ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XG4gIH1cblxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XG4gIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdHJhdmVyc2VBbGxDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHZhbGlkYXRlRE9NTmVzdGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcblxuICAgICAgY2FzZSAndGFibGUnOlxuXG4gICAgICBjYXNlICdocic6XG5cbiAgICAgIGNhc2UgJ3htcCc6XG5cbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGluc3RhbmNlLCByZXR1cm4gYSBsaXN0IG9mIGl0cyByZWN1cnNpdmVcbiAgICogb3duZXJzLCBzdGFydGluZyBhdCB0aGUgcm9vdCBhbmQgZW5kaW5nIHdpdGggdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHZhciBmaW5kT3duZXJTdGFjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICBkbyB7XG4gICAgICBzdGFjay5wdXNoKGluc3RhbmNlKTtcbiAgICB9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIHN0YWNrLnJldmVyc2UoKTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgICBpZiAoY2hpbGRUYWcgIT09ICcjdGV4dCcpIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICAgIH1cblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiAnICsgJ1NlZSAlcy4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgb3duZXJJbmZvLCBpbmZvKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4gU2VlICVzLicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgb3duZXJJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tTWl4ZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlcnMgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3RcbiAgLy8gaW4gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gICEoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2Ygb2JqLmNhbGxlZSAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IGNhblxcJ3QgYmUgYGFyZ3VtZW50c2AuIFVzZSByZXN0IHBhcmFtcyAnICsgJyhmdW5jdGlvbiguLi5hcmdzKSB7fSkgb3IgQXJyYXkuZnJvbSgpIGluc3RlYWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzXG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cblxuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgLy8gSUU4IGNhbiB0aHJvdyBcIkNhbid0IG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRyb2wgYmVjYXVzZSBpdCBpcyBpbnZpc2libGUsXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcbiAgLy8gcmVhc29ucyB0aGF0IGFyZSB0b28gZXhwZW5zaXZlIGFuZCBmcmFnaWxlIHRvIHRlc3QuXG4gIHRyeSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzTm9kZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZXMgYXJlIHVuYm91bmRlZCwgdW5saWtlIGBnZXRTY3JvbGxQb3NpdGlvbmAuIFRoaXMgbWVhbnMgdGhleVxuICogbWF5IGJlIG5lZ2F0aXZlIG9yIGV4Y2VlZCB0aGUgZWxlbWVudCBib3VuZGFyaWVzICh3aGljaCBpcyBwb3NzaWJsZSB1c2luZ1xuICogaW5lcnRpYWwgc2Nyb2xsaW5nKS5cbiAqXG4gKiBAcGFyYW0ge0RPTVdpbmRvd3xET01FbGVtZW50fSBzY3JvbGxhYmxlXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcCB3aXRoIGB4YCBhbmQgYHlgIGtleXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbiBrZXlNaXJyb3Iob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgIShvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvc2luZyB0aGUgYWJpbGl0eSB0byBkeW5hbWljYWxseSB1c2Uga2V5IHN0cmluZ3MgYXMgdmFsdWVzXG4gKiB0aGVtc2VsdmVzLiBQYXNzIGluIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleS92YWwgcGFpciBhbmQgaXQgd2lsbCByZXR1cm5cbiAqIHlvdSB0aGUgc3RyaW5nIGtleSBvZiB0aGF0IHNpbmdsZSByZWNvcmQuIFN1cHBvc2UgeW91IHdhbnQgdG8gZ3JhYiB0aGVcbiAqIHZhbHVlIGZvciBhIGtleSAnY2xhc3NOYW1lJyBpbnNpZGUgb2YgYW4gb2JqZWN0LiBLZXkvdmFsIG1pbmlmaWNhdGlvbiBtYXlcbiAqIGhhdmUgYWxpYXNlZCB0aGF0IGtleSB0byBiZSAneGExMicuIGtleU9mKHtjbGFzc05hbWU6IG51bGx9KSB3aWxsIHJldHVyblxuICogJ3hhMTInIGluIHRoYXQgY2FzZS4gUmVzb2x2ZSBrZXlzIHlvdSB3YW50IHRvIHVzZSBvbmNlIGF0IHN0YXJ0dXAgdGltZSwgdGhlblxuICogcmV1c2UgdGhvc2UgcmVzb2x1dGlvbnMuXG4gKi9cbnZhciBrZXlPZiA9IGZ1bmN0aW9uIGtleU9mKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGBjYWxsYmFja2Agb25jZSBmb3IgZWFjaCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0eSBpbiB0aGVcbiAqIG9iamVjdCBhbmQgY29uc3RydWN0cyBhIG5ldyBvYmplY3QgZnJvbSB0aGUgcmVzdWx0cy4gVGhlIGBjYWxsYmFja2AgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKlxuICogIC0gdGhlIHByb3BlcnR5IHZhbHVlXG4gKiAgLSB0aGUgcHJvcGVydHkgbmFtZVxuICogIC0gdGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGFkZGVkIGFmdGVyIHRoZSBjYWxsIHRvIGBtYXBPYmplY3RgIHdpbGwgbm90IGJlIHZpc2l0ZWRcbiAqIGJ5IGBjYWxsYmFja2AuIElmIHRoZSB2YWx1ZXMgb2YgZXhpc3RpbmcgcHJvcGVydGllcyBhcmUgY2hhbmdlZCwgdGhlIHZhbHVlXG4gKiBwYXNzZWQgdG8gYGNhbGxiYWNrYCB3aWxsIGJlIHRoZSB2YWx1ZSBhdCB0aGUgdGltZSBgbWFwT2JqZWN0YCB2aXNpdHMgdGhlbS5cbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgZGVsZXRlZCBiZWZvcmUgYmVpbmcgdmlzaXRlZCBhcmUgbm90IHZpc2l0ZWQuXG4gKlxuICogQGdyZXAgZnVuY3Rpb24gb2JqZWN0TWFwKClcbiAqIEBncmVwIGZ1bmN0aW9uIG9iak1hcCgpXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0W25hbWVdLCBuYW1lLCBvYmplY3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcE9iamVjdDsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nOyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuIiwiIWZ1bmN0aW9uKGUsdCl7XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLHQpOnQoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGV4cG9ydHM/ZXhwb3J0czplLm1pY3JvbGlnaHQ9e30pfSh0aGlzLGZ1bmN0aW9uKGUpe3ZhciB0LGk9d2luZG93LG49ZG9jdW1lbnQsbz1cImFwcGVuZENoaWxkXCIscj1cInRlc3RcIixhPVwiO3RleHQtc2hhZG93OlwiLGw9XCJvcGFjaXR5Oi5cIixzPVwiIDBweCAwcHggXCIsYz1cIjNweCAwcHggNVwiLGQ9XCIpXCIsdT1uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtaWNyb2xpZ2h0XCIpLGY9ZnVuY3Rpb24oZSl7Zm9yKGU9MDt0PXVbZSsrXTspZm9yKHZhciBmLHAsaCxnLG0seT10LnRleHRDb250ZW50LHg9MCxiPXlbMF0sdz0xLHY9dC5pbm5lckhUTUw9XCJcIixrPTAsQz0vKFxcZCpcXCwgXFxkKlxcLCBcXGQqKSgsIChbLlxcZF0qKSk/L2cuZXhlYyhpLmdldENvbXB1dGVkU3R5bGUodCkuY29sb3IpLE49XCJweCByZ2JhKFwiK0NbMV0rXCIsXCIsRT1DWzNdfHwxO3A9ZixmPTc+ayYmXCJcXFxcXCI9PWY/MTp3Oyl7aWYodz1iLGI9eVsrK3hdLGc9di5sZW5ndGg+MSwhd3x8az44JiZcIlxcblwiPT13fHxbL1xcUy9bcl0odyksMSwxLCEvWyRcXHddL1tyXSh3KSwoXCIvXCI9PWZ8fFwiXFxuXCI9PWYpJiZnLCdcIic9PWYmJmcsXCInXCI9PWYmJmcseVt4LTRdK3ArZj09XCItLT5cIixwK2Y9PVwiKi9cIl1ba10pZm9yKHYmJih0W29dKG09bi5jcmVhdGVFbGVtZW50KFwic3BhblwiKSkuc2V0QXR0cmlidXRlKFwic3R5bGVcIixbXCJcIixsKzYrYStzKzcrTitFLzQrXCIpLFwiK3MrMytOK0UvNCtkLGErcys5K04rLjcqRStcIiksXCIrcysyK04rLjQqRStkLGwrNythK2MrTitFLzUrXCIpLC1cIitjK04rRS81K2QsXCJmb250LXN0eWxlOml0YWxpYztcIitsKzUrYStjK04rRS80K1wiKSwtXCIrYytOK0UvNCtkXVtrPzM+az8xOms+Nj80Oms+Mz8zOjIqL14oYShic3RyYWN0fGxpYXN8bmR8cmd1bWVudHN8cnJheXxzKG18c2VydCk/fHV0byl8Yihhc2V8ZWdpbnxvb2woZWFuKT98cmVha3x5dGUpfGMoYXNlfGF0Y2h8aGFyfGhlY2tlZHxsYXNzfGxvbmV8b21wbHxvbnN0fG9udGludWUpfGRlKGJ1Z2dlcnxjaW1hbHxjbGFyZXxmKGF1bHR8ZXIpP3xpbml0fGwoZWdhdGV8ZXRlKT8pfGRvfGRvdWJsZXxlKGNob3xscz9pZnxsc2UoaWYpP3xuZHxuc3VyZXxudW18dmVudHx4KGNlcHR8ZWN8cChsaWNpdHxvcnQpfHRlKG5kc3xuc2lvbnxybikpKXxmKGFsbHRocm91Z2h8YWxzZXxpbmFsKGx5KT98aXhlZHxsb2F0fG9yKGVhY2gpP3xyaWVuZHxyb218dW5jKHRpb24pPyl8Z2xvYmFsfGdvdG98Z3VhcmR8aShmfG1wKGxlbWVudHN8bGljaXR8b3J0KXxuKGl0fGNsdWRlKF9vbmNlKT98bGluZXxvdXR8c3RhbmNlb2Z8dChlcmZhY2V8ZXJuYWwpPyk/fHMpfGwoYW1iZGF8ZXR8b2NrfG9uZyl8bShpY3JvbGlnaHR8b2R1bGV8dXRhYmxlKXxOYU58bihhbWVzcGFjZXxhdGl2ZXxleHR8ZXd8aWx8b3R8dWxsKXxvKGJqZWN0fHBlcmF0b3J8cnx1dHx2ZXJyaWRlKXxwKGFja2FnZXxhcmFtc3xyaXZhdGV8cm90ZWN0ZWR8cm90b2NvbHx1YmxpYyl8cihhaXNlfGUoYWRvbmx5fGRvfGZ8Z2lzdGVyfHBlYXR8cXVpcmUoX29uY2UpP3xzY3VlfHN0cmljdHx0cnl8dHVybikpfHMoYnl0ZXxlYWxlZHxlbGZ8aG9ydHxpZ25lZHxpemVvZnx0YXRpY3x0cmluZ3x0cnVjdHx1YnNjcmlwdHx1cGVyfHluY2hyb25pemVkfHdpdGNoKXx0KGVtcGxhdGV8aGVufGhpc3xocm93cz98cmFuc2llbnR8cnVlfHJ5fHlwZShhbGlhc3xkZWZ8aWR8bmFtZXxvZikpfHUobihjaGVja2VkfGRlZihpbmVkKT98aW9ufGxlc3N8c2lnbmVkfHRpbCl8c2V8c2luZyl8dihhcnxpcnR1YWx8b2lkfG9sYXRpbGUpfHcoY2hhcl90fGhlbnxoZXJlfGhpbGV8aXRoKXx4b3J8eWllbGQpJC9bcl0odik6MF0pLG1bb10obi5jcmVhdGVUZXh0Tm9kZSh2KSkpLGg9ayYmNz5rP2s6aCx2PVwiXCIsaz0xMTshWzEsL1tcXC97fVsoXFwtKyo9PD46O3xcXFxcLiw/ISZAfl0vW3JdKHcpLC9bXFxdKV0vW3JdKHcpLC9bJFxcd10vW3JdKHcpLFwiL1wiPT13JiYyPmgmJlwiPFwiIT1mLCdcIic9PXcsXCInXCI9PXcsdytiK3lbeCsxXSt5W3grMl09PVwiPCEtLVwiLHcrYj09XCIvKlwiLHcrYj09XCIvL1wiLFwiI1wiPT13XVstLWtdOyk7dis9d319O2UucmVzZXQ9ZixcImNvbXBsZXRlXCI9PW4ucmVhZHlTdGF0ZT9mKCk6aS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGYsMCl9KTsiLCJtb2R1bGUuZXhwb3J0cz17XHJcblwic2luZ2xlXCI6XHJcblx0W1xyXG5cdFx0XCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC80UUEyUlhocFpnQUFTVWtxQUFnQUFBQUJBRElCQWdBVUFBQUFHZ0FBQUFBQUFBQXlNREV5T2pBMk9qSTBJREUzT2pVNE9qTTRBUC9iQUVNQUJnUUZCZ1VFQmdZRkJnY0hCZ2dLRUFvS0NRa0tGQTRQREJBWEZCZ1lGeFFXRmhvZEpSOGFHeU1jRmhZZ0xDQWpKaWNwS2lrWkh5MHdMU2d3SlNncEtQL0NBQXNJQWlnQzRBRUJFUUQveEFBY0FBRUFBZ01CQVFFQUFBQUFBQUFBQUFBQUJnY0RCQVVDQVFqLzJnQUlBUUVBQUFBQnRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFQbU42OWdBQUFBQUFBQUFBQUFHdndlRHBZL1dIYTFXZno5OCtkL3N5UGNBQUFBQUFBQUFBQUh5UHhIRmtrUGY2QUFOWGdSelN6eWVVK2dBQUFBQUFBQUFCeVlMaGtNcjJnQUFHS0x4ZE51K0FBQUFBQUFBQUNLdzNzem5hQUFQbjBBWVlSd0pSTXZRQUFBQUFBQUFFV2hrb21mMEdDUFI3VCsvTVcxbCtjN2N4L05udVNMZkErUmFHeXlZQUFBQUFBQUFEbFZ6STV2OURodzNVMkpGMytnQUd2d0k1bzVKVktQUUliRTdINjRBQUFBQUFBUGxmYU5rNXhxUVhqOXVhYndBQUdHSXhyYW52U0RGVytXeC9vQUFBQUFBQm9WbE9aR05TdWNjODdJQUFBR2pBTldmZGtJOUE3TjZBQUFBQUFBRWFoTnA3QjRyaldzUG9BSHpuOC9SeERkM2VubkFNTUE1ZGs5QVlLcm1zbUFBQUFBQUNEODJ5ZnBIWURZM2FCODQ4VDUvbjN2OUhiMmRob2VPYnpOYjd0U2lSZXdhdFo5YWY4QTBWdDBKeUFBQUFBQVY3c1RvODFydFdEOURqUWZUN3NyNm9BQnFSYU5lcGpKZm9SdUNXZjBCQnRld1FBQUFBQUsrNmN1TldxYkI3NFJPSGRpZGJZQUFCamhjWGxFMjlEWHF1WnlrUWJUc1VBQUFBQUs5Nmt1T1hWOXI3bzQ5ZFNLY2V3QStlWHNBUGtYZzg1bEErVnpzejRRZE9BQUFBQUNHYTA4T1BXVnY1anhYbUd4OG9QbkpqSE53Wk1lZlY5NThYajUxSkwzdlFQTUM1Vm1iQWhIUHNjVnozNU9BQUFBQndvWmFCekt0dC9NYVZXV0JJQVI2RStldkp1MTZBUG5NamtkK1MrVmZRNWxZMkwzQkRPTlpoOHFleCtrQUFBQUd0VmR0K21yVXR2WmpqMXJiT3lQa05pc2ltbWNBQU1jT2kzZm5uc2VhdGswdUVNMGJCTUZTVy83QUFBQUZVMlJ2UGxQMnJ1SENycTMvWTRGZlRTVi9RQUFCRjRQT1pPUGxlYk03RmQ5aVdIRGlka0FBQUFFUXhUUXJTVXlJNWxZMjk3UGxhNTdDOUFjK1A4QUsxdEhlMDlqWjYzZjZmMEh5Q2Nxek1vcmpxeklWSlpIVEsybC9hQUFBQXdWYmJKSFk3WWhyMUxidVUxcXFuc2hENUY0bDg2SGU3Tzk2R254K0R5ZmtybG5vT1JXMW5kSVZqS3BJWWFrdC8weDFOYm4wQUFBRlp6bnBzVlRXNzlLanMzZk5DcjdQNkE4UURpU3VYWkFBUEVTaWZYc0hJTmFxckM3aDhxRzBkNGo4WnNZaC95WWdBQUJ6b0ZaeFcwdDdoQmQ2V0d2VTlxN1lqVUduTWxBQUFqc0Vta3BHT29MTjZ4cjFOY0gwcXlmOVFxTzIvb0FBQXF5eU50enE5dE01OWRXcWZLZnMvcEN0dmRpZWdNUE93R2JvNXdQa0IwYkw5R09vTFkyeU5jQ3hEWHE2MlNMNmMwQUFBTkNBV2NWWFl1K1ZQWnUyVnJLSkVlYWtuVWpESEVJMzV6ZFBvKy9uTzVtSDdKNVhrQ1B3RzF0ZzFLcHQvMFZkWUhSSzk3OGpLa3RzQUFBclNkOUJvMXhhcHdJMVloSG96WTU1cW13ZXVNTmZjcVpTajBBZVl4RGVoWTJVY3lxN2d6a2VqVmpHcFdGdEdLcHJlSURJZTZBQUI1cXExeXNaNzBTcGJYOXZOUTI5Nkt2bDBpRVhoRmo5Z0FBNGRlemlURGwxeGJYMHJPWjlrcjJUZHdybVhkaGdyTzB3QUFJbjhscnhWRnRIR2lWakVBN1VsSWJnbklyckpZSDBCNWVnUGxlL0xEK2tiamxqbUtwN2RNVldXd2ExYVdvVlZhZm9BQUZWMmo3UkQ3TGlxYk4yV09xTGJOU3JyY0ZZOXFhQTVVTjBmWGpIbmU1bDNmb2lFYnRNVnpKcEFRcllscFcweTY1VTlxKzBNM3BLQUFIbXJyVEttdGIydzFoYXBBdTFJeXFiSDN5QjU1cUVmZ25XbTIrRFdoY2RuY2tFUDUxZ25tb2JmOEFwVWR1R25YRnBrUlM1cjF4WjRBQVIva1RkNXFxMXlHYjhrS2p0dzVNS3NzNHNKdEFlSzEyN0E5QUR6QU5LemZwWE1oa3BHK05QU0RkT1RGVFd0N1k2dXRVcXExUUFBcmFkN3lPYzJhbFVXdDljS1BUNHFlenRwOHFHMjhoZ3FTeXV3QUE0TmUyNWtmS2Z0ektWTGJIcDRxbTJTSCs1YVZQYkJWMWw1Z0FCVmRxRmF6dmZlS3R0VXF1eTlscTF2YVJDTm1YSG1vYlIzd0FCd29UYVp4b2JaWkdPZE9DcnJJMldLc0xVSzRtL1FRdnFTQUFBVlZhcFUxc2tkNVUydzVhb3RrcjZUZHQ4cUM0Qlc4czdnQUFJVHNTNHF1eXRwOHBub1pQSE4zN1R6S210ajZqV2xNbkppMC9BQU1GZDJXVlRheFdmSTNmbnprMmwzRlNXMlJiVW1oeVlYWlFBQUNvN2IrdVRETEo4VmowSjdrT0pYTmd5Q3VabjAyQ3VMT2VLeXRBQUE0dkFuTFdycXprUGp0bGJCanJmY205YzJlVk5hdVFxdXpjNEFBQ0pmWllWTGJGV3pmdWc4MVBZV3J5cHVWVGF4VlZxZ0FFUTJaREZPQno3UDBZTmE0RURqYzFsYnpWRnNtS3NyU0FBQVBGWTJpUVBtZHVhQU1kUld6WFZtbFYyb1ZQYkFBQlgvTXdURHZjNkhRMitOZ0JTTndiMk9KY0N5TmhGUHNxQUFBRlZXcWFOSTM0QUloNWpWckZYMmdWblpnQUJWL1huSTFhNHRFQWowWXc2M2V5OExXc3lBMkR0Z0FBQ3NMUE9URkxCQUhtcHRtMGlvcmRLcXRVQUJ5SVRab1JMM0tnRDVRMXlkWWFsVWZMakFBQUNxdk96aDVGbWQ4QUtneldabXoxZGFKVVZ1Z0FLdHN2T0hMMnRvQVZWYW9NRkEvb1VBQUFWOTRzRElxbXp0Z0FLbStkblExTmU0eXNyTkFBVlRhd0FBSTVJd0lOMlpBQUFBaG5tYWl1Snp2QUJXOWkrMkNtclo2YXFyVkFBVm5aZ0FBQURXcnF3ZUxvYlhYNm4wQUR4VWx2Qmd5ZXdBcTZ6dlpocWEzMVdXbUFCektaa0ZuYllBQUFhdGZ4dVRkclA0NC9MenovQUtBQVJyblRZQUFITjZRVnBPZWpWbHFBQWkwUHN6ZEFBQUFyeVY5Z0RUcmZ1VGdBOFYvTWVrQUFBQ002Y25yNnpBQWpzT3RNQUFBQUFCRE9iWW9ZSzYxZldyazNySHlnQUFDSDEvdCtaNUtQWURYcWkzdm9BQUFBQUJBT3pKampWelpQV0hIMUpHQUFBVmh2elBheFJTS3lhYmdWcE9la0FBQUFBQUZTVzIxcXB0cktBQUFBQUVNNDFtQjRxeTFnQUFBQUFBVjdMdXBWdGhkQUFBQUFBQ0lhODNFYzBwZ0FBQUFBQURnOG1YMWZhb0FBQUFBQlVkdGVpdlpsMEFBQUFBQUFjaU85Zm5UTUFBQUFBQWhuVTc1VjFtNUFBQUFBQUFRN2M1Y2g3QUFBQUFBQkgrSk95dUo1dGdBQUFBQUFxYTFJWElld0FBQUFBQVJyVW1CRDl1U2dBQUFBQUJ5SVRac2MwcGdBQUFBQUFWbFlXMmE5Y1dlQUFBQUFBTmFxclp5NHF2dFVBQUFBRFIzZ2MrdTdVQ3FiTzJBQUFBQUFITXJLenVrVmJZbThBR09MUzBBQWFsZDJlSFBxKzE5a09kWEZzQVBNSG5RQUFHcHRmUTBvRnIyWm1HblY5dC9RQXFTMHRrQUFxTFBZWFVjdUQ2ZG43SUViaXRtZWdLbXRrQWZJakx3S2QzUFB2SG04N1U1NlFIRnIyejkwK1JDQ3krYTVJbkR2RnY4QXNBQ3YvTXRpZkkrOWVYOUVBUitBemlTL1Q1R0t0dDd1QUViNDg4QkZOS2NQSHpJQURUcmZGdjQ5U1N6U093MzFJcGZ5cTFzYnRBRFJyT1ZUQUFBSG1HeHo1NTllNUZLYXN0ejZCOHBidFdmOUhEZzFxZ0FBZlBIMzJBZUs4NWNxbE9jWW81RXMxaGJvQUFBQWowRXRqSUhpcUpwNmdzcjcvUGlXYXlmUUFBQUFCNWpVWXg2ZnpheXlHVlpRQUFBQU9MWFVwbG14cXhPTDJQMlhtT2MzUEp0b0FBQUFBQUFBQUFBQVBrZWlYbkxLNUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFmLzhRQU1oQUFBUVFCQWdVRUFRSUZCUUVBQUFBQUJBRUNBd1VHQUJBUkV4UWdNQklWUUZBV0pDVWhJekkxWUNJbU5EYUFNLy9hQUFnQkFRQUJCUUwvQU5PcXFKcm1NMXpHYVJ5TC9pVXMwY1RaN3l2aDFMbFE2YVRJRDVuTUp5Q2VPSVRJSkd4MFZvcjM0NFZJMzhVazErS1NhanhraUxVMURZcHB0ZGV3Uk1ma1VFZnZsb1BGSGxNZnFneUt2bDFFVERNbitES3ZCQ3JnRVpac25jOTNwdnp0TXhoOGpvTWVyNHRSQmpSSjVKUjRaZFRVTmZLa3VLczEwbDZEcE1pS0dVUytCSjAxeU9UL0FBQXl4RkRRakpKSmw5cnRyRFFtT0JRYWhnamdaOFI4YlpFTXg4RW5TMGxpQ3NXUUZpU0Eyd1puM3RqZUNCYVUyMnVOQ1l6RWl3RHhEdCtWSkd5VnAyTmpTNlI5dlM2cnNoRktWRjRwOXZZM1lnV3VkYlhhMXVQaWk2Uk8rV2FPSkpyMnZpMUxsVUthOStzcHBZNXNpbTFFRGZ2VjFCWnVkSGpoU3MvRzU5ZmpjK3Z4NnkwNnR2STQvd0RjUThYdTF5UEV6S1VSOEdSQVM2Z01ISThDNnNhUVF4T1ZiVWkxZDZPYjlxZWVPREhKWTJGeExWNDlBTHBFNEoybVdnWW1wOG85VG1yZm42aXhpU1JSOGVBaTFFR1BDM3h2aGpmcWVpcjVrbHhabXVpdlFOUTVHUU9vZDZDVHBya2NuZFpZK0tYcGhsbFJyWFdBNThmMkhIVnJrQ1J5QVVNcGI0WW1ReDloQkVRN0RjbWlhdkl1cmJRbUxqTTBPSkFNbnc1STJTdE14d0tmVHF1MXJOQzVLK0o0Wnc1amUyU05rakxISDN4eTFtUUtqMFhqOWNZVkVKREtTZGZ6VlZTUFh0N0NDSWhveU1qbW5raG9DalhoVm9vYWZKS0VnS1lkalhwV0szc0t0NEZrTWMzdHRhcUN4YkhPZGo4d1JjSmtQMWR2YlExelFxNHE2bWdpWkJIdTl6V05zc2kvMURVSkpyd3c0QTQvRHhUVHpSV045NXJ0U1pEWHNmOEFrbGZyOGxydGZrdGRyOGtyOVJYdGZJMkswQmxkSE5ISjRwWTJTc1B4dGl1RXVqSytVSXlBeUxzbWpaTkdaV0YwODFSYlEyRWYxTjdjb01sUFNPZTdoMld0c1BYc1NDeHYzMTFhT0F6dkpzd3h0RTVTTzNYdkZzVTdwTDhuVWVNa09mRGlvemRSWTJBeDNzRmJxR25BaTE3WUZyMndMVHFHdWN2c0ZkcjhYQzB1TGVsdnM5dU8xUzc4VFVPVUlpalhZRSttdVJ5ZHhBOFJFWjFHUUErcHlGa3k5dHhTTEc2aHUwTitvdmJkM01vS1JBK3hWNGF0TDE4cjZ2SDBhOUU0SjJtMllvZWljbGtsZjdmYzJXaHNZR2pjTlhpRC9BbUdobVFqSEFKZFBvckFOMFY2ZUU4SzdDTDc3V29Ic0d4bEgwRW9aY0prWFplVXlFSlMzdk5mOUxlMjdra29xaG9ETnlaNHg0WnlpOGdJcXF1Q3ZqN2JLOUVDMHBsdGM2QnhtSnVvQjRvRy9GZXhyMm00NEpQcDdiZWwxWFpFTVRwRlJVN0NJWTU0amEwcW1tcDdpS3dqN01ncGtNYmpscytWL3dCSGYzQ3NkUlZEUUdibm5RQXhNaE15RXNVYUlXTHNzTEVZQmluV2QwK3R4d2NmVFdvMVBIeDRhOWJkZXBQTGFVb3h6VWJhVUxxdTVHT1RzVk9Pcm1pVlpLTzg2bC9aZlUvVTZvTGpxL29zaHQrZ1pRVkhKN0xNK0t2SEJFSXZqSW8yeE0zYzVHcGFYLzhBckF4OTB6NDQyUnM3dVBEUkZrSU5xZktBMmFYSkNabm9YZmt4SUxrRTBVVkxiT1dUSGpaRy9pMCttWXlTeDBsSFpJMkd1dllWUitRd0tsOVpRTWh5a2RWZ3VBSmxhNUhKM0tpS2xyajBjMmdya211bWdtWlBGMlhkSXd6Vk5lS2oreStxM01rb3JOTEViNTl2WVIxNDJQMTd5NXQ3RXRnSW9JaEYrYkZHMktQY3NtSVdHY282L21xcXVDdWo3akxnSVhVdVJsRXVTcnVEMEh4Y1p1b2FvR0hUV28zeEtuSFU0QXMraXNiQmwwNmtzZzlNdmJBRndWNkVVaUx4VHRPQ2dOaWtpT3g2ZXNzb0xDUHN2cWRwN01kdFpFbDdMY09TcFByeTR6aGZta1NzZ2hHaWt5Q3phaU5UWW1kZzhFS1Q1Rll4UnRpajNzckNBQ0tBUXUvTEhnakhqN09PcksvRkYxKzgyK2dzYUZoMUZGSEUzNEwyTmVoK09pRTZjUGIwdXE3SklKOU5jMTdleHlJNUxPb2xycEtHNFpZeDlsL1VOTWp4NjU2anNuaVpQRkM2VEhyVnJrYzM1bDJTKzBzUWhZd3g5bFhobytXYStzUkI0eFlON2F5aXJoNndDZTZLWTFHTjdMUzFIcjJQZlozMnEyakVEK1JZMGdodWxoczZIVlRjam5wMjNsTzVIWTlkSVduWmtkWHJIN1JMQWZlNEFZZUhqQnptcjh2STdMb1JNYXJ1a0czeWV3ZTZTa3JtMTR1OWdiRUNQWEFUWFJqR3RZM2RWNEphWDdudnJNZjRQYTFHTjc1akI0ZFM1RlhzYk5sUTZOZGs3MVorU25hanVyV1Jyc2pQYXNPU3o4SThxaTljV1JnUFNDd0ZuMGk4VTd1R3JhZ2puY0JkemhUeHlObFoyWkRTcTljZXRldGc3TG9OOVViWEdSbWk3NU9DNWo2azFwNGZ5WjVXd3cxVVRyaTMzdkxCSzhQR0sxV0p1Uk15Q0NPS2JJN0dKaVJ4N2tUUmp3a0dGMzg5VFZRVnpPMVZSRU92QWhkTGtCeGJ2YkxreFlNVmdUVU5EWHg2WUdNeHJXbzFPeHcwQzZrcEs5N0o4WEZkcGFXMEQweThzUTFDdndpVlJ5S25iWTE4QjhMVk54NGdBeUU2RHN5S3RraG1wTEpsZ0x2TkcyYUtGOG1QMnlLaXB0SXhKR0NPV2l1L2s1UVUrYWV1RWFFSnRJOXNjWXpYWDl5aWNFM3RTWmJteENGaURIM05MaURnOVJPU0ZoQ1FoUTlqM0l4dGprc01XbUIyMXpvTEhnb0VZeHJFOHJtbzVEY2ZDSVI0TnJUNnJzbGllckh0a1oyRVFzbmlMRkp4K2Vxc1lyQWZzdEJYMGxnRVRHV1B2YzE3TEFURmoxVk44bUI2d0RHYkRyQS9qMkJMUXhNVkVXYVRmS2puTHFuQlFBTGZKN0ZSNE1lckVBRzNJbVlQRTduWkllS1BHTkIyV3R3UFh0YkhZMzdxNm1FQitKWTFBaHlQSHNhRjFUZERucDJTTWE5bGtEUFNGMWhyRHhONTRtVFFoU1BvTFZGNHB2azRhaWtWcGJUaE55UDJYSVVYaW54c2xtY2FlTEEwY2ZZOHBnWXVNaktZWnVjVXdNWEhobjJCMjY2c0NKTDZ4QURpQ0c3TFc5YzZXcHg5R3FpSWlkNzVZMmFsc2c0bmU3Z2E5M0ExN3VCcUt5RGxjeVdOL2dWT09yZWdiT3RiZVN3RU5WSEp2SXhzakNvNThmc1JaNHlZZDcydVN3RHhheFY3TjU0bXpRMHozMU56dmtRUFcxMkxuZFNEOFU4aEJCTVVIV2FYZkpwbm1uQWpORUYzdnBwTE8wRmdZT1B2azFpcm5VdGMydkUzYzVHcGEyTTlzVFVWVU5mRjJ2ZTFqVE1pQ2cwdDlZRjY2SzhNMDNGNUpHSml3bW00N1hvMzhlcnRmajFkcjhXRDAvRjNNMTdmZGg2YmVXSWlpWkFDUnBqMnZUdHRhdUd3aUFMSm9wNEptVHhibERzSmdCbGtvTFJxb3FiNUlJNElvQXBoZ3UrV2hMSVBRbTlkWDd4Y2FiSS9pNWFRNlI0QXpSQk5qcDBGRXhRWnhCVzkyYjBOZmlRQ3h3NzNsZ2xlRml0ZXZEZHlvMXRpZExkRjFvRVFBL1pMS3lGaDJTTjlUS2l5c3BCS0VFZlRXbzFQQ3FJNURhSUlsSktxeXFscjhsVGl4N1pHOWxnRkVjT05PVGp4ME1yWm90N3F1YllpWXVlNU93cUJoTUZGTytydGQ1R05ranFQVlZYMitYQzh3S2xLUXl1K0c1ZURhWnEyVjl2bDVMbnVyeDBGRDN0SExiM3JHb3h1emw0STMxWkJkTlJHcHZrRmk4bWVuckk2NkRzdDdpR3ZiQ0hZWGpnSzRZRnZuUHF4VGtjTFlVTDZxNEhzRzlsZ0ZFY1BWbVRWQjZmeDdNbkNkREpWR3RQRDN5MEwxd1V4aUhBYjVlTC9BQ2FrcnJBTnA0MGxpeGFSNHgvdzhsTDZXc3hnVHBxelo2bzF0S251Vjl2YmxJR0JoNGlzZzN5dzlZQnFBSG9hN2ZJN1BvaDhhcStsaDdMbTgvbVU5RjZISi9EdytwTmVwUEF1cmloUnkwbDJyM2RsNVd0c1JjWXNsN0pXTmtZRTlhTzcza1lraktkNjFOM3VURTJlREZwWENtNzNxZEJldFhpbndzaGQxdHl4UFMzYktDdW5xOFlGNmVxM3lhUnh0a05Fa0VHMGprWXlxajk0dXR5NTJqRDB3NzdlejdMKzVjOTlCVE5BWjNGV0FvdXA4b2o0cVplRjY5c3VwcG40MlpJNzhZSzFMVDI3RVYrUUN1aXlXV0hRVnNHWW5iZlU3TENPaXQzanlkbVQxenRVcDZXQVcrVDEvVmg0MGQxbGZ2bUFybGpxaWtNQTN2bUtCZU1jajI3WldPazFWanBIVTFYd1hMNlV4NzlYZDc1RTVUcm1OcU1adEs5STQ4YVoxMXB2bHhmS0JvQStqcmQ4aktjY2NDTTBRWGZKTFpSVzQvVHRDajdiSzFHQWE0eTJ1RkN4cUpORGlEanQ3cG9JcG1tWTBMS25QdHFaMVpjQ245dC9VTVBpeHExV2JzY2lLaUl1UDNTTHhUZG43SmtXNWNEU1JzVWxVWXpmS0J1b3FzWEk1OVZzUkdrc0dJU0xGTjhHK0k2YXJ4R0hsMWV6bDlMY2NaMWR6dmxaUElxOGZGNldyM2IrN1pSdmFGb0VEaWdTcjJXeHJRQThaQWRQTjJQY2pHMkYzTVROV1k2eGptb2pVOFRrNHBhNDh5VFZaZHlqekl2Rk44bXJWMVJXVGJBWGUrQTY4TEV6dWNMdmxnYWtBWThYMWRadmZOV3V2R09SN05wRyt0bUx5S0xaN3ZWQXN1K0RtY2k4a0dMa0NiWkJQeUtuRW9PVlZiM2k5ZGtDSndUYTdKNlN0eEFUa2hiNVBJODJ6R2lTQWZaVjRhbVYxOWRzYWpHN3pTc2hpSUtMdmk2NnZnQWk4MXJXUTJFTmNlUlRGc2UyUnV5cHhRdU45RGN4U05rajNzbXJUM3pYSTV1ejJvNWxDNWE2ODN5a2JxS3ZHU2VvcXQ3UDlGbEcrWHQ1UkVMMGtpK0JhZnE4cDN6T2IrVURDa0FlejNJeG1NdDZ1MjN5MlZaekI0a2doMkttYU9QaWtMaUM5OHFONmNIR3dPaUEzY3FOYllUelh4NElzWWczd0xhdWlzWUtBOTRKVzlzR2hvT0tGdmE3ZklRMU1yY1NMNTlmdmxqSERsRFNwT1B0S3hKSThYVlJMUGZNb2xVYXZsNXdXMldROHlwb1p1ZlUvQXBmU1JrdTluK3J5cmZJSitucWNTaDVkVXFvaWM2UFhGRlN1WDNIS044d0s1WVZNS2dsZHN1b3ZWY1pKMlpLZTl6NmNCbGVKOExKNjdxaGNjc2V1RTN5U0Z3TmlOTTBpRGRrNlVkOTc1WkdTSUhmVHRocUxtRjFoRmRLSlJYa1lnMFVqSldiVzM2REprM3lLTG0wK0tTOHlwMnRtSkpXNGJMNnE3enp1OUVPR3RWemQ2VnFrNUp2bWszQ0FhMVBuaVNqc2l0ZmlqOVNVRmhBZ0U1ZERMWFdneDZiRmZ1V1Y3NUdYMGxaaW9mVDEyOW9ZMEVQRnczU1NmRUkvWmNoUmVLYldvM1dBWWVTdm8wOTdXTnM3ZWMwaXR4eUtQVEdOWW01OVlLYzJZUStpbHFyU0N3ajFta1NxSldTODhEWWh2cmd3MXl0M2VuRm1IcTlrL251bk9aVlloR3JLclloeVJ3WVhHbkRhOXVVcjlWbEpLWEpERkhDemQ3R3ZiYTQrcU9wYnhKVklrU0dERG8xa2szeVI2bTNFYlVaSHZrVDFQdG9ZMnhSZkV5WVJDYXpHU3VwcXR6MDlyeVZGNHBkR3lXaFZUWFJWdy9jcWNVdUsxOVlUVm5Nc0JiK0xuVk9JemN5cjNvbFpCa205R2trV1RlZktsNFUyT1JyRlR5U01pYVRrSUVPamNrSG1FeHkyRUJGRk1nS1M1UGJYaDQ0Qzh3anZ5S29RbGsxMzFGRGpNSEpxTm5Md2JqckZOdWQ1WHBISGk4YWxIL0ZlMzFOeGhWR3ROOHZHNXRlUmJ1angzR3EzcEJQQkl4c2pFNDBGM0kxczBHSHE2T1RmMU1nekxlRjZzelB6NW01VXJ2ZldDVmNGTWRaNkhvUUlkTkZnYTBpcENuMFZqYjRWbTYyeXNvSW13dytETEFlbk9DYzF3bW52YXhMaTBHUURGaXd4QUlwbzVVMnlhZmsxR05RY21vK05QNlJzdzNOZ1FrVEh3K3F0ZkZrd1hWMTJMbDlUV1ZDSVBsTzlreGtlV2JrL3dEY3ZQbDVMSnRVRkswTm5ZVktrQStJdzg2Znczd3FGMW1KR3AwQm1RVEVTTW9qemRRNHlDelV1TmdPYk5qVXNPaHJrMnVtREtpTWh6V1JlVUcxR0MvR3ZXTmJrZTlyUDAxZmgwSHBDOFRrNHBqeTlIZXlNYkZtVytUZjM3ZXprV0xMdk5hbG9FRGk0THBYOXVVVGNxb3htTGxVL2k5dDU5OVhBUUF3OWhJOFJNUm94TkFWZW54bWtmSHljaGtOdzYvUExleE1pYzJTYklCMzJsMjRzQ2hqU0twOGRsK255eThaNk1tNm9mVWNzY20yVVJvbHB2Yy85cjgyVVBVcXdnamJERjIySU1SNDQwREJvUEVaNjQ4eDdwbzJ6UkdBdUF0dmpYbHU1Skt2SG1wcGpHeHB0bXY4SEQvL0FCOGVZT2RIWVIwQmh6bVlzSWpaOFllelRiQzBxSFhOakFlYnVZMUhaajVxdmdYbFh3cDZ0czFyMzVZSnpxK2lKNnFzK0prdGlvWXVPMVhSdzltYUluU0F5Sk1INDh5L3BaL1R0TkV5YU82cWZhNXE4eGh3dXpwT1ptZm14UDhBNXZ5aVkwbWd3NlQwTEtWQkRwOTdYdGIrUzErb2IrdmtTQ3dFblJQTTVVYTJ1WXR2ZjlzME1jekdOYXh2anpLVCtjeituZWFKazBWWkk2bnU5cS9selpmNVRqWUFZNjJ5bUZJZFBrRStoT2IwM3h5SjRoNHk4bVJWQ3ByT1ZZY1dpNHhZOVhzYjdEWGFkUVZ5dGx4WVpkTFdXOWZvZkk1SUhobHdGczhlUlQ5UFU0a09rTlg4SWdFY2lidHpJZGZSWEVJVUV2OEFEV010WkxjK1M0dUlhOW9GU1JhU2pDd2pNK1NkU0VIMklOY01DM3ZJR2hKWVhTRWdTMHQ0MHQzaFZ5SnJNM3U2R3VZc1lIeU1rWTE5UGljbk1xQzVPVU5oYldyRjQ3bXpqcm9LS29lUkw5TmZVNkdOeHkxZTUzYk5LeUdNdkpmVzVSYjAxSk1hTGxVbkhUMWEwUytEMEZrYjJUUnlObFo4YTdzeFl3cWk3VUFFckl5Wng2YTdiWEJDM3dKQ3Rjams4RThySUlhMkdTOXMwK295aXQ1MFZEWXBZQjcybGhGWGp3UUdaRE1EWGpCTjdMR3ZoUGhwQUpLNGY0dGt0cllHZzR5UEZxQVdDQlBTbXBJWTVFTng0SWhIVmRuVTZxYitJdDNmbGhMcEgxd3JReFBxVVJhWEk5aUptRHdpd1M1RWRHeHNiUG83dWtqTmJUV2tnay9hOXlNYmo3VnNMcjZyTVIvVUZWejlUWDZ5a3FTY2tBWm9ndjB1UTFhV0VHTVdLbGo5bVFUOVBVNHJEeXFqNnE5WTZTb3hLUno2aVI2UnN4cVByYlQ2ZTRiN1ZmTlhpbSthUGNnQURGakMrcXRwRWlyTU8vdE9RU0xGVVlwQnlxbjZmS3grZFUwTXZPcWQ4MWtYVWY4QVI5VmxVL0txTWNoNU5SbVA5cHA0MGlyUHA3Lyt6WWIvQUdyZk5mOEFpaXlKS1A4QVZaRzlUN2VKaVJ4NWovYWFpUkphejZmSW50WlRZcEZ5NmZmS291WlQ0N056cWo2bTBOWUFIaW9iNVpOWkRHc3RSaXN2TnAvcDh1SVdSd2tYSUczSWpTYUhFWlZobitvSW1qSGhYblpIWVJSdGlqMUl4SkdZekowZG44K0l1Q1didU9MakRHeDJHUSt5N2NnaWRYV3NFclpvdnBqallRb2xjVmtoQUFjUVEyK1NEdkRQQ0lZV040NUZWc2REYkxZcDhBdVpCeHNRWStTYnROTGhEaDlST1NGRHdzSGg3VHhXR2kwUmo2MHp3UDQrbkhiR2N1YjRjNU1NR2tYajNFbFFESWJrbnFlSlJFR3l3eE1oajdDNEdFalZ4TXRKWW92RlBIYk1rcDdnYVpoRUhueXV4NTBsUGVqaGp3SGlUcHNSWUNRSVprN2VJdE1YWlNRUXhqeDk5MVZ4Mk1OUmJQQ2tSVVZPOXZDc3lyeEwvRFZMYXZzQ084NXEzbDh0UGFCTzl5dXhra3lZaU4zNVhMcDkvWVNNVnVRRnJCakhxY0dDT0czdnRLK0t3SERzQ3FXWVVxRXVMc3RyeUFMU2pXOHVxM0lvSlVaS3lScXVSTldOOElKcU1RdklKcWt5V2tMYTVITjh1UVhYVDZ4Nmw1T2lxOFV2UkdMaXZXVEdDUFhIakJIckh4Y1ZpaWhEaXA0cmFyZ3NXTm1zcUZ3RjBHWW5ZcThOSFhnUXVyVWttemRUR0ljQjRjZ0w2U3N4QWJsVi9ka0ZrZ0llTGdkT0xzclVYWExaNVNob1NvaU1mS0ZrOTZ0QTlOeXFQMHZ5aHozS2w1YUpXVUE0aTZQcHd6TlB4ZVZxL2paTXNvT1BoRExxeUJpUEhZNC9IcEsreUhQWjRpaTRCSXpiZ3F6bHBhV01ENGFvaW9iam9aQ3JVMjRPcExDK0hiN3pjY3ZyTDhtUDJhME1lSGpvVUdwSUk1SUFKWFVWc2lvcWQ2cndTNG5sdXJQSGJaWWw3Yk95Z3I0Nm9LYTFOK0dxY2RlaHV2UzN4UGExN1RzYllybVd0cFd2RHlBSWpVY3NjamV5U1JrYlNyd0FmVXVRR0dhRng2WWlRVWFFV1A1bDFYTnNSYWF6bHJDR1BhOXZhOTdXTnVyU1N3bXBLcGxkRGIxTVZpeGhOcFNhR3lNQ1hYdUFlaWJzQ0RST1FUbHlBVUVrc3JVUnFmUXFuSFJWR0NUcVRGM01jMnV2SUhMK1I4Zjl4NmxBdnBrL0dwNW5pNDhEQXNjYlkyL1BzNitHd2dTT3pvWEI1R0hOcU1pS1Z2Rk9FcE1NS0Y1SUhFaU1zNzZTdHJvSytMWlVSVUpvd0o5ZmpOZnFMSEsrTjBBOFE3ZjhPTHBnaXRUWXEzaCtObGN1SEZZOUIwNFFpLzhBbG4vL3hBQkdFQUFCQWdNREJ3Y0pCZ1lDQXdFQkFBQUJBZ01BQkJFU0lURUZFeUFpUVZGaEZDTXdNa0pTY1JCQVVJR1JvYkhCNFRNMFluS1MwUlVrUTRLaThHQnpOWUNEOFZQLzJnQUlBUUVBQmo4Qy93RFoyK091bjJ4MTArMkxpRC94SWwxYVVBYnpCQmZDalRzM3dNeXk2czhib1Z5YVFxUEFta0tzdFdkbGJJU1lOcVpzY0ZLam5KMnluZUZreFpYbEJTazdqV1B2WS9USDNzZnBnNXVlc1YzQWlCbXA4cjhWRVFRM05nZ2JMVUtKUmIyMzBKZ2Nva3Y3aWtpQUg1WnhIcmk5d3RtdUNoRlduVUxIQS84QUNLT1BwdGJrM3haa1pVcjRxaTg1aEpINVlDcHViVXE3WkZTMFhEVHRHRWh0aHRObkRWNlhuV2tMMlhpS1ppeCtVMGdHWG1WcE5lMEk1bDNPcEY5TFZmakZtZmt5RDdJcG5jMnJjdTZLcElJLzRDYys4bEo3dTJNM2s2V1VwWjJxdjkwVm5aak5JN3RmbEZYQVhsZml3aXl5MmxBNER6V2kwaFEzRVZna041cFc5RVdzbnpWb2QydEl6ZVVwYnhJRkRBelRvQ3oyRlhIMDZVMnM0NzNVUllsbTh5MXRVTHZmRnFkZFUrcjJSWlpiU2djQjUzWmNTRkRjUkJWS2tzT1k4STV6bjVmMmo2UlpjNWh6Y3JEMittU20zbkhlNGlLTkRNU3g5UTl1MkFwM24zZDZzUFowRlhWcFFPSmo3d0ZmbEZZR1pZV3I4eHBGbGlTeHdGazFnMFJaL01rQ05hWlUzeEs0S2xUaVNUK014emsrb0szQ3BqL3lMbnYvQUhqL0FNaTU3LzNqNzJuOVpqVW5iVk1FaGNkK25nb3dNL0tWdjZ4UkFUTVNxa2I2R0UxV1d5ZGloSE12TnI4RDBKTmpOT2Q1RVZhT2ZsdDJJK2tXRjh5NzNWSEgwcmJtRjAzQVltQ3prOUphWjMvdVl0ek5IM3VPQWk3UzU1OU5lNkx6QlRKeXlsbllWZnRGUlZsRmZ5d0RPVFJWd1RmQ2F0bHdqdm5HTExiRGFSK1hwRGJiUXF1OFI5M0NQeVhRRExUSzBLL0ZITU81MUFHQU5mY1lzNVFsVHVxQlNBTTVtMWJsM1JWSkJIRFRLMnhtWGQ2Y1BaQWJta1oyWDJFL3ZGcGhmaWs0ajBrR01uZ1BPbTYxc2psR1ZscVVvOWl0L3JnSWFTRW9Hd2FOdDl4S0U4VEJSSk5xZFhzSndpMDRyTXNuWWRVZXlLeksxT25kZ0lvdzBoSGdQTkxMaVFvYmlJcTJDeXI4R0hzaXNnK1hFZDBmdEFheWl3VXFHS2grMFdwZHdLNGJkSXBjU0ZKT3d4bjhscnNLeHNWcDdJNVBsTkpiY0YxdW54OUhseDlZU2tlK0MxS1ZhbEJTdGZuR29MYnUxdzZOdDl4S0U4WUxPVFdDVkc0S041OWtaN0tjd1FlN2lZR1lhU0ZkNDQrZEZMN1NWampHY3ljNlVLN2hQemdOWlRaTGlPOXQ5c2N3NENydW5IUzV3V1hCZ3NiSVNpWXE3SmszUUhHRkFnN05vOUdVVnJQRWFxQkhLY3BxVWxtbXFNSytFQnRwSVNnWUFhQlVzaElHMHhtY21wTGptRnFud2dQWlZmVmYyYTN4WmwyZ2dmSG95cFV3MVFmaWo3MjNGbk9xVnhTbU91NStpT3U1K2lPdTUraU91NStpSzhvQ2VDaFNMTGN5MlQ0eHpiaUZlQjZJb2NTRkpPd3huY251Rmx6R3pzak01VmJXVTk2bC93Qll6a3VzS0h3MFNoeElVazRneHluSnFsS2I3UTNENXdMd2wvYWowVm1KVFhtVlhYWDJZNVZsV3EzVGdoUitPanJtMDdzUUl0dW5NeXRiZ2Y4QWI0b3lqVzJxT0o2Q2pyNkFkMk1FUzdTM0R4dWlrckoyUVIzWVFweDh0LzNVcEJ6ODdkK0dzSE92T0wzVXVpcWd0emdwVWZkLzhqQnN5eUwrOWZIM1ZuOU1mZFdmMHdUeWNYOFRIM2YvQUNNZFo3MndjMU9LQ3Z5d2tTODNhRzRMcFNGNTFyT0RmWnI4SXN6VXNwQjRSUkw0U2NLTHVpcVNDTk93K2hLMDhZNVJrdHhkMTltdC93QllETThNeTl2MkhTTTVreXFIa20wVUQ1Um1abWlKalorTDBSeUhKK3RNS3VKVHNqUHpWRlRHejhPaFU0UnliSlFLMW00ckErRVovS0NzODhiNkhEMXhRWWFYUHZKQ3U2THpCUms2WEt1SkZmZEg4MDZXa2JpZmtJdFREaTN2ZEF6TENFMDIwOHc1NXBDL0VScUpVMGZ3bUxjaE0ydUZhR0xHVXBjbE8rbERGRXVXRjkxZDJuVlFzTzdGaUV0VFF6c3VlckdjbDFoU2ZobzUrVEFibVUzM1hXdnJDWldkRmlZRjFvN2ZyNkc1RmsvWG1GWEVwMlJuSGRlWlZpcmR3MEZPUEtDVUoyeHllV0dhbDA0bjk0NXNWY3ByTDM2UlRhenJ2ZFRGbVZSbVdkcEYzdmdLblZsMWU0WVJSbHRLQndIbTFGcENodU1WWnF3cjhPRWFxaTdMajFpQWwvbUhPT0VWQnFORlRicVFwQjJRWnJKNjFGZ1hsUDd4UTBiZjJvcjhOSFB5NHN6SS93QW81Rk9WenljQ2R2RDBKeU9TdmZWcWxRN01aeDNXbVZZbmRvVzVoZE53Mm1BNjVWdVVCOW4xZ05zSUNFOE5Hc3d1ODRKR0pnb2swNWxqYWZyQVhNOCs1eHdpaVFBT2t2anJDTVIwcE5rTnU5OUlna0RQUzN0SDBnQzFtM3U0clM1Vms3bTNFMzJCOG81UE9BSWZ3QjczMTBlVXltcE5KdnU3WDFqazAxcXpTYnZ6ZWdzMHpmTUxGMzRZNVhPYTh5dSsvcy9YUUxqcHY3S2Rxb016TmtpWEgrMEVCRFlzcFRjQU5BbFJvQkhKOG1KenJwdXRBZkNPVVpVV1Z1Ryt4WDR3RXRwQ1VqWU9nNTZZUURoU3NjMGh4dzE4SUlsSkVxdTRrd2JETmpqWm9ZMW43RmRoTkRIT3p4UVB6a3haY3loYVR1TlkrOXA5aGdLUk9nS0cwVmdsR1VTcFc2cEVHeE5DL2V1c0tVVWx3RGZReFdaazYzM0VwS1lvOHk0and2aWlaaEZjZGE2S3BOUnAwT0VaMlNveTl1MkdCSzVXUXFteGUzNndseHBRVWhXQkdpcCtYMUpySGdxQko1UkJROE5XMmZuby93QVFrTlI1R3NvRDR4VlFzdkk2dytmb0FyV2RjOVJPOHdjb1pRQlVvbXFMWHgwRnZ1Yk1Cdmd6TTJTSmNmN1FRbERhUWxDYmdCb0tkZlZaU0lMVXFrdHl2YStzVWJGcHphczQ2Wnpqd0t1Nm04eFl5ZkxldWxveC9PVEdiVHVKK1Fpcjdqamg5a0d4TE4zN3hXTlVBZEZmQnpzdTJxdU4wSE5oYlIvQ1l0U1V6YXBmUUdrV01vUzlvYjZVTURuTTB2dXJpb3cwckQ2Szhkb2pPTkhPeXBPR3oxeFZwV3VCcklPSTBjNDFxekl3UGVqa0U3VU9KdVNWZkE2S1orU1RSbXVza2JJUzgxZ2RtN3o1YnJob2hJcVlVOC9hRW8zZ1BsQUF3SGxXNjRhSlNLd0ZPZ3BsRzltNzZ3bERhUWxLYmdCb1duMVhucXAybUJNVE5VU3V6dzNDQWhsQVFrYkJwRkxaenp1NU9FZi9BTUpkWHFFVmZxK3JqY0lzdElTZ2NCVHpLaTBoUTNHRktiQlpjUGR3OWtWWVZubVBhUFpBUk5ETXIzN0lxa2dqZU5HaEZSSExjbUtPcmVVYm9zTG9tWVRpTi9FYU9mWjFabEY0UGVnU3MzZE1DNEU5cjY2Q20zVTJrS3VJaXc1VlVzN3gyUUNrMUI4OVJrK1VPb2s2eEJoRExJb2xPZ0plVko1TWpIZDR3bHBsTmxDZEMydTlaNnFOOEdjbnljejhlQTRRRXBGQU1Cbzg0YXViRURHS05wek10N0I5WUNyT2RkN3l2T0NTbk51OTlFV21sWjJXOTBBVnNQZHcvTFM1Wms3VWZSZVVwMitFY25tVFNaRzN2YVBMcElGTXdpOGhPM2pGSENCTUk2dzM4ZEJUWjYrS1R1TUt5Zk5YT3Q5V3Z3ODhzTm5uM0xodzR4blhmdDNiendHZ25KOG9UbkZkZW53Z0p1enA2NnRBdXZId0crRE9UdGN4VzRiK0VCS0FBa1lBYUZUSEpzbGkyczNXd1BoSEtNcEhPdW0renNnSlNBQU5nNkFaMTl0TmQ2b05IQ3NqWWtSelRMaWp4dWptNUpkZGhKdWo3b24yR0FwR1Q2cE8yaGdoVW1rRWNEQnowa1R1c3hSMlhXa2NEV0RhVXBIaW1PYW1HMUdsY1l1NkF2U1p6TCtOMkJqa21Wa2tFWFc5MEJiYWdwSndJMFROeVFvOEwxSkczaUl6VHl2NWxHUEhSVGxHVDZwVmVuZDlJUTgyUmZpTngwRTVRbGJuRyt0UWUrRU9qSEJRNCtkTGNjTkVwRlREazQrRG1XenFBNkJXUHRWWElIR09Xek43cm5WQkdISFFXNjRhSVNLbUM2cXFKUnU2RW9RS0pTS0RRVTQ2b0pRbkV4bUpNRnRnWWtuNHh6WXE2UnJMT2xVbWdpbWN6aSs2aStDbVFsZlhTc2Z6VXhtMDF3dGZ0QXo3eTFuYlM2RHpGcXZlTllDVXNOVUg0WW9rQURSTldXelg4TUZQSmtwNHBnbGx4eHZkdGlzbk5XaFNsSzBpelB5eFVOOUtRRWxlYVdkaTRxRFVhVmg1Tit4UXhFQzNWMlNKL3dCOElEckNxamFOMmlNb1NBc3FUZXV6OFlCcU04bnJwMEZOdUNxVkNoZ3RMcVpSemJ3M3dDTVBLcEN4Vkp1TUtZY0t1U3VZZWROWk9semV2cndoaEhaeE84K1ZTMW1pVWlwZ3V1ZmRXdG5DTHRBU1VuWE1wT3NkL0dFc3NKb2tlL1FVNitxaVI3NEFvV3BOR1A4QXUrTTFMcHNwK09pVktJQ1JpVEZpVFRubDc5a0F6VGhhWTQzZTZCbkU1NWU5VVVRa0pHNERwcUtBSTR3YkNNMHZlbUNxVGNMck80ZnRGaWRUbWw5N1pBVWdoU1RnUm9xYmRTRklWaUk1VEpFcmxqY29INXhiYnVXT3NuZG9vblpTOXBSdkc3aENYbWlDays3UUtLRE9EcUszUVpDWXVkYjZ2N2FCVWdWZGExaEZoejdWcTQ4Zk9ISGxka1E1bENZRlZxT3BvSWtKWTFjYzY0SHdoRFYxdkZSM25RNU16OXU5ZDRDS3J2ZmN2Vnc0YUNuSFZCS0U0bUJRRnVUYTIvN3RoTFRLYktFNk5DYmIyeEFpMjRyTVN2dWlxVVczTytyelNyaUxMbmZUakdjWVhucFhhTm5yaXpYTnZkdzZKU3NWU2NRWUUzSkU1aXZzNEdFdkkyNGpjZEJiYmdxbFFvUkMySDY4bGM3VlBmRlJob041UmxyaUZhMVBqQ0gwYmNSdU9nbDBYUzcyTVZHSG03T1RtTit0NHdocEhWUUtlVng5ekJJdzN3OWxHWUZUYTFQSFFXKzUxVXc1bEthdjF0VWNkRkVwTGFyQ052emhMTEl1RzNlZEhrdVRBVnUxcGJIeWdUR1VPY2VOOW5kNHhRQ2c2RFhXbFBpWW81TXRnK01mZTJ2YkgzdHIyeDk3YTlzV1c1bHNueGpVV2xYZ2VndmpQU1ZHbmhzR0Jqa21WVTJWQzYzKzhWU2FqUUtWZ0ZKdUlNWjZYQjVJczRiUENFdXNxQ2tLMENCOXFtOUJneVV4VU90OVd1SkdndHRZcWxRb1lYSXZLNXRmVjBGV1J6aU5aTVp0WjUxblY5WG16cjZ1d0t3OWxCNjlhalFhRE9UcGZHdXQ0dzJ5akJJMEc4blM2dFJQVzhZUTAyS0pTS2FBeWZLM3JYMWlEN29DTGk2ZXVyUUpVYUFiWTVKazRLelZiMURiOUlGQUZQZHBla1ZMSVNCdE1VUW92Sy9ERm1TbEtWMjBySFBQRnRLeGZyVTkwRFB6WnRlRll2Y2U5c0FGb25qYWo3SC9BQ2o3RS9xanJ2ZTJGR1hteURzQkVETVRHY1NrWVdvcFBTbFFCZWFVaWhXV2xibHhWQ2dvYnhwRUxBRHZaWHRFY21ud1RMcXdJdnA0UWx4cFZwQ3NEb0xhZEZVcUZJTXMrYlV1NXQrY1ZGNDBHOHB5dHh0YTNqdmh0NXMzS0hzT2dtYmErMGF4cHVoQ2llY1RxcTBMUDlCLzUrYk1TTFJGWERVL0tHMlVka2VWMTQ5aE5ZZXlnOXZvUEhRY2M3WjFVZU1LbTNldTcxZkRRS3g5cXE1SGpCbnBqN1J6cTEzYjlBbFJvQkhJWkEwWjdTdC8wZ05Najh5dHAwU3QxU1VKRzB4bXNudGw1ZmVwZEZ2S0RwUWc3UHBIMmVjVnZYZkZFaWc0ZEZRaW9nODNtMTk1RUZlVDNpNGphQiswWnJLRGViVjNoQVVoUVVrN1JvbHA0WGJEdWpNdjFYTEs5L0VRbHhzMVFvVkIwTEdEaWIwcWhVaE0xRHJmVnJ1M2FDMm5SVkN4UXc1azk3cUtWY2VPelFVaFlxbFFvWVhLTFBOdVhDdnUwRXpDSzIyVDdvYWNyVlZLSzhmTkNUZ0lmblZKNXRHSHkwR1pGckZkNStVTk1wRkxJMEc1TnM4eTExdm5BU2tVQXVIbHFjQkY5Ukt0ZkQ2d0FCUURRL2hzbmVWR3lzL0tLRFdkUFdYb2tYTGYySWpPemJoYWw4UVAyRVVZYkZlOXRQbUhQTjYzZUZ4Z3V5NXpzdFc4ZnZGQWJEdTFCMFMwOFBBN281Qk5ubUs2cWpzNDZLTXBTMnF0QkZ2OTRROG5IQlEzSFFUTnREbkdqZVJ1aHQzdFlLOGRCdWJiKzBiTkNSdWhsN2FSZjQrVmJhc0ZDa1RNZzc0Z2VhTHNuWGMxQkNDZXM1cm55bFJ3RjhQVGl1b2k4VjkyZzY2VFEwb254aHliY3hkdUhob0psbWp6anVQNVlRa2puRmF5OUROdFh2dVhEZ044Wjk4VmZjdi9BQ2pSTXBrNEZiNTFiWStVY295anpqNU5hRTFwMFdNWWpvVE01UDV0NU45Z2JmQ09UWlIxSGhncFYxZEVwRkE4bTlDb01oTlhPSTZ0ZHZEUUtGaXFUY1JDcFp4UjVLNWdUN2pvS1FzVlNvVU1PeUxwNXR3NnZ5MEZ0THZDaFNKaVFlTjliaG9TMDRucXF4aW84emxaSkp1R01BREFlVlFTYUtjMVJDQ1JSYm1zZENYa0dUZ2IvR0cyazRJRlBLcFNya2dWTU96andxeTNnRDd0Qng1enFvRllYUFRYMlNEY1BnTkhrV1Q5WloxVktUOEJHZGVvcVpQK09uejd5VW5kdGdwbFdGdUhaV09ZWXpTYlc3OTRxN04yQWRvVkZwYzZDcmVheDk3VDc0R2FuaXYrNGlDU004a0R4RVdaNlZVRmJ4ZEhOT2dLN3FyanBXMjZKbUU0SGZISWNvMVNSY2xTdG5BNkluNWE1MXZyQWZHRXVmMUJjc2NkRE9vKzFhRlJ4RUpDanpyZXFyUWFuR3NXN2pETDFha2pXOGRDWG5VOVZadmdLVGdiL0twZmFhTm9ReVQxazZoOVhtUkp3RVRjMmEwSFZOZENYazBYaE9NQkl3QXA1VkxWZ2tWaVpubkJoMWE3TkFNSk91OGNPRU5vVjF6ckswR3NuUzFldHJlTU5zSXdRTkRrMHZlK3NmcGdQUGEwd29mcDB1ZFZhWDNFNHhTVVJtV2QrSHZpM091S2RjM0RDS010SVNQRFRvNjJsWTRpQ1pZbGxlemRBRDFYcGNlc1JSdFZsenVLMGM0M3F6Q1JjZDhjam1ibmtDNDc5QWdpNHh0TXE5OE5HemhMUC9BNkRqSytxc1VpWmtITWExSHEwRmtkWnZYaEFPTGVwNVhHMVlLRkltcFJkMWsxcFh6SjllMGl5UFhBWGRWeFZmS1NjQkUxT0t2QU54T2dVRHJPbXpES2FVVXJXVm9WL3BNNytHZzQ4Y1FMdkdGNVFmdld1dG45OUJieXV0Z2tiekNzb1RZcXBSMUxROStpVktORWpFeHliSkFLaWY2Z2dQVDZzNjlqWjJSUUNnNk9odkVLZWtqbW5zYkl3TWNreXFDRjFwYk96eGl1aHk2VUZsMUY2NmJlTVZOenFMbERRS1I5b2pXVEJsblR6clB3MEE2anJzMytxR3lUVmFOUldneFBJdkM3ekFVbkEzK1ZTVGdSU0ptU1hkVTNBOE5BR3FRbDNodjh5bDJFZzY2cTNReTMzVWdlVjgzVklzaUFzaWhjTnJRbHBUc29wV0tlVjl5dEZVb254Z3ZyR3M4YnZEUVlrR1RYZjR3MjBuQkFwNWFuQ0EyUHVyUjkwQktia2dVR2dweDFRU2hPSk1HWGxhb2xkdmh2TVdXVTYzYVZ0UFRsS3dBNTJWN1JISkorcFozN3VJZ0tRUVVuQWp5M3dsOXY3czZmL3dCRUpXZzFTcThIUWJtMGZZTzliNXdGQzhHL3lsSndJcEQ4aXJxcnVCUHUwRktBMW10WVEzVTFVM3FIUVllQm9seWxhRFFsSmxKb29Ha0pXazFDaFd2bU11eVFxeTNTdngwSmVYU1JWYXEwaGxvQUN5a1llVXFWZ0w0bTUwMHV3OWVoTFNUZU5hbnhNTnRKd1FLZVZ4MWZWUUt4TXo3dDk5Qlhmb1psQjV4NjcxUU00S091YXl0QWszQVFKYVRKNU1uRTdQR0VNdEM1STl2bU5oZHl4MVY3b09UWnlnQU5FRTZEalI2MktmR0hKQ1lxRm82b1B3MEhFbzY2TlpNWmxSNXhtNzFhRXJQTmRZR2tOdXB3V0srVlNGWUtGSW01TlpQRDFhREQ2YTFRclpERG5lUVBLcFFwcUVLaVhVU0NiTkRUekdiZUNpYk5hYUREUU5RaWx4MEgxQWtFaXlLUUY3WEZFeGZIMmlQYkZRYm9kZk42R3EwMjhCb0psMDlaMCs2R1c2YTFLcThkQXEvb3NuM0RSVGsrVUp6cSt0VDRRRzAzcU42ang4eno3WTU1cS94RVdYUHRtN2xjZEJqS0xHMDYzakNIVytxc1YwSGhqTHEyRGRGSkNXb211NnNMdHpHYkIyRlVXa1RZQi9QQ21wcEJkYnJXdUpoTXJPQmFiSnVWd2dMYlVGSk8wZVZtWXBxTG9iL1lkQ1lGOXd0WFFrWDFRU20veXpLVkN1b1lXM1RxTDh3V3Jja21KcDlTUnJxeDBKcDVZQ3JGYjkyZ3d6M2phaHVXeWF6UktFMmJXSmdtYm02VkdGYXg5Ny94Z2NsbTdWblpXa0w1Uks2aThUOVk1bGV2M0RqNVV0ZGhvMDltZzVRMGNYcXBnTFVtamp1dDZ0bWc0K3JaZ041aHpLTXlLcmNPcFg0K2Fod1hTNzBWSGxkWjJrWGVNUFNicDFtelVEeUZTeUFrYlRISk1rZ3FHQldJRGs4Yzg3dTJSUkFBSERRNTVzV3U4TVlMc29vdVMvOEF1TWMyYU9BYXlEczhqTG9wcUxoaHkxYXFnWCtWeEl4S1NJbW1GSzZwNnZsSWlkWVYyVFgxK1lUS2tHaXJFV2oyMWtqeXVMVjFRa2t4TlBWdkpzK1VOTnB0dnFGM0NPVlpWVVZXcndpdDhXR2tCQ2R3MExLd0ZKM0dNL2t5cUhPNERUMlFtVm5kU1lHclU3WWNjTktKRmI0bXB0ZUtqU3VoTFNTTUJqNjRTaE9DUlFhRXZJTnExUWRieGhEYUJSS1JRZWFyTk5kdldFTjFOVnQ2cDBHNWorazdlZlhqNVA0YkpDb3JySy8zWkZodTlaNnk5K25mQW41QzVzR3FrOTM2UUhtN3RpaHVNVENSU3RtdDhXYlZTMnFuaG9UYklCdnFCb1RqYXJxMmlSNWc3VGVJbHdyYUxVV25GSlNPSmcwV1hEK0FRNjJocHkwdE5MNExUd1VsWk5TcWtWbDNVcjhJVTUyemNnY1lPVUp3MnI5VzF0Ty9vRE5TNHBNSXZ1N1VPdFBLQW11cCtZUXpoVmV1YWVVa3hNenJndVRoNDZDbHF3U0t4TlR5eHRvTHZOaWs0RzZKeVVOcmVBZEFPcEdzMGErcUpjcFBQdWl4N01UR2RkVC9BRERtUEFkQ1VMQUtUaURGQ1R5VjM0UW9YS1NwUHRpY2wxQUN5YTZIVjY5MTI4alFjQ2UwYUgyZVlOZ0c0cnZpVlpsdWRtTTNUOHNaN0tMeWtEWWs0eDlqYlA0NzRBRExkQitHRGJsMFZPMFhSbmNtdnFTc2JDZm5EVXJORWwxSnNlRUliUmNsSW9PaHp5QnpiMS9yaGtvcFpzQ2xQSlZhZ2tjWW1VTlB0cWRzMmJOWVZubmtJY1V1OEV4VnBhVitCOHJ1RlY2dDhNNFZYclhlYm9ObzBYODlCMWs5dE5JUzI1ZWhyV1YwYWxEN1JyV0VKU2EyMnRVeE5ObGVOZlhvU2lzTFZDZEJqOHZ5OHdhazJxcmZ0VklFQjJZQVZNSC9BQjBYSFZZSUZZbVoxWnZKcDBUeUtWVWtXaytNT3R2TEFESnJWUjJHTXprdGtxVjM2UVZaUW1TbmhXc2ErY2M4VEZFcFdnN3dxQ3VRbVZCV3dHNk16bFJ0U2s3OXNCMWhWcEppV2FBdVVxc05KU0tBSkYzbThnc1lxcFgyNkQ3b3hDYm9jZlZXMDRySG95RGdZbUpVM0pOUUt3aS9yYTEvaG9Tbjl2eDBKZFEvQ09uY2VPSTZ2akNzb3pONjFIVXI4ZEp5OGdyMVJTR2R0clc2TjJUUW9vVGFONTNRRU1wRmRxdHAwUzI4Z0tTWXo4bW9tVlVjUGtZeWNXcUVYSzkrSG5FazUxczNlUVBHQ21RbGZkV0FhcEZkaHBBS2tad0MrNEFpRnkwd3dXM3FneExBZDJ2U05LYk42eWtuMXhLdUxvRUtzM3g5dTErcU9iV2xYZ2ZKSU9iVkVEMzZFdC9aMDhySW8zMyt1RXRvRkVwRkJwWnA2dEsxcUlReTMxRUNnNk5rM2dMcytzVTAxTnVDcVZDaGhEUjZ0c0ZKM2l2bS9Jc242MHdxNGxPeU05bEhuWGpmWnJkRkVKQ1J3OHNxS0Mrc04vbEhTU2kyN2xnVkI5Y1o3S0V4UlI5WmdXM0hTcmFZS3BLWklPNVVCTStqT3RIYWYzaVFNdVRjYjYrT2hMaFFycWo0ZFBNTzJpUWl0Syt6ek5xZFU2cm04RWRCbmtqbkdiL1ZES3lhcUFvZk5RMjE5dTdjS2JJeno2ZjVsZnVHaXdxbDl2R0dYQmNGSUhTU2YvWkE4UEtVT3BDa25ZWWJtV0txWXRZSFpDSG04RHMzZVZGMUxHcjd1bnlqK2I1bnp0eHMwMWhTK0pxWEt1cWFnUnpyeUU3YnpCUEtBcmdCR0x2NklQUFdQekNCbXBoczF1eDZjazRDSEpoZXN3MGFqNWFWbDFDVnAzR0FsQUFTTUFPa2sycWJiVllHZ3B0eElVaFdJTUxsSER6TGgvOEF6eXpDaHJXYWtIajAxdVlYWkd3YlRFMXlSbk9xZU4xMkVKV2hzb0c0QUNHK1VVenRuV3B2ODR0dnJTaE84d1c1QmxUaTlpaiswRjFQOHZuTWFta0F6RXd0ZStrVUxSWHhVWSs3ajJtQ014VGlEQXpUcmlQZkZaS1l6aU83WDVSbThwUzVTcXVLUlNMY3U0Rmo0ZEkrUWFFaXlJQyswNmErWnR1dk4ybHQ5VTZURTJqRkJvVERMbzdTZkpQUEExcFduclBTMmV1K1Jjbjk0RTFsUmFzMnE4SjIvU0xERGFVRGg1MHRjeE1meTNaQWlqRFlCN3h4NkFvZmJTdFBHT1U1S2NVYitwdCtzQmlaR2JtUGNyb3J5QkRLVW01Uzc0bDBxRkNFQ284NW1MUTZvcUlRS2RSUlREcmhGYktTWW1YS2F4VlRwS205MVhVVEhMc28xVVNiU1VxMjhUNkh6MHZxVFNjUHhRWktkVlI5TnliV0o0YVJXNm9JUU5wZ3RaUFlLMTdGSDlvcTY3bVJYQ3RJcTVQV2p4ckNFaVpEcVJzVWFVZ1pwek9EZGFyR1p5azFtejNnSUNtMUJTVHRIbTc3ZWNiVzZVMENNWUxMYkdjWGF0VnJkRGpYSmtwdGlsYjRETGt1czYxYlVVenViUDQ3b3FrZ2poMEszSERSQ1JVbUZ6TTFVeTdadUh3SG9ubGN1S1B0M21tMFFDcjdaRnl4b1p4MjlYWlR2alBQcXpVcU1BTVBWRkpkc0Q4VzNSS0hVMzdGN1JDbWx1NXdWcUxzUE5seXpLRk15NE5MV0FJM3hXWlVYbCt3UlJsbENObHdqQVJSeENWRGlJSlFrc3IzcGpPeVQyY1NPc2tmdENXWHhtbitPQjZCcko3RjYxbXF2bERiQ095THp2UG9xZys3di9QeXJkZE5FSkZUQm1KalZsbTdxRDRRRU5nSlNNQVBRaGNaQWJtZCt4WGpIOFB5blZLazNJV2RJcVZjQmVZbUo5WUZsT0hqNkxiZkhXYlY4WVlkclcwbS93QWZJM2s1anRVSjRtRzJVWUpIb2EwaTU5dnE4ZUVGbDg4KzFkNGpSZk5hRlFzajF3MmRyaEtzUFJjMGxBcWJNSkN1eW9wRUtXbzBTa1ZNVE0rN2ZRNnZvaG1iWkZsdHpIZHhpb3cwR2tEQmE3NFlRcnJKUUFmUmN5dFdGZ3dmK3d4TXFTYUd6U0VLdXE0YlhvaFNnS2xzMm9sMUh1MDltaEt0MDFhbFZZVDRlaTNFM1ZjTm1HQVVnS1VMUmovNkNKWkk3Z1BvaWIvSkN2OEFzT2hMZjlueWhwWXdVa0gwWEx5RFhaeDhUOUlTaFBWU0tDUC9BS0NKWmFjTEFIb2lZdGJSWkVJTit1U3EvUWNOMm9RcUpjbFZTQlpQb3BieS9CSTNtRjVSbURhVXFvVFg0K1NaQ1FDUW1zTmcwMUNVK2lHSkZxcFdzMUkrRU5OZHhJR2c0MnJCWXBFekl1RzlKcUwvQUcraVZPdXFzb1RpWUJzMkpOby83NjRTaHRJU2tYQUR5S1FxOEtGREUxSU9IRTZ2cTlBTGFiY1NweEhXVHUwMXV1bWdIdmgzS013TURxK09remxGa2FxanJlTUljUWFwVUtqMFBibUZoTzRiVEZCek1vai9BSDJ3bGxrWERidk9nemxLWEczWHB2aER6WFZVT2tVVWkwb0M0YjRjUTZrSWVSaUI1aTQ2ckJBckUxTnJycjNhUmNmV0VnZStBS1pxVWJ4LzNmQ0dtaFJDQlFhUzJYTUZlNHdySjA1cW9ycXFPLzhBYm9UWnhpWmFteUxhRGQ1b25QT0pSYU5CVXhkcFZmZFFqeE1ackpyUmNXZTBSOG81UmxaeFZUMkJqOUlDRzBoS1JnQm91TXVkVllwQmtwcFg4c28zS1B4aW82Uk02eU9aY04vekVJZGJOVUtGUjVnSk5nazJUcjAybmRDSlY5aGJWakVpK0t0VERaMlkrV3JzdzJObU1XSkJwVGlqMmxmdEFtTXFPS0E3aHgra0J0bEFRZ2JCMEhkZVQxVndaSEt1cVVYSldZQkdIUUd0elQzejZTWVFXZ2xEZUNnZWdMTFpzdE5pbHFLeU0xYVJqUzFUM1FnUFMxcit6SDJSUnlSc25jU1krNkovVkF6TWdSWGJRbUZBOHlrK0NZQzV5WlU0ZG9IN3hTWGFTamp0NkN3N2Nyc3EzUUpXZlNUTGpCWDdSbkpkWVduUnNOODYvd0IwWVIvRXRhM1d0bmJUd2l4T2N3OE4rRVZRdEtodkJpODBpaVZaNXpjaUMvTWtzc0RxWGZDRlNzOGxRWlVjZDNHQVVtb08zcGpMU2h0VEJ1SkhaK3NDYW5CV1lONEI3UDFqbjJVS08vYkZXWEhHdmZCemM0TE95dFlHY25CWi9EV3NWZWNjZHY4QUNLTU1vUjZ1ajV6VmNIVldJc09KejhydjJmU0xuTTJ2dXJ1MHFGek9MM0l2amxZWUtHV3JnWWJkN2VDdkhvblZWMTFhaWZHQzZSck9tdnEwMUJLdWZYY2tmT09VTzF6ejE5K3dlVzhBeDFVK3pwUzIrZ0xUeGpPWkxtRCtVbWhpazVLMmdCaVJUM3dMVXE1YTIwTUpUTFNhbEU3Q1lvZVlaUDhBYjlZRGpuUFBEYWNCNUZLY2JzdUh0cHVNRGs4NWR4RVZtWjYxdk45WVNvcExxeHRYKzNrTFR3OEZiUkZGalBTaE9PejZRQ3lzV3RxRGlPanR6RGlVRGpCbHNsb1VFOTdhZjJqT09IT1RCMjd2TTZFVkVGU0FXVkh1WWV5UDVPWnRwR3l2eWhJY2w2OGJGZmhGT1JtMVhITm1PYllzY2JORDc0L25adWlNYVdxKzZBVnBMeXZ4d3BsU1JteUtVRUxsbnovTE9iZmhBSXc2RU1TWXRvYnJUanhnU0U3cUtUcW9KK0IwcXVxMSt5amFZL2lNOWMzWFZUditubWw4ZFVleU1CMFJTb0FnN0RHZHllc3N1RFpzZ0luMlM0MkxyWDFnQlN5MHZjdUt0clNvYndkRXFjVUVnYlNZTlhyYWhzUmZCYnliS244MkpqUFpWZVVwUjdJUHppd3cybENlSG50aXRsd1hwVkhJY28xRFlOQVQyZnBBVWdoU1RnUnBGU2lBa1lreHlISjFWSk54VU8xOUk3ejZ1c3FOYlVkR0N4QVJNSXowc01EOVkxMUthUDRoSDNwbjlZZzJud283a1h4bWNsTUtyM2lMNDVSbFp3dUw3bGZqQUF1QTlCWHhWVE5nNzBYUUZTazJwTkR0MlFvTXpZS2Q1WEg5VC9HUDZuK01BTG1SNmwwaXMzT2xYdk1BbEJkVitNeFpiU0VqY1BRRmg3SFlvWWlDV3hucFgyajZRQTZTeXY4QUZoRnB0eENodkJpdXlLdXVvUU9Lb0dacStvOTI2S3JxeEsrNzZ4WVlGNXhVY1Q1YUVWQmcxWUNEdlJkSDlYOVVWc0tYd1VxTExMYVVEZ1ArSDY3SVNyZWk2T1ltVkQ4d2pOL3hBNXZ1MzBnY29tRnFOZXlJQ20yYXJIYVZlZjhBMWEvL3hBQXNFQUVBQVFNQ0JBVUZBUUVCQVFBQUFBQUJFUUFoTVVGUklHRnhnUkNSb2NIUk1FQlFzZkR4NFdDQS85b0FDQUVCQUFFL0lmOEE2YW54RmxBYnRmNEN2OEJYcCtNK0UvOEFrTHlXbGlpblE3S0N6NzRxQ3Fza0kvdWdXRDVqcXFETTZnSFNhNURXQkw1RkVCTjQzbFU0WTBVZnV2OEFiL05mN2Y1cHhPckcrZXRCeTdVaS93QjFlQkFYMTh5b0FVK0hRMUtKcFl1M3RRd2JGMGw2V29BbmtKZnRWK3VSSnQvL0FBNElxQWEwN2FNNjMwck54UmR2MktCRi9NeDVqTlBEY29TejFhWUFDRjlIbkZHaHRBU2Q2ajZremNpNDFpZ3NNR1paVVNEY3NrZVZFZFdkQittbHVGRnlYMXZVRmN0SDlzVnpJQU0vK0Ftb2dpVGRMN1Vvc29DbDVLbjNSL0VMVWNjM3Y2RkhDZlNMN1hwWFJLa0FYWGoweFU5UTR1YzdZcVRxekgvRW1qVFNDeitjSXNiV21PcnBTVEs5UUk1cjJwK3k2RWp6eTBGRnlJaSt3bjZVVjF3ZWlqNUVRaS9sMHBjakhsbEx2bWhhKzRXN3BRUVJFY0orWW5DRnpJNnVDbEJlby8wVVZIQmVDeDVVQUFBQXh4c3dnbVNMVThETEp2VnZ4OVlQbFV3ZmRMUWcySjhQTk1Rd0p1NThxYmdVcmxvZzZ2aFBPYS94S0gvaWVBVHBPd1FIMUtKT2hWVnBwMG9ueXF5aHJyczlHbzQvUm8rcmlpSnZrVzgvUUFpSkk1cm81TkhtWWFaaGxvR0RwbWtjblpIUTBmbElpSmJyb0ZhdGxZc2Z4WW80MUpaNVJyM29BQUFhSEZMZnh0WXF4T1A4Q2pSMXlNV3ZxbE9YSlprczZ0VGJYTlU2akZGUlZtQVorbyttQkNpMEFGUk1LcWVFaGtUZnFZcUJLMnFEdlFNSmhrNStUYW84bTZmN1lvS3dZVkp4b1RGZldQT2x4UHc2ZkwyTlhEazJDZFB5TEFseFdFbkpjT3dhdGFGOC9zTk9oUXpkZ0RoNXVHaXFjSzRGQzdaYUxrNjArUlVUcmVQOXFpcmFvK3lpbksvdXFrazdWVUJKRzgvejJxMFR3c1Blbk83OEIxT0sya3hHUnFjWVhZT3IyYWtTYTVBV2RHbldnQWlJNFQ4Y1B3SmhiOGdhMFNpRXFqdXRlaFE5bFN4dTlOdUY0QmF1clNIRTduL1ZIRVZtRFkyMktpeEJFVXZ2OTB6WWJMK2RNdkpKZVZOQ0JQYXdha211TFI3Y1dDeWpPK1ZBV3FtWDhuUjVVTDFwZlFKK01lcGZQZGJGQmNDSzRjbWh6b2Jhd0RneWdTU0FxVkxEZG1kbXRTZEYwWmZBcmNtaVo2bjZTQXloRkNRbEt4citocDlZTlFsZjdpdjlCWCtnci9kVnFXNGxLblFZVGVIN3FUc09ZMktuNk9kSHd5VW9BTEU1Y25KUW9xc0t6MzBWb0F0MzVFNFJIdkFKbW5GK2JNdTBtaWowZ3I3ZnFibjRxZjUvY04rVkt3ZW1TVG44S0lZOFpwWVR4ZDM3N1VFakdnSFkvYWdwdXA5NmppbW4wWkcxbDZWYUJ0bXpQN3BZdXBKVEhPV0NoZ0MyeGZVRklWd0xNaXZlczR6UkkwK0RKR0VlVVZ5djhjNnU3L3h6WCtQci9EMGxabE5pUDNUSC9EMXBqWW02ZmlydklXbUF2T0dtL096SUhtb3hRN0VpTzFGWTRnenh2STB1SUxBSjBNUUxpTThhSnAwTTFKSEwyS1VDZ0Zwa050eWFFY2NDVFRNZThCK0ZLV2pvc2Y4QVhLcC9EaHVHNTdwT2RJWEh1aytUenFQRXlvQXl0WDg0a0g5NTFlMlY5STl6UUFFQ3dIRlk0Qk9RN1UxVjBjbnNvWktuWmRLSm9DWmpIdnJRc21FWkh6YUNNWXFQclFZYVp0dDYzeG0zNjFPbURRNGpsaG9zSFc5K3cxYUQvU042R2VKbENTQjM3bXRjOHJrMm5SMzVVYndVN3JaT0dYNHY3UFZRSTIyZzluYjhNdVNUbnVrNS9xclhCNzNTK2VBRXFTcXI2YWxuVFIrRkFnVmd1Zmh4UUJDMTVoNXVsSEtVc2lEL0FIYWg4ckY0Nk4ydVZ2b3Z0bVRMWkNTcmVaT3BkcWlwbm14YTVtU211alhmMythSkFUQ2NJdDFoUlVFSmxNb2NtcHpxYkJNdVhQZHd1alhLWS8zVnVBa3QyR3JuK0VkT3EzUTZIUDhBVldYSDMraytlQ0l3dldkZ29DVmdPZzJOK2FocHpabm03OEppQmlFOWlvM3d3TEZ1ZndwWkdyR0Y2YTk2QkFPQUlENk0rS0JLZzUxL28wT3dNOWZxSk5hc1QxblUxcmVBY1REKzZDMEphYTcwMzRRRUlJNlVvVXV0bVUxMk5DWkhzQmFuTGhmcWpMYWVZQ3RaNy9naEVycHNHOVM5cGNydGVCUDJWaHliRk0yV0lMQ2YzTFFYUmFBSEFUUVVxNEtWVEpWMEI1TmFtcm14K3oyckVrd1lEalFKVURlcHFETXJpZGlnR0NReENONW9DbGNUM0Zxc2pwaUI5YWtJWXRUK2dVeElCWkwrcE9jMTJmdncrdzhFQUpXaHdpbmQ2Y05LZmxGRDZOSUFkU0tzOG14RHBWdE5Nd3U2VkNtaFo4dFFBYmd6eHVnbFdScHRjRjQyYjJwSUFRWkFidXlnenRPcTRJckNHeUdFTitmT2xzRG9aZERtNTBjRHBKRytjbk9ud0xEZjVPWDRDWG9LQm40S2pzSWRYUnR0UjQzYUEyVzcwS1NNOFd4SDl5MEVRTkFEZ0JpT2VieUtBSm9KTnVxOWlyc0ZoM2ZCeGdnZlNUUXp1WGtGWGxReFVNT1VZdG11dU0rUlFRQ0JGaVBwQUlBOWFITWhsV3IzcVZJK1lIWm8rV1V5bnBiTkZFbGFmcXNOR1NVelk5Y1VSSUt3bXZFK09kQmJvTk9ITEVsOGpSNTFiZUE4SVg1Z2VRTm41bzZlZ2MyL280RUVSSkdwb2lKc1MxSGsxT05qVmxhbjMxMUVSeXFaYnY3ZnVoTGdJRGJ4bWJNcVN0VncyRzNOVWVZdEFEZ3c2VERURUduK0Q5MWdxVUhDZ0ZXQXF6dFdtc2ViVitiMkhLL2JVVzhIRmc5SzVLSit5aU5oeU1sWklnblVvQXdmUUl2MksyNHZVL2lqRDNoSkhoVW1XeUptb25zbktoeTNPVldBdGJ3ZUFhUldQQTJhUFBacDVuc1c2UEFFb0NSclMzU0tOeXoxS0xJS1JOZnZaUHVraGRaNlZCUVd1VjM4UUN0Z29XeTZtM00vYWhpQXdhOCtCaG84bTcrS3ZFR3hqMmxCcEdnQ3djS0svRi9kOFVzWERtZk1hU3BBMDVoNUZSOXZlVk9SNW10VFFwN2dUM0dTZ2FOZGMrN2hTUzlBVGRJUFZ6VUFGYUN0L3ZoUnZJL3RMbFlTb0RSeWNBTGdDenZSTDlOTWR2dkJKWU1JM0d0Rmo1ekRPeHdLcEtFdVp4V0hydmhxN2RPQ0QrRmh5OWltbU9ZMDZEbFF1VmdFQWNCSWdCZFdwbUw5TWgvbWFLNjlkWjd0NnR3MkFnT05vYllhQzlNanhFbTlCbVIzSTBUczZYaC9Ud04wR2NGK2thRkNZNkhJVTZwKzZlb1R5Q25wVDh1T00zbFNRWUlGOFVBS0VkVGpRaUpJMXNodFluczBFZ2dIa2M5em5SU0RsVWp3bzJiaS9tVWNTTFFTSTcvUEExcjJTS3pjOTFXRVJhZXNjQTd5aDVTdHR2dEF6OTFjeU1VMlRNd09SUjR2WWFHbnFwenJLNUdmVThFaUltNVZJZm1yQnNjMmh3QUFiY0Fqd2xLeVB2RVR6WHRXQWtHUTlOamlkQ0RWcTZycU5GMXFLREphUm50UWNycUdJN0ZKbU1aQkFsWVA1MURwUWtWb0kwRkliQUVCVWVFVkZLcDdKVGVrUkszQk85T3NFV1lEVTBzNEExNU5xaTlWOHVPdUtUeFlBUWVlS0xDVFVaNG1YOWlSb01sVTVQeXFjbzJUTDJlQnJDQVJuTzMzcDFrVVlyN25MZ25zTUhLbWFSbVJuM0NuWWxFajR3VURCeW94aDczRjhQYkZESmI3bS9taUI2SHZWNndIN0I4WmdBSnNVSTJ5OWRCMWFBQ3dQRllwbHRhSUlOMXlOSzlkQmx1OEcwMG1xMktKUVBoZi9mMG9SY2t1cXQxNFJoSktJQ2tuVE03ZjkxcURJQmQvTjZWa0RPSHlycC9WSDFrcUZrRWpTcEpZdytWYm9hQ1kvdTFDbjQ0ZnZ0Ump4bEVqd2orS0VyZEpVWTVmS2p5YWpidjQ0RWt2UlZ5a3BhV1Z5ZEtGMk9qbHM4RGpBcFRWOFU4akpKN0dlemdmUk1PVTFLU1d4N3cwZnVIUHRhTjNRcVI5TW4xZmJnUmxBR3djVWlwWmg4QVJuUXdPVDV0V1hBRWpnZ3JKS1VXbUNPbjVVRzRFQWZ2aFlTZ3U3OTlxbm8wQzR1aHJSQkNlYTl0dnRGUVV4Wi82cVVvdHlCeWFkYUJ3YWk1Nk92Q0M4OFhBbEoySzR6OFNveFJzbnZ0Y0JwNTRVL015enlOUG5SR2tva2VDeEJFUnJwM1ZadEQrd09BcEdYSTBoejVORUNTcmo5dXQ4Mk1kM3dVRzhBSGpjWW5jelFxNW1GM3E3WTRHbHM0TXJvVkNtRGt1YzZjQ0FWWUNtSlVLdkR1L2FtUVpsWjFGNEZBbGFYUE1vVC9PZFBRNVBoZnMwVEFHQVBvUk4reEdVV1ppWXY0TVl4WjU4eGJVNkxHWVdwNHdDQVIwYTE3dGlYZmsxSm9xL2FOditxRWtUQ01qd0FOZUFrU3BzR1VaUnU1N1VKa0pFNENpQ2ZuZFR2U1R5V1hjSGJnbVRNRlBPWGhhVG85K0NBeWY5OHFMMXduTG9mdGhva1dIUFNyK3RxK3J3TFRJRHNsdjBLMHIzTzdxK0xWNGtkRzVlaFFMeGhHdlBndlQ4TDBYL3JXdml3TXUzUTRDYUNsV0NnemxxdzYxMHBLdVM2WG5ZMk9LN2hKU0FxVzJVTnZPa2l3VUpMOTV4VTZiYkRBSFJTZzQ2Q0I1dFFTVTlIeFRZTUxwUzF6UG1yL1NWZDlwOFVjMzlBdHpScEcyYVF5N1E1b2N3aTVmV2NWR0tXaEhyWE1jcEp4RnpSWlA0S0YzcGVjT1RsUmRpU0hCTjhaY3VmV3BSd000QTArZEFsRXVKcndRVW1JaC9FNG9pamNCM0RnbUVGdXk1dTFISzNtcHI0dEJER1NEb3JlVDl0QmNRWjV4VER0RXU3cStOME1TRzdVMUNxWGRaZUF3VzFCelVPZHJxTi9mZ2dFd2Y3ZENoanpPODU3K0FVZ3BWMG9iZU8zRXkveTlYdUdVeTd2RG1Ja3NGTW16WVhvR3RIcjFKTXZRMFZGdldINlZCaHRDQ28raTRFbWlUU2JGT1JmcFhVRGRValVEWkszYzByR1NoSkhobXZxNDVlNVNJVVp0Z2ZzNVVVa3JkSEFrYVlpdzdkR3MwMUNJc3oxY0ljQWdOdG0wMU81d1RvQURsVGo4MGl6dW94NHh3dWttN05TakJkYlB0QlpRRXRFQ1Y3WEZEeGt0VUNIT2dxSFVHZXV2QTNpU0VldjJxT3d3Tmp4QjNnSldsdWRoUUpZRUFhY0Vkb0hjdjh2VnZZOFdlUnk0Wis2SmZWMm9mSWtvdC9HclFFYU4zZnVmWU1JOXR0NzFwMDRYdHlhZFNpRU5MdjhBVy9EUC9HNTVlNVN0U28yUElPVFNBSmNlRFNSVU5kUFpWdW50RG5nU0h0OU9iczFPWEdQWTU0R1JrRjVBOWFrUkdMSFFaOGNqSGZlcDBDRmR1WjlJKzBTTUhxR2ZTckdkTTJjSGpoWkpVK1hNRjNMZ1EvSG1KWXFXQ2U3cUhQbndXMFMyNVA4QXFyUTNuenAyT0Mvd0Z1WHFXdURoSmZZNjhLaXdkU0R0elZKUVJpSTVuZG9BZ3g5RkJoQTlhLzF2b0NSRWthNlRBSXQ5alRWdE1PdzdOREpiZ0FpOEE5T2pVMUYrTjN1OVhBTHM4ald2VlZ3ZjRWUGpKUUFOeHFLUmZIZlY3Y0J1QzdHa2FFenBTWjlPQlJVT1RoNlBwUUZnU2ZzMmxaU002dWZTaEJRRUhpMDJPMDZhMXlLQjM1Y0RORnNkSmZCV0dDbnQ0cjJTUTZGTk9LMm5MNzBZOFVvaEsrS0Q2Wkx1dWh5T0JwaXl2VXY0MW9DQU4zSU5qak5ZSnZueVZmajVLd2UyYXY2MmtrWW9MSHlMSHlLZXEyYm53L01JNmxwNTBaT1JZRC9Tc1owYnJzMW5DSXBKNFVNUmNubGF2a0hXRi9GNkdjY0VxWEFRWmoyMWJnZkxIVGdKU1owSGNLdVpkMjJmTGdzaVBPWmliUG5SRUVEMGM4RnBFa0Mxek05cVV3VGduallkQVQwYTBWT0RYN0lLbUFsV2pIbk9KS0pjZVhBNTBvTlJMbjBvQllFRGw0enZUSEd4VnhxZVNaUC9BRGdzZnhFWmpta1BtM2F1bmkwalZrR1lmK0t2ZXhKM2RYZ0ZhcE9ZUExlaWlKYVhRNkhQaXp0Y1hGOFVqWnRuMVVoRkpsU1BObHJHdXNYY2ZMV2sxYlFUbWFPUG9TM0Rya3FCWkhMWWUyL0N5QTZNZG1yTzJKclFOSG53QzJRaE42d2V4RE83Mm9BUmtmRkJFY05UUlRoT2duczBYOGN6cFZTd1JTYVRZOEVCTHNPMmF2OEFKbFc4dkVNSmU0NTFkdVFGY0l3bjJVT2NxVGV5dFhBbkY0eDRuaHhMVHpKS0pxLzg0TklnTnRNdFNCRllyeThGMXFjWFNQM2FQSFQzUjNXS2ZSTEV1dCtCRGcreEJTWFVFWkhoRFNKS1lDcmFxU1YrM0xuVEpKcFNrdlBlakpnd0JBZlRGaEV5T3RTYkRZa055MnFOZlFmMGQ2QUF5T0U0RmhybllSczUwRDNsc3UvQWR1M25udDNwSGlTQ2N2OEF6amdNSlZ0TlhtamlsM2N5Zjg0REFsQXVKTFBwVHlDWUUxOFJ5TktwUkNpeWIvOEFIQkV3Wk95SDdrbyt4bmt1UXpHa1ZBc3Vjemp4RFF6RmlacWVCZTV5WVBGbzUwbUV6ZTc2VVFEQlk4WTAzR3ZLMUlNWEMxai9BTjRJWmdTQnYzNkZZODZlM2lRVUFYVnFldGpLWTNQZWo5Z2cyT0EwQ1NqRlgyZGxZL2hpcytRSmZyb1UwV1M1OFV0dTJCWGoraWlPcktMSjRnZ0JISTFJTG1IS2dNWm9HcHdFekN5RG5qNzB5b0tDYW5qbVZTNlVpdDdDWEwrWW84YjdUWXB0clVjM2tYdGowNEhuUUJlaHMwZUxoOTRCZTE1cUFRZzNmWTNPclVQbTROUWdVZGk5UklESmhPdml3MEhKNVZDaUNZRHF2amd2YnNBZEFySFRUMjhjcVpkWDJDbHVaWGZUZzVNckdUVlRJN3FEWTRGREFTcnBXc1FMYnErMUFnSUN4RXQzN0ZhT2lpNytLU1ZkWW9kdWpSNGxrU0pOaGluWHVlWWI4QW1KMHJNWkt5alN4enQ0TGJrcTh5NTcwOE1sUGZ4Q1FXSTVORldPUkZtV2ZMZ3hnVnlUclZyVWtRdkx4WXhPY2NoaTFNQW5ra1crd2FpeEplY21PQkpPOE9FaTZVZUt5WlEwTGFqWWpRTjR4U0pRQnExL2lhSW1PVWphcjRKeDRFZjlIZ3ZHejRkRkFrRU1XcXo0NFhvdGI5YVNXODNoYjBXSjlHaXZaVDErekFzSTRvWDJxdjVqazhqd0JsRUJIK1pLU2FTSHhZU0dvUElHVkZsYzhta0xjVFRkM0ZYdWdscDVSU0JZSXVuOTBpTjRnVWJiRlBCSW9waGIwTG81RWtmRmk4SlJWQ2tFOFJZUmFib281OXJQVjR4VWMwY3d0Ulc2cEx2Ti9zRkxKU0RvVWNnUW5ObE9BdWtyZXFZUFRnakticXZ0eXFMdUVoWWpWd1ZPZkdtWHRURmNuNXZtcERBSkpiOWltRlZRajIydzFxR1lrdGtlSVVodmcydGUrdEhqT3RNM1BQcFZ6WXlYUEFRTUtZWjZCUjRFRlpjL3REY29KZlZoaUhQazBRSkkzSHhHQ0hQNmFLc3dUSGtOZlh3SmlrcVFGTm1HejNlam9jNklsRzdPMzVvR1YyQVFIQkdOc3Rudld2RlpFZ2NtbldwMWN6STZOendnSE1DNjN4UWhxNkxWMThWaVVJbm1WR3pJcDZGOFlpeWlWRHlBSTJrbjJDaUNjSlUrQ0lGNWVMd3dvY29wcEZCaHl6NDVNV0duTy9GV1VKTjlUYnBSc1Z3TUhBaldNaEkweVlEUDdoUWtycktCbSt6VGxoYzhMRkJwTWJMdSszQTBhdzJYaHl0eUtOQUNBYkhBYzJCWm90KzFSb21MbDlxUjVYZjkxMUJpbHRqZ0tmUkpZNktBQ01qaWpzTnpzeDdLRUJrUlhmeHhnZ0pHeU5UeFFZL2wxRFpLWk9kaW5zeWg2TDFmNmRRNk1uaTFBcWI3RU0rTFRKUUFEbThuNyt3YVVTMngxcFNoVXMyV2FjaGVzVlJvKzR5ZDZudlFiQXZUeGtsa08xUmUrb3JuYXB5SGVsSDdYNEQvQUNIMEVNR2tERTk2V1RBSWkrbzBUSXYwMVRqMDhSaUVCTFNjRkc2OTJMOGpnekVSZHFtclNsZFQvd0ErMksvUWxVQThsNUE1OG80THVtT05XZmFyNUlsbVVMS0NPRGNUblFQb203ZU1CS2o4alFidmNxSUtJalFKVWQwMXljUjR0Q1FRUGNEZ2VDQnVsZjdmWVAwQmczczFGSWdMWmM5M2xTSTlZRXc2WUtId2loVlFJOElDRmN6OU9YcFdZcGlONVV1QkVDWWF0R25EQjlCckRUeUdzOTZhOU9WaGp3NWhBVUZTNEtGek5tcGhXT2hHS0hCb20wMVBnUlp0Q2FwelJXbDQzVlAyelV1akN2VVJIQmlOU2l5UlNHbHRQT2o2Umd5Ni9MVW9rU1c5dHA2VnNwdlNURHdBZTZaWFc1d0FJZ0pENnZzQjQ0TjdpMEIxbys0NGJoMjY4T1FBNHpTQ0Mwblc3OUx5VUV4VnVWQUFIL2FsTTVSS1QxRDVybGpGNzhVeXR3WWhqeXE5MnNoL2RNbWxtL2VaUnpjZWVsdzBOUHpRN05CSUtPZVQvYWhleTVMZmJpTER6Ynh3SHl4NVJmRk1jMU5xSC9aK21OOUJEVFkvUm13eWVsT1pobHpLbzhmUmNDSW9xWGVjbjE4TzFBM1dLbXJhbHEzNGtWR3h1UDRvWWJLYnR1L1NTYk5TbDFjR2k5QWpRQ0s3ejRiUTVvU3MwR0ZjL2pXbUJ1Ukc0b2xIYWpIMjZGWUdWdVJoVUNZWkJ1OWRxc2Q3UnBVRUlTbkhsVjdpbHBiTm1sclVjKzdmNmhXeTlIWTBqeVFDZG05ZjVHcFN6NWpmQTZyTmV3K2VEMW43L1hkK2JFekYvd0Rpb1R6RnlPSzB2YXJDTkVhbHdNL1RON3BCNkI0emt4ZzFOdXpIUU1mYlg2dXpYU2M2dTRya3BEcnUwZE5kQkI0c0V5aXhkeHJRQWdnd0hUNmwxZDRHdUZXZkxNWXZZb3kwVUlEU3NqcExIcVVyeEZtbnlvamdHd1JDaTNBSEFTUTdpK3VycEhpOG5LajdLWjFKWUl0eitnYzBrZ25tclgwRGRUN1Y4MHVxdWQ2S0VOMVZubGRlR2ZoR082SW94VkFEMCtvQ2VDWlhyMGJ4RzQ4SVRWcmlEcU0wbmFyVWVWWlczZzA1bjloRCt1TG12M2NFbEQySktZZld5T3kvcXB5VEN3UmlyWGRxbGZDaTR1REVPVFNoSW9GcXZScFNTTS9XY01DbFhTbHhiaVl0aDc4VnhZVERKUXVWakFENmk2Qkx6b3IwWndFQ0NOUlQ5clVrM3k5dkJxeFlEYWhCOC9XanVTMlJPUlRoS2JlVzVjSFdoa2VXbG5VYTVQVzE5d2RsZXJGTnpEQmJQVEttY2dtY3VIbHRVaDNGZ2kvV3A4aVprejZWL05lOVpFWkVtU3Izc3lzU3BXUVg3TjFMQ1dEYU96VzZ6QWI5UjlTVVNXZ203VmtNaHZMQjltU0RPSEY1NGdBcEhubVhwQWl3c2I2MGdTNEtZRkpLWVQ2bzIxcWVuUFlWSEVGM0M3YUtCamV6M3FQdVkrY3B2a05vMHEzR2IzbjMrZ3hCYUNuVUFrN1czSlhWNjlrNWJQS2o2RTFsNDV0QTB0aHJhMVJSdmJESDNOdzZEbE0wcUFPNGErOUE0Q0VOYlZiUERMbEUvVXh2aURxNzlLakpxSWwvRnFqOE5ZemNvdDBkZWRNcVRMM2k1OFdmTEN3VXFCbUF6UFFWZGxaNmZ5cUkyS0pLOTZ3Ui9TT21qVXNsem85YXRCMWxoRHpOcXZST0ZrZnRtbXkxVE11Y1UzZVhKZ2VsWE9SZHlCcTVrMERCZW81NUEvdFJkSzFVL1JNUE5DdFVJREg4NjBJSWlQeEc2a3VaZTVUQUIzSm85K0J1a2xoeTZWTFdFcVhJYjg2a2RkVmRkK0VyMXRvdTlhTSs5ckQ3Wk1Va003a2RlMURFN1RGSTRGR0dXci9HcTU3cGcwcFFZd3RwNlVHeE5QeVdhbXcxdDN5MjZVY2RrVWdQUjcxQTVpOHdmeEtVQUZIZ05JWHMwZUJrWm9hdkc2TzFzOTJqOG5BTEg0TnJMNm1uK0d0WG9GK3BGMjJhR2VGekFham9WTGpESFpXUFQ4V0dtUE1hVUNDSVpCRmxuMThDdW1VSFV3ZEtETENYZDFmd3dsNEM4bWcyZXdkM2hqY1hXSmxzL1UxUE1TSEIyOXZ4Y3FSbkhTN1RNQ1d6cG4zYUtrZ2pvRk1VWmR6TUw4SDRoWkoweE9nK1Y2QTdpSk9CVjhVYndXb3JZRE9jZml6MFVGYm5iM3IrenNVWkJZWjFsaDlLS0psa21wZ244UmFJYzNpRERTbmtUS3pPRStuQkp6L1VNUlhvbjRzcGlJSTdaWThxd2NJbk10bnlpc1A4NXBYMUNZODcrLzRqK2puU1dSV0l1VmpnVU56TkFiUWFPYm40dHBFa0U4WlBTZ1lnQURZckQvT2FOeEZFZVZ2YjhST3VQUEZvODJjT3FMZVhBNVc0ZHBpM25VRWx1dEkwOG8vRlhnay9RS1EwdlVuZjJlR1dvRHBETDZVOXlMVHRPdjRpRk1wbk9nOTZNMlV1dkk0TXZWZmNvUkE4OXhhSDRrUVJwU29HV2Vkdmw2VUVRNEtBUEFxUlFIWnBHSVZRa1MvSS9BWWw0R2VNV2NkaDFhQlZ0Zms0Nk9oeGFVb3pabnpLTHNNM0ovRHJpbmNkaWdwT2JxRDcwaVlYbFoxRjRFNTRFRm9iOVMxTE5NNG5KeStwUGZCM1cxTWJQWUo5aWs0TnVwVnJtZXJNdCtJVmhTR3ZJRlhQc25WSHorbFdqZ1hMaU8reFo4aHBmU2ZpeDhsSDBFSEV4c2M2dnpBRmhMeEVmYU5sL0UwdEFCUW01eFFudmU4cVRGK1AwS01oV2tRbDE5aFFEM2dFQndpamVyNXJUZVVXSndPVzlFQ0NOeFBxYVJaZWIvcFYwTVI5Z1lNZnBqbXBZRFlDNTVtWm8zSTJCRVo2TlNWSnZTT0J0a1Zub1V5RkNBSXZ5MVZQTDlzay9RckhUZzRQb1E5Z0dMSEo1VTNUckR0c3UyelRzaWlSTmZvWVF4Rk1kWFdqNlNBcXdHVnBNUVpJekVQMEpVSk9NMk12blU4UktQMkZacWNQblpORzZwd3orcS8wdnhVMWJCR2RQS2swWWxwZzZPYU9VaW9jOTFKSnhuSmQvb1BpZ3VlWFQxOFFpVU9iVTVVUlNiU2FkZUNhbkk5TmJPcjdVRW1KaW1uUTI4cXlka01HZnhSUnp3SktCVWdYWmFDZHN0SWRXanR2QXc3TmV0V2hyM2hiTnlqekdrREkvV2k3c1dvUjd0WDZtbCs1YXg1aXBReVpqSHRWeUhXaWFzUWEyU2s0WmR0ZVRRV0VhbDNuOU1TRkR1RGs3bFRkaXdYSU9UN3FOQWFyeTdPdERQVGdBU29HN1VyYUgrN0ZRM25CdUY5WFdwU0VDUFlmU0lpQTkxVm5icTBMSHZ4bEhDaFpLVGhaVFY0aTh1Y3l2OEpRUmlvK216ZTZESE0ycEFDUC9UWWFKY01oYmR2QzFhY3JBaWE1aEtsMmlzSWJjeFNqK3FKMXprVkZLZy9JVG5Wc2czdkNQYXI1ZzRKZXFrYldNMXA5RlFWelBoWmR5clRiMmZwdXEzVFpSSGErazB3MExsZDZHdE9WOWtXTDJWaHRidkhUOC9adXhKa2RhMXUzVUVKY2FoajJsYXBRdU4yOVpVeE5SYmZhS01hSmlKOVpTNWVrUVhvV3FISzZxM2xWd0M4b0lxQjhzbDhHNzJhWmdVU0pyOUFrVkFMcTFCMUlpMjNmclF1eVlPSS9yTkNjTDh5eVFwajVhTVduSFo2MGZaZ0lBblB3VUV5RTlQcEN6YUVKR3N3TURYeU9TczZmUXU5RFpxZlJSc1QxbzAvNEduRGNBOHdncUVpeUkvOEFGSUFWdElpOWlzNm9YcjMrRkNPVFhQWDcxVXhnckRzOHFXQlNHQWFoS0pIaUFta29nS2c2blMyandmOEFNNVVlbG9aZm83bEw0VVpBT1dqdlFHRVM0K2tsREUwZ01IazVyN1UwY2RyenlZTzlTc2krWHplMUNHV1FHbjRJekFFMmFlZ2JyZjdVeGxSSTlrUlQrRTZxZXlNVUNpVnpLUldIM0JuS1BJb2lheGtIMUtLUEl2SVR2RkJBZkF3ZmdJWlFiNXpWeXhkanBxbzlMWkJNdXBWNlB4RFNhMWc1cHRSMU13a1RScHRnUU83VW9XM2lJOHVhSkU1THp4SFlyQkV6VW1ReGQvelhLL3ZwVTFtaUxvcmxWK0tldTlSLzQyQ3BwZWM3VUpPemUrUjJxSGxDejBKb2doVWtnRTcwVExBV0tvUC9BSlovLzlvQUNBRUJBQUFBRVA4QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FOT1gvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEE5dldYL3dEL0FQOEEvd0QvQVA4QS93RC9BTmcvOEgvL0FQOEEvd0QvQVA4QS93RC9BT2UvL3dENDMvOEEvd0QvQVA4QS93RC9BUHQvNEgvby93RC9BUDhBL3dEL0FQOEEvcC9VV3QvdC93RC9BUDhBL3dEL0FQOEF3OWUvOU44di93RC9BUDhBL3dEL0FQSC9BTC8vQU80OXYvOEEvd0QvQVA4QS93QWQvd0QvQVA4QXcvOEEvd0QvQVA4QS93RC9BTjl2K3NnL3IvZi9BUDhBL3dEL0FQdk4vd0RIWGY1OVAvOEEvd0QvQVA4QW5YK24vd0NSOCtmL0FQOEEvd0QvQVA4QW41Ly9BUDhBNzljLy93RC9BUDhBL1B2L0FQMmYvbDViL3dEL0FQOEEvd0NmL3dEOXlibjg5Y2YvQVA4QS93RDkzLzhBNi84QVcvTy92LzhBL3dEL0FMbkgrLzhBL3dDZlhUZi9BUDhBL3dEbXV2Zi9BUDhBK1h6N3YvOEEvd0Q4NzkwL0xZZjF4MS8vQVA4QS93Q001NStESmMrdXVkLy9BUDhBKzgxejhILyt2MzN1Zi84QS93Qjc3dnkvL3dEcDQ4L3Ivd0QvQVA4QS93RC9BSC9IMzRkYzl6Ly9BUDc3ZmV2bmxuKzc3N1AvQVA4QTd2T2UreC9YOC84QWVmOEEvd0QvQUc4M3p3Ly9BT3ZmOS92L0FQOEE3dTk3ei80L2Z1TzczLzhBL3dEY2V4OTVtUDd2L3dEKy93RC9BTHp1NjgrcmxjNjEzTy8vQVB1OTl2OEF3LzhBRDNlODczLy9BSjJNN25uL0FQN3JHTjl2L3dEN3VlN3YzLzhBKy8yTS93Qi8vd0I5Njk1Ny93RC9BRC9FNStmL0FQYzc3dTkvL3dEMTB0dHUvd0QvQUg4di9PLy9BUDhBdjMrL1ovOEErT3ZwcmY4QS93RDc3L2huZi84QTEvOEFHWC8vQVA4QW5uL3ZmLzhBOWUvNFF2OEEvd0QvQU4vOVAzLyt2ZjhBM3kvL0FQOEEwdjhBK1gvL0FPL2YvUDcvQVA4QSt2OEEvd0NIZi81Ly93RGYvd0QvQVA4QS9QOEE5Ky8vQVA4QS93RC9BUDhBUC84QTg4Ly9BUFovL3dBLy93RC9BTTBmL24vL0FPZlgvd0QzL3dEL0FQNzZ2NmYvQVA4QStmOEE5ZjhBL3dEL0FQOEE5L2xmL3dEL0FILy9BUDhBL3dEL0FQOEEvd0NkL2Y4QS93RHg5K2YvQVA4QS93RC9BUHEvL3dEL0FQOEFmTDMvQVA4QS93RC9BUDhBemY4QS93RC9BUDhBL3dEUC93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93QWQvd0QvQVA4QS93RC9BT2YvQVA4QS93RC9BUG4vQVA4QS93RC9BUDhBL0QvL0FQOEEvd0QvQU4vL0FQOEEvd0QvQVA4QTQvOEEvd0QvQVA4QStkLy9BUDhBL3dEL0FQbi9BUDhBL3dEL0FQOEEzZjhBL3dEL0FQOEEvd0Q5L3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEM3Yvei9BUDhBdjc2L24vOEEvUGw4L3dEbi93RHVOLzhBL3Y4QW44UlB3NnMvL1RML0FLOFArZmhIL3N4Ny93QTMvd0QrSG44Zm4vOEEvd0QvQUxmNS93RC9BUGozNmV2L0FQOEEvd0QvQUp4Ly93RC9BUDhBbi9SLy93RC9BUDhBL0QvL0FQOEEvd0QrVC84QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEEvd0QvQVA4QS93RC9BUDhBL3dEL0FQOEEvOFFBTEJBQkFBRURBd01EQkFNQkFRRUJBQUFBQVJFQUlURkJVV0VRY1lFZ2thRXdRRkN4d2ZEeDBlRmdnUC9hQUFnQkFRQUJQeEQvQVBUS3hwVUttcDRmYW1KM3F3Zk5mM0wrYS91WDgwbWpKbUtIdFU5L2FnTzlUVTMvQVBqVm9jNFE4akUzYWlNcThjZ0M3elUwWW90TmtReVduZDRwQ2tzd2dha3drN21FeS9NTkw1VFcweU1rMGU1VWVjc2l6cG9uM3BLdkJXNU1XWTljbVFJY1NzRFppcnEwVzB6U0x5K0tscXdSdTJIOTdGWjJDSkFSZ1NQYWtpVW9QTElRdFRuQkk1and4UnpOV2dJUm52TWdQTmFXa1NjTTVvZC8vaFpONktPVXFZQTcxY0dLRkJOSEFYU1VvbmIyNE1peHBzN3RMTUticFRZQm5vTktoNUM1NkFka08xU3FvWmcxZ2dHczlLS2x6SWlaNW9CZ0R0VUZSNm82UlNEa252VjFKS2xwcEtTVnJUMHc3dDVLc29VSUFhUXdaR0wxZkVqRVhodUtsNEpvUVVXOXpxZ0pmWW9ndm10RGttZDZBdFdEQjhsVCtmUWYrVTJXcWNKd2IwNlFDT2k3U0V6dTFMeld1YUJKZ2NocEN5VVlDekxGY1JwSHZlaXhFQWFZWWxMdm1nMyt6Y1ZlYjh3cE40UnZWNmgyeXlzcXVWN1V5bFpLa0hDVXZsdFFWd21PR3lHMXRFMUlRNEVKamh6NG1nTy9rL05yRk1vR3hKTnNmN2NVc1MwdUV4bE50QlVHMDFlVGFaay9CYWlMZ0FwQmlYTDVvSStqUEZUdzFQRFU4TlR3MVBEVERTaCtrV3IraTlwcWNCQXBaMExwSFpwQ1ZFd0VjeG5kN1VvNm1BVi9ZOTRvQXhTaVJOeC9MckJNMG5CQ0pCTCtjNzAyaG9TckhPUkVXTFVneFh1Vy9rWm9Pd1FBZ0Rpb052VWtXRHNWbHZTdWhoRUVhS0VEVWFmS0dCMmlMcWlMWHh5SW1Wc0xyaXNWNlN5emE3SktoYmtGS25BRmFiV1pacTNzVXN1VE5KZTBJcjdkRGdCaWZTcExoRCsrbFFpK0FnRm9FQzNMVTZobkx5cGZkS3Y0U2xaTndoeDhVVE9Nb01NaEZubG9HVHNVSE1KQjVxS2xXWlM3QXkwWTlZOGdRRWtUYUtqUVFnTlBiUlBaNXA4eDVRTGw4d3RTSVZzaERYNzJNTU5LYnorVFdLUmhiQlR1Qy9uRlE4cWdPbEZ3bWR6dlFUU0lOMzVjcDE5bEFFQ0FJQTQ5RWtUcFVsQ0FBaGxrdkdwdFYwQ3BLc2pkdXFSeVVKS1NSRHRUYUhtZ0RxQUk4SHNyeFVLdk16QTJZK0ZRaHliSnV1Wm9QcE5TSVVDRTJWSm9pQUJSUzZzTU1jMHFnWkF0MHhBOHMxQXJFajNGd3VLWnJNZkpoQytvWjJTbUxMeSt5c0FaUERSTVdrUk95VlBwUzlQaVdvWjlsZVNHbDBnM0lpN0YrSFdpQXkyeGt1T3krUzFTZmtDWkFCS3JFVXNWQzRiWURmOEFJdG1nSm9HVVo0MEVmOUtCb0ErQUJIdmJOSFZZcC9odU5KMkRMNHBKVGx4WEE5aTA3MEpvc1NBWElGL2RwSEk5TXR0WXV2TjVPMUV5UFpGdEYzTFJkTS9aTW5OSGs1RVJ1UTJhQ215VElSYVZhTmJSVXBIc216TEt2RFRCR21nTzYvTVBZcU5uTVQ1TGNvWlBRNG9HcFEwblpvZTk3ZDVJaHRVRXJzanNRdy94TkhDQVVTSTZuNDU5K2dDYzdwWXh2UW1WRElHd3l1czJoUmxvRFdLYkxoN2JYcUQwYUFmdVR3R1Y0S2RXMXlta0JZMGg4aWloQ3NIa3kvU05EUHVtQ0x2N1ZCOXhCdFF3dmlSaHRBdWVHZ1BXNHNkanVYM3FSQlllSkhCOHQ2QlJaTHZOZC9KTkhvUWMwL0Y4cjlDWUhEdmFLSklxbTQzYmlac04rOUdQVElKZGNvUkU4V28vRktHYWt3bm1IUVgrek1Xb3BpRU1RdUh1S3UvTkhwMlNBQWp5OHZvTmpVbkEzVm9WQXNwYmtzM1U2dHU5QkdRRzI4d3ZMZ2xLRVJKWVMyNlhhTEhyVU5ha3BVTUNxc1FjMWZYcURCMkdYeFUyUGMvNHEzSWkvZlpwUFBvUXd6QSs3MWdEckVOcVpqUm1IM2dVOFhmNXRRMEJKR1RjcVJ3MUp2NnhJaEJxSFpwSTN5bTFleC9LVUpCckN4WE1QazVxQnZzSlpvNUExSjZGdFFMQUpEL3RMZnh6QWZ0R1NnL3VlY0dmOVRlcE4veEN4UUN4MU1FMkxobWVQSm83QTNFUnM4M2JXd0RORVFBQVFCcDFZRTBBRlNNV3hKeDNMdmlyaENpSWlEaUd6VmFwYVpjUjNXZzRLRWVsYVNadDNweGRGMnhraVYrR3JHV3B6aEpld3BJY3VyOE01d1EwYm9oQUFuSTd0SnVuQkxOeEJEclNEREJEa001bjRxTlRSNUlSVTlBd3BCUXNGRWJUWThWL1EvNHIrcC94UWs2RUdGMkNBVXRBQlJKSnlqU0NoaFdob2JmQVNaS1NLakZLYmM3WlRVYnZZeGN6Q2p1bEszTXAxYkFKMnFaVHRpTzk3UjNhRDY4R0NiaVVNK2x4UitVaUxEa2RIdFZ3ZGhRRmVEWndrOTZRTVY0bUFFTis5YWpSUWlTSXpQb2dJeENSY3BjZzJJSFZIUnk2R1drNXN0aU9aQTBNWDFhYlVTL0RuSWFYb24vZTZGUXFmVUVPNVIxZlpwUU9wRTBsRUFhcTFkSVhWYldmTTdVR1Zla1lsNU9KOFdvOVJTd0FHQVBTMUpXU0c5a3g1aXRtcE9KdW1FamRvcGZSWnlMcld6bHZSeUJTYkxhOWwxK1NnWktHT055TWkwQUFRTEFZS2hVZlRpMFZCUjRpaEkyRVRjelJLd0NDaWx3cExHMXFiM1ZERUV3cHlhVUNOSkM1ek1QNHFOSWFGZ2JPNVkyWnFJSWlKSkY3ZWxKM3FHakZpQVpqQU85NnVoSElZTXJuSWE5NlNNa2dJZ1RxQm94MVNhWHBOQzB4blRFcm1yRFRLb1k4WFlIVXZ3dmVoay9DbXRXc0cvNzNGTXJJTllHNnI4Nm1vT3FSQ094NERWNHBXNVZwREs1TmRqUTYzRzg3R3lkRHpVRzNvYTBDd0NIc2Z5YUJXMG4zUXE3Mm81SG9nT05TMlBiRkR5M1I2STd0UWJmYWpHRkJzT2JOVDA3S2VVdTIxOW54V0NxQ25HVDRiVWFTOEYwdkduMlVKS0pWSW00K2xNYzUxSTdiUEpTbHBTUk1nZkdrbnpSZEJ4SWQ0NFI1S2szNnBaZ29iVVFMQ1lGMDJ2aHBGM1ZPWVhUbzZuTkQrQ1dLUG0zaEJOdm5OR2wzanNBM1gvZXA0OUZ6NUFiZ0ozSGZHOUUwOHphb282MXB3bnRGR3NzRWdXRVNhdVgwTEZRQll0dTIyanV4VFRzQSt2T3ZGSUM1Y0VmT2YwaWl1TEVNT0FzZlFXS2hVME03MDBBV3Fnci9BQk5GbERBRldwcWFtcCtnWVJCR3lPdFhVSEFRcmJFUG1vNWhyQmxtTXZ4VDZNa1dUZDRENzBNdm9abUtGRWlPbERRcUR4MFEyNE1OWDFqaXgyUWZZdzZVTXZWSnhVSFFFbHhMbUJvNjRhVGM1UjVWdERESnhORFA0RUdFd0pLYlQzZGltRFJDOTVKMVUzZE1VWTYzUndVd2ZZM2RDby94Y29EZzIvcExZN2ZSb0JvVVc2b1V3L0FHVmRDa2UxTE40MXBlK0xVcVBkeUJ3L3dRdFFBU2cwSFk5YkFRdXBnS2pvYkRMTjd5TkcxbGlMYkNYOVVJaHhHQzEwR0ltaWlJS0lrdmFlUEZFeWxFdzd0SGhvTkRsS215Q0k3MVBqRXlCdkRUK29melR4Y2xtT0VhS2w4YVB5WXFWVEJKWTl5S1JNZ1R3MEVLN2ZxbUpvSU9XNE11YWxON3FhT1RCRE5XUTlTTUowbUJOOFVFUnlRd2ZKUjZnRkZRSkVjaWJWYUJQUzRUTWwzeVdvMEtvWmZOOGhlMVR3c0JKNkRRNWtRR2dBYkhid0pwRFJUYkZZR2k4RzI5S1FlcVMwOE5xeDIzZEt6SnFWQ2dJemFXQXpMNGJVTS9mNVZTSWdmcFpXaHJ5eDczYkZvWW9RUVk2dlN4d0Ftd2YyeGVySlRLUWcreC9TYVBja2FCYUZSMDBwV3ZrcmMwREt1MUloZFlXVExxbi8yb1NKTW05by9RVkhwVUNWdFV5NFNhWk1sckQzYVhEcTVaRE9nYWRxQnE5WEpkU1lDTzdOTlN2SUlEVTJsUnhla21GQVpVOTBVTUJBQ0FHQzJsSU9la1ZCdFVHMVFiVkhTQ29JRFlUV0s5QktOWVEvTkFSelEydG1ON3ZSbzhsb3BpSmtUZW1nWE5hQlpRRTNPS0NUVnphOFpQZWhocEtKQnVOVDZJTnFoSmEyTHFkd3FZaVFTRGNnOXB0UjBEaG9SL1pPcDZFdHpVUWI4RUMrZmJSVFJnVW9VYW1YZHJqYWpUcWJJRUlralU4QUNBUnNQYTJhZXNTWVY1ZTIrdjMwNys0OHdOdWFNbG9NUUpKQmQzS0tOZ1liQUNBOXVwYTEyb0xCWUoxY0JXUHJsdE9YZ1M2RkJRYU5BdE9zMVo3Z0RLQmdORFNXMVRma0NNQUhDNVhWODBJK3dESmdpVjFlVy9wTHNDVldBNzBwT2IvaEo4RXRKbFBzbUwrN3ZUS3VFOHFJR1crN1JzVnZHSHdVRWZZbmV1QVdPeldPWkN5K1N0ZmlLWStDVllkMWU0V3BLNTkyVmQ4K1ZxTWU4a0E0VFBwTlZzT1FPaU5KVFpxU2U3RDMxaXBJeld5L1NOelNobkhXNmlOMFU0Q1NDK0c0VXcvYmxFTWcwR3UvZWhISFZwSHg3QnA1a3BOcVVJVzJpN2xBZnd2SUVrVDd4WXBNR0Z3ZWZDL3dBMDVheUtsVjFPNjlXYkJLcmdDbDYrYUdNQTEyRFJQb0FGMXF0MTFlcXhTSWdtRWJoMkdyWHR0TExZTkRDNjk3MGUrOFNCZ0RiMExGTFJ1TWdwdm9PV3BhTGpTbnVkZ1JSeGNKaERjeG43cUJFWU1mYlJSeHN4QUd2c2Z0VFpIbXhlMXl2SmFvdjZBd1ZGMWFQbWhrOUJzWERvMWJCQitQU01SeWEwRHNZU0JPTkRxYTBYTDlVb1pCc1NFbWtQTkdTa041QlE2UjJPc1lhR2VqZWtTZWgwR2h3NGU5VGQ0Q0NnMzNxVEp4VS9kTkNGbUtCTmc3WU9hY3ZDT1NTNG5kbVhtakhScG13ME94SVhHYnZGSTh2ZjNhQzZDeDcwQVk2OXFFazlpMWYxbXBuSXpJU1oyWjFUTjlhTW9tSUJnRFE5QU1Ya0lBTXExRkVpd1VzUWNQZGFsa24xQmxNdlVPbUNpaE5DQWJBV0tpUFVnRmNHV2x3NUpFU002MW1XOFZkRWl3UnJtck1LRkNFWm1Xci9BS3FRVzdGeDJlZ1IxSmxyWFJ2VFZRUGtSa2FOSDRzSEVZWU42UHZsWWdhTUNvdytCeWpjdXBNNHNVRzVIR2NVZWRwRWtmUHFpaTVBaEVrYUpHQzNrZHBIdkZNSUFBV0ZtTnVKUkUrQWc4SjZFSXhXVHNUU0wyTUhNYTk2S0dObGc3QjNmMjlBSW5GTllyWjNRakVhblpwR2FPNk1WM3RSMFNhVC9FdW1NRnZHRzJLMzYveEp0bWprNGZ1cDgvYmNLTXRYVUkyeHRCRW9hdENDRHFpQktpQjNEWUwrMUFGRmJ3RWxMZjhBZzlGb1laU3dKdHp0VUltQ00zSkZ0WFhUMm9QakZRQUlPczFPbWZPTmdOVjBOYXZTcW9Bd0MzTUdybkwwSmRRYm1oUmowU1ZjZ0FyQWQxcWZBQ2NDUlpsZ3ZWZ09KMGczWEhEaWdJaDNFZ3UyQ0V4QzBHNFBRaGpWT1dhdHF4V3RydXRRSDN1bUR1azBDbFljRFlERlEyUGFnQXRhb1RncUd4N1VtQUZZcWNxeFdjVFpGcG0wcVZpb3FrWmxXNmNVa1VKV2hiaE1BZWFnWU5UVUswd0ZYTXRPQWk1cGpRN3JYckV6d1FmSlVucE5TV0pBYjlIRGFvVWpnSWs2aDhPR0trQkRBYlIwZjM2QXRMUWJmZ2h3Rm5ZZWQ2REJZaEkyMjcveXBucVExMTlVUlJKN2dhNGdScU1PNVJBd2dOa2NQVXNDYWRVUWxRd1pTMkVPT1ZjN1VRS0VTUk5mdUZpa01MMXpLdC9qVlNlc2doQ2wwODlUU0tLMkFsYVpiTVFVdnY3eDRvaGdBQVlBMDZnSmNHYWtYbE5KUmUyTnpSd0F5dWRRbXErZ3VnN2VDTFZhWVlFbFFIdnFHREErVHBtbW1VMUYxOUtleFJBR1ZhUmhOQ1lYaUwrTkFQSWtvRzRZWHZRMS9YOTd3YkZDeTdBUGFLQ1BxTkd2T0JBYkk1cGJocnVBeXNyczVxM0twamU1Vis2RXZETTFUd3ordEZGb1VBNmo2VTdvRGtlVFo1bzZHU3hub0pwc08xRStNSC9xUmFQb05nQ05rU3pUNEp1aXVTTnhscEhGSGJXcEk2bTBqNkdkV092dHp1d2xLS0FwdXRlWFZZTnUxVDFVSXBoem92dVg3bFFyQkRWc1lVZGRIdFJmN2NiMGwzdXdkMktqOEhrMlZZL2VGUjBjVWozS2dzVFBLeThGQmZHS1hidDlRd2R1clRLV1laVXVpTlN4NW9FS0Jvb2l4MWcxNW9PcTN5czJEK1hpbGhva0xpdThNSGcrZDNIeG5WT3E2dm9jVUpaaGtKYzhEdmVsNmpFY0g3ajViVVk0bHhEZUdQQ29LQ1BzWUtBUWxrVGM2ZVZYck1ZMS93QlR3cUF4bHAxUk9Mc3o2VzZZT2tNaVZkSEFaQVc1NnZSL21vTG1zeUxLL1p4NkdZOEJrUjc2NmxhZ29RQWtLTnBnZitVYzRvR0VTUjZwTkMvQ1lRRGtqd2ZGRkF4U3NwWlA3cjFTMUtDVUJZTEIrVHRRZWdnTUk0ZnRtblczd3JhQStSODBTK05SbUM3NTY0aWdCaFN3OHJVanUyRWVSMlFLT3JPaVRxS3djcWxBOGlGR1FpT0F3SFBiMEN5QktyQUc3UytZMVlUQXhhRUhQTkUyU1pWUjNUSDY5RElBQktyRVUrTDhCcVpEcThyV3BrYUU5Wjh5dml4UnFwZ1lBMkF4NnBxVGVnZThZZTB0UXArVUxON1RYKzQvNVgrNC93Q1YvcVArVmYwaUFXR2MwbUhzaUo3dzBCSkVpcFBVVFJvUWtUa3FlT0ExNWtDZThXb1BoSGFld1dSMjcwZW41R0J1SjZISHBraFpFcFNKUUl5RHRpOHR2TlM1R05qY2RrYkoxY1VmUzBoWXk3TUE3eFJJeUU4Qk1zNi9yMm94MUg4bWhrU0ttWEFhazl6SEVMUEpRejBhSU1scEYxRDVDYWQyWUJmOUZieDlzZ0FVQk00RDNpbWVFZVNpczhXUThkVmlpU0VLY0szWmM4MFRSR1lPK2NyUFZRTCtxS0UzWWI0eWphWTdyUTRrZ1JZWFc2dDE2clMwS25GeUFJMWZoYW5VSDU5cEI4QjcwV09xOWtPd0JsWFFvQWdFckxxREI4MXZVWlNvbnNtS0NQUXNVUk9vV0RkV29jQkVhcUxuYmhwamNWR1J5RkZobzFEd0NsUVdIQ3RTU1d0R25Sa29kb04wRW5nb2R6eExYZGhpdjZ2L0FEU3BIay85NlpDUlRqSFJPVVFnV1ZpUXNjWnFJK2tLWjVhOGxYMmdpS3RrSjRSVFZqS3laZ3NrbG82NFdCdDVLR2ZURElUZGd3THJ1S25Odzhqa2E3dEZEUG8zWlA0ZlFUU1NCS2tzTmczR3BQSlNaUmdEQW1CUXZSRXBBNFIyNnBOQnhJbUpPWVhBdUtEMUJZTEZkMlI5QldFaTJsWkpjcitheGpGcmVLM2tROVJKZkZYV0xjVEdBZkRRL2FOaXNZMFNNc0I0bFh4UkZRWFVaMDdzOVRNQUZNUUZqM2lwT2FVdXY1Z0dQTkJIVU9aZEM2Vm53UytLbFhRcHN5SlZPRlg3UnZRUVIxYlpTdEJGbVI1SHhTYmJRaFJKZHdxWTQ3MUY1NnZFd3ZBREt0TmFtS01FWGRZYUdWVXZoUUYzWitqU282dEJEQ1RTOHRPSFhPcnVPL3dLQWV3bzZUZzJ3MXBtenA3NFBEVGFqSjdnZ2VDb1ZIcWlvS3oxdU1IdzBTVDdGeUptWEI5cWp5bVJlVXVSN2xKZFVOeVdMOS8wbzh5U0dEaFBRMWdvQk9LMi93QzZobmxaZkF4ci9xZ2VBVFVMUG9VUVU0cUpsN0Q0cUk5M0FTWEp1aFpPTzFESjFueUFXc09FMlJoS1VjTFlTeFk0WW54UXoxSUlvcElvaEtNNnhBRFVYT2xZT3JScGV4YTdpRUdhTlJJK1dKOTgrZnRDMUlNc0FCTFQ1NXdXU0d4ekF1MTZ3Nk5EQkxpbHJJTTV2VVBRaHpMSlM2M1hxNGFjcVdsYTEvNFZBV0ZFc0JBZTNVOUxqc0FFcTBJbE5UWklJYlJLRHgyb0tWQjRBWUE2elJ1S3gza1JoR0F5dUlxUElKYTUvQU5EelJnOUJYaXl6b09ybythVUVja2hYYW1DaUZwd1dWdXJIWW9ETUUvV1NvcUNQNFlaN00wM0Z4R1JmM1ZGQlBqSUFaNTZmbWhuWDBGSUZBY2RQNDFySHZYQXVTK1kwYVVFQklqSW01MVNTb0hra3U4b2Y0WENWY29yKzBDenROemg5RVRTa0VLZGsrVHMxQXBIaGhIdXMrZXJpaFA3RmNUS2UzN1VCallYT0VIblh6MUd4WUYyQ1UyY2NLWWFGT3pKejlwT2NwTG1CY2NrcVF6T2tGd0x6ckIrK3FpUXROZ0phTGkvMUl5QnRBTFJqcTVoR0tKRkVKOSt3MWZtemtBK2N2YWpvNHFISVptd2tObFc3RFFCVjZheFdYZ084OVpvb3RVRnlJWWI2SE5XYVlSbGhOenF5dEhWWXpSU0d1Qkt6dWNzRkhHbU9rN210ellvUUFBZ0RROVN4VWxUM3BJQ1pFQ1YvbWFuaG9ScWIra1NJRUk0U2xDakJHT3ZJZXpocWV2NGp2SFkva29BVkkzSGYwYXBSRERxM3djWnFBUzFWanVjNUduRkRQVkZrd1JBbHlpM0ZJRm8rUU55VUJCSFBVN0NpNEJDVTVBUXRoeXZiajVVWTY0Qk5nM0xmTVVmcHByN050TUgwRlp1U0NSdTNpVlNIRktaSWgyUzMyYzJwNU1KUmxhQkJaNXFIc1JjQkIxVUtLZ0NLNjdSYTI5Q0ZwVWtJYkJuWS9mVllvejFFc05kOHI1cEhWYjNLQUo2cW5FbEFCSysxUlhyVFNrdDRRa2J4VzlucjNmak9NRGxZUE5NQkJWUWxtd2gxZWFDT3FnV3hHOVpNRTFTMm1OZDZiMFk2WHpidEJIcFdLMnQ0YWFRaGU5V2tRWmNia0psb1ZQMmxBc2JMY2hNekZDYlM3b2dnQXlKck9kVUplYUFSQ1RVbzZTQ0xGbUhkV08rb2R4RUtJcUpENUFWTFZ4MjJhOGlNazRnYytLSlJoOUNTVURFTnhDZjNIVHRXMWEvNkpIVGFnQVVJa2lkWEZJbGJPNURrN3RXNFZMSUlIQWhDUWJzbm9kWE1qZTJ2dkVTY3p2VUJNRTF1QStlenVQVkpHam9zeXdGS2ZnZk5BRGN3UkZndms2cE5LdU1tNlFtTWlwNW9JS1ZMSWtqMVdFRUpPTUJHcUpUSWxTdGcyRHZhTC9aQkVjUWdBSlZxZkhpQUtJVzlsbzJvNk9LUThFU3c0dEM1QWhyaFBJUUlEcnpZdVVFc2MycG9WckNVdTBEc1luU282dTU1REY4U1dEbTVSSVJzTUV2eWRZSVBRVDZqV3VUSElaWG50U3NBTnVITWh5eStndWlPT01GQmxQU2djVVFTRW01eXUwQkhwWE53RGhVVGZRY3RUaTdaZ1l4TGRiYVZIczV6eWovQU1HS01sUUxjb3hLM2FncURyRlFiVTJYcncvbTkyakJ5R1JPY055YlhHZ3RiM0dsak1qRTcxKzBValpZSGFobnFnNXBabUdHQXIyL2gwcUdjNWYxcWs2ZmtvNnN3WS9BU0VhS3FBbUN6RjJOVytTaWZBRVRDT3ZVMkJDRWRTcEtvUW13SDQrMU9FakoxT0psSVlpY1BoaHFjOEtsZzJEU1NHYUxoMXZ1QXV4YXdjMlcxSzFTeFlJWDdySmZxb0FHWlFFdHpVTU56MGdJWWNDdEdQc1liYWppd0pOcnRDOEtGSWdXQzY0ZmZxdVVMYmdKYXc0K2lxb1l0SU1jMFk2eXZUS0QzbHJGRWJTOVlyOE02aEI0NnJVQUxUMndob2h0dzdYb1JucXV3eUh4ajczOFUrQ0tlOTh2bGtPQjlEa1FKSTN4azR0ZmlwZHlSSkdVem9ZUGlqME52bXpBTXEweGdrUmNyb1MyRXFsRUZvekRKdS9paDlmQXdPQSttUGtZR0lOa2FleFVjSFRkWTdUUThId1FRbGdHVFliMFZvWW9rUndqNkJnWGhCbUlOR3VxVkd3UVdGQXg0ZjM2SStsTHlaQmZ0RnZha29ZVTVRMm51bjJlaFV3RnNBOHlCOTZXYWJLbUZaZThIcTB1c1VEaERPTHFUdFNEVWtrQ1NJOVE0a2czRVJxWlVGS0diV3RNcFhpcDZPS2dKMEpoaWkyckp6V0gyS2xGM2d0QnVNczBLWXBVd2tFeUhWRTd4TXRZNWlYeFNNVVM0RGNOckhYQ2djMDFFTFoyYnlBNFdnZGd3Tmc2eUxMS0FZSkoxSm54WHRYRW9KZVpQVncxSURKZnhxKzU4dFBhcis2Z2lmT2VvY0ZVSUFOV2dnYkxvaTNHY3NnZHFFYUVPQUlEcTAzUXNjQWZ6eFVJUkFoSUc2bXUxQkJ3UzdjMVhRNExWSDFVa3EwNElVREV1dTRxVjNCUjBnbXIxTktNa3lhS3dqMUtJMEFrVFpvV1pndEl0SGdpWk9DZ1RkVmtUQ2RVbW5vc2gyaFJEN0dpWmpXa1FrVHgxRjlTRXRLSWF2TUxjREtoT1pFNWF3NjJTSmlTaFlrY1B4VjJ4TWdZWkVNRWoyOUNNRHlvVmlkRldKNm5GT3F4RTNzTXRZb3Z4TGFFRWZzWkk4U1BHUmpCaWUxUjFWQXN6RUZ6WVN0RWlFUk5pVWQyWHJQWXZaQWxmYW9Da25ObGFPa0tNSFZSSmhTTWtMTnNDK2FLa0l0QW1FVEJxM1h2MVM1STcxQXhRUWxyNHZLT2tRUE5IUnB3WU9oM0Y1eDVxUzdRRXM2L1l2NTlEQ3lQUUFKVm9JZHhCS3pmY05qUTYrQkMxdDVYN0JKb2l4Vi85Z3JVcXpIV3JOYVR1U0x2U2t6UFdYNkt5OTlEdmp6VFNBV2JCWXUyVHY2REN1Q3VVYk8wayt4V3h1ZEFWM3pGendIUmFXMUgyRVF3djM5V1NIQVVUeEdBaFpPdlYwYld3Z2lmTlhDa1hCSU1yM1JISG9jYWJhTEc2VHBjQTcwcmoyWlQzUFZqWlpxbVhjeVVaN1dKSzBKdkFmWUtDWEZYSC9yTU1JczNnMDlCai95dmlOdklIbWhGZ0E2d0VuL2RPWEdhdlBNTm9EQVhYRSthRXUwcVFIZHIraGZ6UjVQSUVZYnpVRThXUXJTZG14ck5IVlNxbFpBb3BCZTZoR0c5VEhOTjBPVlBtUEhWQTFRRjEycGt5U0lzMnkrYzNhakdPc2xIZVVwUzJDZWpxOFZPRWtRQ3dTSEJnK3pIdzdZVXV6NHlkcVdVb0xnSjBUNGVhT2pTY1FKd1J2eFk4VUpsa215WThkU2dCR3liMEZuWkNJWVl0TWhEcFZoK0libFlKb0Y1dVVDRWtFa1BBd2FacVVGUzJlWndFcXlFR3ZicFJlQWROZWFid2lhQ0Z0YmdUQkUybzd1SThFbithRWVseDZIVVp1QVhJRXRSTUpFazdkVUNSa0pVNUI0cWU5cFU2d0IyQk9zb1BGR2JoWGhCcVFpYkxOc3cwaVBzRGJ2SmhVWStLREl3VVRrTFdMblZZSmNWQmZVZ0M0dzFzU2c2T0dyV2kxTFlFQTZzeVBGSTFJTFFRbGJreXpUa215OG5ZUUlqVG9JVDFiYm9ZQ1V2TG1rSTVORGsyc01vYUREUDRnMnB5VU0wMGdLWUN6V3pmQmVLRWRSUVM3NWNuaVh4VDdyRERTNHRmelJqcVpGbU1tL3A0cTRyUVFTc1cydzdVRWZaZ1FRUnNqclMza0xpSHRqeVVIZ1lEQ09IcktOWlptRzZPWnQ1b0lSdWRrTUhzUTkra0N4V0FicTBjcUZWZFFYUS9kVFlWVEd0T3VyNzBaM1lPRFlDZ2pvazBnc3VEZTFaN05UNiszaE4zVDdGQm9LWmExZjJEaWlwQm9jU3c0a3BIUXdVSWtKOGoxV3NLV0VvRThVNGludE54UmNTRkdPaUVKQ0R1aVVGTVBPV1UzOGZZS3JGempTM2hhbExtQ2xBaUQ1T3IyeWdKZ0thVlZtd3RrSHZmcVBKUzF0TmpVV2NhcUdYM0NsTEp4Um9xekxrUDRNMUJVVkZIdEdBdTRHalR4VUFFWFpyUERacDJSTkd3SCtGYWQrdVNCSWsrYVVPTGY3ckhHZS8wSXpFbGhWYzZFTDhVZU5pSUFJQTl1clV3WkYzVU95dzkyZzZBQm9DUHRHOVl1cmlEQmpPMFMrS2d0d1Q4d2RySjFTOUZhVzdJTUVlOFBBMFFZVW93amhxd0dGb0RkNzZaRjFvSmh4RVA0ZzBLajFITU9nU0k1RXFQV3phWE56bkFtazAxcStxUlo3TDJkYUxsU3JFbUtObUJLQXpVeGxnRGlKNmlSSERSU2k5Nk9XakhUQTcwaVNhTUxLdmo1ZllYcktRUkltUjRvcE9oeEZBN3cwVU1sU0d4TG1vQjNGd1MxRkF4VFM3ZVF3aVZIVE5Rem5WMndHTHlFMDNBQWNpYjVGTWxKMUVpbGxOakxTbktTZDh5MmdCcWNVZXBDRzFaN1Q1WGtRYVlzNjRwOTZ5eTBzNEdCSG52VE9pSkZreTVBSGpxM3djaXdRRzlQUkhaaUxBTncrelIxWGFMbGhZVHJTQ29oeGRsUjBTQTk2UHRRNEV3U2JKRkdtTXNBTFV1VlllaEcyUU1yaXUwQmxSQVp3SFRFd3hFY3RGckNteSs4dmE3MzRvTGZRU1NvNlZaRXBQSVNKVW10Wnl2dzBoNUtETmdlR2FMbFJobEZYMlc2NFUxb2dUYVpYbWFNZEdoNGk5Sm1DSEZ4Umo2NGUvazJJd1BrS1Z6a0tySGdoR1NpOFpud3d4WW1OYUkzZ3RaYnNZR2lTTUJiREJpcGFSeHZPYWpoUU5vTW04QWZwb0ZHUWdpWmFMTEY1b1A0YWJCL1g2QW1vT0cyd2dQOTF2SnBsYW1oUng1cFlxN3BRanpPTHRQN1FtUlZZaktDMVBZNGdVZ2NhYTAvRWlkdGNZYWgwSWtIbzRzT1FscHlzZTdpMDhnQjlzSnJMay92TFJacElVZFFsSXZLZ0tXV09ZYUVFL2hNM1piQ0Qyb3dRZlJhaXRyZENmTVg4Vk83Y3FaaExuMmVLRnF3djJPaGpjRjlxT2pjcUlIRnpiRHRZT3JpbDFCU0NKYzd1MFlQckxCU1FDdzVVbmxPTkNqYXNRaExSbzduMm9JOUNVUTJaWUU0S0pNUjd3dWFXOFlENlVZS3JTRUZjOGtsRkNGbkFqRXVnSDNDbFA1R1JYVFJoaTlHMTlBWk5xU0RBSmFzRW9FS3RVc3F6Z0RPSTJpUlIxMUlLQnBOZG5Fa1VDdXlGdTJjRDgwODlrbUlGa05HbUljckxBQUQzVU5nK0pHQzBmYnVnWFRiQStQUkM4WDFOT3lIZVdmRkdCdWdUbmptNmwyb0kra1hJZ1NUSWtVdnkxdmN0SmlWVFVQVU5VUUZRZXhXSFgrMzNVZEhGTmlwQmtncDVob3g5WmlCbDNqRDN2NHB6VjFES1pHUGdvQ01la2wydTNHVWRoRFQ2SVVXbzRPWWpQMGlDQWlRaVpvUzl5ak43RWllTk1WSW5jN05xdTgyMHFEYW82UWJVTFA1WFJ5T1I1S0RsaXVSNC8xUkdoWkJHTkFSOHF3VDl1RWNVNjNpUk5sTjZVRUpGQzVKV0RHbEcrNlBjSWkxRFFqTWd2SXNId1V5ZUFFaWxLYmh4bWlYU2E3eXlPMHYwNG9iZE9JeGhIRUZKMHdwQUdFN1hxTFEvcnZTK0xTd1ozaHB4U0lvQXRnY1I3cU9qaXRaaitaOVp4U3owaHMxQk9rZ1VlYUN3Q0dnUjZra1ZFTGZDYWF0RVRRY2lEZCttS1l5Tmd0RHRJbmlqMUtRTUVJaVJyclFvc2pTK0llK2pTa1I5cXRxSGF5Mk4vMXVsQkRnc1ZjOC9GUkVVZ09IZzZOQ05zUE5wQk9TWHhRTWdnQ0FzMCtwRnVJUldJOHFNQWJsczI0Umd1MktBVmk1cHdReFdSNjdXbHcxMmR5b0ZQSkh5SGxObXJweGZGNURjaWpvNG9BUGlra2lQaEJveDlWeFJXanVuVUVGMkFxbmFoSDJVQWtSUldVYm9sVm90NmtrcTNFSmQ1dVRzV2ZGS2xTbUM0NVl4T2Z0WkM4UXl4RTg2SExVWnhYSmE0TmxsYUNDUFJPcWVZV0pxVHRJVm1JZ3dXZlUwa0JaZUlMVHRSdS8wZzZzdG9hQ05BOVF6eTBNb1pSWnFhc0VPRWVWSFRDakF5SlJtS0orYU1mV0MyTU14ZVBzNlBvSUY3bVlFSk5ieFFIcGxoTUtmaTFHd3VWeXdpWmFQOERQYkVFVi9zUCsxbENNVHlJbTFZbG5wdGxob1lnTnhuNnlxMEtRQXV0Sm1CRWJWQm5NU09Kb0k5S1JMRUhNYXc2MFlSQkVBd0J0OVJVUEM4WG1FSXIrKzJQUW1KSlVnYUNZTzlqWis4dW9NUVVGZ0N2TVNLTWZVVUtBcFZFSVY0RE5MS1ZUQUFPdGJDam8zZ1M3S1ZHcGxCY0xGQzhmY1o1SlhEZzFYZ3FjbzZFbTRYZVlweTVoaFdsdHZkbzBjQjRqRjRLV0tSdDF6dXpBam9ZUHBUQU9UVWx6VS9YNVJ3b21JaWxMa2tGMThNT3lvNzBVUFNCQm03bTRodlErRlAzVVhNUDFFQmZaVVloMkltOVJEUTJFWVdHZHIrL3dCbWorSllMZEFZYjBFUHBCQXdVRUc2NVpJcGpobUpRSkFsemNhY3ZBU3V3Vk5lSTZFTXNlRDZpd1VxcmduSnNULzBhR3BaT2dXd2RpMnVrVm9XS01WM2NsNWVnSVB1RUdDVm1FdVZhRzk1bWlObHhQTlYvQlFSNmttczdPWmFjamtlU3JGc3F3SnJ3QzFtOUdETWd3dklHOEVYWjBwVDlFeEVJbUJQM1QyTGVBa1pYZDZtVHBtZ0pMV29aKzRWd3ZVeENJZmxvKzZVak1KdWVhTllNdENCV294YWsrdEQzZnB1S1MzZUZEdkhRWmZhaDE0SlZWd25UWlVBQUxCdDkyRVVXK2pCUnNncE9JTGlkQnBTTEZnRWhtUzVHbXFiK29CWXlZSDkycWNGN1E1WERlSW1oVVVDNXdtUU13RGhhQWhNRElOcjB2NWJZZ3NRWnBTbUtPYk5UUzR0UXQ4WmlTUkw0NUZEZkdHQTRUN1pRZk5CRWxOekNMa0pNMzJwVkFrQ0VCQ0NadFVVMkN5QWhnU01UVHEyZUdLRm9TNkJRVkRxRU9nVE9nTzdScGlrSUh5ZlJXdmhTQUQreFZoNGprRjVBTkl1alBtZ0VRRmcyUHhFdGFZeE5hSXkwSTdUVVJReENZV0owQlBlZXF3UzFkR2xmdHpZM2RLd1g4Z0dVWnlsNGFOSnBCZS9YZjJxRHEwZU83RDJpYk56RFM1cW14S1hMN3QvdFhGTGlHUktNbUd6U2dieGFyMkV5K1doQUF5UVJnV0phL3pOUmswQ1lqV0VvWlFPNVV5dXpTUUdDR0VMc3NnZ0xsNlNnTE5BUzhuSnZDcENFSSt0ZG5YZnl3dmRsZGloZ1FJQ0ZycjNaOFIrSmt6Q2JOSFpNTEMwUDcyYVVuUjZpRXJISGRZUE5QZGZ1dXlrYmR6UWIwOGNBd0gzalVPL3FFbFNaSjR3UkRYWUUxYm1oS2JlVVg4TFFBUmtiajZVQ2xGQUJLdEhPbkplQlo1QzNqV2dqSDRvcXdCZUs2V3dTRFJCbTNnUXd2QjZJN2VyU0hFNFpaNG9UME1CRytjckwrRlNhbktYb2tnbFd0NHM2TkxtcVhSRFFJMVJJZkZIbzBqV2F1QjV5VVpwTkZnTEFYVzBqdjhBaTV3U2lRV1JrNEdveUE1Q0xidDJibE04QXFBRXF1aGFvUU9HVjN0dlpBZWFBTUg0WkNnQUNXeEsyQnVpRzdUN0lTYmlTZWdCQllpOGx1MHZSL3ljWmdFVDhXNU9tRVdUSFBJckMyS2t1VW1pd0lBY3NtbmVlVHVTRGtRL2lHWlZzUlpGTmJPS1BiVnN5UnZjM2VnTVJJWXN4aTVqRFBpaC9VMFB4WW9rMjdzcE9RVVZrUmRwc283dndWYTVrL1ZVYi9DR1pNOGNyOFJ1TmY2VWVtQkN5Q1dEYlBvTnJBandxeG5xVkFNUDR1K1JFWXpERG1ET3NwUm5Vb2dBZ2c4VmVPcVh4VXBPQ0daTS9sZmlIRlFjQXNrZ29KVzdrQTJPeUErZlF5SlhrM2hJTGRwS3hXQkVtZ3VUNVB4TTFZRWNFbFVzN1RuZ3Awb2hOUmM3cG84MEZFYkliU0JJTGhBMVlBbU13U082NytJYWV6Y3BNazd2WkZJYklsU3NCbjBhWlo4U0NFazYzcGZSQmxjU0hzeitJYVlYRnV3Ykc2NkJtakhlamxVaWxzZ1lNUGtNVDRRV0FPaHVTTGtRaEU4MFRaQkZ5dnZoUTJHaG5IM3l4VWpCNXJsaTl0L1dnZk15R1B1bGFSK01pRy9iTEphN3BRUjZJcDIwSXdFb0QvZVNnYnZMVUo5OUhuOE0wM1lqcmdKaDFmaXJuUVhmU1p4Tm9ZQ21YNnBGZTZZOUJBTVlnV0JocE1wYzk2VlBEV1RxdGtiZlVaYUhqQ0FwNU5xa0lhVXkxQkJ1STJhUHNFZ3AxUVNGaWVXQ256V0UzalN0VEZqMU1lS2xKL0tWdFN1QjZHZHplTGhZTUNvNk95cFlHcnE3dnFNdXR0eWtXZVJvaFVqQ0ViSTQxVFphWWxtVDZBY0NhMnNMSHZUOE5yQlpJaklKbTlESmI2Y24wTERtWGNJbWtxTWtTUk85U1JtcDZTVkp2VGNyQnNpSmkyVGZZcGs1SmVpN2xkN3NGQnZGQlJHRVdIQlFWcUZnQkducFJZb1lYSndPUmhPMU1ha0w1OHBHQWFONkRpUWhJamhIYjFLR2FrM3FaNnVLamYyREVPaGNoQjBhQ3lIYVRDWWRrd24xMXRXTlhZZGtJMFRmbWdwUXBOeXRBVFBhaEhzNGIyU0RQaXVROTY0SHZRR3hrQzlseG0yMUlYbVVRWmFDNkhSaXJuTWdaSXdCY1h4ZXNaaEJrMWVYbDliZXJqZWF4WjVudHBrcERIWFFHalZJL1MwQ1Z5VWdjSSt0eFVWTTZLUUl0bHh1ODBwSitrWllTb2dEbWpOeHZ3U0VtVmhSTFI2MnhRL2dta0h3VGRWQlY3SGJsWXRjSWxveFVjNnF6UkRjVlFlMVJ3d1lCYnc5TE5CZmtWbXhETzgxSk9aWUJPQ25SZTlTeTVPRFdYRkw1dFM4L0FQSWQzdE5CRzNxY1VaMldGMy9BQ09wVHB2cTZFNHZjRTA0ekpaVnFCdVBEUXk5WVg0b21hZ0pSVmkxcnd2MnB3Rmh3UmlTenAxSlVqQ0E1RGpNU3VIRlRMckVWMlJvb0VTQVFidEc5aXNpTk5FOFMwM2JvVTNYaElocXZPbFdKSVVvbU5sWkpqdlFIS1FvT0VUNnEzb3hBR2dib1JsYmFVNlprOWx2eUw0NzA0ckNPemRwK2FPemJkZ0doS0VqZVdoaE90RGVRVXB2RjZUc0tGUWFFRXNEWUpXZTlDZ2dFWmNURXU2M2JyUVI5Sk9saUNUajVDOGUxTWhBWFlITzVZc3RVWkxrSkp5V3kwOXFBU0k3ajBJQkRLUUZKZ3pFajhVV1ZHcHNCQ3pGTEtZc0ZxeGlBY2loOTgrZnBMSmJBaVVkblFKV3IyU2hSTU1aeVRJVGYxdDdlcm5zOEFNYzA3RU9ZWENvYnk1ZkZRVkJVVUF0SnI4MS9RUDRvQUZnV0Ewb0JRUjlGS0VBTEVoYVJKbGNsWHZQS1FDOFFzNExsYWtsSXJDa1NtaFZsYkFkdVJONHFmdWdxVzZRTE5OeGlKQzRJN3JrWW8veWlFYnpkNVo2QzVuZExtNkxMdVZ0TlpOakpPUE5UUkRnS29JQzZJb2NMR1FCcURDYnd6aWdnQWdDQU5LdXc5RTJhZnN3MG1KSUpGTVhtM2gzc3hVa1pNdU9vNnU1SlF6OUZRVkdqSDZEa1hZcVRrWWxqaGxiZVNhbUNneDVsTG5ucXZRUjFpbytzUXlZRUlOa3B4UlN3WFRLeXNlSXBZNXJPVHUweGVnTm9nTnAxa0ErQ2xqSXlUaGoyQytzMU0yYzRNY1lPWXFIWUlwWEVFQVFvT0JSMWtabU52ZWFtS0ZmRklnREZGeEFmSVdidkZBZzFJU0J3anI5QUE3S0VBR3ExTUtSak1abkFNQTdHOUt2ekhJWXVZdmpWaDBwQklpZDZHZXMwNVFhOG9mb25WcUFrY0hsV0ErNXFvUVFXRFQ3S0NrclZvSksvd0F0Ukljd2hFcURiMVIxY2NZUUIwUnB3dHMvYzIrSGVrd0ZKNEdqSXNERTMzcXhXcU9KRklEWjdzRkpzVkVrbVFScWFrM3FUZXBLSERVSUp1clYyUUJEeE1qbzgxRVE4Tm0ybXg1bG9rM0pPZmpRT0JRNWpraGVTeXZMOXVsck5RNzBIVnBxZ3pnMmU1TFdPOVhBY2paemErcjMwcU8yWXdkeE1ucWdIS3NIZFd3VU52SzZLMUIwT3JyMnpObU5XdlBHUG1rL1M3c05uLzBLbVZ1WXUySGZMSFpROGhzRXUxRWt4dkJRQVFKTnkvbWl3TFJVRG9KbHd0ZnNoYThmTlZXZUZBVGtaakRIQzNOQ1RnSGdCZ0RRL0F1S1N2OEFrSkgzcTlmeFpVR2lHSGllYWswTVdQSVpmZHFPam9kQ1lUVkdsQ2dBcEpGNUtFUWtUck5ZRFpCTkUxVFdOcG93enhaRTBKY1FYb2NBNkVOQmd1Nk0wUG00Qkx3VUVmZlJUdHJZWTdEYzNHMU5TdmtKR1dVWDNrdFIvSURJQ0lQZXVGTnh0TUlHa2ptdUQ4MnJPOVQ3NUpvQktGNzF2TThNcklaNENsUTNna29hRmlxWmJGVEdTUTZZaTd0c0ZyMEVkRDNWQmtHeU9hbVdOTEVSYUFMRHgwYVFTOGxidXNFTSthR1JzQ08xaVJmeW9nZmhvdlVGSVZGL3dqQWtFTk53WUcweTZXYzZsWjQyZ05nRWkvTFJva2JPbWRuTlJtQUcyMlVvODB0S0ZVa1JoYkVSb1VCRUFSYTMvd0NXZi8vWlwiLFxyXG5cdFx0XCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGh2d1J0QTZJQUFQLy8vOHpNekptWm1XWm1aak16TXdBQUFBQUFBQUFBQUNINUJBQUhBUDhBTEFBQUFBQy9CRzBEQUFQL0NMcmMvakRLU2F1OU9Pdk51LzlnS0k1a2FaNW9xcTVzNjc1d0xNOTBiZDk0cnU5ODcvL0FvSEJJTEJxUHlLUnl5V3c2bjlDb2RFcXRXcS9ZckhiTDdYcS80TEI0VEM2YnoraTBlczF1dTkvd3VIeE9yOXZ2K0x4K3orLzcvNENCZ29PRWhZYUhpSW1LaTR5TmpvK1FrWktUbEpXV2w1aVptcHVjblo2Zm9LR2lvNlNscHFlb3FhcXJySzJ1cjdDeHNyTzB0YmEzdUxtNnU3eTl2ci9Bd2NMRHhNWEd4OGpKa1FFQ0FnTURCTkVFQmRIVUJkYlgyZHJiM04zZTM5UGgwZ1RQelFFQnl1bnE2K3lVNTg3UTB0L3o5UFgyOS9qZTR1UURBdWZ0QUFNS0hPamxYYnhwK1JJcVhNaXdvVDVxNU13Um5FaXhva1VZekp4VmM4aXgvNlBIanc2alBmdDNzYVRKa3hRTnlnUEpzcVhMbC9pbWxVT0hzcWJObTdmT1BRc0hzNmZQbjBDN2lmU0hzNmpSbzVtWXhRdmFrK2UrY2MraU5qT0hqaWFBcXVleXZzczROZXJCbFFpWmRvd29BS25aczJqMzZGd3FOcUZUcWYrc1BzbTRzMXJZdHVBaXlrM0x0NjlmTFVvMzR0WEh6OS9lTjNSWERyNDI5UERmeDVBajg5QXBlTEcwZmlRUkpiN0xOSnBoeWFCRGl6N1JySEpuc280dnJUWGRWTy9vMTdCak0yREd1dlZNV0lFNXY0d291N2R2czRGUFkwNXRLN2Z0ekwrVEt3ZFkrcWMwaWVxYVFZUHBtZmp5NjloeDBkWU5zcnAxZ01GZEVtaVd2Yno1VitIRmovOXVrakwza0FPUW41OVBINU43OWVRbHAvZkl1NzcvLy8rTGJOZlNVTW50eDFGL0FDYW9ZQjRDZG9jWmZRWTJSQTU3QzFab1lVRUMxTWFRYXhZRzhBeC8vVndvNG9pQVpmaWVRdFdSK0lCR1k4V240b3N3R3FFVU5pRk5TT0dMTE1KSFZJdzg5a2hEaEF0eDZPTUZIcDVvVDRwREpxbGtDRE9PdGQ2U0hoUUozNDFRVmpta2xDRVY4S0NWSXVRWVpJaGNocG1rbHhzK0thWUp0RWs0M3Bsc1h0aGdRMXUybVFKbGNKWWw1NTNta1ltaW1YaTY4R1krMFZEWjU2QnBuYVBoa1h3U0dnT1E5U0NvNktPRm1sam1qcERhUUNlS0xsYXFhVTJYZm1ubnBqdGc2UmFsb0pZYWtLZ29rbXJxWkJrR3FlcXFzQTZEYWtKZ3hpckVuMGZXYXV1dXVzd2FVNmE4RnBFbW9Ja0dhNndyMDdrcTZMSC9PZ3liajY3TVJpdUtzNEJDSzIwU3Z0SXo0YlhjYW9KcnJwOTI2MFMyODFncjdybUpmTnNvc09oRzRjeW95N1lyN3h4NjVocnZ2RVJRdSs2OStQWnJCcm56Mk9ndkZ2WG1GZTdBQ0t1aGJzRG1Ka3lGdnRxKzZ2REVYUlRNOE1FVVp3RXdOOXRtN1BFVkMzL1Q4TWRaU0hyUHlDU25YTVM3eEdLc2NzWEpOcnJteXpUZkd2TTl4ZGI4eGNiYnpLenp6NWEyV2kyL1FFOGg5SkVTRjYwMG1qZmJnL0xTT3pjTlR0SlFWNzJCeVRoVGJYVVlQR2ZUOGRaZ1d3RHh4V0d6TWJaUTdKYXR0Z0pkZTUzejJtaGd6VERSY0djY3dLRWNwNDJNUVhYWnRWalAxbHpXejJmSnlEMDEzWFg3ZTdaUVB2ZXlHVUpHL2syZFNNUDF3bktqLzFvbmJyZlU0T2dkeStPU2g2NG1QL0toeDNuZW1yOXNNY2VOczZKUzVLTEgzdDE0bVkvU05aS3BUMng0NXk3YjdpRmJzZ2NmZTJPb3ROMTY3dk11bmpmaWphd0d1L0RReTA3OHRLZHI0eG55K0ZiUGNlM3VhUFI4OEUrUnc0OVhVekdqRlFSWWFlV1BkRkdORTNqMGdJL0V2Q0dydXowLzlvUzJEZEg5ZzBqM2ZWRDdLQWYzYnZXNC96bG5QZno3ZzRmc2hiOW82ZTlybGNnSTNwd0RrY0VsY0M1S21ZNEJIVFRBZEUyUUdoMXNZUDYwWjcwUUZpSTRHendRYWdMeE9yRjRwbmVNdUZ6QVlDakNSOTN0ZWRlVEJLTjJRN3NMMnNFNHpvbVRJM2JYcytQVmtGRDFzeDhrZHZnUnlwbHdHYjhMNGhQNWNMVE8rZkNJYnZvZ05mODhad2dtdG1pS25nRGlnTjVHQ09VeEJveFl4TkVBYUdURlJUU0hoMExNeFgxYU1wSjBrVkJMTkV6amtJaTR2RVFrTVVnQzI1djNXT0tvUWR5d0hselVJNC80MkxNQkhLSlQvQkdTUUVLR3FkTDVnWkZudktJaUM2UkZNdkxCaThTS2p5Wi9VYVFVZXFPT2dxamlLZk80U1FVdEVIYWVaQkFtUThsS2xFQlNUV2hjQTg4ZzJNb0tIUkp6b3dUREh4R1ZILzNNRWx3S25LQVJlMWtmNDlWeURsSDhZakF2QWtwRTV2SU1kMHdrTTdOelJ4RDZnWkk0ZTFwdmhqbkRhV0pobDQ3YzVueUFSNWhudm9GRnB2U2FOc3VqUDMzTTg1MXJEQmdCektuT21od3psbkFBcDdZQTZwOXFpc3lkYVRBak9mcXBIRlhxNDVwaU1PTkFJV3IvSG9HMjh3NGJDeFJEWmZQUGU1cXRtMjNrVWowYmlWQXpPTFNSR3gzTkwrZDJCM0tpcmFROXNtamVZQnJSa3lveHBaQzVuVWZUOEM1VDRrNVJMclhlVHNzZ1E2SFFGS2Nsc2FuMTlrbUhKbmtLVmlQMUdrWFBxZFF0OGhPcHc1aGxEdVZ3VE1ZZHRVOFM3WVk0eVdBb0l5MFRxeWU1M1ZlOUVGUjVydFdHVmJYblZaV2dQVjZpdFNRU1BXdENRVXJTNU1YVnFITTl3Z0xMOWRhN0ZrT3I2VVFNWDRVYTJEdUZkYW1OTFVKZEUydllpYXhVcm9qcGFzK21HcXlvRWxTWStSUlpaQ3ViaXE2TlZReWFkUnRucGZYS1gxbHlEQmt0TEdseDhkZlBnbmFEUC8xWmFuTkxWTE5TZHJiSUtDcmFSaHVFeDVhUXVMd2FxVjFocTcyaC93SlhPeVRVcU1JODYxeWRCZlcwVzZpcVhwK3JpNzlpbHd2R1pZd29jeGZlN1ZhTUoyampMakF1QzFpRjhWVW1zZ1dhUzIyYmhlcEpWNzI2aUc1MXFXckFyYWF4bnN2OWduYmppMTlQWU5LL1JGMHNmWkZYMWlOcENiazRZSzlRQzB3TFpnQVREUi82RllIaFZzL3ZQcXk1RUtad0trT0wyWDhwZUxXYWV5eUNCWHlpKzRxNHRDUis2QmtBekZUZ0N2ZWlFVDJVZVYvY2liZ3UyQW9TUGx5QnlibmpLZ0Jzb1R3bXhXQUphOUwvclJpL0Q5eXdFWlFhNENUYng4ZFNUc0o3VWJ6TktIUE5yQ0cyc2h2dXBxM3hSaFNrVHhZekFQNTZSakFjT2N0cTNrTjA0Ynd5TFc2UnprajlaNUdsWU4vZnhubUplS3N5WU93czZEOHZJUC9ERTJWeDV3d2RDZTN1bVFvM3RpZWpNZERWL1RJaDBsYWRkSUJpakRyVWR2TFJtbFlBcGhuYmhTQmZ3OUtocG9Pand5eURyaFk2MVJINEo1ZC9ZRjlXd3pvS0dmVXpGOWljNlZ0M1FOYTJWZ0dWOGV6clVwdTF4b3BHV3JCSk8rcHNlSGdKd3k2MkhwU0g1QytnZWRhcHppdXFCYXVoYWt0YjFaenUyYkpaNEdwaSsvcU9yeDVYdU1VNzdtLzdZTEx0VGtHNTNUMG5kSnNiQitzK2RienBmUU5UdDdrZ0gwenpxZWp5RlRhMjVTa3oyZmNqczNsdkcxUnYyL3kyZ3FOM0ZuQlE5eXFEZm9NZmY3WVl4MWNnVnVFZ29ETElJKzZDUURjOEI3ZXorT2Y4WjJlTkgxQitxNmp0eVdjZ2NwS1RWY2ZJQmd5NlZWN2FRYnI4NTNuLzZhR1N2VHZ5RHBpYTV6Wm5BclYxZllXZHp4d1NwWWtuMEtmT0dFbHVBcDFGM3dDWlpaejBMcXp4UFM3bUw5SndJMGFxbTMyTUhhZUVqNUZ1czZsMWZkQXRodmlVY2ZqMFFrVGQ3T0VUbjFRR1o1alhhaVVyWGVsYnhxTTNQYlZITHV5NFBoM2IzeDZFdXRhZDV2aytMaXJ1UHJ3S0poeGJHRzg1RHduM2lGMCt2Z1hkL2p6alViQXh1ZWNMM2FZUGtFelZvNWVzb3duakJ2ZUpTRnlQNjhQbm5NOWdaL3Jva2JEMWg5SmU2N1ZOL1NPbEpIVzNrTzYxbVpWVThSRWwvRGdvVlBRcVVMenVkMDhFN2Y3K2FzOXJ2aURtS1B2V2E0YnlQVWs3Qyt0NmV5aEluL3BLd1BuMU0wRG1ZNisvWktuZGs5QXRzWnJOdjM4SVdMNC8vd1JzNm0zMEMySFUvV2RrREhkbG1oZEt5TWNKdjdOOFlxVjlNMFpDREhnRC9EZDkvcGNEMXFjeE1xZC9VRkJLNm1GbUhvZG9rWVJ0WVhCZzBFY2F1VGVCUDFCNkdEZ0J6VFlOSUNnSFVTVXpIQ2hIYlVWWUtkaHZEbGlEQ3hDQkpqZ1prUmVBVTdCa2VZR0RTRENEWkhNTXE1Y1h6N1lHSW1nMEpiaURPRkNCSUxOMkk4ZzFpMVZtTFdnNkJkaGVlZ0J2VXRCN0tPV0VOVUJsNVNjRnpiWkZ6Vk9GQmlPRVN4Ui93NVVIemZhQU5LQ0RZTGdvZlhaTytxV0dKMWlHeERTRkZVYUUycENFWlRCWlpBaDJmTGg3UU1neGVNZ0FVbWhINkxVaDRtY1VCclZLaVlnQ3ExWjdYRGVISytDRjNBQ0hFVFpuajhTR015VWFSN2hVVi8rWWdZN25Mb1NJaWNJV2Q1TzRab2ZIaVdXQUpmRlVTTERoaDFvQ2k2aklVbk9SaXFwb0FuVUlaTGJYaW1HSWhrSlZpQU1CaWhCUmlrcG5YMk9ZQlB4bmpPNTJpSnNGWkhNbWpLMUdqT0lGalJieGdza0lCNmY0Qk0vWWl5RXdhcmdZaDVHbmI0R0FqTWxvamVzRmlyU0lCdEpJYWs3QWYreVlaeTFHQU5SNGVOcDRhZWRZaEMvaVZJQ2lqSUlsQVBRQWlEdEFqK0xJQWIvNE1MQWprQVNUaGV1NEpHMGxjR013WU9BSWR2V29UaGJtZGc5RGtBV1prZkpHak8rb0pEUFNYK1VvV0Qwb2dVVEFPZW1Xa0ZmUmc0bm9ZeXFKR056NFl6NFNmeFFKQmlEbUJDeUpqeTQ1QVpvb2oxM0loYkxrVXc3NUgwZllrbHBRVlNjWmZlLy9NWk85U0dWUWVRUXJ1SS81b29mYkE1SkZFVlVHMllVNlpwVVlzRzQrK0pQUlJnWGtwNVZkVW9XOFpTcktkWlR2Rm5jOEtXay95UUFQQjVaR3A0OFlwWlkyQ1ZjdHA1UVN4NHJMZUlrL1dXcy9xRjFObVlGc3VKZWdNbEpkT1M2SGNwaG9VaHZOT0lmZEJwa3NFSThsVkFlZTVaWmlzbHVjbVFOZnFYUVltWkNZMld1NUdJU3FobHVXaVNjQTlwazNZRjkyU1FGQnlSaG95V0Z3T1pTK0JVMEt0bmpSb2xsK2VacnBCVzFQcVlwbGFZbmxVcHNhZ0pYeWhKd1ZoV2FyQ1lINTlwczZjRkpqU1gwMU40Z3o1SHk4eG01RjAyRm9DVERQR1FLbkU1c2JSWkNqbVhoenc1d1ZNRi83cEo0SjBpcXdOSmxXb0hqeTJYaUNhWWdQL3llRWh1bWVLdGlYcm5rcy91WTFlT1FGc0xrRVlzbWZPaU45UXZpTlptT2VPTU9iSkZPYVJRU1N4WW1TK29DZ0tsT2ExWWt0T2hhZU51TmtIb291dC9OZzRIV2J2UGVVR1BveHJiVTkyTGxvSC9VOWE1azZ4aE9pZmhLZE5JcDl3Wmwwcy9sdjVtZFc1Q2tEQVZxTWloUlcwc2w3TnFvRU52V2pOWFIwT0NpaFJmcVFNSHFqRGtPay85a0MrYWxsM0FHaElyYWppTGNFTzhxamNmTnBTaW92VkdxQkp5S2xHWENnL05aK1FvR0RIbmxRQ2NWckk5bGx0YVdsUDNDZE1ySnVhS3BIU3JXblVYS09WZG9zY3Vxbkw2TlR3b2lud2pLYzBzWi85Wm1vTFRhbUxPQ2NLYW9waGdveTBRbXBvcGFsVTVsa2ZRcWNySU9oRnFXWVhmK0dlaUR6cUVqQWtwTjZMZ3Jhb3lIVlcxbVRaRUdhazE1NnFhZDZvYWwyZm5PeGtHVEFackxLWFI5bkJhRm5vV0tWcXRLQ3EvUG9vMDBXZXhNNmFSNG9sMmJKaTRtYW8zOFdyQmZacXA2R0tNVEtMZEZscHpwZ3JOV1hwWmphbllvWHJoQ2dxeUZZY2RrcUxsajNyUGY1ZjdhcVp1T2FxOWtaVVVGNmF1UTZmUEJ3RU1vcWV4RGhSQWRvQ2xwMXJ4SWdoNUoxU3VrS0s3VHFtTWZKWFB1cVdyekFOeERwY29JVHFDMEZTMnBJc0VNUWp4c0tYT1RTcVBnSG1GUVlud0liVU1haGdHZW5UNDhZUWRYWW9wMldMKzl4c0tDaWVDa29sV1BRVGR5cVF6NTNzdEpqZFpNUXBJMTVrRTM0clcxS1lScWFnZ1Y2cnJZM3NtU1ZzenIvZTNhRkIzV3Y2S2JRT2dUaEZnMFVkanFFcWdGT2lwejFlck5kbElCTkc3WURsYkpsNUlsUWdMSEZWYldieWxEUmlZRmZxaVVoaXptZklFRW1TeDM5U2o1VFVUNTlWeFd6QVhpQkp6N3lVTGNmcUxReVlsWUZRTEVnd0tWanVxTXdPeWhZUzdoUytaM0JkM1VhS0RuaVlFSENrbm1DRzVDRUt3VFJWWU5vQ3dUVTJiaDNJck04YWFvQzFvOVBha2lWNjBLRkFaS1pCMENpaWhpQmxyWEpPYlgyS1ZhejFiYW55NUhHRm95a3V3TE5zYm1FVVRsdDBFSk5FWU45VUluSDJxNCtvTEdkcTZybk9hdG5pcGIycGtQc3RJR2NweFpNeTBIQks1dUMyTHhHSmJTSWVGZThHNWlFb1pVQis3MGtZSXRqaTdqZzViNHZ4YjdsNm43aS8xdSsrSGRLYUdXNjZDdXRjRmRtOVBzQmtmZ3N5dHM5RWZ0UzA4YWd3dm11bnVzTjBSc3QvTHZBenR0MHIvakF4U1cvUmJTOW9EREFhWWdIaG5tLzRwYXhXUnJBUFJMQlN2Q2xYbnVDc0dUQno0dkJia1hDUURDS0NLeVpnYVovTm1XN0RYQlNPT3d2Q0hscDFRdGVxcnUyZHVEQ0Vaa1QzTGdOWkpzR2puZC9Oenh5ZXRwUDRjZ0U5Sm1SUkZkRzZpaWdTVndjMld1QUxwaVM5NGUxSXdldTI5VERCcHA3OWVpekxOeUpDaGhJZTlPc2JySERFZmFtREt4bHppcTZXY3BNWkl3dFYycW1BQXdJTXJ4VWNPd3QyR2lhYkdDUlpheS9uc3NkUWd3M1VYekNDVnN5NTlpbEhuekYzcEZVMkxpNjU5U2g2NGVaRzRzRHJKSENPditqdVAzYnNsaGd0cDgweURHS1Y5c3BvTE03bjJEbXlCUGNMSGY4WDQwb1ZhTHB1MWV3Z29IOGY2Z012N1FGa1ZrTU0vTnFwTEZNZ1lpOHBMakxiYmhzWkk2V3hpOXd4SGdFdzRBd2czUHFaaDE2d3ROTGErTXJRcHk4eUJSWXk4NW1qVzlyaG01NHlidjhzSHA1enBINnlpZktPQW8zbXo2SlA5M3N3K2xiWC9hYmx6N1Z5a2h4UzlveW9DWVZuUjdMQTlRWnozZXFHNTBjTnZNc3daOUtNSkhzemJDMXlzc3B6Wkl3a2VwTWVxRTVoSW9LQkNPTVBWaEx6NHhqei9vVXdPNVkwZEd4bTg0Y2xpWnFCQ3pwMEpjNXk2a2psZ1NOMFlSaGgyVldCOVJNMHVDQmt6ZzlBcEY3cW1Jc3VnNzgwaWg2eVA3TGhDR3Rtd1dJeWN2L1VWNDd6U1QzK0h0aUdadFZLOUVOTmRSSUdyUWZocXhjbGRTK2pCWTBkdEpBU1poNU9zZVRvY2gxMDhRbkxNZGZhR1NSMDlUUHJKWnViVXVlR1FaSEc2M0RDdFRkQU5Za2FkVllXc3hLTjJDTnE5TjZuUkx2RmRjNFdzY2kvTkVhUGJRSW5jMUhFSzhDcUMwd3UzcXBYQ1hHcGRSVWVhUnpWOVN5ckx0Z0UyUUIzUU9RRFdrMTdRWkJwYzh4OGtDR2pRRWFHdE9Kdk0xdnlhSld3OGtDTzlxNE9jeEsySmMvbXlRUEZOcTk2ODRxL2RNK3NORlZ3NUsxdmN4bjYxdlordFcyNG1xcmJRRjduTEZxNmdNT2RkQWtzOUpFamI5RzdhSnFNRi9QSFJ2MWlvNUxpYnFKN2Rudnh0aEZvOVovYUtEZ2dJY3J1dERkM1krcVJkWGcveUhmK3pQZTdXM1hhMTNXNXExYmZQM1lqZzJPS1puYkduWXVNeXJPai94L3dpM1EzREhZRmhKcFRYMitMQ3RXRG83U0RTdDVaR3F6MzQwKzVPMnU2TTBETGswelhMcCtqL3VET3psamNncktrRUtsd3VpdHVidUo3UmFVMWowd3RFMVhBZDRFL3FiaUtCbWw5STBUTEU2TjNKMjJ4OHdEVXVQYjJlUFgyb3prVkhtUEZRNitNTnJWWitKMEZDd3k1R3M5aC9zRFpxMHlVVzNqcTlTRlRJbWd4b1BhMTVKWFJpNVpQNnpnc0EyMHN2MHgxTW5TTkdEQ2pwblNaNFpET2c2ZzBVV2lrQVoycmgzYk1IN2VIRU15YmM3bEh4N255TDB6dkZybnJHVnZlTWlvSUllWmJuNENzOW5rOVBUZmRVYldUZkRsUzR0RHU0MHdTZFNyeXY5c3NMZnlIbFk1MVJURHlkZVh4Ny9OMlFTcTZUM09VYXBiNXNWMTVuYWM1aWlYNVE0ejNVdHU2ZFJiNlBGNzRkeVpPQUNKMk9vbVdtamU1d0k5NlAyeTVUSk42Nk5zN0VpN0wvaXpyUmI4cFlGY0c0OXVBcmJPdzVycWpNbXMwSDMwN0gzTXpYZFllNVRPMzNuZEE3UFo2bmlWMFlXcjVGVk95Z1h4ZGVHT1JXVW81cGFpSVhCTW5mdFl0WXBUN3FIdTdsVGI0YVhXVFJ1K0tsVU1CYkxPNTBpOGJKR09MNmJlemdaOTdmMm1ZN1ZKNXVydVN2cGxpc1FPQkU5ODdOcU5Mcmd1TEdJcDhaWVNlUVZ2QVhxNDZiWjVlRFdJNy9zR3o5clk4TzJpNzhTczZzdHU4N244NnBKdUtqSnB0QnRQM2NROW5jZ3VMWUZlcXppLzJRRC9iNHF3UlBJTTVvQ0VDOW83ekRsTUh3TFpQdWJzYnVaRExzVm51dlBhOWx5Ni9BVDQvdUlURmlwRGJ5eU9EdFZYbjkwZnY1UkJmUEc4emJ5ekt1eWR2ZmF2MmQ4UXJPdEJnTlk0YnFPd3ExODdUNi9zNHo3RUd6Q1dseFd0RUtEMnZpaFl6ZUJDTVJuTUhpdzBuK3VOVCtoSHY5MjR2UXFhSzdaM3E4R2ZjSVBOTGs4Y24vVjF2NG1zbGZSUDZPK2YvdmpBaUplblVIYWFiM3pCM0htUlBMSlFmNEpWQzQweS92ZDhvYkZUbjRrM0x2bXFuOVdFRCtVTnVzV3ZUMGkzU1B4Y3M1OWUydTJuZjlmZGF2ZTdZdTIwVitPWDNtSlVISXlkOE1mSFQwZzgyeng0by9JWTRmeXZXZlgzdnVhN2dxcElRUDVZRDl3NngvcXFzUlBkL3c5MHBBTUo0Y3VoZUQvNjB5ajBmODRya1MveUNGQzZTZ0l3eWttcnZUakxRWmdmZ1NhT1pDa0tuZWNSb09tK2NDelBnY0NwZUs3dmZFZjhySUZOUUF3WWowWkFDQkk2RW9tREtEREZxMXAxTE1GeXh1MTZ2NU1BRmNmYWdzOFVWSTVnUnNQRTVMWjdCRjg5NXZpOGZzL3YrMmxqQ3l4L1hEY3FnNFJnUDJzdGlYNTFXQTZPazVSaE5vRlhtV1FGUDBKYWxSZzFsNHVhcFF4WmNxQ3FYd0dHYTNlckpHcHhzUkt6cHdPMUFtUzF2YjYvd0k2WUNybkJGYTY0eGhxdHc1ekZ5ak5SUFovUTFTSkdITTJtTzUxYXFkWVlVS1RiVlQvVTRPQzNaTS9vNmd6c3RRTmtzS0N0T1BUbytmcjdrOGlDMzhEY0xXaTBqeGtqZmlURWFQOGpCaERocnhyK3lLMUI1ZERMS0ltUnpsV01aVkFId1hURGZqd00yZkRQcmtNYlU2cGNLWXNrdWdBZVN4cXo5NHBsQllFcmt0aXNCUkZqSkNFNzUwQmNhQ3BMMEVrNEJlR3JGdEhaTDV6d0tnMWJlclNxMVpraHFRYUQ5RUhtVm5rMXE5TGNvZkhxbjZFK1Y1VHhhcGJMeGJUTzJMYU5ZWU5iVkdoZzcvM0tlMHByb3BNcjVnb2VQSW5ydTVkOFQ4bjFaVml4MVJ2YTJDd20vQUliMFV6ZEpsUG1Zdmx5T2FDYnZYUmNwN2xTWXFXTVE5YkNKQ20wNjllRmNuekVHN1pnNU5MV0ZISXJDNXRHTnJocmUxUHE3Tk1CN3Q1Skd4eFBORGFuTDRHSVZFRVhUcjM2Qlp4czBEVnR2UTlGczlrc2szUGlidjNGcGJRVXk2K3FNVzcvbTNIMXl4YVNoOVpZdVMrWHE2YkMzLys2L254bFRSWGdGelJKL2JEY1RBRTJBQjUvRnJSeVdpbm1ITWlnRyt4NXhvaUVnNDEyeUYxYmhVUkFhcnlzTXQyRUpMYlZ6SUFnNHNCaE5RVXVtRkpkTzRCVzRrM2lsZlBlakFoYVNCcU9DWW9Fa216UHNiWWlJZnJoYU9SS0QzTHkwbmNZL3FXTml4V3h4d052TTJwWUZKVkhCbk5lVVRkT0NDTVoyVm1EM1pETVBSZ21LQ05tcVdaM3cwQ1pvZ3B1R3RQaVVjMnBpT0orVm1yUzVacjVTS2xqQTVKTldPY0hkOGF5WGFHUHRCbExrWHcycW94L2lLNXlLRDh0TnRtTGVHVWNtZWNWUmptNjBaWjZ4dGxiajVHQ2t1U1pJczZUS2txZXRucWZrTnBsUldrejBkbVVJQ2VsOXJhcC80MVl1bHJRcmhsWnVsTnl0U0s0aHJDKzBhSUthN242NnV3WmdBWDI0eUhOaWtncm1md00ybFdWM2hVbEJMTFBxbUlaaERLVzkrV0d1WDEzS2F6U2hSanV1M3hnQis0Y1NXRWJFSzNWRWloZnI5YUJpaGtJODhJYmk3KzhCdXlRdGdNWnpBb242TWFqNnJMVUNpd3hoV2JteTV5SHMyNWk4VmNMbFl2bmI2RXFQTEV1N1gwbXNqNjdHc2lpckJ5cDFpNmNJOGZjUlpMMkx0cm15V2hFYXdmT2p5U3BJTThJZFJ1eXpCa0tiWVU1NVpIS0ZIN1dSZ3l4Q2tBVG5lVjIyaDNMcHNiRDdzc2dzQmRLSFJyWDFFYXRETEViOTNHcTJCaVlpWFlhS25ydGRueHhyTzBDZG1VN1VpQy8rL1NJcXJrbDkrRHgyNVNkKzFsMTlUV0FkLzg5Wm43WWN0dFBPd2I0NHhFZ1hIY2ZoVTlPeU4wMkFWc3M0VWIzVU1EZmtHOG01ZEdmeTkwTHdrNk5IVkxOZkVUMDMxK01odzY0UEppSXV0N3FWeis4a3VCMndBZjJDcXpMUHBkdVI5dCtWY3JCMjgxeWZpcWF6Z1JyemdzZm1yeTVuYTBQNXVGMUhQMVRQdThvdlhxL0QyUTVRc2h2bnpiVGFESkt5WVBqZjA4aXBPQnNaMzRKTU5XV2t1YkdEMS9qQjhtN0gzamZZR3BmM3A0MFB3dWN5bUdIaUY1ajl1YS9kNW1wZjBoWjNyU2NwaExOQ1RCS3R3SmVBUnVJRmM4Z3pUWEp5VitaMXJFNG1KbEtMeHlFRjFRbW1Jdys0WXNsaFZQT0JvZVRRVUc4TG9YOENkOEhSY2V3NW1GRmQyZ0NvaU1XaU1OdytXZUdEVktYQyszLzl5bnRVU2Q4enJoZ0VjMmlROUMxSllZTUpKbXlFT2V1OVZGd2lwNlNJSUJrZzhSUXZIQjNrWUZnVUZDM29US0NzUnFqNjBFV3FYaXFPVXBxRFFOalZqMjYrTVkxTlVXTmlaQmZuMDRGU01aMDc0YUVJVjQ1cE5qSG9ubFFoQlc4elZkSWVFYzRSZTgwZG15a29HNG1KakhTaDVBcnNRZVRrTk85VTJSU2swYnFYTmN5NUxOQWpVU0loVkdmM1dLSFNoN0JFaGorS2VRSUtYbS9OTHFSY2dCc1l5MmR0VDljL1JJTkNPdUFHNm4zTXVkSUpZSERuQkhONGdla2ZJQlNKY1RTNVVZVWFaZGpSak5qaXlSTU1FL3BSVnJTMEp5d1V3RWp2NGxHSHpLRmpOYU1pVXFVNXBvcWVwT2QyZHJmRHRzU0lFUldRbHViVXg0T25FZEUvM3o2cm1LZHZLVXhycGtTZW9xdWhxa3pLTHppaUFWSU9tU2M2NVFCL0paVk8rZEZKS01TN1E0dkgrVkpBSTF5bTkyektKSThDTktRQ3VkM2Uzb01yY29JbGUxQnA2VVo0S05MUWVpeWQ2SlRkZkRjNWpoVjJsRFBmR3VuTWZ1ZEZYZlNUNXk2WUpxcWVCQlJ2WUJKcHlJVmwraGJhRkFUNnM0b3BYRjZ3ZXpMUGE4YXlyQW1qSjh6ZlVpU3JIcUIrckExRGJVamEyaGNwODE0WlpXa1Ztc2lGdDU2dThzRVZLNFQwK2ZoTnRKUEpCNHhxaDE5cGpNQk94Zm9LSTQrSmUxUVhpdENyTEdDQVd3ZEdDeGp3MVdqZlI2bHNIdFJWT01Zd0ZkYm9IQ3p4MU1iSEtHYXJtTlo5Z0lKbW1yUS9DcGIxRFlLczdYRlMxcDlnZEFnUXYrVEVxeXg3VlhXYW8wL3ZoYUEvb3dmQVFuRHU2NEs5MjBFKzJKUXRrTk9RaHdXRk94Q3ltbWZtNzJmUHVXdXhrQnVYZi9aeXR3aWhpZ3E0MjdvT212ZVlBU292YXpvS1NXZ1k3ckdqRmU5aTlyaUQ2VnIwcEZtcTUvM2hhTmc4U3U5RENhM0l1K2Q0UU5IT3hEVERKVEFSZVV2TUJhczNHb2VyTHdaOHF0bUlUeXk1dUxpdFNZSUpueTdjTjM1UW04NERlTnd0bGp6V0tCYWtvV0h3ZUJlQmFOVUVLdllMSjB0YmV0WTg3a2c2VFNRM3UzRE1HN01EL0F5WnJMNjJ1cUtaOXhZOUZhWHlGSVRaVVZ0ZkEyR0drcVdGL3Z0TE5VSjVWaHRWN0pmM3ErV1Y3eGJLcHJWbUYxdVlJN1hhR1Z4cWRiQkpoeGljTk1NMlNEM2dyWC9rT1hrd1phTFZyOVJtYzVYdkZWNllYZ3FIU2ZSdVZudVhUL0dET2pUdmRuRjIxb3RFMUhHNStPWmRkQ05Wck44RG95eVFsOHFCNGFHZ0ZTSEU5ZE1Qd2ZVY0l4c2FCVUtEcGlzN3M4bU1QQURZRzFxS3Vvc3hXVlZ0VEQwbStpK0FKZFZ0YjdkanczcFh6bmh6aUVocERVZFNwbXBOeG9CQ3IvNUUyYkdFNFVpK0E5VFQyNTFtY1VsWDBlTVdydGNEalpIR1IwUUN5Y1oxN2tUNW5EUkcybzhpVVBhY05HVE9UYjhMSzV4ZWtsSU5sVjI1U3hoSWNkWjNCRkVOMVo1RFdaZ2cxUGdPK0htQ2dTazdBcStKZDRRSjBjVzJqMFlUSTA0ZlVyR0xzRk5ZbWM5WUxMaGdQV1BOWFRORTVyUmVrNGd2ODZtVTQ2eWgwZjg1Ukh2LzRiRTdNMXlBTlNMSjZLTkpia3AxM0dBNDZHM1krejVlcXczMjROWXhkNzBkbFNGWU03MHBnZVE0bG5iRFV0YzEyTkRzVHBlUXAvRG5IMStscHdiRzlIdW5YUTdyblVWYk90a29zeUF0OVBYRHB5WThrbmhIMTVwc1grOWMyQStlTXNlcUxsTGpWenlqWDhYMWVRanUxVXVIZUR5b0lYdEUrbUVKN1RnalNRc29RblBoallRZW9oNFhDUmRQWUpPZVRLaGJ2TjlwL01ET2djOTE4Mm1SOW9nL08rbjUycS9zVW1VaXd2blBHckhURGRDL1d5UU9YM2VhMUtscis5SDlLaGVYUS8xa2R1RFJzK0graFRlRGRocDdTRmFmRDNCcjlIaWVpZHY3SGwxK1g4U1lmSXZqNUNtNUhQOElmYituM3JHZTR5WkUyYmluK0hSQlhjY05QK1FDMnZzc1prSFN6VVNSZHZ1RFRwSkllWnU1OCt0WE4vclNHTTgzUHltYUltd2RlYVhNMWkyRjc5M1pYNjNNa1lYRkI3Mk00NFNYUkxuQUp4blhXbUhIbkZSSXVJUmZ6RFdZSlcwV0o4M2ZwZFRkd1dvVWQ4R2FTTDRkYXRYWjNNM1QxcXpKdk1uY1VjRlB2ZFhIUGxIT0lkVWdYUnhiUFVRZnRaMVl2Mm5BRG9JWWJlbUFONVVZbUxtQVVQWUVnMllPV0hWYkpvQ1VmREhmMkp4Z1JLaGZmdlJJOTFIQ0pPQ1dDdW9CMFc0aFJwQWdDWElHUzE0WnduSWJXZklnbDg0VzE4VmhkTVhSZEUzUkJMSUtUY0lHOFNTYldHM2dIL1FiVjFIZ25sUWhIUFlTQURsVFg4MGNpejJaNFh6VjFHQ0tZTW9GRks0RGtzSVEzVllNSWIvSngvS2xremJzMEJpcUFGaEdJQXBXSVl3Y0ZOc3FINEx4WGQ0dFlia2MwaFVtSERGRkVCS0VHVzZkelQzTmp3T3RXUlo1M0Y4bUFjTHREYVlKSXFBTUd4bzJJYlNRWEtUcElyL1pSY3pNb3VMOUlndkFVV25VRHJWY1l2cDFrTGdsNHM1ZzQwTEE0REErRlJBS0NmbWxuNkMwSWw0a0V6a0tGQVQ0WXdXVVVxTU1Ja3Z4WXpkOUhwdldIU0EyQWM0b1dPOXVHdWkxNDBtd0ltbCtBL1ZvRVNkeG9OVDUwdGJZM3Vjd29IZnMzVHlWbjJFRmlPMEpramtKWXg3d0Q3ZVZvLzhTQUYraUlBWTZYdmZHRS9oeUh1UjRZNGlFb2tRT0V3OVFTN3FtQUdvQTRYN2NGSW1sbnJBUjRZOHg0MFptUUd1UTVJUXNFTG5Cb0pldG56RC8zSklLL2tHcnppT1F6azhjTWNOdFRoZGtwU00ydWdHNlBjSEZqbUFCbmVUYlhXQzRzZ1EvMmc0L1BCZXNkaE9xMlI0SnRrcFY4V1FDWG1VRkVDTlk1ZUd2SGlBeFVlVFdPZVRWcG1XdStpRkFoaGV5RGhoTU9tQ1U2WWVSVGtlRG9sS01haVVhQ2tCV0tTVDRZQ0tkdFdSYmxCNmhGQitjL2s4a01rVEljbVJWZG1COWxHUVRNWTVmM0tIakFXTm40T1l5RFNTQ01GK0d2ZHZad0YyZXdDWGtRa0FaaEtRZGZsL2NzbUFxcm1LTVNLYVBhTWpMc2xoOEJnMnJGUlJDSUZuNkxoNzF2VWdhSE5yZWxpQ3BEaEdnYkNVb0VpYytCYWIyZ2FST0tpYmdTbFgwTWlJYkVZcnpEZWR4SmdIcnptY0h2aUhTdGlhRStCMUE0ZWFyLzhrazFuSmxXQ1psN2I0TDRXWmUyZG1sSUlCWUZSR045ZG9rMzd3a1daem1YTlpoTWxKbFl4WlRnRDZTV0pIajJ5SlkreG9uMXdIUmJ0WkZiRkZaY1psR3Y1cGowL3BGbmZYbXY3WVgvenBZd1dLUU45WlhFMEpHMGxwSjJVNG1ONVRkdHhKb1pXWktKT3BCeGM2a3grYWtWSDVKcUdJbzZpaEQyMkdZTnd3bnhWd29tb0JwTzlpbHZISW92TGtRbzRwZmdBSlpEVUtuZ2Zhalc1bGVyUFpDd1JaWWV5NUpOZENwSVpabnhsb2xVYmdwZEo0ZENXS21RTUtCbGdKbzlMQ2NWRFRtdWo1RlBCcG9HdTZsaG1LVmM3M05SQVZvVlpaaVhFbkZtVktvclc1bUhmcEI4WkpvS1FWbVRoeFRDS0hnazFLcHkvV1MzZEtHVHAwbmFQL0IwV1VhaXdKcWxWWkNxWHFLYWcyNUtTbk1KZkdSNlhRdVo2RG1tb1pwNkFqNm9vc1paNHNtYWVYaWt1dEJHSWI5Wnp1eVlVaFNtSTRFS0RTR1hyN3VJZkFRMm41cHFwVjJoYkY1Sm11R2ptd2FuOW5oSm10cUFIaE9ZS2QycFpQYW41VHFnd2IrV2tVR1hZeldvMm14S1ZDcWhSYzJrQXFTaWhIZ1ZFZ09hMXZ1YXBmMEswL0Y2WG1kNk4zdHFTbWFvckZsYW5XVkdtc3BHSGppa1BoODZ6OTBLeVNGcU5ndUszMFFyRFpXS3lWNnBZbDlLdHF0YUI1RktjZXFtNkVVVU42bXF6OWFMRUFDNnJzdXAvZjZxdUgrb1B3cW5YVnluVnBhcG4yZW1wMVNtb1NlNHBOU0dPMDFhK2FoRm5PdVRURHFvSnpLcTA1KzU5dEtwVWovd3R3eTZrbERMc3FQNnVqNDRsZ2tScG9OaUt6dy9TQUtZdTArUG9xbTBveENJdE1LenVLdXlxSzJuS09NNUN0RFZ1cUNOcXJ4OWl5MjlSWk5ZdXhKdUMwSjhtWFl1dXhUeHVYQ2pzSEgwZWVJYXVjYll1cnVVb2tudWRUZWJ0cUVBdXAwOEMwRWpWZ2NuZTNBZmVvaGxxM2ZsQ0ViM1VhWEN0WGUzczZienF2UUptdmZ3c002RXBqQnJheGFEc0JCbmFtZW5tejVUYTFCdGkzWFZ1MFlGQ0VaU2lneHlTdlg5dW9xbWVOcS9nZHVHa1JaNmFRblVzeDZQVzRGYmx0bUhxcS9oYXNYSWdKYjdXaEMxdTFNUW04SEFGMHlxZXVyUVphdHNodXVWc0pabHU3T09raFk1Vjg0cG1aYXBxam5PcTl3UmF0d2VDMVJPdXdZZXU4MWYvakVkWTdBK3dsdU1MVnZoRVdxSlNyVG1zenRISnJ1bGk3cytLMlFEcnB1c0tHdVBkcXVDV0h2ZEVMZit1YmtaaDF3TWV3bDJNckNBV3dOdlJsWGNnckdzWUxjRkwxUzljS3JHQTdzUnVNR0Zod2xEbm12Z1NtdGhkYk5hbGFyNEl3Q1gzRFY2eUpCNlhtYy93YmRIRkx2UzhxdEpmTFcwbWFXdHdud2lvbWE0VEZ3S01ydkJLTXYvbWJkMndhcWx3M3VWcWt2T3RCZVdmbG5VSWNuRTc4eEdYSGJMRTZ2VE81d3hmMnNySXF3TkV3d2FMeHdzVkh4TThWd1hpSnV0NlhBeUFHUUp6N3JxSnJLNjNIdzJsV0k3akxNV1FiaEZwNU9lNTZ2ek9zQ0NYYlpVbzhNRjdjdTZUN2dYM3NzdkliU1MrSXhZUGtOMXQ4eHpwYm5oei91d0J2VlQrU3pMTklIR3htbko3bWkzTUd1eTZEN0h0Z3NwTFF4OGpFMnJITEc3VnVGc3Jtc2NlTmljWmRnSndBWjc4blJNWjVZSXhMSE1VRGRNS0V0c2ltL0YvN29vaWVsb3FkWEpGZ0hNc1ZyQWZKVEdlc2k3T0txN0ovYktVMURLaXN6S2dhUkRUWUVHMzROM0Z5bkxweGpJdTJYTERISE11dWZBYjI1YlBGRE1qajNJZUpqR0pYQzJTSkZaeEFETWRTTjFFdVYza1RVVzNkWEJsV2ZIQ0hYQmorNjhhWGpNbXdLODZaM0dpdVk4MW5XM3dCelZ1S3ljRnZXMEY2czg5RWlaRDRqQkdkY0hieVY4ckNXczNsR01oNGtDWTFPZERBdDh4UVJzc3NpNzQwVEx6UnljUzBHYzQyREp4S3g2Y1hEWEVSUXRGQldrcHQ3TTByL3hxNkxzM0hKTDJhc013RkxOMW9Bam8ySGoyYTdmeTZsSXhzdmt1SmtiSFF1a0xUTmIxMkhSQUZPRzBMdm95WlZYZkcrZ3VHTFh5dy94d2JYNjFpTVp5VjJsbkxZNjF2Nyt5MkVZMVNVWjBsUmxyVmROMk9ET0swSmV4ZUFua3ZiZTBDOUVxajZXeTFaYzJibnl5bktSelRzdHVUN3dCcmkvaUlRaXJWa3ZxWDdqRWVRZUFKUi9DVlRLQUVvbUFEMm94NDZXRWRYTFBUVk1Wai9adlVkRkRZN1RyVUdsWFVYWGJXdUhURDY2cmFLZjNUU2RqQkx4TFZHcjBmVk0wbDM4SXpvckFJY1FnbW92M1NzRTEzTUUwaElFMnl0SjI2Nnd3RFlreGtSNjJwcGlUZHR2MExWK3JCeGExYjFKbERrbTBYQVBNUTk0elJ5QXF6ODVpK3B2OE5MU2g5V1gxZEFzOGRpTEtOblgrZHl3Vk5tYzE5a2V1Tng3ZktWS1RwYnNGTmJibWREcjBwbjhLeGY2K1ZsS0RMQnc5OUJzTVFOWE1iMnd5UTFjeUYydm9ZMkc3TnZZbzkzOVZ6M1JKOW03N1QzYWIwM1prVDRDYURoMXROekJSZTRXbWRzQ2V1M3RIc0JheHQxdkV0eU1jTkxkbE50OVVOMFFweUZHcEF3S0R0NFlCeXhRSm1raFFycVRub3FJazl2Mi85eW10OXVvTjlmdStOVkorSTFyemJqOG5kZDRXTTVDdnVyVWZlSCtGYVVVQSt1MWM0M0VOWDN0cDk1ZXo4NUVVTXZzZzM0NkdBNWlHVmp4cDgySmg3M2lHTlIvN3NvUFNzeXBxcmRoU28yMEl1cnY4VENaWTF6S2gzNCtaY3p2SFY0bDFnMHM5MXNwNjgzTnYvSzRSbXFvaTA4bGwvK2pVZVhzZnZLS2JtK3B2cFNFMTBUbFdoZmgzMS9RSmg3ZVJCelYxd1BtRVNidU55ZnI2R3pzbitWMWFDcml0Q1RwWnFzdHZYSEorYitTamY5K2lwL3RGc0hnNk1UdU5OdmxtT0hyRTlpN0lZenVyM1RTUnZISGhiU3VLZHFla2xBcHFBS1JoazA3eFpQc2tXYnN5S3pobnRMUlJaUzJDcnp1ekVnTmpQN015dm5nL0lwY0Faa0UzOThaZTRia1JqT2FaSXFnTmZUaThhdnNvcWZWbW5qdW9ITGFQTHJsN0ozalJMSHJ5elh0dmZqcVdRYnVRUG4zQ1JpSVZKTlpiVzdwU0hnTy9zbnQveXpmRzZXUEFsRGZJQ2ZiVFBkZTczOGV6TWpjcjJyY3NPditXVTlTVHd6aGtUTCtiVm9ldlpmblFwZFU4Uy8zbnlBQnp5M2Q0RjQ3N214MDVXVVI3RVNRNnlKTC94UHRKODA5eVZMU282WG5yVk1jK3FlakwxSXRBak9oL3RTQy9wbEZPb0JOMEFmbER1Slkvb0tsenEzM3YwLzV2d1BjakxVaHlXbWp2RmJyK1FNMjhWMis3clRiOW93MDdxNFU0RFprOENMMjViUlErbmVhK2hmYy9RTlc2cmdLSjNFNXBJZVFyWk1qUFhmZW1BQzRHWXVZVENFWVhnWWkvVVB5OERqcXZxWkkvZms3aTE2WEQzemo3NGFjekZPa3lMRUs1V0ZwTFh0b242b0t6eTdtMzZiTFAzbk4rY0k5M3VteFg0MER6d3VuRDREcjdZdXl6N3JBLzd6Rm84cXo4VHIrajZ0cEcwRGozcU1TRDZkamYwRkN6eWM1RDVueG5qYWhqeDNhdm0wa3o4aDh2OWRxL25Edi8zU01rdkpnMzZwWnJKOXN4VHViR1A5cUp1L2NydC9ha2Q3RmZGKzlwSy9kN09DV04xaUIzOTd3Z0F1dHorTU1vWFJya1lFekc3LzJEWUNFUm1abHNncm16cnZuQU1CUUZSbm1jcTcvSndtNldCaWtjRTFIQ0VRYkdIWEVhT0pxWHpJY0JOSFpib2RjdnRlaHRRRk9jckNtdkc1QThwaDA2dnpCaWhPMWI3WmVSekp4dzF6S2ZYZGtnQ2ZYNkZobVFWZ1RnRk9vYzhhMGdFaEk1Z2lveHRsSHNiWkphVFZ3RTRtRk9nUUpTbXAwdFZKMUtvQzFsYXJRcUtOckVVcjJLMUU3ZDNucmtkZXhxOXZpMkppMkxDdzhtNXhjWVhOcUxLRVpCSXlJN1RmSzI3em9nNXJGMkszbHM1MWRIbGhaclFtYlBwaDZwQTVLWlZpdXkrUG9MLzVoUEFGM2o0WmRlTFNlRDFHemlIV1RNYkFxUHBlMVl2VWl0ZzlJck1JbU1QMjdjVENRbHFMT0x1VHNOVnRUU0ZXMmFKd01CL3ppS2EwMWVBMzhZSktMdGxmRW56VThWbUxXZjZxbUJNa3ErU0k5czErZElSZzhvZHBFem9iS0V0YU0ybk8yWXQvWklVVnl4dGpNcVZQSW9LV0JLb0MxMUNaY0FUWjhDeGFBdmU3T20wWDlsN0liZDJ4VHJJaXlaT0lMdFUzWmEycjR1aWZHdGhiV3NJWXJTMXpnam5zcFR6YWN4OVU4c0ZlR3pWcitVdUFoRERmVmtISU5jNU1YMmVBc3dvOGdxc3BrV1EvbUxsc21zUDY1WlJxMlZKc1NtdkF6VTNyaG5XZFdhY2wxNEwzL0lidU9pWHVvTUxydDJLdVYwY3RwRXFTZzFpM3ZEckRFaWIvOHlsN1dzc2xKdVVZVDFlVG5kNG1vL1BXazUraGpyMjkyQllPdHV0MGVDSnoyNkFvZ0x2M3NQYllGK0E0MFZUOEYwWFd5MzgwUVpkTkRGRjE1VmNOUlhYeldYeU1TSldnUmkrUU5rWk5DVjMzb09iVWVJY1pxRVFOWTVlT1dUbzIwVGNUZmpkYk1rQWMrRXdYamtZSTJQZTlXVmZpQ3IyU0F4N3pwQ1hHMk1GNEVkR2cvMUpoME9TSGJDSUlrWmV0T1pqV25UbGt1QkRsaGpweDNoYUhvSlZWcnpocUFTVG8zMnB3WXhUcHZrQlQwUmErRkpvUlFxMmlJMWUySkJYRjkyUktZR0FGeW1sSmxoT1hsV2lvQ2txMDJBLzV1bVpSMjg2QW9uUW41Q3lVQ0ZER2xIV1paOUFYS3BISjNieFNXSXBlTjRYYVllRGZpZFZMT2hFVS8rU29sdDRwZWtwbmJtWTFuK0NzRHJxZXh0YWFDdG1KY1dKSll5VURMWXJBNEcydXVTbktOeGFYN0dvVkVrb0xNbG85cUV5TllZSkVKM21iUGlvc3R5dUNhUnlKL1g2NmhUU2JxZk9zVSthTUc1MWQ0b0RhcmZtT0d0cW9hMW9ONnlTN1I0MjU3MTZmWm5qV0xUS0N1L0FFdVNxWGovcHJidkVlTmh1b1ZuRGtucktCV0xtYmpFZHdkU2VxcUNvc1l5NDAzajhFcEVvVFFISDBWZXVhR0tzc2dMZlRsdU9wYitlZUM2VW9kTE14VjRYOEd2ZHlsYVdXcS9HK3dIcmkzWVFuN01xeWFTNUdUSkZiYnJNODlOR1dFRGt2OW5pcURBUm9ZMjJZTG9lMWNreGNmbENMYUxNSGZ0OFc1WVpEMldPZnFUdWkxYXNib3N0dHdLVHRWbi9XcmllWllORTBVc0F3Mi9BRlR0TTd5ZUR6MjBJYVh4ekFSNkNRcmRJOW1FZWEyUmU0QkUybmJqaGY1YU13dVY1SkR3WGo0VWc3Z1ZwSWVNc3BCTlNZbDRJcDZqS0N5dmFOd3BzNk5ISU1aYnlRSFVmdExUcXdtbDdlaktlajFiYjdoTDRyWmZFbit4c3NjMjh1NEVTNTZPbzNleld5ZEN1RUlRYnBVZjh6V2JxMmp6dk8yYUtNSTdiNnhKNUlROFBtUHJ5MEY2QkdQVGZpNENhNCtyT0t6N3dpNVQvQXNQbzJhNy9GQklDWGZ6bXBxM2IyWThOMDBPZ0k0eDNNN01CY0gxNktOd0FqYldLLytVRE9oYU13R0RTRnJaaEpJMXliaUhmV0xTVndRazJDaWNEdUJwUlJIaTJ4dmxCZEpqU1FLZVlOd1VKbXRBSjNWRmhFVndYL3cvV0RRTmtLN0VlUVJhaVF5OU5EWDQzekp5MmlqaXhrdnp1aGJOQTRndFNwVGgwY1FGNVRyaFlFa2ZCck50STd4VG5ReFhzRk1JbHpyQ1FOOTJqMmhaVkJ6Y01acXNuSldSQUdhMUJ2ZVIxTUJVMjNPSFgxb2cxQjVxQ2g1UzQwakJLZ2cvZFNGRXQyQ05aMCtMSVI3ODRpcEVmU0k0QkVTRkVQekNRZmNuaW1qUHVCWmhETmhKb1hYR2hJOEpZTHdGYWlaQzEyeHRVU0NBbVNHNkVCcG14RTNBaWtZUVUwb0JnUzR5WC8zcFlSL1Joc1c5V3hLUlJHdml1UnNvQWhzL0tBQk5qSUVpUzlMSjZwaXdQMjJyQ0hqVU9iREtzbktVMkQyS2hRYmdTVnRXYzVCOTNHYXhvVXZKeG03cWpIdHVYVGhNWWt3ZWdoSlVvRHpIR2ovKzhJMTZxeko3dG9GTE5aZnFsYm5iYnBrRFo0azAxQVVtY0N6U1BKNGxSeWM0OWMySG9kTUpxcmtqRGQ3TGdlZlE3MDR2eUNLSTlBZytWeTNJSUdudnlSRFVCZEtBb1RXa2s2dEtqQUVaME1kTnNSeFFYR0U5Z2VyU2RHYmlYTnZ4cHd2bUo4YVgwVk9BZ3YwaWpoZ1l4YnB5UldpUytDYzd1cWZTcEtnMElVNmtTenZKY3l4U0ozTkl2SmFKT0ltejFFWUZZcUFudklpY2dpRlZEUkQwZ2g2enFSOG1jOFpWSGpGUUZuQXJWdWtMVkJnaEZTelZCMkxxODBYU2U1N3duMkFRNzJFeTZ5N0FXWllGUFkyYVIxd25WbVYzOTJVUHhlYUEzVFkybkovbFdWUEVxQUpiU0RRQ0R5SXdQWkdsWHowejFDcFRaVmxHekNzVzJwZ0gva0VYQW1hOG82Q2RoWGlDeERPV29VQ0xyVU4zR0E3Q01iZXlRelBteXFaM1dEU2N0TFdmSlJJTUJqTGEwaVRsdWJFbjdXTWdDMVExQUxFeE4xNG5ZS3lodkNsckViUWhJZzFrWGFJS3A1NDNkVGVzeDAwckYxTDNHU0dHUGt2dFV2TjR5RFpONWJsMmwrcHArY3JDQ2Z3V3dJV0RieHhPb2o1MFFyWjk0UTdCZE92SVdOR25WbTRCbk45bnJ6WW1hclZSUkxPdmJDRmhsczc3eXZjeEJLUnhoNTlWelVWMGtBaHlzR1ZzSXRoakJDMzVDaFlOSzJCYmVieWZFQlNkd2kzcmhEdUdvcEw3UjdMVThTNk1OcDlTK2xtSEp3VTRwVWhyWE9BOEVobWNnK0ZxRVlQWnR5akgrUUlOM0MyTXZ6ZmlQSlU3bVduSDNwYnlHeEV3cy8zWk43Z1lhQkNKbk5xQ20xUkYxbjN5Vjk2TDR5OGZ6TFIyc2pNTUh2OERGV2E2RW4rZFFXUnRYcG1mWGxleWc2N3pqR0hub3JGWVNzbG1sUzR3MmFuUEovUHh4ZVdOZ25rMTNRRnFlM2xPaTZmRFZSK2daQnVFTjlBTnlpS0FVRHhqUG80UjFKcktMdCtxNkJjMmh6c1NITDkxaENrbjZHR2hKYmE0bDVhOWhROENvUjNMMURycWp5ZHNLVHNHcWZvQ3lEVkhvbVIyYWNhTSt4Unh4ZDlWWEt0WFdTYzRWRUp3bW5QQ1pKY1NPdVd6MWtKMXMyUkU2MnhwS05YZ3JxdUpGVzVTOHJUNDFkbVZ0TkhjeldkOC96UUdWeVFqSDRaZ2JJTDNPMEpwNWJXeWJzSVhIQW5jRXJYdmJaWGphVzdFWEZ3SEFFN3ZsVjJQa20rbjlJZjhqaWdsTmVKZlY1SEVwK0d2WWRHazNwK25nY1NZWm1pRk5hcVF1YWp4T0JwRDdVTjRDd0F4Y0JvcUl0Z1AyUVBQY2tyeWNHY2Z2aWRucjJtaXhPMlBrcE5DY0FVSWZaZEZnNm15aGRDU0paR1lUNXpOMDFYWWV2eVhGNXlXVTNlSzFGVHJMZUU2UnB0K1p6aEtPZ3RicE5qeUNoS2JoUEZEeTNLZUk5VnF0RE9ZeThmRzFwTnRwTDdOZHhkT09RYW1qc2w0ZTdGVHRkTjk0WUlXTDlJb2Jlc3pSYW5USy9TMFpNM1VkSDRDL0E5NEIxbmMzNmxQbEo3L3gyeTFmTTJqMzJjQVRTL3FhWkg5RGZHL1U5ZGJXdVQyN1JtTGNkNzdIUStUNjNva05aMHpMYmVGbUFmSkhFWDVjelNtL2lZZlBlK0w1VHU5Nnd4MHBrdWZqOVBQLzBIRW9qMzFSbWc4dzY1ays0VnZIZC9pbktmN25jVmw2RFZRZDlPcmVQTzJCSHViV1kzNEppNWZCMlhjQTZBWEx0dWdYOVgxNWRuMWdKSUJhRlgzV3dGcHVkWDUrSVc2WGdINlY4bTBIc1g3aUIyNjVwMUZnWjRHamszOW9SWUJSRVFpWUZYUnExMzAzaDRBN04zKzhZb0pLWjRBVmVIOUJ0RTl5RmxBSmwwU2hGMTFrMWhPajF3R1BrWU1BTUhINzVvRXdJRnVjbEgwaDhIalJSblFod1lKMkJJU3gxbmhsbzRLV1ZHYjE0WGtuWkJ3dXgwYzErSUMzWmpYY29ZQlVzWFR0Tm40dndJRlRSSVFnMEVsQ1ozdHg1NEtHSjRhSEUzNUdwSUUvVkhjM2FIUHBaaHdVMkR6SWg0TmJhQXc4S0FGbFprSDJzanBtcUFhRnlDNXAvMmRUM1JWajI0ZGNqZmlGVUhnellCaHdicWhvVEhobWcvYzI3ZWM5UitpQTZNWldYL2M1U2toL0tQZ1hibGVHMVlkMnluUllNcVJxYXBoQXZzZGx2SWRvUjVkUnVuZFVjamlIZGloNEtBU0IyRkdEeHVkQllpSi9sWmdLWVFlSnRhaUtKbE5ZclRodjdxUnFlVUtKelhnS2NMaDZiSWdxb1loUG5DY2VETGhLTW5oZmtMY0FlK2gzMHRSdGxuaHRyMVYvejVhSU80Umx0RFdOK0plS3hvU0V0N2VLUVZPS3pBaVB5eUFzdzFWK3VyU0xVMmczNUJhT1VTT0Rmemhldzhob2tXaDBzVGhEeFZnRys4ZDQ3RmhnOWhoamk0VUtKSmdmQzdtRTZJaHRxcmVBRzRsZFVkYy9sdU9MTDdlSnFyVjgyUWhtNnVnK0dabEZJZWtBMy84Rmt3MHBBemdEZ1BEeWlFY3lpaExGay9hbmo4UzRqUDNBR0FkNVVTUHBiVTB6a0FUcEFMc1djeXE1amRRR2ZJN29rOFJBbFJEQWJQbllFcXdZR09LRkVrVXBrekZKaWhQWlVSMnBrSlNuTDFBNU5HK1ZQVTZWWmt1cFFadjRpV29aWDlLSWdSQVdsb2k0aUhrWGtYdVdqUHpubDQwVWplZklsWUZFaHVoamxZb3ppY0pZamJ6RW1DR0JNaWJaTGFFWGpJTnBsOExqbURhNVFSUlhrZkZZa3hLWlU5NEZlK0pGajJ1SUFVemxRMEY1TjhwQWg3aDRpY0YxbG5XSWc1RjVUU2o1bGNXVGtNM3lkSVNUaTF5RWo2dDJpTERoaEp3bWoxdmtjN1lwampxWmdvQlplYk5JZm1VcGNtbUppVG4yWHdENWxrYkpUWG1Jak5INWJvai9LVDh0K1hwamFaUDl0d05vU0M3Q3VVWEpPVHFuK0lQaGVYbWJSSjFDK1ViZlNaWWZTUkNPY3B4YjFETDRPWFM0Nlo2SllZMy9XUkRkMlFBeitXSjZpWDBQcVlmcnlaMndlUTd6dVNVRCtrQjRLWW1ZV1JpRlowWnRrcDNXK1FUZm9xRVV1cEl5VmFFdzRJTUJBcHlBNkpzVUlHOUVZS0ppSTVqN1laaGZFR1VYcUpvUTU1bTJtQkw5YUZhS2RCQlh1S0hMSnBEN1NSYjlHVWdBVVQ2R2NaYzJhb3F1MlFJcXlnTXNDalVSeWdSTDZwQUhxbTFSbW1ETDZaRUpLbkV3ZUhxbzU2T2owS0hTeFJMNEtZVkkycUN0a3A0ZndKY3dVSjQwbVFHNFJUcDFxWld3eUpseitud0xOSjJoOUpLWHVaM1FtWWxncXB4OCtHOStTbFY2LzhwVktBb0NMb3FveldtZ1FMbHN4RGxCYWhwNzlhbGRFK3A0VjZwaW1va1B1am1uaklDbkpCRlhnVXBWSldsZGxacUJsMW93ZkxxWGlib0FQc2NGNDltbTV6bEFzaFdra3lxaFd6cDV0MGlvdXlvZWlobXFwbWQzYVRTYmErUTd4eFU4NC9TZ21OcXF3Wm1sVlNtYXpnaWFFWlNyY3JPb3Z6V3JHam1sYzdDcFE4V3NhUnFzQkNlaUNaaDFvM3B6bG1PcXorbDloUXBXdklsSDJNb0NCU295M2dvQVQ2b3ltVHFHcVJxQTgycVRxL3BDNHNwOWg4cVM3ZHFGRDFldVlIZEVwNlU5a09RcTIzcXZFUUNqUlZpdlZDQ3hEVUN4OFBLS2pkbW9PZmVldXhlZ05XcW4zTGl1d1VLVUcrRmZCbXVoVFJPazJ0T24ybHB6cDdxT3ZmOHFuczc2WnpNTHI5QzZSbGhabWprVFN2dnFzbWhxcFZNR2dUSXlQaUI2UFQ5R3JERzJSRk8xc3NrNmJnMXJzYit3b0N2QXB2amFucWdXcWMzanNCSFRzNmN4c0JES3RUNTdqVC94cjFPcHRXRktyaWQ3TmdpclZyeFFnRjZMTCtrYXJZODZuTlRxQVVib3JpQnJRbkphU3UrcW5YTTdvNkRxY1hKWFNPMzFlK0JhTlFXYnRybXBPMlpac3dQWXNySUt0VEJCdFN2d3FxamxyVGY1U1pKN3RZNTdZRW42aG1EYnBzZTRFeUFGaWlnUXVDODZxSXBiTDJtMG41SUVTVm1UclorTGVNd3FoTHRacFVFWXVqNVNxOWlvdS81eHE0OGJzenBMcDJ0RERlaDNvVVJibmF1YlVCUElWUDZDazNaYnRKZWJyNzhKdVUzU3R5d1FxelQvaTd2Tlk2M015YkhYdWprZVpMYWlTNzN0S0xXRnVRaEJxb1BHdGJ5THlYelpZR2VXNUlXaGliMHlPN3ZlMmJraTBLUmlpUUhhNTd0ckFyRXhCTDRiODdOWVJiNXcyN1lncWFNbk1YS0I1NzdDR0grMzhid1phOEFjMGErS0I3V21BN1A3SUxmT2xrUVlTNlQyVzBVQXJCb0kvQmNZTExnV2pKRk5ScmgwQ2NIVWtrYlE2eC9GMXJUaW13YUZheUxXZTV0WSs2emM2d0xhZ0xSbytjTUFxNytVdXNLRStMSnVpNy9wTzhJcWpNU0xHN0F3SEtLQU9tdCtkUWdsbzVTS0NNWDNxN0YwNjhWL1NjVDZtcmQ2S01ETjVwWUNXc0xqcGF5YktieXArWDY2YUw0TE02UlQvSlNIYTZsa3k2OTN6TUVkbkk1R3JJT2JDd0Q4bTd0MS96c3dlMXVucG9uSU96dTJTanlqc3pYRWNVdWZZdXVjalZ6SGZhVzYxakFlcUR1OXZpdGJteHk1VnN1UWllekJqN3lpZjR3eHdJdFQ4ZG1DWU1LcmhLbWxmOHUyYnJMQWhReGxYR2pKZlhqRjQ3ckhUMXZKOGdyQVpueTlUR3pDdFF3QmdieTc2S3ZEb1N4MlR0eDJQZHh2enp3MmNneXB2Tnl4WEl6THFXdU91OHpBV055cDBqZk5hN2ZER2pTdkcveW0vcXUzNEp5WHNjeWc2MXdZYkh5bTdhdzFieHVINlN5bFVvek5rcnc1a0tSUVRWek1pbnJDdk91bzUxeERONnVNSHp4QXdVd2M4Um82Sjl5MXpheXJCS3hlL2t5bGtSeS9jN0srK093dGpEdXk5NXhGbzZ2S0VVMVJFODBBbEd1enk0eHhKLzAwcHVPNjlhd0xMZjhOQW1RMXZzZk1YZGNNelEvOXRYbWMwU2dMdjh6YjBkT1YwOUhydXo2bktBdHR6OE9FdDZNY1B6bnJXQ1BkbDAxTjAwZE51aS9kY3gvZE1hUkV5YUtuMDA5aHNsZ2NpTnNNeGxjR3pnRk5rZkU4eHF1TW9HQXROd25OeVpQY3kyMk54elhObm1KOHdEUHRlS3dKT1VXcTFkN1lERVc1RUhHMGJUL1p4eVY2eWpKVzBLdzYxeHIzMUZOaXU4MVIxekNkeW54Y3luZDZ2Q2tNb0RqNlJyV0IwWHI5QnFKS3hmZFJRbDZ4TkNHbm5vYWR3U21kdmFVZEE0NzlIa3Z0bnpNTXlEYzl3RFI2bzhRTG40SXQwY1BzMmVLODJiVEJkZjE4dzRlVHcwZWMxclFMM010SzNDNHd5RlVMcC9HejF1YTUyNHhhMW0xODI2bXB4WW84MjMvL3F0aW90WmE4dmRYQzk5V1dpZE1WcmNmUXJjNnZ6RXliRzhUbWZOQ3FjOGhMTE4zTlZ0dFBHTmQrck4wOU9jK29PcmpGbGRmZDNSZnM0YUZmN012ZnV0b3lLdENMZk5odURNcG5iZFRzalRtdExjS243YmtKcnR2VVBkbkZxOFpiTzlVWnJ1SDluWmhmNmdkWTk4a1hUTDZqL2FISXZiK3hYZGlJZlliUkRDK2thYVhsbmNEbkRlTVJycTcyamRRVFR1UEdqZHZqM2VGMjE3NFd1bFJ0U044T25kdEFiTEVFUXREUGFPQ2FqVERhV3hET0RkVUhQcWV2emRrY0hnSkRDOGtuYnNVKzdlTzBMT0FjZWVPLys4NGJudVBrcWR4bVBlUDlPK1ZvdmVBdHV0b3MzdUlpVGVTQmJkMnk2T2FwWitiZ0hkTFdmTmxlTG5XM25OODcvdzRhd24yQ1JzNmtyZnJrVEpIaUR3RG5hbGJVU2J6aUhuN29GSzNtL2luaTRJZmZKYWpwQnlpeWZ6NUV1RWJoZmc3aWxRMlI3aWpobG83b2xENjVpdTNvbHpIVUQ1SE13ODNuNFV2Rzhpem1YaFZ4RENLVitDTzluLzQyN1BHSEkyUFRXejZpc3U3RDBucmNlRTdJa3Q2c3pJMDVjL1p6TnE3bmxTN2ZqUjNqdlludEpLenQyMTNObFFrWnYzNGRqeGJrUUozbW8zNjd6YTdxeGU0Zm13dTFJbWc0ZTRDZkx5NXhKUTNQRmM2M3VDN2o5KzZwZHU3SXRCRHUyREh1NTJDbVVWanU0eXpuaTA3WXhzenRDL0R1di96c0JIVGxURm52c2kzdFVjbnd4VTNuOVozdWJoM2VVdTN0QUg4eWRMeUNucDd4SG4vZitXNEVGQy9NeWY4dTVZb0NHRUw4dmEyczQ3USszWkxOMUJ5dnpPdE83Rkg5dnFkcnVCSWY4dmlWSGdCTzFWM080RW50Y0FodjBqdnYwdG9OR0V5RU0wMXUyL0llNVE5UDdSM1A1dk9OOVUrYzZ2NkozWDBPTGtLUEhlbGg4WWFPOFJwZDE4ZzA2elBmeFY2UDdQdU9pazBQS1JOMWp6VU9xeGcrNWdxUExITlA2RUgvYVVmL1d2UTc5aXRTeFZrUDdxM0Y2Q3pQOVhDdjlUQ2c2S2lkOHhIZzZta0IyZEg5OWp1NTlLUzk2bDRENWhzYjkzYWY4c3drdjRSdmNMNWQ4Q1Z2MERWdmFxRnI5Y1NpK0dDNTVLWXMrYnNMNlpuTytaZmY5dGV1OGR2ZTkxNkg5aWJQK0pZTitxVy9jdC9kT1lOdjRyNGZ3SEw4NE1hdTNXak85QU1OTmJDdXlKai9QcTI0MyszWmIxdU9mOG1pdnorQjc3Y0tYUHdZWW1seDhEK2hJWWpoRDl2YmYwR2FUd0dTZTdlcVB6ZXVuK3ZmRC9qQUgrQ3J2K2RtNzJENWYrWUlVTG8xOERES1NhdTlkREJHQXY1Z0tJNWthWjVvcXE1c0doQWJNM2d0T2NEeFhKT0JGaE83eWl0V0NGcHdzaURSK0Fqa2pENEdjMHBGRFRlQ3FrbUFYR1Mxb21zU2ZCSXZnR1JVbEVGTFc3dGU5NXZZa2F2aENzTFh6dS83LzRCTVBVUUtPbnlEUkE1K1puRmFhNDJPUDBGNGJUdE9HMmc3QWpHVmdaNGttekdmRW84Rm1aK2hISHVqRWFsbnE2d1FsNWl4RjY1bnRSV2xwckM1RDF4MHZiN0R4TVhHRW9pSm5XbU1rSHk3ZFZYTnAxU3piRHVsaWthU1FkWUt3c2VmLzNqYXJJbXhlTlMxcHJURnUrQzEwKytzd0UvSHphYms0ZnI3L0lzRWVJV1drYUdIU1o0MGdQbVl1Q016VGxNOUkzaU1lQ3Rnc0orYlpoWHQzRklnY05HUGhQT0laUHd6VFI4MGV3Q2pGVXZHenFMTGx6QXQ3UXJZNTRZeVB3UmZhY21aaDB5cGRDcVdLT1MwYlFQSW1HazJxaHoxTTlhdWp1SitRUDIwRUtYVVl6WUxoc3RxZENyU3IyRERBbURKQWFoUFFrY1ptb3VFeVN1TGlRWGNqcURFWk9QSUVkekVwa0dYU3lTclptazlBVjZKVHE2blhZRkg4VFJsdHRaaVU0YjFTcDY4a212WFF3QXArbHRialhNVlBIZEJsQW9kNW1HTnZKU25ZSFFzVkxIZllVK0xiZFJzajA3a1B5bHZiLzVCT3JYdjN5VC8wVW1zT21YdkZ2L1FkSmNvREtacGpZM0VUNkJ1RVJHNGtkbTUrTEp5UGt3N01lWllQUSticmNmZXpPalcwNnUvT0xPQjhoV1dGeGl5Y3c4OWl0bjJyVnh0TWJGeFVGR1RBTGdlQzluQUE5cGZCNDczbW9LbUViUFlVcjdVdHhWQzd3MW80WVV1ekVSQWZqV2NoMU13V25oWHhZSXNWQWVSZ0IyaWlLRUpKS0xTbW90dEVmTlRoWHZ0Wnd3NkhOWmsyekdQUWJqaWowRHlsOW1HbUJGeTNBcGs5VlRGYkVlT1VHQU5DUVpSQ28wVmJFVGxoVHo1R0VoRHJJZ0lqM2hmd3BGakh3OWVDY1pzdEJFR1lwQnN0cWxDa25tTStXWnVmY0JWWGpWZTFtVWpmQTIyWUZjM1JMa3AyblNDUlNsWWkwNFJZV1lWUHpVcEIwQ09rbkdQZjZQQTJZQ2dtR2IvR3NJOStEeERvWTZFU3NtYkZzMHMya1NvU1BiNVpneVJXbWdvakJ5WVNpQWNXbzdDNVRBbDhRaWVqT3ZFeWlOYXNtb3FMSENjRW1tSGNLcUNjVStyRjhBbDUxekpTdGVTRXRPMkVLMm1TZ1ZiNHJWODNKb0xrKzBnNmd1a3hqejQ3RVYwRHF2dXVtTU55ZXdJazc0THlvNVV4TFlrcWlmUVZkUUcrK0xDTGdUY1ZTcnVoNEdPdTJkMitNWkMzakhJY2hDT2NmOUdyR214OG9iUW83WWd3SG51Qi9pUnFpK0JyREpoNG1uVnJ2dXFKMG9sV2pLQzNBWUNMc01EYjRkT3hWTjRLUEhOZ2xKc1IzeUZrTG1yeUFlZmFOUnpMWnN3WllEOFJnd1h4aXA0RzhoZ3NBVjlqdFNzSmZ5SmhPV21pL1BXUVQ0RzJiRTQ5b0hRdlNFei8ybzF2R2R2VVRhVUt3c2I4TlV4OHpFYjA5U2xUUktZQm1zVkx0VXM4ODMxMytwNVhXdHg5TW9SRDU1MjZ4ZGozVWtET3ZRT0k1dGN0Qnp4VVhwczRuTEhmWmpmcm1GZTUzRGhmUVQ0NkQ4S1RuZVZLWUhhTm5LS2hyajJDaC92NFBrSHBTamQrdFNQWDMzeWRyTWJUb2RWZXVONlV0YS9rMjQ4bHBuTmQ1Ym85SkZMZU80MVR6NG85Q1E3N0ZEajY2WWN5OUloTFo0TDFBeHVjRHJSMGhNY1BLNWFINjkrZWw0cjcvR2FsUCtNdFBoa1k3L3E2aWxFdm9LVi96cTlPZjdkNmwxU2JoZWhQSDF2WmpmQ1d5MmdRYlAxT1ZCR3lSc2ZNdEpYbzljNWpnTWIrd0N0NUNWQURPanZmZ3hvb0dSS1ZRdi8zYzJDdUxOZStFTDRxLzhPcG9GbmcxUE0yQjVJUStEd3JGTnV1R0VHUzBDZTB4a1FjdVh6b0lyOFZEQnJZWUZkMnZzTEFmK253bS90am5mZVE5OFNENmk1UWhXdWhsaWNUTU9veHhZVWtnb3hWSGpaRkpMSUovb0Y0VSt5NDJLbW5pUXpBRjVPalV6aEhDQ2MxY0xMZktkNGV6dGZGdmNvRmczdGNGTVVQSlA4YXBBcjFVenhQa0VNUVNJeDRNTDBWUEdOWTRDYkhsUG9yNmdWc1R1SFZCZ0NaVE5EUG5veUxKYTYwMEE2bVVNRmd1eVM4M09HQ3hwWkFWWkt3SlcrNlk4RWVaQkpQN3hOWWJYVVhRNW1xUUtlL1pFS3BDemdGVDlKVEppRVVvUVYyS0lxbFFXL0MwWnlLRzRVQVN4Zk9jU21WVk5RdHd4RU5uR3p5QmZLOFE5aXZDTXFuVExJcWszL3Nwam83RWV4ZU5tdUg4UmxaM2dVbXYyY3FhUnR6ZE9lVWdEaVBRWDFSRzdDa1V5NWZKb0p1elROTUpwU2w5MUUxMEhUeVZEaURUT01uMUxvT1ZrUXpuNHR3RlNqZ2NJMVVmQkJOM0ZQaWVPMFpVSFBHTkNuTFRRcUUrMWNOTGYwMElhNkZIZ2p2WUROU2hsVENQeVFkZitjVjA1UHdMOFU3Yk5OMndUbk45TndVbjgyTVJjektsZXY1S09tbERKbGt5K05xajdheDBzNGlWSlNVQldWVTFWQXhsV3VGRzA3MVdrK2hUVlFvekpWcGRjUTVoR2wrTlZGTkNxUFIzVmlVYVZLVjZxazVKY1llSXo3ZGhKUFM1UTFWVkZNd1l1cWQxWWltakZUSk94YldxbFNVOFA2YW9VWE5ZYWRPRGtxdUo2Qm5YWE43QjFBNXhOSVlYWlovMU80S1Q2WG1hK05DcmF0SDVnSVp2blJWWlExVmxwcnpWdGNLVmxQWG0xVm16K3duTXVNcE5uZTJyYXl6V25tbWZwS3lFZWVnSTI5OU9KL2ZncGIwcklKdVNoOTVtNURlaWpsU2pLMnVDSXVMb2U2R3p2NjlydTB2U3hXdGZzWjQvTGdyMXlGSlhUa3VRQnFTYmROcTFHc2MxVlhTYVMrOXBTUC9TMEx4UmxXM0hJWHZBQldsb1o0cVVNNWxBbWErZTFHN0JRMzIrUXlsMFg5dFZCL3pGbGZUNWlYRDNPdEUzcXRpRnFOa0JlazFnMndpQTJYRXQyT1ZpZHVjSjZDRTZyQkVPT2x3N1NqTG9RYkRLU2cra0cwSGc1czkxVGhJT0JhRXJzR3VyRFliakxpSW9NemVlUDlMMWZMQ2J2WHRyYTBEMVlia0pkYjRUYjEwdzlDTnY4YmpMMjU1UXJTdUZKTVp1eDlLU3BjSTV2WkRUM0Nxd1hNOWFnc2c2Q2l4ZFd4MFdSc2dvbmd0YU5BS21tT295elIvVkl4d2hwbThVQ1lwMVllRXdOclowNTAvTW9zRVFhaU9jeHpBUFJ5Nkd3eFFWT2dvSGhlMFpNQkFkMDU2dGw4aTdXdm5HUFIwamlPbVUrMFdxMmlGZTB1WlFXemkrL0Y3MWcxS21rTDJObWlwdERucklGcWFiKzZtSEtuVmtPd3k0QmoxL2I2ZVljdHRKOVh6ZXd2RWlLR2ZubzFSSldjTVRlL0daWXh6WFFKYW9lcEt4OWlzSUZZNmpmWXVtd0tSN1lZa1BadnJRTzR5MmE3MjJPQmhFaFdZVDNmL0RXMkdZemI5WW1MNEZOOUF3a3VDeHgydFVkdDdBUUh2TXNEUExZZzB1MnllYi83NGI0bU11TC9CSDVna2xJYXlpaTJackpscllEcitidDBBZytCdDRHTmNIcm5PcnNLRHkyMVU1emhRS2NjNGpDSFFKcUhTeXMxeTlUYXpkcndjWHVkVVkrZit5MFhWOC9JZlJkMFYvLzZEemdmTHNGUlVld2pyeHpOcFk2NTFIbWFHV1RLSWpuTVlQaTJHN3RwV3E0YkF4T1JsMm9GOVdtb2w5d1NaYzljMFRFYzhqbmYxcXoxNXZDVXAwNzNuVE02NG1jWFFWVjhIbmNVZ0x2T01VMzUwZG5YOWhaL1BYcDVWM25pNnpMMEV5NytPbHIvQTJKVVhYY2pLek1QRXJ5aDFTZjQ5QXZvM0FTTlo2UnBtMXZiRlF6ZU9wMmU0NElCOGZraXpkM1VCai80eHNPYnBnamR2Zks0MzlSNUpCaHZCSmViNDEramRhd256V2NTRlBUbE1BbjlvQjhQLzhKUWJ6ZjJZRVkrM3NYcmk0cGpVdnE1ZnppbmJNNTU3RTlnR3RxQ2l3Z25YRWJuTjduNGltVCtTd0N1c3VIVHQvVGg1YjVqemYvODN4UDA5RDdyZlBaelAzTkdPVHkweWlkeWpaVjJhNFovSUtCdHhxZCtMdEYxV0dhQTVYVjRSdmQ2WXZabDBVVjljcVdBdXVaKys3ZUJ0Z0F4RDdoMGNWWXRBUkFBQWlBQUEzQUQvd0FES2tnSUxOaUNMdmlDTEppQ0czS0NKVGlDQTZlQmJ2ZHhwSGR5UWRKNm93U0NGMEdBQnFaLzBpQVNsQ2NDbXlBbS9HVi9Pd1o5SFBpRUZuQkQwTFprTFZkbkpKZ1pNSmlGV3JpRlhOaUZlY0FZTkRoU1BiVnZWcloyd1lXQlVrYUJyT2Q5KzBPRUpqZUZvRlpsMjZOaVVGaUh6VEpnOVdOb1Z2OUFnaWlJaFY3NGg0QVlpSUxvZ3Y5QWd6YUlTQkpJZkRxNEh1UjNmMHc0WkJENFBvbklVbWdJZElVbkF2L1hScFZvaDh6MkF0SkdTSmUzVnhSQWdpWjRlWU40aXFpWWlxcjRiUGd3QTNJUmRteURmcjVoWTk4R2hNd2doR2JuaE5VMWllcEdmMHgzaVdHUWladzRqRTF3VjBWSWFFM0FoNmE0aXN6WWpNNzRqQnRTZ3BjV2lSS0FnTllSZ0cvWWhKajNZNFVsYW1xb2V1MG1XNDg0Z1RoSWpKellJNXNIRFNlNGpNL1lqdTc0anN3NGc0MVlmdTBWSkxqNGdkMUlpZVdJZEE3SWN0VElWLzM0ZzV0SWhXOW5qbldJaDhnR2o2ZTRnako0QXlkSWd6VW9BQ040aVBBeUZpUklpaVg0a09zb2crdmdod3JwaFNaMmJiSklHVm4vTW9kbU9DSW5tWEM2YUZJcDZZOHJ1WVlCeVdYL2FKQjF0M3VXVUlvZjJZSXFXSWd6SUpHeE5JSVoyWWZpbHBORzRZb3BzQkZCa25wQ05aQkkrSGV3SjRkUENYL2JVNFZCQ0l5YkVuVTBTWXlXa2tGWDZKSE5XSWcxT0VkQnVTRXpPQUJoK1JmS3lJN1FxQWZLTVhZL2dvMWF0bzh5bVkra0ZwTmdRSldQa21yWHA0ZmlTSmRabVpYOUJ5ODQ2WTRwYUpZVUtSaGNzSUtFaUE4K2VXZzlnSUx3dUNHSGFXc3RDUmJzNTRoOTU1S1pDVkMyeUptekoxOVNlVjB5Y0lRV0UzbC9XWWZvbURHRCtaVW5PSm5NZ0pFUFNaWWNxWW9NS1lNOENaRVNTWnFrbUlKZkdZMmlONDdBd1lDMStKSzV1SWk5R0pya2lKekp5UkY3Q1p6Ni8raWNwem1NT2dRVk9PbVZXc2lUVkFLVUd2bVFKV2lDUW1tZFJQbVZZSmlicXJHYXFQZ1AwamdCZG9rVVNpbFNURmxwN3dsNjY0bVN2QWlUMzVoLzhabUdveG1kL05rRUdqSUJpWG1lMFppZFBhQ1c0Vm1ZM0JtYkJucWdZR2lZaTFLSzRQbUN2Z2tCYkdnTTl3aE04eG1MME9tWnZvZ3lxNmVONCtZTGU5ZVhJZHFmL0lrMVY3aVFocm1INWhtZU1XaVdZVkNnTHRxRk1BQ1JWaENnZ3ZnUEkxaWhoK2FVL1BpWm4xT1oyZGljeXVrSnBtbGdUYmVVK1dtaVo4WUk2Qm1oejhhV0piQ2JVRHFqVjBWMU14cUlLdGlhdHdHVUM2cVRWamxkKzRsV1JUcUVTd290OWVseUcvbzVTaWlpU1FjR2RNaWswWWttZnppaG0vS1lRLy9KaFZ0YWxrSzVpcUpvQlRkMG5iZTVqcEQ1anRocEdNcTRrQ3ZTYzFGNUtZMHFmNEFGcEFWbmdkN1lvZUI0cGlPd01ITEtwSUVLZzRVWUdTWDRwUzlJZzV2U29sMElxWmJ5YkN1YVdvOVpwVnBxbGhreGdwMHFvU3Z5b1hEM1RxTndvV2Q0bjVESXE2NDNwckszcHIwcXJKdjZoRjVEaUVZSmRqSjZubitLaEpmWEFXM1FCWEE0SjRUWW1HVkFwMnNKb3h3enE2cEttaDR4ZXZUaGh2emhvMGJLbzhTV29XUDBwZ201alpCVnBzVUtoU202aGVqcEZnWHFxdFVxRTNvSkFHc1FrdnRHRTZCb3BWTGFMTWZhcllFVHBnQnFzQkhRbml3cHFXSktxU1dFc0xxZ3J2aVlCNXYzcm1ZV3Ixa29tUjJSa2FJS2tzaEVnbTFoRGZ6L21tLytLaEVSdXBNTlk2OW4wS3hqZ2FPZXlySmh3YWdWV0tMbG1xWnE1NnVRQkpXaTZaZHk1N0QxcDdNVys0VGNpa0hDMEpVS0NhbXlRQ3RBKzRFankwTXhPS0RVQ2FHdkNoVVlLNkV3aXhTMjJvQU1TM1JiZTZ0STZ3SndPWmZzYW00OXM0UVVHN1RFT0xSNWNLVk5NTEJhR28xZDIyOXhLd2lXQ3JiRFVTSExDb2pObXJmVjZxM0hPSklBaWJONTZLNWFXN2RLNnJQUmg2bXBkYVI3SnJob0MzRXVxNVBXR2dHcEtvakswd1dxSnB5dVU3WVc1MTF2MGg1YXFLMFVFTGt4V0xFY3lybkwrYlZvS3BjM3U3VDI2YnFIKzNNL2k3b0lVNUNQQzNOOHk0S2kyMzFSaXB2ZDZaMXFlU2V1Y0lTUFlMcTJ3TE5IaWE0SGl3bXkvL215SFpHN2Q2c1hNbHV6eERweGh1dWVyTnM4eXN0ZWhNdHV4T2wwaW51N0RPVzJqQm1GQkN1WXB0Z0JTS0M2UXRBRnhsdUEzUXVmOHBGNTJKV29Ud3NPMEpzRDcwc0d1bXF5UXNwM1BOZ1gyd3ZBMHpxYzFTdVEyZXU5MXl1KzcxYTVjZks4NURHNVBBVzYvSWE5dFRlY1Rkc3NjN3MvbUZzbG9Hc3MzOGV0SUJ3VDh6aXA4VHVrMzBPdXozbkNKUGU5ejlDL2dldTRESHhtSmppcVVBRkQ0ZmVmam5mQmU1YkJGckRCbGxpUFVUZ2tGQ0VRK1F1c0w2RzVMWXk4Q2t5ejdRZTdhaXE3RHh1K0dteXVITFZCTTR4N0E2dWpRK3hqd3NmRS9Nc0JTNFd5cXlwUHY3UUdsR2NORlhHc2tqbUthbm0xbHNYRGdBRERJV2ljci8vcnhDQmF3ZC9peFkzS3RpQW13MWs4WWx2OERxVHJxSkxJd205QnZsRXF3VlJtS21MQXZobGd4MlBSSHVpSk9wS2JmUCtMZHVCYW5JZ3NLWFNNZUFtY2wxUnNhMGw2WTN3Y3lBL1hxVzNzeHJ6bEJvQmNaNHFjc1l5c2lENDh1bENzZUhKc3kwOXJ4S3JzdHd3bXlad2N3Q3RzeUdSYnkzYzV3UDg2azErOG1majV5cWo4WGFxTXYxNnp2NmNpeEhDcXNzaEtJMnNnTDFFQXlSRkx1MVZjdXFQSXhyNnNuNTJNeTh3TXA1a01nTW9NZVozNXd1L2NaN2Y4Zm5qOHpNMFdxS3Njd2tqR2R2V3NWWFFRamVRcEN5MXJxaXViZzhLc2NibXNrdnlLclRqMGZWaFl3STFLellhM3dNeTB5VkhNbkc0NnlwNEhzY3VMUVQzSzBmYi9URHFDa3hhYzBuSDBOYml2OEI1SGZCdlNPajhTalF6enJLODJQSXFCQ3NlWWlkRTdlOUNTWjhWVEtxNU1JTEYwaTh6N0J0SHdKTlFoalU0NjA3NHQrTkxGR05ONmg0d1pvbk5qbUc5TUxYTXhEUmZoT0FGUzZNMHNvTUtOZTg3Y205REhxZE93Z3JqTHFjZDV6TlhuQmRKSHpUWEh0R1orU05UWTRNd1VnTVh1L0dVUFFqUGR6R2xPN1pFMTJzV25YSDIwRWw1VlBZMUEzR1kyVzlSMHZhN0UzQ1g1bXRHSjNkYStoU2FENDRrdStKeHlmUVNSdlhWeGRjVGduTHhnZlg1aW5Vd3ZDOWllcTErZi9hTVVIY09oM1JueGpOZ0h2SHlIbldTTHpkaVpMZGwwRlM4Mzk0TEhPY0ljNWNMVWVsWUUzUUN2ZlFHeDNZWmorOVNlLy9vT00xSFlxeXZGZ0ZDU2o5cXV4dnkzcXczYlRyMDhzeDNNbzQzYkFPWm9wdDJDZnV1QlBGWGJnQ1RHdXVzQlNwR2JWSUxHQmp3bVNCQ3FNZmk4dzJPaEZpMjJqWDNIM1czSzdlelAyVTNiWUh6UlpHMHJQdTNkeGNSbXBQeTBBVTZmd0RKakF6NnhSQ2JmT2dtV3R3SGNiNEVFbVoxV2RQb09vTFVTYkIyMi9ndTRycnpPUUxQWkttblcwUTNVZXNMVEJxNCs5ZjNOUnBnSzFRM2F5SG9YcnZDdHdTQ3JLbHVqQmxHQ0pKNWFpU1RqbEpzNjhLdlJHS0N3L0F6TXN2M2ZGVzNldUlhcnRldmtHc3JrYWxIY0xmNVM0SmR6OVBMSVFmcUZFZ3JRRXptUkdYbmM5TWdMazR6Tk9kNmRoWW9XdTFwMFhFNEtnZjBBakp1ei9mOTh1Zyt1MkF0T3p6T2Vya1kraWlwZXgzbmU1VWg4NVNMV01SMjRKOXVzdldjQWlGam9hUmRsdEdCcW0zbDZpc2pFMFBsTjJ0YmNDdGRDUjJhTDFtT3QxaHU5M1ZWTzVoQU82aUd3QzVDTjRreVVjWVErWWtrVjZ2Zmt2dkljTWpYTTZNT3NxZzRxQksyYWlnRTdLNnpDQ01RaDZ6Q3VuRW15NTRiVTUzTCs0ODJYNmFEcDZZbDczU1BlMytQYXByYkgxcTJ1TGlmMW9kNWc3SG1GaGZsZ3YvSjY2NnBRSWNQTnZNczRyOWVxTlpaQjBsMFFHSXlRVjlhdTZkSk9aY3dldTNkdTc5emV1VXIrMVdZZXJHZkxqZWw4N1M0bFN4K0FMOXR1ZFpYYjR4Q3FtQi9tWmJhYld1N0F5eTlheHVOOGdwT2UzMllnRExkZ09ZOEFkbG4vTzliT0xRSFNQYlA3VGMrbVBqMmhqTi81UHVXdGJiMVVMdkRFcE1RaDFoODBVK3pFdXNYaEZ1Y1pJbU1VM0pHUzdwVi9hZ2FWVUpKZTRRMHhKdXJxalBUTGZPbjhEZTBPajlOVFRPcU1mZkxIYTlSa1p2VXc3K0pIUjJrUmRhT1FrcjJLN0sxbzVQSlFQczVvRHRXdGhBdlFheDlSTnZaVGFlWG9EUFdPTHVXQWJ0SXBmTi84WHZZRUR2ZWpydXBaVDFkSFUvQnhpOCt6dkdiNG5BejhlbGNlRUFVci8ySitMN2RUNk5uT1d4cUxUb0JSZG10M1QvZW5aZUVvM2ZqejEvSXJydmxEZllFcGYrS0IvdmNOWlkwQUFBZUlTc0dER3BSci9teGZFTjlYeWJ5VllBMm0zdEptbXRvZTdKVXBtSjZLV0lWR0wvaWxiM0loTCsraS95K2ZKdDczMzFET2RZMzFrU2IxUzMvYjJ2MzRxUDlTcWsvdEdhTzJlcm9Ld013VFJ5SHNOSlhjYzltV1JzSGVuNysyK3FsYjhiNzZ5dTVneFIvV3p2LzhTcy9nMEYzVzVOK3pvQi9VODM3OTY2UDZDREMxUy9Bd3lpZ0l1emhySW9JTTF5U0NGK0dKUUdBeEF1cStNS0JjWjJ6ZjBGbzRPS1NHUFJ1Sndha0ZkVHRiWmhCc09nR2FweFNHWEJpbjJGU0dsKzErdHQ0d1JBQVdoNnRKYzVhY2FhbTlNOHoxVGEvYjcvaThmcy92eGhsekkyMU9GVVFhaHp0RktFTmNMajhzTVVNTEE0Rmlqd3lVZlQ0MFRwSk1acHhTZndWdUw1S1RtcEZscVNKUnJCTnNGNSt2THJGRXRDK2pCYk80WDRPOUVtaU53QkdYdDhUSXljckx6UC9OTjdxbHBycVZwa0FDQWdNREJOb0UyOWtkTjBBdlNOSFZKYnhtdWdYVWVUcmxPTEVtbHNkUHAvSXd0Z3Z2dmZtN3lJVWxrS0haQjJ4Z000UEwrdDFEZGdwVnMzNmtuRW1jU0xHaVJUUDkwTlZDd3c1RnFET1FhbDBndUVoREppOEIxQzNBRlVjakRuZGk0a25wUnpJQ3gyVUlnZWx5eWVybU1tTldtRFVzY0hBVk1sMExjUnE5eUxTcDA2Y1NoM2FFb08zWFMwenA2SW5RTWV3R21oM2c2Z0U4MUxWUFMxRmFzOEIwZ2xTSWhxbWFmQmJNQURkUHc3TEE3alpyKy9PdFVneDRnWTNGQ3JXdzRjT0k4UURkQlRjbEdwNG9iSm1SVkVuU3pCMGJCblRvR0NCQWhhOWd4YkU2K3dSZzRDYTI2bEo0RExjYllHWkxjVlZKU2t2LzRkNGxSVEhVZktVdW9ZYmR0SkNxVGt5OHVQSGl3b0RuK0FwNUFsY3pTQUxGT1cyaktxSkUzYnB4c3dBNnBJN2hhdFoyU2l2bFV2TVJYMmxIRnRiM05URzl4SElxazUvTTcxOVpPR2M3VzN6K3VQLy9BRElGa1hvdVdMZkVWTFpRRjhRcGM1QTJoV2ZkWFhjZEJ6WVJsb3BsbHpYUWhURjFRWGpJU1RBc3RzNHkwUHlEVzN4MENTVlhNcmExSjRjeS9EbURsSElCMW1qampiU0lDR0lNZ3dHbVdTNEJoWkZQT2VKbDRaaUVTQ3JpUzFDcFBJZVdRdy9xRnFKam9HMVRsem9LTnBraWlsTG1GZHQ3WCtwMG9qSjhKZE9iTSt6aHFPYWFiTElDRVdNNEhEbGhOcDBGMDJVWCtTeWtRMytFY0lNa0Rld0UyVWRxVTR5RXhTZ2MvMXpqbVdmWStDa2hoVjU5UldNZmFDU3pZbTFoOXJKVGJvYmVaNkZBbWZMelc1dWtsbXJxWktEdEdJbHJmMkxHM1JhVDRuT2dET1Nwd2VnMW1sMXpUYTFMcHJHSExYd1dLQnBxU2JZNmttb0d5Z0tlWGFIMkFaK1lkODVuVlRKRENXWGZQL1JaT3R1eXAzYnJyYWs5TmtEZ0M5Z1ltMlJZVXd6NEJ5MTdWbGNDdDJ5OU8xTzdUY2hwN3FPcXdxQVNwTXBrWktKN2M3MElHMkR3M3RFaW1jMm1JbHd6UXdYNzdjTVF0N2t2dnpkMGx1eTlnQ21KR3F2WE9UelpSMVNVRUdzblZSUXNTWmJGWEl4eFpzUFppNEhIZkpSSWpNeTlQQXRqd3FOTkMrckxNRDRtNDJ3alJ5ejAwUDZwQk5heUhxNU1WcUxVZUpaTmhLUEdOV3pJOHYvYU9rMkdSRnpqaU5NY0swMVcwQ0kyVVBBZGw3SzdaYzA0S3p5bU10Y3kxTFpnYjF1YU50RjAxNTFZU2gzRG03VFhpTHdLTlJIZGpWMHZFdHYwTUdNWUttd3JSWlVOSk9JcTM0K2lHMmU0UkFodWh5dkVZSzdwMm5KSDZ6YkJKTTY5aHpDVzB3RlIwSGFucm5wRmlmY044d2VVUTI2c2xRKzRISkppelBWQXVXWjZxK3pQRTBiTGpySEdDd1kvcnBjQW81MjhiR2RMaThGdHkzT0pIN1haSGlYNjZ0aG5qMlozM2FCZWpPM0NMeTI1RHhlam5PNkVxdUV0L201Yzk0MjYrb0NGUHp2eFRmaWV0VVQrenN3NUxacFRlLzNvT2tPZXdLd0hPaFh0VDNzSVRPQkV1cmFGNC9XZ2ZmSkxrbllVQlFDYW1LNEtsSmhWeGY3bXF1ei90SXArUExKZkJCOEZ3bzFKS0Y4STg1elpCb2dMbTdIb2dNQ0ltNmlpMTRzME1VTWRwVk9nRG5kNFFSTG1zSGFPR3FIU2FPZUZjSDBDS04xSW53ajV0ZzBLVHFBemplS2dFTTh4dm5sQkRZWE9tOW9LdFRnYURITHFkdjZqWVExaCtJcWhlSzhkLytPaEd0ZG91dUNKNjRjK29OSVU3OVc5Z3BVTFZoTEFFaFpIc0VUWitjMFFjMHdTN3pEQ1FGakJzUTc5eTFFYTZWQzlnRlh1aG1Rc293eURzMGhtQlpDTm1NeWtZdnJZZ0NvaURodUZET1FHbUlZUFVJNndpZXlBSWlkRktVcnQxTWxXc1FQTUdaMmxIMkxrejVFTVlGZ2x5WFpKWEJ3TUdTYVIwUllPcWNsaUduTUM1aUxpSFN5MnlrQm01NWxTREI5M29NbkthaTZOLzNmRS9FQXpmMWVSVzI1T2hheHc0YittdDR4RTRoSkt0cHhrelh4MnpIYTYwdy9SSk1JZTY4QW9EMXJ6bnZqTVo5Kzg4VW85N00xYzJYd0R6Y2JJUWt6eGpCbU45T1V1NmJDWVdiN0JocjVwM2pzblN0RlZlYTJPTmVQYXEvVEowWTRtY3dkMENpZzhGQkJQY2k0d0EvVkJxZjdBZWM0UmhlNmdMeFJqR1JOS1VFRlY5S1k0dGRNR2tsbkN2RGh0T3g0TjZoeTFreXVSUGlpVWZkdUFRL1Znem5BdVZBeGxFeUN2YWdyR2xab1ViaEpsQ0UxenlsVmprbUUyVE5pbXVPYTVIMFk5elRVbEZTb1RzWk9Ob2hyMURVNmpJNFhVOFRwTmlKTTN2VXhGVTJkbzA1UStyNXg1N1Vra1dUTE1yaHAyb2lKcVJPdm9PRWcxZVFDS3V2OXE2elltQzgzS1R0T3kwTlNHWnR1S0RWMXRKZ1Uzc2xoYW0raURyN3gxRFlPTldWYWRLbFBDc2xTaHJYV1Q0ajczV3FxaTg3QzQxU1NXNWdDK1AwMHd0emo2WnpMenBiSzZxcmEyZlNnc1ZxKzZNNUFSa0xuZjdHdDBIMm10d0FMM3V0bDdFMGxFeTdmR1l0Y3czUFhhajF4Z1dvbEU5VUsxYk9sUzZiQlg1aFZVdlZuOFZBcWwrOTM2cmc1K3lvckVIWm5vWGZ2dXg1VGQ5YVFFSUdKY1BWUUtUTEhsdzRGZE5GVkZxalNNVlVNd2NtZWFXdjlhK0ZzREd0bG4vSWpLQzdjUXdKRHJLWHJVMmNLbmhtR2d1RkR1Zk9XYnpnUnJva3hXYlRCczMrdmhHbnRMUi9YbzdSRHBaR042eWxGNEdDVldoUzgwWkRUU09CWGU3SnovYzJOODI1WVdtSkZGbHBxTGUweGxHKzNXU0J1T0lEOVAyMVdObnBJU1kxdU1BL0U2WVFEK0ZWcWQ4dFJLRUxyYUhKMlh0VWRlcDNXclRHY0FpWG05RkNoRVduMGIwanFuQUpSNzVqT2VIMUJjTnNmWldTYjJ3cHNkVE44WVBuaWNNbjV4b3QrZ0VDNzcrZExURlpjZElCVG8rZlVadUY1bVpZZHRSVG8xRTBYQ0xIN0ZndnNWNVQzYzFiM1EzV0txcFJkcFROdTZNT0VhTStKMFBOUUo5cE9OcWtUclBWMTVXcFVOT2d5VHpnS0tKVGxsU1pmWjJiR21zTWdndkdSVVYvWFcyRDRNZm1ldEdCQjNORHR1alpoWnE5SnBEb09abHNuZVVMcW5zR2crSkxtNWdEQjB0UTE2WmliN2lrU3p6YmErRFRNZ1M0Y0kwR29kSmJpLy8vRloxbFVRVjBBdHR6TjU3TnBuNjhHQ3RGNHptcStkdVdZbjk5SDJmdkpEVzYxZ2p1Lzc0KzhSaHNicENmQ0FoL2h4bUUwNVpoMjNBb1diZk1zOVcvY1VyaVpWRFVYY3BUZXp1S3Rsam9XdElyck55bk00eUllKzNFWXpyT1FtVDdyUzVkcGZZYzdaekZ3a01reDcwVjVLVGgzU1RTNXhBVnRzOUV6Zm0raGdaNWlrdEkzMHBadGRxTDcyTnlFekJreU1XejNOTFV6dmlwa1VYMzJ3V3VkNFlLZTh1UjMydmpjOHYvNWhwckRQVG5nT28xTHRSbzV3aXZGZWgzYi95dU41cUxxcXQzN3pZeHVKeEl5ZXQ5ODNqMTQ4a3Vxbkd5MDg0Y0d0S01Sbm51ODd2enIvM0U1bXVOTzIxbmJsZWFHQWptVFpLOXYybk0vOU0vUStOUDlWSmx6MFFHWnJ1SVZXNmhsVFhPcGRweFR0bVIxdGVzTSs5Y21YY3ZQZERIbmRXeDhMZHk0bVpOdTZIV0czZklpTjg5c3pONnVyWC9Qd2RMYkZ1Zkd6THRoNm0rbnAwRDUrNjFHUDdrT2ZudTdYeno4ZUNxMS9ZNG81L2M4bGZ6OFhmZTJuZWJLR2YvQ0ZkVHRnZXMrQWUvMm5mMkxHZ0E5WUl6aTBlQVJvWU1zSGZmVEhDcExIZ2F4M2Y2Y0diK3puYUtvM2dTWjRLTHgzZ21zVUk2dDNnWW1YUy9abWVjakdlSXJoZ0VId1MzSW1kSHh3RnhLb2doOFhnVDZZU2NWWGV5WG9nUzZZZHhsSWhOT1hNMFU0ZnlPb2hNOFhmellYaEZSNGc4RlVoV3NVTGpJSUQvQlhnMDBvZlRENFVxNTNjejNvRVVtNEJ6QkdQVjJJaFZYL1dGNXNxRVlRcFh6MjkzZzZlRGswaUlSenFDWHVGM1RVVlhGMStIQ1k5NFpZU0dDQ3FFWVZxSWRSQjRZSXlIeFIySEY3NkllTnVIODJHQ2NxTm5kZlY0aVk2SWFZcUVBc3FBbVRhQU9ydG40Uk1UQkhTSWVBVjNudmQ0ZDRFRFdiaUlsRzFJbzdGSWYrOUlreFFJdFVZNENNK0lST09JcHRsNGRRSjRET0p6YXdpSW1IT0l3SVpFYXg5NFU3YUl2ajhJRmV0NFZxY1lZUEozZDhHRytRcElyRzZIY05rNDBLbElKNXNHeHVVbjFxd0l3TjZJc1g5NGh2dDRHbUdJbis1SFBjcUgrSDg0N2FzekNPbUlobUlZM0xSSTVLNEl6M1p6NFlhSTR2cUl1NUtISHk2SVAvVjVEWmc0ejFHSWJwVjRZVXNJWjhvSSt5b295ZVNIbFUvNGVQeDFXS0NObDM2TGVSMkNPTGR5Q1J5TVNQOXdpUUdqaUZxVGlHd1hpSksrbVBjcWlTSHBsL1F4aVRkbE5wRVltTllpQ1NPb1dMNGZpSGVNaVRHYW1PZXJBcDFhVjROSmwvMjNpVXFkT0pYZ2lUeWJpRWU5Q0JhbU9TVElXVDBJR1J2T1NUa21pVlNubHBNOW1WUkpPR2RnQ09VR2gza0lpU1NzYVFyNGVXRjRtT2NHYVBCOGhOWUtsN0J6bVhkQU1SbHFZTEFiaUlieW1RUmdpWFpTbVhmTVdPZFNDVzFzYVhkaGwyZUptWWRlT09YUkNLY2FtQTBKZ0ZPb2tDWk1tRVRvbUl3UGdLT01pWWZRZVNudmt0aHZrR2xRa0JVdm1OV0prSFBUSnlHK2VXQldpTlo0bVk2Y2Vhb2VsaENsbWJFYk9ZcThpVlhWQ2FEd0NaTWY5SWlvU0pTQ1E1Z01PNVRJNkhtN1pHajhvSk1ZNFpKUlE1aTlINWo0Q3BtUVM1bGl6Sm1iNUphT0pvQnpiWm5FUjNoZUQ1TUtNWkV4QlpCeEJIZ3NkcEI4QTVtSDZKaHQxNWxWcDVCMFE1bmovb2VmWjVZNVVvVUtuSm4xVEpVUEhKWHJ3cEJqUkhodGdaZ29BMW4vbFpYK1c1b0d6eW5FL1FudGFKb0tJNG1kQUpsWXFvZm0xWm5ZQTRvUE5na1E1NmFVd1pvcVhTb0k5Wm5GR0pva1Babndaem5wR25vaDJxa1dNWm9QNHBveVQ2WGQ5NW82V1NvNlRwb2JObm82M0pvU1VKbE1iSmx1bjRudFFKbTNYSGl6cnFaeWJhcEFHeUdFYmxtdzFCbXlmcW1wSEpZRWdha0JyYWp3NVpFaXdLcFlmRmltTDZvRFFxQ0FvcUpDNy9LcUJBR3BJd0dwUm1HWnU2dG81R1duUjFXcVlYeHFONGlpT2RxYVpwQ2dkaENnbys2Z1hiV1NIL0NhQ0QraVNaR1pkV3VxZnY5S1NPYWh4U1NnY0ZDbXRxZVg4V1doNW5DbFZ2dXBVWVdwV0hpcHlCR3FtSUJhR2tlaGltZWhWWXVwRFh1WkpmS2dMcDZWZnJLWitMdW95SmlscTNlcXBaR0lpNm1oaVE2Z1FTV3BGdG1oV2hPcVBGaXFqRFNxdVgycExRODZtOW1sTy8rcXpnZFpwQlFLV2Iybk9kK291dGFxZE1xblhKeXFsLzJxUGhLcTFDdUtia2VoSEoyUVRYcXFuVCthTGZLcTVDQ3AvSGFwN3R5cVd2K2tUN2VhNjR4WVA2R2lEZWVIbjFPcFlsMDR1enlxWUZHeDdaYXF5MWVwTFo2WjROMjYvUVdxZ1FTNi92Ly9xUTh3cW9GNnR1QVp1aXpxcXRGR3Fwc3FrSmZacUFFNHRicVZxeUZGRXR4RXFrUDdtc2ZkbXRYTGVaZXBXckMxS29KNHM3bzRxeU84U3JPc3NVNmFxcThXcUhGWXVyTE90dU9mc3hHMHRQTm51MEdDR3hQY3VuVHZ1ME0zZXR3WHFPQitzSENjdWx6UEJ1dTVpcER4UzF0SkswVXN0RDlUbTJoOUVqTGxtTE5FdUpZaHVrTGd1QUVWVzBXU20zM3JtdWltYXVacHRBTjV1M2JKTzFMbUN0NDBxWmEvc0VVZnV6dTdtcWNBcXpOYmV0Zk90LzFOcTRYeFN5NnRxMlRadXh2VG00VGxDNGZtc3JTMnU1Rkh1MWtFczNyeGE2Rm5HWjlZSzNCTHE1NDBpNTlPUkZDUXE2V01DMXIvQzRIdHVvcENzMFpYdTdBakpwL1hDdlZmOXJxeDBib3pJcnJMQTd0WUdMZldCcnVMcWJQY3E3dkl1YnRzS0N1S0JhdkZpanBBcDRyOFZndHhHcXVpczd2RVg2c002clE3UWJ2bkI3cFVGTG5FTjdLRXdMcnVlTEI3RnFnZTBMWlo3cnArbEx2cWN5dXZhN2Q1SUx0RzlMdkZ0S245d3J2L0dyc1AzN3ZkRGJlQUhzdG5HYXYyU3J2UXlzQnU4ckJZQzdzRW5LdUJ0NnAxbktyYlo3b2RSckpQbjJ3RHJVdkNEOGxFSUpBNzdadXdTTHdTM1l3Vmd3dnBTNnZzakx1c2pLd2lOOEk3OWJ3M0hIbFE0Y0JKVUt2eXI4c2h0OHVmVzdPREJzdkJROHBDV013eEVEdGtyOEFDN2NLd3Vjd2VyNXY5SjV4SzdtdWxNTXZpOXB2YWpZeE5vanUxN2NrRVRMeGE5cHdTUWN4VEgvdTc5bnJMaklSOE5OY01NemE1UmhYSk9vTzhjMTZyM1JPOENDT3NUMVVNZDNiTWJhT2IvVlM4VktpN2szU0kxMjNKaEZuTWdjVE1oNWxNQkM3TWE2czhqUktMMUlyTWFvS2NpRExKZ1p4OGlxQThlZWJFbkpDc3FIbThRRURNaVRaOG1zK3JHcHJNZmRpOFl0aGIyaC9Mby9QTXZUVzhEN3lNZW5lN3pzQnNsN0xNbkE2c3N0TE16WXFzbUNxOHEydkNiNG04d1Z6TXJWYXNnVFNiY0lqTXdjQzh5VHE4dlhiTTFlUWN4NHdzVE0zSk5XL00xcTBNUFpYTXVxU2NtWkM4MDlzTU1Tck02T3dNN1BqTTJLYXNyaUhDQVJYTS9DaThsL0s4TjNTODFDcTgxZnk4c2V6TTlZSzlCOVROREtxcy80WENPa3ZOQ0lJNDRONGJYYi8relA2RXZQN292TzdCck9oWW5SVm1qUXd5ekhEdDBtRFIzU0FCdThGaXZOQ256QUJ1dklBRXpSTFdyTWI4ek44NnpRMCtqT0pDMnI1bnpUaEtxS0tKekZLZzJ2c094MTEraktNeWpQUnlEVDZvdlFPdDBVM2p6SFR4eTJSTDNUUnMyMktEMjN1RHloaC9uVHErdlM3TW5SUzkwTThQelZBRERTaGhyVmtjelNFT3pWNlR6Vk1jM1ZIMnJTRlozVFZ3eWlZbDBqRVYzWExUM0FaQTFYZmx4RVNQM1JBSTBESjZ6V0ZSUFdOV3ZUZUEzT1pKellHRnZWZ3czVDlmUFhQeHJZNFlEWUUwRE9nYXpSRjYzVWpPMTBadDNaQThhaWovM1psVXphUlczUmJnclhDT3ZXcjl5bDZTZlJvSDJremh6Ympjekd1WXphcloyV3FOekdRZitOcVhLcTI3TWRsN0pNMndrZDNNUzkxcWh0MkRHdzF3SjgxV3M4M0ZyZzBmRk0yYzNJMnB4cjJjZHQxYnVkM1pWdG8zZmRVaml0eFlFSjNUM3RyYmk5MWRRZElrM04zY2d0MSt5OXo5NU4yR3JMMXQyZDN0SHMzSmRzM0F3TDIvV04xaThzM2UvdHYrSWQ0Qyt3U1AyUXdnTit5d21ldUVPTjMzbTkyTHpOeVdKTTRJbXgzbk84MXdmKzJ3aXUxYzI5M1Z2czRROE80cHRkMVhFdDRoVHVETXI5MVh1dGw3RVp4TzJzMmwxdDNhdHQydHNyNDQwTjRTL0w0U2VleFM0TzJudnRjbzJER1VIK1IrS0hWdFNVTVptbEhkN0FmVXplS0ozbFdWRGVBWnZSR1ZRT1drN00yZjFNNDZYdDNpV3U0eUJoNC9SNzNqdWV4Znl0NGxuLzYwYkFsK1pwVHVRZHhISXFOMzV3dmxsTXpuMzdOUkpRdmloVW51ZFdqdDVjSHVOYWJzUjRQT2JDMmR1Q2JwbG5ydWFJbnVpS3Z1Z2ZCRWhjRVg0b2h4MlhKWENWeFEyYXRlUnpyaG5mc09sUlhucDVydWVMVWVpR0lkOWZ6ZUtSemVpb251cXF2dXFzampHaVhoaWt2dFFaTG1TdFh1dTJmdXU0WG5oZS91b0N6dXMzTU9zTEF1UzVQdXpFWHV6R0xwNitmaEdTemRqQXZpRGpkdWxLL3VhVzVlYVJIbnFFQTBqSG51M2F2dTFDQk4zSmJzSmdudDBOa1Z1UDllbUwwdW1lcGVucW51bVNaZW5Tbm5Jc1YrMURIdVRjWHU4Y05hZmZqdUQ1Ymc1L1hyTGxidTVTanU3cjNpanNmdW51VGxudlR1MXMvdWowTHVRT3IzU0YvN1B2RnJIc2lUM3VFbi94bDBieGVHM3hHTi94VkJick9zM3hIai95RndieU55M3lKSi95MzlYWDNOM3NLdi95dU1YeTJlM3lNRi96T1pYaXNxN3hOci96UzR6bHRHM3FQQi8wRTJYaFlRejBRbi8weGtUMFhzemNTTi8wZGFQMFRjejBUai8xRVNQMUFXNzFWSi8xcDRMMTdJM0lXdi8xcW1QMEdQL1VZRi8yYTRMWit3NzFaci8yMzF2bU9vM3piQi8zS1F2M0pFMzNjbi8zZzc3Z1kvN2RlTi8zcHFMMkkxemVmai80YThMMXh5MzJoSi80L3Fyek9tMzRpdi80elJyb0orNzRrRi81Mk5uamVBMzRsci81NzR6ZDRxejVuQi82RWtEMk00L0Zvbi82VFNIQzc0MzJxTi82a1Uvb29xNzZyai83UnV2emVFMzV0Si83Yi8vZDcwdTl6THIvKzNIY2g5OE94c0JmL1BudDl2VnN1c2EvL0o1cTM4a3MrOHdmL1JrdC9MenUrOUovL2V5TDR6cytzdGpmL2RudjM2Q2R1OTQvL21IZTU4UTlxZVNmL29nRC9aM05yK3IvL2xzTy9va2RyZkJmL3lKQS85bTl0L1lQLzFKUi9UeTcvd2dBdXR6K01NcEpxNzA0NjgyNy8yQW9qdVJHRkdnNmxHenJ2bkFzei9RaXBDbFI3M3p2LzhDZ2NFZ3NHby9JcEhMcEdPQlFPcVowU3EzMlRzK1ZkY3Z0ZXIvZ3NIaE1MaGNEVDFUQXpHNjdZZWowK2sydjIrLzR2SDdQandXd09GcDlnNFJmTjA5UmhZcUxqSTJPajVDUlRXbUprcGFYTElBcW1KeWRucCtnb2FJVGNVOENvNmlqcFRpbnFhNnZzTEd5czBhYUtJTC90TG1FVG9pNnZyL0F3Y0t5dkU5enc4aGxmMm00eWM3UDBOSFNYc3VtMDlkVHF5bkgyTjNlMytEaEhMWUZsZUxuTmVUbTZPenQ3dSs2aDlidzlDTGF0L1g1K3Z2OGl0VTQ2L29KZkZBc0I3ZUJDQk1xWEppa0lKUldEQkgreXhHeG9zV0xHRXNJSU5jc0l6MTVyRHlLSEVteXBMcURKZEdsS1pleXBjdVgvRUJ1Z2lsdUl6T2FPSFBxeEhaeVo3ZWVQb01LSFJwTEpncUlSSk1aTGRBeHFkT25VQmROaEJKMW1EcWtWYk5xM2RyRzRWR3V1WllHQkV1MnJOa2s5MWllZlVXdUFNcTFjT1BLbGVHMUFOYTVuTVRpM2N1Mzc0ZTBZLzAybXFwR3NPSERpQm5Vdlp1NGtON0drQ1BIQlN6WjM5WEttRE5yOVVxZ3FlWTZkUU4vL3g1TjJxVk5SRzlMbXprTmtMSHExN0F4dHZVY0cweUF1clJyNjk0ZEV5anZNR0pkL3g1T25CM3U0dFJtSTEvT1hGeGF0ODJyRVBBZHZicjFaS0d2THhuUVZyajI3K0JURVdZYS9zenMxT1hUcThja0Z2MTZ1aXNKdUg5UHZ6Nmg4UVBtMnlmQmZXWHUvUUFHV0FkcklRbjRBb0VHR2FqZ2duUzBKUitESkl6M0lJUVVWdmlGaEJhQzBCOGkvMlhvNFlkQ2JBaFFoeUE2c0JSVCtwV280b294T0pqaWlnZyt4T0tNTk5ZUUk0bzFQaUFoaVRuMjZDTUdkWkgzb3dKQjhqamtrVWd5OE1kbFB6cEJYWkpRUnVtQWhDOWFLR0pyVW1hcDVRSlh6bFRqaloxdEthYVV0NjBrNUl3M25qbm1ta2Z1T09ONE9MSXA1NUJnVmlrZ25QOFR6cWxuajBIbTZTR2UzdTBwNko5RjJsbGZtZkVGT3VpaUZjSnA1S0Y5UHNyb3BBS0NLYWw2ZUY1SzZhYjJkU2tqaEloU29pbW5wTDdYcDZMcndSbG5xYXhTR0NvaXFKYTNaSHlqdG1vcmVLOWlHV0NhcTk3cXE0RjRHaG9kbnFMOWF1eDdhUklRYTNYSjVuZnNzNVcyVmM2eXpIa0toWi9RWmt0ZnN0UVNkNXUwYW1vcnJxblNLaXRya09VNE8rNjZ5SUxiclc2OGhzbnV2T3RabTY1MjlrNUw3NzdxMlN0dmM5K2FxUysvQkllWHI3cklxY3JVdXdVM1hCdXZBekJjV1FDODl1cnd4ZEhGS3pGa0FadjVMOFlnWnd6dXg3RlZiRzdJS0E4N01yYWtkV3hteENuSERQQjBBck9zV2NVV3k2enpieTVUSW9Dd2U1VTU4cy8vT3hlTlhMNDVRNFl6ekVZM1RSelNURWNtQUxwUUlPejAxYnROTFhDNlFKUFZjNkpZaDgwejBpY2Jobk5uWFl1dGRtSmtXNDNYUnVCK3V2YmN0U2s4OEZ4YXg0MDIzWHpYVGJiTllIMU5TZGw5Ri83YTJXNXZKYmpQYVJ2dWVGK0x0OWE0UzVIbmtQVGptTjhjOXkwYnAxUzVycG1IWHRybjVSQStGT2x5aTY0NmFYQnZYZnJrRldudCtrT3dyMjY3WEVqbjBMbENGRytlUStLM0I0OFo2dFB0M2cvcVZkY3UvUEp3dFQ2N3NzcTdFOENzczNQTi9QV2xPZS82M2hqMVhuM3kySWVmdmUvbExCdzd6ZDlETC83NjQ2ZXYva0RJNng0OSsvU2ZwZjNzVWRmai9mZWMxKysvYXZmYlhuN21sNHY5OFk5Ny8wdGd5OUNYUHVCZC84T0E3aU9hQWljNHV0eUp5bml1aU4rSU1FakJEc29GZ3RVN1FjUUllSWtBaHZCOUhreWhhalNZQXdRVzBJSWVjNkFLWjZpWjNwRnZjQkxNSU02MjFoa08wdkNIUVlPaHgxeklDUlplRUloSTVJMFJMMGhDMjB6dGhoNHpYeEtuT0RZbzFxeUhUV1FDeGZwalJWcGxrWXBnREpvSitRY1FwZ3pRRFZ2czRoVnpHTVkyZW11SjI4UGlGMWt3dlRHU2tZbHV6T093N0hqSEdJNlFDSFhramhwRCtFYzlHdkk2V3l4Zkgvc293Z0dNY0g2QlpPQWlHK2pEUTFxeVpVOGM1Q1FwVWJyT1JPeG5vSnlhSUJXNXlVVTZjbzZYVE9WbjBsaktWcnJ5bFJ0RXBTcG51Y0p2YVJLV3VEeGhJV25KUzFjNThwYTVmT1YwZHRuTFlwWm9lazIvQkdZd2EzWktXUnJ6bVpnU1FDYVgrVHd6c2hHYTJKUlRIYWZaeGVuMDhKclpES2M0eDBuT2NwcnpuT2hNcHpyWHljNTJ1dk9kOEl5blBPZEp6M3JhODU3NHpLYys5OG5QZnA0akFRQTdcIixcclxuXHRcdFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvL2dBN1ExSkZRVlJQVWpvZ1oyUXRhbkJsWnlCMk1TNHdJQ2gxYzJsdVp5QkpTa2NnU2xCRlJ5QjJOaklwTENCeGRXRnNhWFI1SUQwZ056VUsvOXNBUXdBREFnSURBZ0lEQXdNREJBTURCQVVJQlFVRUJBVUtCd2NHQ0F3S0RBd0xDZ3NMRFE0U0VBME9FUTRMQ3hBV0VCRVRGQlVWRlF3UEZ4Z1dGQmdTRkJVVS85c0FRd0VEQkFRRkJBVUpCUVVKRkEwTERSUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVLzhBQUVRZ0I3QUxzQXdFaUFBSVJBUU1SQWYvRUFCOEFBQUVGQVFFQkFRRUJBQUFBQUFBQUFBQUJBZ01FQlFZSENBa0tDLy9FQUxVUUFBSUJBd01DQkFNRkJRUUVBQUFCZlFFQ0F3QUVFUVVTSVRGQkJoTlJZUWNpY1JReWdaR2hDQ05Dc2NFVlV0SHdKRE5pY29JSkNoWVhHQmthSlNZbktDa3FORFUyTnpnNU9rTkVSVVpIU0VsS1UxUlZWbGRZV1ZwalpHVm1aMmhwYW5OMGRYWjNlSGw2ZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJoNHVQazVlYm42T25xOGZMejlQWDI5L2o1K3YvRUFCOEJBQU1CQVFFQkFRRUJBUUVBQUFBQUFBQUJBZ01FQlFZSENBa0tDLy9FQUxVUkFBSUJBZ1FFQXdRSEJRUUVBQUVDZHdBQkFnTVJCQVVoTVFZU1FWRUhZWEVUSWpLQkNCUkNrYUd4d1Frak0xTHdGV0p5MFFvV0pEVGhKZkVYR0JrYUppY29LU28xTmpjNE9UcERSRVZHUjBoSlNsTlVWVlpYV0ZsYVkyUmxabWRvYVdwemRIVjJkM2g1ZW9LRGhJV0doNGlKaXBLVGxKV1dsNWlabXFLanBLV21wNmlwcXJLenRMVzJ0N2k1dXNMRHhNWEd4OGpKeXRMVDFOWFcxOWpaMnVMajVPWG01K2pwNnZMejlQWDI5L2o1K3YvYUFBd0RBUUFDRVFNUkFEOEEvVk9paWlnQW9vb29BYklmbHhqT2VNR3ZqRC9nby84QXNsSiswQjhMMjhRNkZhQ1R4bjRmak10cVUrOWMyLzhBSEY3OGNqNlY5bzFGTEV2bG41UndPT09sQUg0TC9zb2ZzLzZ4OFdMWFU5UytHbmlTYnc1OFgvQzhodUJwam55aGNRQTdkeXVlalo0SzlLKzAvZzcvQU1GR3ZFZnc1OFJXM2dmOXBIdzNjK0ZOVCs0bXZHM1pZNWd2QUxwanBubmV2SHJYR2Z0dS9CdlhmMlNQalZZZnRFL0RSVXRkS2U3alhXZE90enRWWFkvTVdVY0NPUVpYMkpCcjZrOEo2dDhLditDaS93QUIxbDFUUzRiOHNvVzV0R0lGM3BrNS91UDFIcm51T0tBUG9ydzE0cTBueGxvOXZxdWlhbGJhcHAxd3VZcm16bVdSSkFlZUdCNHJjakcwQVl4eDByOG85ZS9aKytPdi9CUFhYYm54ajhMOVVuOGEvRHlGdDEzcFV4TFlqNzc0eDJIOTVlUlgwdjhBc3pmOEZMdmgxOGRaTGJSTldsLzRRenhhL3dBZ3M5UmZFRXora2NwL2tlYUFQc2lpb0lwdDZCeVFRUUNDcHlENy9TcFZKN2tVQVlmajNVSjlLOEVlSUx5MWtNVjFiNmZjVFF1dlZYV0ptVWo4Ulh5Si93QUUrUDI1MC9hUzBGL0RmaXVlQ3o4ZmFZb2FVZ0JGdjRlZ2tWZjcyYzdnT25CNzE5amVKdEwvQUxiOE9hcHAyQXh1N1dXQUJ1bVhRci9XdndyOEIvQTN4Rm9taitPZkZYZ3E1ZXcrSW53cjErVjd1d3R5UTgxanV3ckxqNzJDai9VRVVBZnZJRGpuQUI3MCt2bnY5a2I5cWZSZjJwZmhyYjYxWnlpMjF5MGpXSFY5T1hob3BjZFY5RlBKelgwREhuWnljbWdDdGVPa2NiU09kcUlDekFuQUk3ayt3eFhNL0RyNG9lR1BpanBVMnBlRjlZdHRadFlacExlV1MzY0hhNk1WYkkrb05lYy90cS9GZTMrRHY3T25pN1cydWhiNmhQYXRZV1B6WUpubCtWY1YrWkg3R1h4WDFuOWlQOW9tMzhKZU1Sanc1NHV0clI1SmlUc2pXWkZlS2Rmd2NCdnBRQisxcWNEazVQclRKK0UzSE9CMS93QWFpaGw4K0paSTN5cmpjakE1Qnowcnk3OXBENC82Rit6ajhMZFM4WGEzTUMwQTJXbHFXdzExTmo1VUE5elFCNWorM1YrMTFaZnNzL0RXWVdCam44WTZtaGcwcTBKejVZN3pNUFJldnZpdmtiL2dtUit6QnF2eEQ4YjNueDU4Znh6VGJicVM0MHo3V3Y4QXgrWExrbHJnajJKNFByaXZDZmhCOE8vRy93RHdVaC9hV3Z0WDhVM3M2NlJiU0NmVTdoY21LMHRzL0xieFo0QjdBRDYxKzIvaFR3enB2ZzN3NXAraTZUYUphYWZwOXN0dGJSUmdLcXFxNHdBT25TZ0Q4dlAySWJ6enYrQ21YeFlLRENUWEdvNS83K212MWpYN29yOGtmMkZMbFgvNEtTL0ZBcVFVa20xSERqbkE4MG45YS9XMWFBSFVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGTmNuSEJ4K0dhQUhVVlc4OVVQekVqNi80VXBuQklDSEpJL0dnQ2RpQU1tcTF6Y0phUVR6enlwREJHQzdTU0hBVURra24wcDQzSGpkajhjMTgwL3dEQlEvNHR2OEkvMlcvRmQ1Ymx2N1MxU01hVmFsVGdocGZsY2o2SnZQNFVBZm1YKzE3OFdOYy9iWS9hc3N2Q0hoVjVMM1FyYTgvc25TSVkyeWcrYjk1Y2ZRNEp6NkthL1hIOW0vOEFaODhOL3M0L0R1eThMK0g3UklXVkExN2RFZnZicTR3TnpFK25VVjhHL3dEQkdyNEYydDFaZUkvaXBxdHNsek9rcDAzVEpKVURHSTlacEZKNkhvTStqR3YxUFJWQTRBN1VBSWo1T09udFR3TVVCUURrRG1sb0FqbVVNdUQvQUR4WHhuKzFwL3dUbThHZkhPd3VOZDhNVzlyNFM4ZElHbVM1czR4SERlUDF4S282a25IemRxKzBLWTZEREZRQXg3NG9BL05iOWtmOXMzeGo4S1BIaWZBMzQ4VzdhWnFkb290OVAxZTdHR2JuQ0k3SGhsSXdGYXYwaWdZTmpiZ0FBRGc1eHhuRmZOZjdjUDdKdWsvdEtmRFc2a3RiVmJieHBwVVRYT2s2akdBc205ZWZLTGRjSEI0OWE0Zi9BSUpzZnRMNm44V2ZBZXBlQnZGczd0NDI4SU9MUzQzcmwzZ0h5cHU3bGdWZFQ5QlFCOXJVVWk5QlZTK3ZJYkMya3VibWRZSUlnWGVWMkNxcWpxVG5pZ0M1VWNtTzQ0OWZTdnowL2FSLzRLMitIUGh2cmwzb2Z3KzBoZkdGNWJ1WTV0UW5sTWRvckRxcWxlU1FhK1h6KzBWKzE3KzE5cTF6TjRKajFqVE5MWTdGaTBNRzJ0bysrMHluQUorcG9BL2FZM1VhNDNTcDZaM0FacVpXemozNmMxK1BOait4bCsyemQyOFYwL2pEVXJhUnZtOHVYeElDeW4zdzliZHQ0Mi9iZy9aUmdiVXZFTm5kZU52RDBKTFRDNm5UVWxWQi93Qk5FTE5HS0FQMXVvcjRWL1o1L3dDQ3JYZ0g0czZsWmFGNHNzWi9CR3ZYQkVhdE93ZTBra0p4aFg2ai9nV0srM1lMMk84aVNhQ1lQREpoNDVFSVpaRlBUQkZBRjJpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBcEdBWlNDTWowcGFLQU9ZOGQrQk5GK0kvaFBWUERuaUN4ajFMU2RSaE1FOXRLTjNCL2lIdU9vUHFCWDVIZU1mRG5qRC9nbG4rMFpCckdpdGM2eDhOdGNZQm81TStYUEdEODBUbnRJZzVVOVQrZGZzb1lRU1RuazlUWG0zeDcrQm5oejlvTDRkYWw0TzhTUWVaYlhhNzRaVkE4eUNSZnV1cDlSL1UwQVgvaFQ4VE5BK05IZ0RTdkZHZ1hrT3BhVHFjZTVjZFY0K1pISFp4MElQYm12blA5cUQvZ212OEFENzQ1clByWGgyRmZCZmpFWmtTK3NFMlF6eWRmM2lEdjArYnJYeEg4Q2ZpMzRzLzRKeC90RzZqOE9QRzgwc25nZTd1ViswSm5Lckd4UGxYU0hzT3pZOURYN0lhVnE5bnIybDJtcTZmY0plMlYxQ3MwRTBKRENSR0FJSVAwb0EvSjN3bCsxTjhmL3dCZ3p4VmFlRlBpdm90ejRuOEhCeEJiM2N1V1l4NTRNTTNSc0FINUNhL1JuNEZmdFIvRDc5b2ZUUHRmaERYb2JxNENneTZkTis3dVlUL2RaR3djam5rY1YyL2pqd0hvZnhJOFBYdWgrSXRMdHRYMDI2UXh5UVRJQ09lcHoyUG9SWDVmL0hyL0FJSm1lTi9neHJ0eDQyK0JHczNza05udXVScGlUYkxxSEJCeEdjL09PdkI1NG9BL1dFUHUzRnZtWEhUQUlIclg1cDZCZDJ2d0YvNEtxYTlvZDM4dmgvNGdXQ3BIYnVQM2J1NkFMdTl0eVMvOTlWZi9BR1UvK0NwTnZxMnEybmdqNHgyYmVIUEVNVExhL3dCc1NJWTRuY2NmdjF4OGg5K2xabi9CVnZTZjdBMS80Uy9HYlFieU1uVDd3VzczVnVRUXlLNnVoRERya0Z4UUJ3bnhpOEthNS93VGcvYXAwLzRpK0hJN2lYNFllSmJ0emQyYU1kaWduTXNCWC9aSnluc2NEcFg2aGZEejRtYU44VlBCMm1lSi9EVjdIcU9sYWpDSjRKWXp5UjNRanN3NkVkalhBL0VId0w0YS9hNS9aOFd4djRra3NmRVdteFhsdGNMOHh0cFhqREk2azlDcE9EWDV4L3NvL3RBK0l2MkV2alpxdndZK0pieU40WGx2VlZicHR4V3prZkJTWmZWR3lNNDcwQWU1ZjhGWXIxL0VtdWZCUHdNanNZOVQxbHByaUplUE1VbEZYUDRocTZiL0FJS1Zmc2cydnhKK0RkbjRvOEpXTGp4TDRTdGxFTU1BeVo3SkJsa3lPNmprVjVmOGVmRXkvR1gvQUlLbGZERHcxSHR1Tks4Ti9aWldNYkIwbUJIbmxnUngwa1VjZWxmcHBjV3lYRnRKRzhZbFNXUHl5akRnb2VvTkFIeEIvd0FFd3YydUcrTXZ3eGs4RitKTDJOdkZIaG1JSkc3dGlTNnRGR0ZjanV5NHdmcG12anI5c3I0cWEzKzIxKzFicDN3NThGeUhVTkNzcnIrekxIeXptSjNCeExPM2JBT2NIMEFOZHA4VnYrQ2VIeHArSC83UWV2Nng4RjRQSjBMVS9PYUM2aXZvNEdoaW16dmlJWmdjREpBSTdWOUtmOEUrUDJDcnY5bk9XOThXZU9CRE40NHVGYUNBUXVKRXRvVDk3RERnc2ZXZ0Q2US9ady9aODhML0FMT1h3OXRQRFBobTBWQnRXUzd2aWQwbDNMakJkbTY5ZWc3Q3ZUN29Sd1dzemtBQkZaemo2YzFPSWdwR09QYXN2eFhmcnBmaG5WcnR3Q3NGckxJYzlNQlNhQVB5WS80SlpPM2lYOXNuNGtheHMza1d0eEx2NkFGcHdQNUUxK3Z5OUsvSkwvZ2pMRUxuNHUvRkM2TWVjMlFBa3owek9EWDYyZ1lHS0FGb29wQ2NZb0FXaW9ubDJIR1AxL1NsU1hkMUdENlo2VUFTVVVtZVJTMEFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZRdEl3RFlZY2QyNkNubCtjQWdtdmxiOXR6OXQzUnYyV3ZDNldsaWlhcjQ2MUtNaXcwdlBFYTlQT2t4MEhvT3BvQTllK05IN1F2Z3I0QStHMzF2eG5yMXZwdHV3Smd0ODdwNXlPMGFEbHZ5cjgxUGloL3dWaytKM3hMMXU1MFg0UStGZnNFRWpsTGU0RnVidThsWHNkZ0IyazFKOEovMkUvaWgrMlQ0aWorSlB4dDEyNzBqU0w1eE5GWXNwRnpKR1RrS2lkSTFJL0d2MHYrRWZ3QzhDZkJUUW9kTDhJK0c3UFNva0dHbThzTk5LZjd6djFKTkFINVk2WCt6dCsyNzhiTFgrMDlVMTdXZEd0Yms3aEJxR3FpMktnLzhBVEhkdVg4cXRmOE13L3R3L0N4dnRtaStKZFMxQ09Ia1JXK3Vvd2Nlbmx1K1crZ0Zmc09Zd1FSemcwalJidU54QTl1djUwQWZsVDROLzRLVC9BQmwrQXZpQ3k4UC9BQjQ4RlRQWnM2ckpxTFd6VzF3cWQyVmNCWk1kYWwvNEtuZnRBK0dQakYreno0Q3VQQnV1VytxNlZmYXNibVF3dUM4UldGd0ZkZnZLZm14Z2pGZnBYNCsrR1BocjRuK0dydlFmRStsVytyNmRkUm1PUkxoQXpZUGRXUElJNmdpdnczL2IzL1kzdS8yVS9GOXZOcGR4TGQrRGRXbGM2ZkkvM29XNm1KdlhqT0RRQitxLy9CTzN3aEQ0UC9aQitIcVJ4aUZyKzFPb1RJUDRwSkRnay9rSyttSStSWGluN0dldHdlSWYyWFBocmUycUtrVDZQRXUxZWlrWkJINWl2YkVYYUtBRkhTbHBCeFMwQUZJUm1sb29BamVKZHA0SEp6elg1cmZ0RHhSZnNoL3Q4K0JmaUI0ZmdXdzBEeHl2MkxWcmRGMnd5VEZ3cnRqb0R6R2ZxV1BjMStsamZkTmZuYi93V0p0UXZnRDRiYWpDUDlOdE5kUGtldVdDSGo4VkZBSDMxNGo4VDZmNFQwUzkxYlZyeUd3MDJ6aU0wMXhLMkVWQU9wTmZqOSsxcisxMzQ2L2JIK0pNSHcwK0VLYWpONFlrT3lLT3pRcEpxREE0ZVppT2tZUEhQSEdlOWRaKzNGKzBoNHorTUdvZUUvZ0g0UHR4ZDNGL3B1bnZxaHRuTFNUWER4S3pSTmpnS0F3SlB2elgyWCt4Sit4dHBQN0wzZ1kvYS9KMUx4bnFRMzZqcWFxUDNXQnhDaDdLT2Yxb0E4dS9aRi80SmUrRXZoTmFXWGlQNGd3eGVLL0Z4Q3ltMG1BZTBzNU80QTZPUjYxOXo2WnBGanBGb2x2WVdrRm5ib01MSGJvRVVENkNwNG9WVUJ0bzM0NmdkS2xBeFFBbmxxUjA5NmptdDFsaGRDQXdiczNJcWFrWVpIb2ZXZ0Q0My9hOS93Q0NkM2diNDhhSnFHdGVHOU10dkR2anRWTXNOOWFyNWFYTGdaMnlLT0NUMHpYeGIreWgrMmo0NS9aQitJc253dytLMXZjbnc3YjNCZ3VFdkZMWEZoemdTS2VyUjkvVEhJcjltREdkdU4zT090ZkpIN2R2N0VPay90TytGMjFmUzFqMDd4N3BzSk5uZElBdjJrRG55WkQzSG9lMUFIMURvUGlTejhUYVJaYXJwbDVEZTZkZXhwTkJQQXdaSkVZY01wSFVHdGVNbGtVa0VFanZYNVZmOEV1UDJodGY4RGZFYlZ2Z0w0N21rdDVJREwvWmNWM3cxdFBHZm5nR2Y0U29KQTljVitxc2ZDZ0hxUFUwQU9vb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS2lNWHpBOEU0SXlhbG9vQStVZjI5L3dCa2JULzJrL2hkZVhPbTZkRTNqclNJak5wbDBBQVpBT1RDeDZrTU00OXdLK08vK0NjLzdaVjE4SXZFMG53YytKOXhKcG1ueFRHS3dudmlRYktjSEhrTVQwVWs4ZHEvV3FTSm5mN3E0SHI2OWlLL01UL2dxcit4dWwzWVQvR0x3bmJzTDZBTEhyVmxCR1NYWHRPdU9oR01OOVJRQituS3lMTENqb1ZlRmdHREE1VmdlUVFSVC9LTGpxUHhIYXZ6MS80SmgvdHRyOFR0S3RmaFg0c254NG4weTB6WVgwajVXOHQweGhNLzMxQjZkeDlEWDZISXdZdGdnMEFmTC83Vkg3QW5nRDlvN1RMM1VGc292RC9qTmsvYzZ6WnB0THNCd0pWSDNobXZ5MStPUGhYNCtmczVmRDNVdmhWNDJzNTlWOEMzc3lOYVhUSTF6YlJ5S1R0TUUzT3cvTWZsT0R6WDcxeUx1R01aSGNWU3ZOTGd2a0NYTnREY29QdXJNZ2NEOHhRQjRIK3dYWTYxcG43Slh3OHR2RU5xMXJxQ1dicjVVbkxlWDVybE0rbVZLMXh2N2VIN0VOcCsxSjRYaDFMUkRCcC9qdlRSdHRMbHpzUzRUdkhJZlQwUGF2ckZMWXc1RWNleU0vd3JnWXdBTUNwV2pKSVhZU3VPT21CUUIrYy83RFAvQUFUMjhmOEF3WCtNZHQ4Ui9pQnJWaGN5MjluSmFRV2NVc2tzNEpVS3BMRmR1QUZBSFBhdjBiQ2tqUEFQdDYweEltWGsvZVBHVjZWS293dUQxOXFBSWhia0Q1VHRQNTA1WWRwQkdCNjRxUUVHbG9BU3ZPUDJpZGFUUWZnUjhRZFJaaW90dEJ2SnZsNjhSTWE5SE5lT2Z0ZkdYL2hsdjRwaUJROHc4T1h1QjMvMUxVQWZDUDhBd1JSMDF2UCtKMnFjTXUrRzNEZHlTZDM5Sy9VM3p4dXhnNTdZNXI4Zy93RGdtMysxTDhNLzJZdmdyNHl1dkdXdEcxMVMvd0JXamtpMCsxaU1zOHFyR1Y0QUhBejYxMnZ4TC80TFJ4SHpiUDRlK0JKWjVuUGx3WGVyeWhTQ2VtRVRkbjZIRkFINmpmYVY0ejFQUURrL3BYbmZ4SC9hTytHbndudFpwdkZYalBTTkphRWJudDVMcFdtUHNJd1N6SDJBelg1WldIaXI5dFg5c2lSN2F5WFVmRCtoU2pMeXBEL1pscnRQZkxZTC93REFjMTZ2OE5mK0NRdHZGTC9iUHhiOGVTNnRzL2VUMjFoSXdSU09TWGxrd2NBWnp4UUIxSHhpL3dDQ3huZ2pRbG50dmgvNGV2ZkUxMHYzTHk5LzBhMk9EM0IrZnBuK0d1eC80SjMvQUxYdmovOEFhazhSK041L0ZlanBhYVRiTEMxaFBad2JMZUlna05Gdk9DekhJUFR0ejJyNEorTjlyNFkrT1h4ZjBQNE0vQWJ3dGEyZmh5eXZmTEY5QkFXbHU1dVZrdVpYUE94RjNIMzdacjlqUDJlUGdsbzM3UGZ3dTBid1pvaWZ1Yk9NTmNUTVBubm5ZZk81UHVmNUNnRDFBZWxMU2R6UzBBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVoSUhVNHBDdzU5cUFLT3M2Z05KMHE4dmxpTXYyZUo1Q3E5VHRCUDlLL0t6OWlqNFQzWDdZbjdRdmk3NDQrUElocU9rYVpmdC9aK24zSjNJWlJ6R0NPaFZCamoxRmZxcmZRbTYwMjRnSS8xc0xJUWZjRVY4SmY4RXNMdTI4SjIzeGMrSFUyNkhVdEE4U3pGMWJ2R0RzeitZeFFCOTV3Mnl3eExHbVFGNkFjQWUxVEtwQUdjZmhTSmdIYU04Q24wQUZGRkZBRFpPSTI3Y0hwWHh6L0FNRlV2aDViK012MlN0ZTFIeXQxN29WekJxRnVWR1NTWkZqYlAvQUhiOHEreDJCSU9QMXJ6cjQrZkN0L2pUOElmRTNnejdZYkY5V3RXaFNZakt4dDFYUHRrQ2dENTEvNEpRK01WOFMvc2phYmFQSnZuMGpVTGl5TWVjc2lEYVYrbWN0K1ZmWjZuSXI1Sy9ZSi9aRDhVZnNqNlg0djBiV3Rjc3RiMC9VNTRMbTFlekRLVVpWY09DR0EvdkN2clJSaWdCMUZGRkFCUlJSUUExemhEeG12Z1gvZ3J4SFBxL3diOElhTnAxakxmYXRmNjdIOW1raGpMbUxhQURqSFRKWWZsWDMyd3lNRVpyUHZ0SHROU2VJM2xuRGRHQnZNaU1zYXR0YjJ6ME5BSHlUK3dqK3hORDhBOUZieGY0c2VIVy9pSnEwWWVXK2ZjMzJTSXFNUkp1R2M0SEovRHRYMkZIRVZVQWtFZGVLRlFnRFBYTlNEcFFBQVlGTFJSUUFVVVVVQUllbFJtSml4NUJIVVo5YWxvb0EvTWY4QTRLcGVBRStGWGpINGNmR3Z3MVl4MjJyMm1wcEZmU1EvSUoyVTcxTDQ5Y1lKOTYvUnJ3SDRqajhZZURORTF5RUVSYWhaeFhLZzlSdVVHdmlyL2dzSlBuOW5QUjdOSTJsbXU5YmlSQW95ZHdHY0FkeWZhdnNMNE82Rko0VitGWGhMU0p3Vm1zdE1naFpUMUJWQm1nRHNhS1o1aSt0S0pGT09lVDJOQURxS1FNRFMwQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJUSGxTSkM3dXFJb3lXWTRBcHg2Vlh1WWttdFpZNVU4eU4xS3NucUQxRkFITk44WC9BQUlrbmx0NDA4UEsrU3UwNnBCblBwamRXdFkrTWRCMVJ3dG5yZW5YYkZ0b0VGMUc1SjlPRDFyODdmMnVQK0NXbGg0Z3NiN3hYOEpaWmRKMWFOV3VKZEdsbVl4WEo1WnZMN3EzWGc5YStLdjJldmdWcG54UDhUNmg0UDhBRS94SzFUNFplT0xWekhGWmFyRTBNTXhIWXlOSUNyWjdFY2pwUUIrL3U5Y1p5TWV1YXBhbloyK28ybHpiWFVLWEZ0TW15V09aUTZNcDRJSTc1RmZsYWYyRXYydXZoMWF5RHdqOFdZcjYxakcrM2p0ZFRsVjVCMndIVEhUM3JtanAvd0R3VUk4TEV2SmNlSWIxYzRYZmQyMDRJSG9BM0g0MEFjeiszQit5NzRoL1pGK0x0cjhWZmg3RkpaZUdKcjRYZHRMYUE3ZE5uenpHMlA0RzU5dVNLL1NqOWpIOXFqU3Yyb2ZoZkJxeWVYYWVJckhFR3EyQVlaamx3UG5BL3V0MUg0anRYNXYvQUJSK1BYN1cycC9EN1dQQnZ4RCtIOXhyV2lYMEpqbmVYUVhsbFRuNVhEb1NNZy96cnpiOWlYV3ZpejhCdmpMcGVyNko0SDhSWG1sMzBxV09wd0RUWmxqa2laaGxzbFFBVnlmeU5BSDcxaDFiQkRBNTlEUzVxbmJ0NWdXVGF5YmxCQ3Qxd2VSK1BYTlcyKzc2VUFMdUdjWkdhVGV1VDh3NDY4OUt5dGUxM1QvRFdtVGFqcWQ3YjZiWVFETXR4ZFRMRkZHUDlwaWErZU5XL2FrMWY0ajZnK2gvQkh3MUw0dm53NGZ4UGRnMitqV3B6ai9XRVptWWVpQWozb0ErbDd1L3RyQzJlNHViaUszdDBHV2xsY0txL1VuZ1Z5T3FmR3I0ZjZNTTMzamp3M1ovOWQ5V2dUK2IxNHhwWDdIRUhqQmY3UitMdmlmVlBpRHJjM00xcjlvYTMwMk05MWlnWG5BNkFrOUs2eXovQUdPZmdyWTJ5eFJmRFhSQ2c0dzhKYlAvQUgwMUFIcGZoMzRsZUUvRjhxcG9YaWZSOVpkdWlhZmZ4VGsvZ2pHdWtMQUhCSUJyNTU4U2ZzTmZDTFYwV1RUUERnOEphakNRMEdwK0g1M3RKNEc3RlNDUVRtdVB2L0hueFA4QTJXTlJ0RDQ2dTMrSWZ3dmxrV0UrSm80eEhxR2toamhXdVZ6aDR4M2NkT3VLQVByVWtFY0VIbXNQeG40V3RQR25oTFdOQTFDTXZaYW5iU1drNm9lU2pxVk9Qd05UYURydGg0azB1MDFMVEx1QzkwKzZqRXNFOXUrNUhVOUNDT0RXdjJGQUg1ditHdjhBZ2pCNEx0UEYwMTdyUGpQVk5TMEh6V2FIVDRJUkJJRUp5Rk1tVHorRmZXSHdzL1kzK0VQd2Q4bC9EdmdmVDQ3dE1IN2JkUmlhZmoxWTlUK0ZlNDAxK2xBRkVSTERCc2pSQkdvT0l4OHFnZlFEaXZ6WC93Q0NuMzdiQ1dGbzN3aDhBNmdiclZyMCtWclYxWmNtSkR3TGRTT3JFOWNmVHZYc2YvQlI3OXJEWC8yZXZCRnBwM2hYU3JpVFY5WTN4dHJNbHE1dHJKTVlQemdZM25QQTlNbnRYeHYvQU1FNGZnZDRROGJlTXBQaXA4U2ZGMmhlWmIzTFM2ZnBXb2FqRWx6UGM3cytmS3JzRHRIWWZTZ0Q2NC80SnEvc2ZINEUvRHovQUlTN3hQcDVnOGJhOUdITWJZTFdsc2NGRXoyYy93QVg0Vjl1eGpjUWNFYzg1SFNzL1EvRU9rNjVIblN0VXN0UmpYZ20wbVdWUjlTcE9LMXdlYUFEK0tsb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNrM0QxRkI2VndmeGsrTVBobjRHK0JyL0FNVitLOVJUVDlNdEZKR2VYbWZzaUwxWmo3VUFkemNTckRDN3V5b3FqSloyd0FQVW12RHZIMzdhWHdVK0dVa3NPdjhBeEIwcGJsR0t2RFpTRzdaRDZFUkJzSDYxK1MvN1VmN2ZueEkvYVcxdit4ZkRqWDNoencwOG5rd2FUcDB1WnJ2SitYZnQ1TGY3STZWZStDUC9BQVN1K0x2eGJzTFRXdGFlMThINmRjNVkvd0Jxcy8ycGw5UkdBZWZaaUtBUDBvMHovZ3BaK3p2ckZ4SGJyNCtqaGtiZ1BQWVhDTCtaanhYekw4U2ZpbjRhL1p4L2FjdFBqcjRJMXZTdkVIdzI4WXF0aDRodGRKdTBrZUdYSE1yUkE3Z2MvTnlPdFo2LzhFU0lCcHhadmloS2J6SHlvTktYWm4vZTh6UDZWNXA0OS80STYvRlR3L1lUeWVHL0VtamVJWUVYZUxUelpJWlpHSG9wWFpuNm1nRDlkL0FIanpRZmlSNFZzdkVIaHZWWU5YMHU3UU5GZFFPR1Z2VWNkQ080Nml1a0JCNlYrT2Y3R3Z4bThlL3NKZUo3M3dsOFUvQ1dzYWQ0TTFlN1FMZFRRc1lyS2ZJVXVHKzZWeDF4d1R6WDYvNlRld2FqWlFYVnRJazF2T2dramtqYmNyS1JrRUgwb0F2VVVnNm1sb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0ErVS8yLy9nNTRzK0tYZ0h3dHFuZ3pUVjFyeEY0VjF1SFdiZlM1TnZsM0czZ2h0eEFQQnppdmxEV1AyaHYyOC9EOXE5eE40Q2lXQkNTQkZwYVhES3ZwaEhKUDVWK3JkUlNBbGxJNmc5YzRvQS9Jend0L3dWcStMbncvOFFRV3Z4UjhDcExaajVaMFd6ZXd1RkhxcXZ3VDdaRmZlWHdHL2JlK0V2eDdndElkRDhUVzlocTgzSDlqYW93Z3VRK003UnU0YzlmdWsxNlI4Ui9nbDRIK0x1bXZwL2kvdzNwMnVXckhQK2tRRGNwOWQzV3ZpejQwL3dEQkl2d2RxYzQxbjRaYTllK0M5VmlielV0cFNaWUN3UHk3U01NblBjWm9BL1ExSEJPYy9nVHlLZnVIcUsvTDM5bno5dFA0ai9zOC9Gb2ZDbjlvVjNqMDBNWUxUWHJ5TWd3N1I4ckdUN3NrYkR1RHhYNlphWmYyMnJXbHRkMmt5WFZ2TkdIaW1pT1ZkVHlHQjdnK3RBR2pSU2RLV2dBb29vb0FLS0tLQUNpaWlnQW9vb29BUnZ1bkE1cjVLL2JOL1lUOE4vdE9hYXVxNmMwZmgzeDNiRGRiYXBGSGdYQjdKTmpISCsxMUh2WDFxUmtVbXdlbnRRQitTL3dEL2JRK0lIN0lIajVQaEo4ZGJlN3VOSWdrMlE2cEsrK1cyakp3aGpQOFVQQjV6a1pyOVVmRG5pTFR2RkdqV1dxNlRlUjMrbjNzYXkyOXpHMlVkVHp4WGpuN1Z2N0ozaEw5cUR3VlBwbXRXMGR2cnNLbit6dFpqWEUxcS9vVDFNWjZFVjhEZkFyNDVmRS8vZ25oOFFZdmgzOFhMSzl1L2h6Tks2MjEraUdWWWhuaVNGemo1Y1l5aDU1L01BL1hJeEt5RkdVT3A3TU1pbXhXc01BeEhESEdPdUZVQ3Nud2Q0cjB2eHY0YjAvWGRFdm90UzBtL2hFOXRkUXR1V1JEMFA4QVRIdFd6bjVTYUFFbDRYT1FQYzF5M2ozeDNvbncxOEozM2lMeEZxUzZicGRralBKY1RISlBzRjZsajJBcmUxSytoMDdUcmk3dVowdDdlQkRKTE5MOTFGQXlTZllDdmpmd0hwdHgrMnY4V0wveGpycnZMOEh2RE4vNUhoM1RjL3VkV3VFLzFseklPTW9HNFg2VUFYOUUrSHZpWDlzelhkUDhXK1BvSmRDK0ZWcE45cDBid216Rlp0VVgrQ2U3L3dCazQzS3ZvZWErdGRFMFRUL0QrblEyR21XZHZZV2NReEhCYlJoRUErZ0FGVzBnaWppU0pJMUNLb1ZWVVlBQTZBZWxUYlI2VUFBQUFIRkJBUFdsb29BUWdIcUtvNjVwVnByZWwzTmhmVzhWMWFYS0dLV0dZQXBJckRCQkI2NUZYNmF5aHNaR2NVQWZHRmxhdit3dDhRYkd5RjNPL3dBRC9GRjZVV1M1ZmNQRDk2NXdrYW4vQUo0T3hIUGJOZll0dEtKbFdSSFY0bkc1Q3JaQlhIVWUxY244WC9oWm92eGsrSGV0ZUVkZmc4N1RkUmhLSEErYU54OTExOUNwd1I5SzhuL1l3OGRhcnFmZ2pXZkEvaWljM0hpdndGcUw2SGVTOTdpTlNSRE43N2t3U2ZXZ0Q2UEhTbTA0ZEtNQ2dERzhTZUd0TDhWNmJOcDJ0YWZiNm5ZekFocmU2aldSR3lNZEQwTmZuaDQ4L3dDQ05XaGVJZkVtcDZ2b2Z4RHU5Q1M2bWFXT3hYVFZNY09UbllHRW1jRDZWK2t4QXowcHZDbmdZUHJRQitWQy93REJJejRuK0daekw0YStMNlFzdklNalR3Zm50SkZlYWZHZnhoKzBaK3hIZldOdGYvRzJ5MTI4bk8xZEZ0N2hyaVZZd0NROGlzZ3dPUDcyYS9SSDl1ajQwZkVYNEtmQ2dhcjhPL0RFbXZYODd2RmNYcUlaUDdQajJNZk4yRGs0eDlLL0dqNFFmRXJ3VHF2eGgvNFRINDVUNi80cWhXWDdVOW5aeHBJOTFNRHdzak82N1ZIOTBaOUtBUDFmL3dDQ2QveGwrTnZ4czhMWG11ZkVteXM0L0RzaTUwMi9FWGszRjAyUms3Y241QjYxOW1qcFh3bDRQLzRLemZBR095aHNvclBXdkR0bmJxSW9vWHNZd2lJT2dBUnppdlYvQ3Y4QXdVWS9aKzhWeUxGYi9FS3p0Sld4aU84Z21pT2ZjbE1mclFCOUwwVnhmaHo0eCtCL0YwS3lhTDR3MFBVMWZvTGZVSW1mL3ZuT2YwcnJWbFpsUmxiY0NNL2RKQkgxb0Fub3FGSE9lU1NmVEg5YWtVa2tnbm1nQjFGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSU0U0b0FodURnRWx0cWhUa25nZm5YNHRmdGVlTWZHZjdidjdXemZEVHdiUEpmNkpwZDBiSzF0bWt6YlJ1bUJOY01SMnpuaytsZnAzKzJiOFc1L2duK3poNHk4VTJqSXVveFdwdDdNeWRQTmsrVWYxcnlIL0FJSnFmczQ2QjhQUGc5by94QW1zMm44WitLTFUzRjVmM0hMYkdrWmxDK2dJSVB2bWdEclAyVXYyRmZBbjdNK2t3elIyMGZpRHhWS2dOMXJOM0VHT2U2eEtjNFVIUFBYdlgxQ0FPTURnVUJGVThBQ25VQUpnRHRSZ0R0UzBVQVorcTZMWWE1SDVHb1dWdGV4RGtKY3dySVB5WUdyZHRGSEJDa2NNYXhSSU5xb293QUI2Q3BOb1BhbG9BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0JNQ215QUVmTWNBOFUra0l6UUI0SisyTit6blpmdEhmQmZYdkR5MjFvdmlJeENUVGJ5UUFNa3lrTXFsc1pBYkczOGE4RS93Q0NWSHg0MVR4ZjREMTc0WitLcnZ6UEVuZzY0OGlGYmgvM3oyMlNwQUhwR3dBei90aXZ2UmxHUHVnbk5mazNQZEQ5bVQvZ3JHNGdqYTIwanhXNER3eGpDbExrSGFNZW5tSXBvQS9XZWltTVQweVFjNHA5QUJSUlJRQVV4bjI1Nyt3cDlZSGpmd29ualB3dHFXaXZmM21tQzlqTWYydXdrOHVhSStxdGc0TkFHM3VmakFCK3ZGWm1wK0t0STBRa2FqcTFocDVBeWZ0VndrWC9BS0VSWDV2ZkgzOWlEOXBQUkxhYVg0Zi9BQmcxWHhYcEtJVDlndmJrMjEwb3gwRERJYys1SzE4WTJCWDRYYTNKcC83UVBnangzZmxtSWE1L3RtU1BCLzJReXNqRFBvNG9BL2FmeFYrMXg4SGZCYnVtcmZFWFFiZVJQdktseUppUGI5M3VyeVh4SC93VkwvWjkwRXNJUEZjK3NGZW9zTEtRL2tYQ2l2a3I0UDY3K3dMcjhWcEZxV2hYV21YTGpFamVKZk5QemVtNkpqbXZzajRaZnN0L3NyK0pJRnZ2QnZoVHducXlTTHVCdExwcHlQcXBrSkg0Z1VBZVNhLy9BTUZtdmhEWURicG1oZUpkUmtCKzg5ckZFcCtuNzAxd0d1ZjhGbzViamV2aG40VDNkK0Q5eVc1dmlwLzc1U052NTE5MTJIN00vd0FLdElaR3RQaC9vS0ZDRG43RXJZeC92WnJyclQ0ZCtGTE1ZdC9ET2pXNHh3c1dud3IvQU95MEFmazk0aS80S1JmdE4vRWx4WitEZkFUNkpIY01Famx0ZElubmtCN2Z2R0FVZmlLemsvWSsvYTMvQUdvSm9vZmlScWMybTZPMHl6N3RmdVk4QUhxWTBqQk9jRS9LZHRmc1phYVZiV01QbDJzRU5xdjkyR0pVWDhoVTdRYnU0SjdFak5BSG5uN1Bud2lzZmdSOEovRHZnYlRyaDd1MzBxMjh0cmlUNzBqa2xtT08zSjZWNk01MmpBR2FSSTlqRmljazllS0pBMlBsem1nRDVjL2JsOGI2dGVlRi9EM3dtOExPQjRrK0lWNy9BR1o1eVB0YTN0RncwOGc5T0RqUHVhOTArRjN3NTBuNFQvRC9BRVR3am9rSWgwelNyZGJlSTkyd09TZlVrNUpOZk5Qd3BXYjQyZnQwZkVIeGZjbzF4NGY4Q1djV2c2UktSbUl6eURmY0ZUL2VCd0sreFBKQUE1NDRBQjdVQVA2WUZPcE1VdEFCUlJSUUFVVVVVQU5kTndQT1BldmtiekpmaHAvd1VhaHRrbk1lbWVQL0FBdTB2MmRlRTgrMUdOMys4UXRmWFRmZFBHYStQZjJnNUk0djI3UDJlaXEvdkd0dFFYelFmNGRqRGJRQjloRHBTMFVVQUppbXNPMVBwa2pZNmM0NisxQUVjdHJIY1J0SEtvZU5oZ28zSUk3Z2p1Szh4OFJmc3NmQ1h4WElYMVR3RG9seTVPU3d0Z25jSCtISGNBMTZna3U0WkhwNzFTMW54RnBuaDIwZTcxUy90ZE90VSs5TmRUTEdvL0ZpQlFCNEI0by80SjNmcy9lSjQzODc0ZVdObEt4eVpyS1I0M3orWkg2VjVyNGsvd0NDUjN3RjFhTi9zdHZyZWt5Znd0QmZydC9Jb2E3YjRxZjhGSi9nWjhMWGx0NWZFMzl2MzhmVzEwYVB6am4vQUhpUXY2MTh2ZUlQK0NvdnhVK0s5OUxwM3djK0U5MWN4U1BzdDlRdlludU4yZUFTQUZWZisralFCcmEvL3dBRVk5SnRIbG44SS9GRFZ0RGtVWldPZTIzL0FKdXJyajhqWGovajc0QS9HWDltV3hhOTA3OXBMUTdlT0Z2bHRyaldaUE9ZRHQ1WlZ6bjJyMHJSL3dCbkg5c2I5b203KzBmRVR4L0o0QjBtYjVaTEtLVlZrQytpSkgvVjY5bDhCLzhBQkpmNFVhTGRSWC9pM1U5YjhkWDZqNXpxVnppSmo2N1JrLzhBajFBSHhGNEwvd0NDcGZ4LzhPMzY2T0p0SzhhUEczbGhuc1htbG01NmdvUjEvd0IydjBqL0FHVGYyaXZpbjhabGRQSHZ3b3UvQmNIMmNUUWFxMDZtS2YyOHM0WmZ4cjF2d1A4QUFMNGQvRGEwaXQvRFhnN1I5TFdJQUs4ZHFyT1ArQk5rL3JYZHgyNnhjS0FGN0Qwb0FjakZzNTRQcFQ2YXFCU2NkemswNmdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0FvcEdPS2FYeGpwK0pvQWZSVWZuREdRQ1IwcmlQSC93QWN2QW53dHM1THJ4WjRwMHpRNGs2cmMzQytZZm9pNWI5S0FPNGFUQkhHUjM5cVo1ak4weG5QUWM1RmZBL3hjLzRMQS9DL3d0YjNkbjRLMHpVdkdHckE3WXBBb3Q3Uno2N3psdncyVjg5WEg3VzM3WUg3VE14dFBBZmhhNThPV0U1MmliVDdJeEFLZldhYmcvVlJRQit0SGlQeGZvL2hPemE2MW5WYkxTTGNBa3kzMDZSS0FQOEFlWVovQ3ZsNzRyZjhGUXZnZjhOUFBndDljbThVNmhGbFRiNk5BWFhkN3lNVlg4aWErYnZoNy93U3grSS94TnVScVh4citKVjhVYzczMDZ5dVh1V2JQT0N6RUtwK2ltdnE3NFhmOEU0L2dWOExoSEpiZUUwMTIraklJdTlha003QS9RYlYvU2dEODZ2MnVmOEFnb0RxUDdYWGh2Ui9CR2wrRVovRDJnWFdxUWw1WnJneVBkTUh3b0FDZ0RBYmtaUFd2Mk4rSEhobVB3WjRGOFBhREZHSW85TjA2M3N3dnBzalZmNlYrZW4vQUFVNjB6UmZCL3hDK0FXbmFicE9uNlZweTZ5ODBpMmRza1FZN29sR2RvSHBYNld4Zk1XN2dIZyt0QUV0RkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVUxMzJESjZkNkFCeHg2ZS9wWDVhZnRmL0FObmVLLzhBZ3B2OEpkTjAyNFZ0VXRQc3YyeG41VmRyRjFYNjRWdnpGZnBiNDQ4YmFSOFBmQ2VxK0k5Y3VrczlKMHkzYTV1Wm0vaFZSbjh6MEE3a2l2eU4vWXYwTFUvMnRQMjhkYStLbDJrc3VoNlZlUzZnOHBPQU1xeVFKK3U3OERRQit4MlRubnJtcEtqRVkrVWs1d2NqNjFKUUFVVVVVQUZOSUpwMUZBRVRSQmllQjB4OWF3L0Z2Z0xRUEhlbXRZZUlkRnNOYXRHWGI1ZDlBc2d4M3hrY2ZoWFEwVUFmRmZ4Ty93Q0NUL3dWOGRSVHlhVFpYbmhHK2tkbldUVFp5WXdlM3lQbmoyQkZmSS9qNy9nbDM4YVBnbmNOcjN3cjhYdHJ3aC9lR095a2F4dWdSMCtRRXEvNG12MktkZHdBL1VkcWlLTWM1VUhIUTkveW9BL0hMd0wvQU1GTmZqcjhCTlFqMFQ0cWVHSk5jdDdkaEU3WDl1MXJkS0FjRWlUQlYrUGI4YSs2dmdOL3dVYitEbnh5bWdzSWRZazhPYTFJQWZzV3RBUlpiMFJ3U0NQcml2ZlBHSHd5OE0vRUhUWkxEeFA0ZTA3WExXVlNyL2E0RmR1ZlFuSkg0R3ZpdjQxZjhFaVBoMzR2U2UvOEM2bGRlRGRXTGIwaFovT3RTZlRIREQvdnFnRDc2dHIrM3U0RW5nbVNhRitra2JCbFA0amlwUE9YT09RYzlLL0dmV2ZnbisxcCt4TERmK0pkSThUU2FsNFowNENTZDRML0FPMDI0anpnYjQ1c1lIVGhUbXZzNzlnVDlzN3hUKzFGcFdveGVKdkN6YWRlV0EzZjJ4WnhNdG5jZXFEY1NRM2ZnbWdEN0xTUVAySVBvYW9lSkwxZE44UDZsZU45eTN0WlptNXh3cUUvMHE3RHpnanBpc0Q0azJwdmZoMzRwdHhrR1hTcnFNRmV1VEN3NG9BOEkvNEo5YVNJL3dCbnUwMXZ5eXNuaUhWTlExVm1ZNVk3cnFSUmsvN3FMaXZwckhTdm4zOWdpZUYvMlN2aDJrSk9JYlNhQmxiN3daTGlWVG44UWErZzZBQ2lpaWdBb29vb0FLS0tLQUVicDB6WHhmOEFFNlErTWY4QWdwSjhLOUdWU0lQRGVnM2Q5SzNvenFTdjU1QXI3UGRnaWxqMEhKcjQwL1pqczErSi93QzJCOGJmaWVXZTRzZE9raThNYWV4NVVDSURlVi9JNW9BK3pPdExTRHBTMEFNYVZVem50eVQ2VjVKOGVmMm92aDMrenBZUVQrTmRjRmhOZEJ2czFuQXZtWEV4Q2svS29QZkdNbkF5UnpYcTdSbG1QRzRaL2lQdlg1YWY4Rkx2MkhmR091YXpxL3hlMExWN3J4VEZ1VHo5QmVFdEphdzU1TWVHNVVjWkFBK3RBRFBqTC93V0t1TlFsbDA3NFcrRVpmUGtVb21vYXVwYVFOMkloUW5rZlUxNDk0Ty9adS9hWi9iZjF0TmQ4WWF4cU9rNkJkdDgxenFralFSN1BTTzNYR2Z4eDlhOTQvNEovZkh6OW5LYXhzZkRONTRRMHZ3VjQ3UUNKN3JWa0V5M2t2Y3JMSm5hVGpvUUsvVEMyRWJSeHRiN1BzM2xqWVlpQ01lMk8zME5BSHg1OEMvK0NWdndoK0U0aXU5ZHRKUEhPc0tRd24xUDVZVWIvWmpYK3BOZlhHZytFdEo4S1dhMm1pYVhaYVZiSXUxWXJPQllsL1FWcXE2NUF5TVl5S2ZtZ0NJMis3QkorYkhKeDFOU0l1MVFLZFJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVnWUVaenhTQ1JTQWM4RTRvQVhjTTQ3K2xOODFkd1U4TWV4cm5QRzN4QThOL0RyU1gxTHhMcmRsb21uS0N6VDNrd1RPUFFkVCtGZkZueFcvNEtvZUc0N3lmUWZoQjRhMUQ0amVJbll4Unp4eE10cUc3RVlHNXgvd0I4L1dnRDdzdnRWdExDMGx1YnE1aXRyZUw3OHM3Q05WK3BiQXI1SS9hSS93Q0NtbndzK0NWMUpwbW5UU2VNOWJVRWZaOUtrUXdxM1lOSm4rUU5lQTZaK3k3KzFCKzE5TkJmL0Z2eGhMNEs4Snp1WC9zUzFmWktFN0FScjBHUDc3TlgxTDhIditDZC93QUZmZzh0dExCNFhpMTdWb2NFNm5yUDc5MlBmNWVFSC9mTkFIeHhjZnRSL3RXZnRrU3lhTjhPZkNoOEU2RGNxUWRRMk9ueTVBNW5ZZE9mNFZyVzhILzhFZS9Fbmk2OS90UDRyZkV1YTZ1WkdCYUN4M1hEazkvM3NoNC83NXI5UDdLeHR0TnNvN2EwdDRiSzNqRzFJWUVDeHFQWURGV0E0QkFKK2IwUEEvQ2dENTErQ24vQlAzNE5mQTZWYnJTL0RTYXhxWVVEN2ZyUkZ5K2ZaU05vL0t2b1MydFl0T2dTQzNoaXRvVUdFaGhVS28rZ0hUOEJVV3RlSXRLOE4yVFhlcmFqYTZiYktNbVc3bVdOUitMRVY4dS9Gci9ncFQ4Ry9odGRuVDlOMUs0OGJhMlcyTFplSDRqTVEzb1dPQVB3elFCOVhCMUgzY1p4ejJvRWl4SVdabFVZeVNUZ1YrYzl6KzFGKzFmOGVkUUVId3YrRnllRHRGSklYVk5iWExiVDBKTFl4K0Ntb0xYOWdiOW9mNHZYeWFqOFZQamZkYWNUa3RhNkhJNTI4OUFWTVl4ajFGQUdQL3dXUXZOUHVkTitGbXRXR28yZHpQcHVxVGlaSUxoSGtUaUpoOG9PUnlPOWZvZjhKL0U4ZmpINGErRnRiamtFbzFIVExhNjNBOTJqVW5QdURrSDNGZm5EKzFyL0FNRTIvQ3Z3cS9abjEveEpvZW9hOTRrOFY2WTBkM0plYW5jbVVtTUVpVENBY2R2VTE3ZC93U2srT0ZwOFEvMmVMZnd2ZFhVWTF6d3ZNMW84TFBsM2hZNzBmSHA4eFgvZ05BSDI5UlRRNmtrWjVwMUFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJUZDR6MW8zajFvQUM0QkFQVTlLaWVWWEJDbmtjOUQ2MUZxR29XMm5Xc3R6ZFR4Vzl0RU4wa3N6aEVVZXBZOEFWK2ZYN2JIL0JTN3cvNEwwWFYvQm53eTFNNnQ0cm5RMjhtcldwRFc5ajJPdy94UGpPUGVnRHkzL2dxNSsxb25pVy9qK0MvaEs1KzBxc3l2clQyeHo1a28rNUFDT3Z6WUpIcUFLK3Z2K0NlZjdQaS9BSDluelNiZTloQytJZGJ4cVdveVl3d1poOGtmMFVaeDlUWHhML3dUVy9ZdDFyNGhlUGsrTGZqNnhtWFJiU1UzTmhCcVM3cEwrNGJwS2M5VkhKNTc0cjlkbzQyQjRRS3ZHMFl4Z2VsQUZqc0tXazdVdEFCUlJSUUFVVVVVQUZGRkZBQlNaSHJReHdNMW42dHF0bm9kaE5mYWhkUVdGcENwZVdlZGdxS0IzSm9BdmxnVjRJUEZlSGZ0Sy90WCtCdjJaUERMYWw0bHVEY2FsTjh0cm84REF6ekgxeC9DUDlvMThvZnRRZjhBQlVlMjA2K3V2Qlh3WnNaUEVYaU9aL3NhNndJOTBLT1RqRUtEbHo3bml2Ty9nWC93VGI4ZmZIanhNdmozOW9QVjcrSkxyNXhwMGs1YThtN2dOMmlUMkhicGcwQWVXNjU4VXZqdi93QUZKZmlBZkMyaExjYVg0UGVielRiUklVdExTRUhHK2FUSDd4dWZ1K3VPQjFyOVhmMmEvZ1RwZjdPZndvMGp3VnBVOGw1SGE1bG51cHVHbG5ZRHpIeDJIUUFWMVB3MitHbmhuNFVlSExmUVBDdWtXdWthWkFCKzZ0aGdrNDZzM1ZpZmV1dmo1QjR4UUEyRUhuSUl6MEI3VWx6R2tzVFJ1b2RYQlVxZWhCNmlwcVpKMHo2YzBBZkszN0pPcFA4QURMNGovRVg0TGFreDh6U3IrVFd0Rm5ZYlJkV055NWtZS1BTT1F1dkhxSytxOGdWOHYvdGUrQ05lMGkrOE9mR0x3WkZKTjRuOEZ1WHU3U0FITi9wam45OUQ3NHh1QTlxOXErRmZ4UzBINHllQ2ROOFVlR3JzWFdsMzBZWmR3K2VOaDk1SEhaZ2VQd29BN2VpbWo1VkZPb0FLS0tLQUNrSkFwYW82emYyK21hZlBkM1Vxd1c4S004a3JuQ29vSEpKN0FldEFIRWZIbjR0YVo4RnZoVDRoOFhhckw1ZHRwOEJLNDZ0STNDTCtMRVY1UC93VDA4Q1gzZzc5bXZSOVExZU5rMXJ4SGN6NjNlTklwVjJNN2wwREE5Q0FRSzRTKzFJL3QxL0U2MDAyd2ltSHdVOEszb20xR2FlUENhOWZSdjhBdTRrUGVKQ0FTZStLK3k3UzNTenQ0NFlZeEZGRUFpUnIwVVl4K1ZBRndkS1drSFNsb0FLZ3VVV1JkakxrTndjaklJN2crMVQwVUFmRFA3Vi8vQk1qd2Q4YmJtNThRK0VHajhHZUxaTjBqU1JSWnRiaGdEdzBZeHN5ZjRnZVBRMTh6L0NYOXIvNHcvc0xlSzRmaDc4WTlLdnRYOEtXcEVNRjFJcGQ0WTg4UEZMMGRmWnVhL1htWVpCNmRPZDNJL0t1SytLSHdoOEovR1R3elBvUGk3UmJiVjlQbVVyaVpmblhqRzVHSEtrWjR4UUFmQ3Y0cmVHdmpINFRzL0VuaFRWSWRVMHVkUWZNalliNHovY2tYK0ZoWGNBamFPYS9LZnhuK3pyOFpmOEFnbjU0dnZ2R1B3Y3VybnhUOE9wbkRYMmpOODdKR0RraVJPL3B2WEJyN0cvWmIvYmI4RGZ0TmFlbG5Zei9BTmorSzRGSDJyUmJsdHJBanJ0ejk0ZnJ4UUI5S1VVMWZ1MG82VUFMUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVMThkVDI1b0FYSUhla2ZsYTU3eGw0MDBid0xvczJyYS9xdGxvdW53amZMUGV5QlZBSFg2bjZWOE8vRXYvQUlLSGVJL2luclgvQUFobjdOM2htZnhWcXp5Ykp2RUY1QTMyV0JlN0x6ampyay9sUUI5c2VQOEE0a2VHL2hob0Z6clhpZldiWFJyQ0ZDN3kzVWdVTmdad29QSlAwcjRyOFNmdDhmRVQ0M2F4Y2VIUDJlZmg1ZDZxNWJ5MjhVNnNqUjJrWS92QmZUM3lmcFhRL0MzOWdUVXZGR3Z3K0wvMmdQRmx4OFE5ZTRsVFJXa1lhZGJ0MUdGemhzZlFDdnNYdzE0ZDBud3RwY1dtNkxwOXZwVmhEOHFXOXBFSTBBK2c2MEFmQ1doLzhFMi9GUHhqMVZmRVg3UXZ4SzFQeExmRmc0MGpTNUJIYnhkOXZJeGp0d29QdlgxMzhLZjJmdkFQd1YwcUxUZkIvaGl4MGFKQVAzNnhoNTJJOVpHeWE5S3JsZmlCOFN2Qy93QU10SmZVdkZPdTJXaFdTOGlXOGxDQStvSFVuOEJRQjFFWndjbkE0NXBKNVZqaloySUNBWkpKNEFyNEQrSXYvQlZ2dy9jNnpMNForRVBoTFVmSCt2U0V4VzhxeGxZQzNxQU1saCtWY0FQZ2QrMlArMWEwZHg0NDhWcjhOZkRWeHkybjJqZVZLcUU4cjVhRU1lUFYvd0FLQVBzUDQxL3RxL0NUNEYyY3I2NTRvZ3ZOU1E3RjB6U21XZTRKNTR3RGdkUFd2bkczL2JsK052N1JOKyttL0JINFRQWVdERGIvQUc5NGtMZVVnUDhBR0ZBWEIvRnE5WCtDbi9CTjM0US9DUVEzdDlvcDhZK0lBTno2bnJUbVE3K3BJais3MUhmSjk2K3B0TnM3YXdzNHJhMHRVczRJaGhZWW94R2lqMlVjQ2dENEFzLytDY254RCtNK3NEV1BqejhXOVExcFNkejZOb3g4cUZRZWR1Nzd1Qi91Wjk2K212ZzUreHQ4SS9nYXF5ZUdQQnRvbW9EZzM5OERQTS91QzJRRDlBSzl6SFNsb0FyeHFGVUtlVkhRSHQrQUZUSjBPYWdhUlZKMm5PZjRSMVA0bXZMZmlaKzA1OE1QaEFydjRtOFphZlozQy9MOWlqbDgyWmo2QkZ5U2FBUFN0ZjBtMjE3U2J6VHIyTlpyUzdoZUNTTmdDR1ZoZzV6OWEvRDdYby9GSC9CTmI5c1F6V1VUWEhoOTVUSkNqRTdMM1Q1R3p0WTlDeWc3YytxKzlmbzFKKzJmNHM4ZnEwZnduK0RmaVR4UkVmbFhVOVp4cDFzb1A4UkRCaXc3OFlydzM0N2Zzby90SmZ0YzZYRkg0OWJ3WDRkdDdPVXkyRUZpclMzQUJIM0RJY0huMDZVQWZmSHdzK0pXaC9GM3dQcFhpcnc5ZVIzdWw2aEVzc2JLd0pRa2NvMk9oQjdHdXh6WDRWZkFqNC9mRWIvZ25kOFhiL3d4NHMwMjhmUVhsMjMyalM4UnN1Y0M0Z1B1T2VPdmV2MkErQ1A3UkhnYjQvOEFodTAxZndsck52ZCthdTZXeWVVQzVoYjBaT3Y5S0FQVnFLYVB1MDZnQW9vcHA2MEFPb3BxMDZnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNrM0QxSHJTT2NLVDdWem5qdlNyM1hQQ0d0YWZwMDdXZW9YVm5MRGJYTVp3WTVDcDJuODhVQVNlS1BHM2gzd2RhU1hXdWEzcCtrd1JqSmE3dVZqeCtHY212ajc0OWY4RldmaFo4S1Vrc3ZDOHNuanpXd0RoYkZ2S3RGYi9ha0lKNDlBSy9LSHhwWTY3cDN4bW44TWZHUFhOZkVWcGR0RGZ5U3p2Y1RSRE9CSWl1Y0VkeGl2MU4vWmgvNEo5ZnM2eStDTko4WDJDTjhRbzcyTlpvYjdVNUNJZzNjZVdoQUgwYk5BSHhINHMrT3Y3Um43Zm12dytIdEhzcnFEUWJpYkFzZE1pZTNzbEgvQUUybDZzQU92T1BhdnJyOW1UL2drcjRiK0g4dG5yZnhKMUFlSjlhaWNTeDZiYTVXMGlZY2pjVHk1OStQcFgzejRiOEo2TDRRc0ZzTkMwdXowZXlVWThpemdXSlIrQ2dEOGEyeDlLQUtlbmFmYjZYYncydHBDbHZheElFaWhqWGFxS09NQVZkb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUs5ODd4V3Nra2NabGRGTEJBY0ZqamdWK1NQN1l0cCsxL3dEdEFYYzJtU2ZEelZ0SzhKeHU0VFR0SVliWlVCNGFWdDJXendjZEsvWFJsRGpEQUVlaHBGaFJRQUZ3QWNnRHRRQitJbndBdS9pZit5Njl2Y1dmN09BMVB4SkF4UDhBYk9xVzAwazZqdnNBZmFweDNBelh1bDEvd1ZxK0pYaDJaazEzNEtYRnU2ZmZDK2RHUHpLSCtkZnFRVVU5Um42MVd2dEtzOVR0Mmd2TFdLNmhickhNZ2RUK0JvQS9NWFQvQVBndFRGYWp5OVgrRTE3QXdPZDBXb2hRQjlHanJ1L0RIL0JaejRXNnBleFJheDRaMTNTSW53R21qMno3UHFCdHlLKzFkWCtDWHc5MStOMDFId1A0ZXZRd3dUUHBjTEg4eXVhOGsrTFg3S0h3TzBid0I0aTFxOCtIR2hLTk4wNjR1VjhxMzh2QlNObUgzY2R4UUIyL3dqL2FlK0dmeHpsTVBncnhiWmE1ZVJ3K2ZMYVJzUk5FbmZjdU9DRGo4NjlWak80blBQdjdWK1EvL0JHM1JJOWErT0h4QzhTUUlMZTNoMC95WTRVeUZSWnBTeXI2Y0NPdjE1anh5UU9UMVByUUEyZU5XaFpDcWxHRzBxd3lwSGNFVjhiZU1Sckg3RXZ4TjFMeGRvK2t6NnA4SGZFdHlzdXJhZHA2ZjhnQ2NqRFhFYWpxajlXSFFFVjlta1pxcmYyRnRlV0UxdGNXOGR6YlNLVmVHVlF5T0QxQkI2aWdERjhHZU45RzhlYURhNnpvT3FXK3I2YmN4cTBWeGJPR1VnaklKOURnaml1alQ3dGZKT3Qvc2QrSXZodjR1dmZGZndLOFhId2RjWEpMM1hoZlVWTnhwTTdFa25DWi9kNS8yY1lwTGo5b1Q5b3Y0ZFdFNDhWL0EyRHhiTEVjSmRlRXRUMlJ2N2xKRlkvclFCOWNEcFVjaGNFN2NEME9NL3BYeWJwWDdUM3g5OFVXb1hUL0FObSsvd0JKdUpBREhQckdzSXNTNTZaQVRQNjB5ODhEZnRUZkYrM0VmaUR4bDRlK0ZHbk0ySkxidzNhdGVYVWtmY2ViSXhDSDNBb0E5MitKM3h1OEUvQ0hTM3YvQUJYNGl0ZExRZmR0ekp2bmtQWUpHdnpFNXI1dGwwN3g5KzNGcWtNMTdOcVhnRDRKeFNGVnNXVXhhaDRnUWRXY2pCaWpQOTN1T3VhOVIrRWY3RlB3L3dEaHRxMGV1NmhEZCtOdkZZYnpEcjNpV2MzYys0OTBEZkt2cndLK2drUmV3eGpqaWdEQjhJZUVORzhDK0g3TFF0QzA2MzB6U3JLTUpiMjl0R0VWRitnN25xYTM5bzY0R2FOaStncFdPMVNmU2dCYThLL2EzL2FjMDc5bG40YUw0bXZkTnVOYXVibWNXbHBZd3ZzODF5TW5jMkR0QUFKelhyZmlUeFhwZmhMVDVML1dOU3RkTXNveUFacnlVUkp6N212TXZFbmpENFBmSFR3M2RlSHRTMTd3MzRpMHU3QmdraGx1SXlWWmdSdVRkMGJucU9hQVB6YzhSZjhBQmFINGpURVBvM2hEUUxPSGVRUHRRbGxPM3RuRGlzYi9BSWZRZkY5ZHAvNFJyd25qSFFXOXh6Ny9BT3VyWCtOdi9CUC9BRno5bkx4SVBpRDhNZjdMK0l2aHkxa01zK2dYOE1kekpGRjEybGMvdkZ4M1hCSHJYMEQreWg4US93Qm1UOW8vVExmU3IzNGUrRmZEWGpwQVZ1dEZ1Yk9OZk1jZFRDeEhJejJQSW9BK2VyUC9BSUxVL0VkVXhjK0RmRGNyZXNZblQrY2hyWEgvQUFXdzhXdDVXZkFHamxmNC93Qi9JUHkrYXYwVmcvWksrRFlZcWZodDRjNElJeFlSNC9sVS93RHd5TjhHZk1aLytGYWVHeXpkZitKZkgvaFFCOEM2WC93V3pMdnQxVDRZaWFKaHRmeU5UQ0FqdncwWnJ4VDRwZnRGL0FiNHFhODNqRHd0NGU4UmZDTDRpVy83KzJ2dEMyelJUUzljU0lvVURQcW9IWG5OZnJoRCt5MThJSUZpVlBocjRZeEdkeWc2WENjSDhWclR0LzJmZmhoYVRwTkQ4UFBDOFV5ZmRsWFI3Y09QeDJab0ErTHYySXYrQ2s1K0pFbHQ0TCtKY1pzZGVaaEJZYXhIYnVzVjRSMFZ4enRjK3ZTdjBNaVl5S0NlSzUrdytHdmhMUzVWbHN2QytqMmNxc0dWN2V3aVJnUjBJSVhnMTBlQWFBQVV0RkZBQlJSUlFBVVVVbEFDMHh6Zy9leFVRZGcyNW15ZzR3QlhnbjdSMzdhWGdIOW15QllOYnVwZFU4UVhDNXRkRDA0Q1M0ZnNDMlB1alBIOUtBUGRiKzlqczRKWlo1bGhnUmR6eXlzRlJSN212aS85b0QvZ296cHZoblduOEdmQ1RTSmZpVDQ0bGZ5c1dpdEphUU1lQUN5L2VJOU9Qclhtai9EZjlvZjl2UzRnMVB4ZHFjbndwK0dOd3draDBXeUpTNnVZK3hmdWNqKzlrZTFmWnY3UDM3TXZnRDluUHc4dWwrRDlIamdreWZPMUdkZDkxTzNjdEllZndHQjdVQWZHSGg3OWlENHpmdFBlSWJieE4rMFY0dWF6MGN5TE5INFZzbk8wS0RuYWRwQVE0K3A5Nis3L0FJVWZCM3dsOEZQRGtPZ2VEdEZ0ZEgwNkw3d2lYOTVJZlYyNnNmcm11MmtoVlkyQzRYUEhQVDhxenRZMTJ4OE82ZmNhanF0NURwMWxDdm1UVHp5QlVSUjNKTkFHazZxc1orVVk2a1lybWZIUHhFOE0vRGZTSk5WOFVhMVk2TlpRREptdTVRdjVEclh4SjhiZitDbzFuZGF1L2d6NEk2QlA0NzhTemt3SnFKaUp0a2M4WlZSeTQ5eVFLNHZ3Ti93VHYrSm43Ukd1UitNUDJpdkdWNEVhVVNMb0Z0TG41T3UwNHdxRHRnRFB2UUJvL0ZUL0FJS2QrS2ZpRDRqbDhJL3MrK0RMdnhCZVNTR0JOYm1nTWlGK21VUWNBZTdIOEt6dkFuL0JPajRrL3REMzhYaTM5bzN4eHFiVGVaa2FGYk9DVlRyeWZ1cDZmS3VmZXYwRStGZndkOEdmQnJ3OUZvM2d6dy9aNkZZb0FDTFpQbms5M2MvTXgrcE5kbUlseDA3ZXRBSGxud2MvWnArRy93QUM3Q09Ed2I0V3NOTmtWTnB2U25tWERlNWtiTGMrbWNWNm1nVWpnZnAxcEhVQWRPS1IzMmtZSkpJKzZCbk5BRWhBUFVacHNoMlJrZ2RQd3JoZmlwOGIvQmZ3VzBKOVY4WStJYlRSclZlZ21jR1Z6MkNvT1NhK1cvOEFodGY0bC9IMjV1ZE8rQW53M251ckhKai9BT0VwOFNrd1dhQS94S29BT2V2VW1nRDdIOFErS2RKOExXVDN1czZuYTZYWklNdE5keWlOQitKTmZOSGpEOXZuUTczVnBkQStFM2h6VlBpdjRqREZObWxJVXRZajZ2TVJqSDBybFBESC9CUHZVdkhlc1ErSVBqdjQ5MUw0ZzM1UG10b2tVclcrbXhuT2RvUlQ4MksrdS9CWGdEdzM4TzlHaTB2d3pvbGpvZW54akFnc1lGaUI5emdjbjNOQUh6RGIvQ1A0L2ZIeTFFbnhKOGJKOE5kQ2xPNyt3ZkJ5bGJ3cWY0WHVYTEVjY0hhQlhwSHcxL1l6K0V2d3p1VXU3SHdwYjZsckNuYytxNjAzMjY1a2IrK1dseU4zdU1WN3A1YTR4K3VlYVk2Z0hHQVYvdTlxQUZpaldKQkdvQVJRQUZBd0FQVEZMSU80VUU5UFRpb1RPQU53YjVSOTQ5bHg3MTVIOFlmMnR2aGY4RGJmZDR0OFcyRnBjbEM2MkVEaVc0Y2RnRkJvQWwrUGY3TUhnRDlvelJQc1BpN1JVdTdoVTh1RFVZc0pkUStnVjhaeG5zZUsvTHY0N2Y4QUJQOEErSlA3SWVvUDQ0K0hYaTVwdEZ0aVpEZlEzQnRidUJSenNjWjJ5RDhCbjByNlE4Yi9BUEJaTHdOcGNEeTZCNEkxclY0c0h5Ym04WVcwYnQ2QTdUL092ankvOFZmR0wvZ3BoOGJQN0p0YnE0dE5EYVVPYlNHUnY3UDB5M0hHNXdNQm03ODhudGlnQ1h3Wi93QUZPUDJrTHpWN0d4c3RTajhRVG93VTJTNmNqdEtCeGc3Um5uMXpYNnkvczNmRmY0aGZGWHdvbXErTlBoKzNnZ3NvRVNTM25teXpOL0VUSHRCUWRjY21zbjltRDlqandMK3pKNGJ0N1hSOVBqdjljS2czT3Mza2F0Y3UvY0kyUGtYUHBYdjRqVmtCT2NuSGVnQ1JUdVVIMW94UXFoUUFBQUIwQXBhQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNrS2c5UUtXaWdENHMvNEtOZnNmYWY4QUhiNGEzL2l2UWROUlBIbWlXNW1nbWdqQWt1NGw1YUo4ZmVPTTdTZW5GZklYL0JKLzlwcWZ3RDhRN2o0VTYyN2pTTmRtTFdSa0pIa1hTZzVYQjZic0g2bXYyTGtoVndlQnoxOTYvQ1g5dmY0YjNYN01uN1lzdXU2QURZMnQ3ZFI2L3A1aEcxWTIzQm5WUjB3RzR4MG9BL2R5TUVBNTlhZFhML0REeGhGNCsrSDNoM3hGQi9xZFRzWXJsZjhBZ1NnMTFIYzBBTFJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFWOHRmOEZLZmlOUDhBRGo5a3Z4Wk5hU2lLODFUeTlOaVkvd0RUUnN0ai9nS3RYMUd6YmEvTmovZ3RYNDArd2ZEWHdQNFlSOEhVZFFrdkpFVnVkc1NBY2ovdHArbEFIUi84RWJQQWFhTDhCdGY4VFBBRXVkWDFab2hLUU10RkVpN2NmaTcxK2dSZllNQWMxNEord3Y0RGorSEg3Sy9nRFN4R1ZtbHNCZHlnakJacEdMWngvdWxhOWI4YytOOUcrSDNoWFVmRU92MzhlbWFUWVJOTlBjeXRqYWc2NEhjOWdLQU5MVU5aZzB5MmU0dXJpQzF0ME9HbW5jSWljOXlmd3JQMGJ4OTRlOFIzOGxqcHV0V0Y5ZG9DV2h0cmxYY1lPRHdEMnI4cVBFdmo3NG9mOEZPZml2Y2VGUENNMC9odjRVYWRjYjVya0FvcGl6Z1BJUmpjellZaGUyZWE4OVpOUC9ZNS93Q0NpT2dhSjRXa21HajZmTmE2ZmN2Y01GYTVXV05TN01Sd2NzMzZVQWZ0dHN5UWM1OU1kL3JTaUlBOVR5UDg4MEtUMDR4Z2ZNT21ha29BaldGRjdaOXoxcUtjYldKVUVrakhJeU1WSzB1MXNZK2xmSC83Yy83ZkVIN0tGN28yaGFUb1VQaVB4SnFjUnVXdDUzSWpoaHlRR0lYazVJTkFIMS9FY2pnWUhRQ25PL2xnZWhQV3ZEUDJRdjJuOUcvYWsrRjhYaU93ampzZFV0Myt6NmxwcU5rVzB1T0FQVlNNRWZXdmJtZnpHR0FjTHlDRzY4VUFLazdNVUpHQXc3ZXRPZVRIQkhYdlg1VC9BTFMvL0JTVHgxOEsvd0JxWHhMcFBncVNQV2ZDK2tPdHBkNlplV3daUkxHQXNwREtBeTRZSG5QMXI2cS9aZjhBK0NpWHc1L2FNOHJTNVpoNFc4V3NBUDdMMUNVYkpXLzZaUDBiNlVBZEYrM1IrenczN1JYd0YxYlJiSkhtMTJ5QnZOT2pTUXFKSmxHZHBIY0d2ekovWXcvWTArSGY3U0Z0ck9oYTk0dDFyd3I4U3RIdVhFdWxJWTFqWkZiQVpReWxpUWV2TmZ0eSt6Ty9Bd09yZWc3WS93QWEvTWI5dWo0UGFwK3k5OGVkQi9hUThFUk0ybFBmSStzMk1JSzdaQ2YzamNjWWtHUWM4QW1nRGV1UCtDUzNpblRvWS84QWhHdmpscmVuT2dJRzh5Z0FkQ0JzY2NlMWVaNnIvd0FFYlBpSm8xOUJxbWlmRXZUcnpVbGxFbm50Ynl3U3EzWGVKTjVPNnYwNitFSHhXMEw0emZEdlJ2RjNoeTRXNjA3VVlWa1VLM0tOajVrUG9WUEJGZHFCNXE1NUgxSm9BOEwvQUdVL2gzOFdQaG40U2wwdjRvK003VHhmT2pLbG5KRkNWbGhRREdHZlB6NTQ1UFBGZTdxU1R6akk2MDBSRU9XM2RSeUFLZXE3ZmYzNzBBT29vb29BS0tLS0FDaWlpZ0FwRDBvSng3bW10SnRIU2dCUE1KSndPbForcGEvYWFOWVQzdW9YRVZuYXdvMGtrczdCRlFEbkxFOU9LODkrUG43U0hnbjluUHdsTnJmaTNVbHR5d0l0ckdFaHJpNllEb2lkZnhyNHMwL3dqOFpQK0NpK29SYWw0bXVaL2hwOEcxa0wyK20ycEtYZW94NTRMZW9JN25qMm9BNkg0dWZ0cGVPZmpuNHh1UGgxK3pocFQ2bXhQMmZVUEZra1o4bTBYT0N5SDdvQS92ZGE5Wi9adi9ZTjhLL0NpNlBpcnhkTy9qejRoM0JFbHpyR3JNWlZoWThzSTBQQTV5UWNaOTY5eCtEL0FNRmZDbndPOEUyUGhqd2hwc1duYWRhakpJVWVaTS9kNUc2c3g5VFhiNTVBNituMW9BVHlZNDF5cWpid1FvR01ZNlVubStWem5qR1FEMkZRNmhxVnRwZG5QZDNkeEhid1FLMGtrMHJCVVJSeVNUMkZmblIrMHY4QThGR2RZOGNlSXY4QWhXMzdQZGxjYTVyMTJ4dDVkYmpoM0toSndmSkhQVCsrZWxBSDAzKzFCKzI1NEMvWmwwYTVYVmIyUFUvRkhsYnJUUUxTUUdlVmowTC9BTnhmYzE4UTZINE8vYUEvNEtSNjJtcCtLTDJYNGZmQzZOeHRzcmNORXNxRS9kVUhsemp1MlI3VjdCK3pGL3dURnROSzF1SHgzOGF0VGs4YStMWm1GeWRQdUhaNEk1TTdnWkdKektRZXgrWDJyNytnc0Z0b0lvWVFrVVVhaFVqUlFGUUFjQUQwb0E4dCtCSDdMdnc5L1ozMEtEVC9BQWhvY0Z0Y2dZbDFPVkE5MVB4eVdreG5Ic01DdldXZ0QvZU9SMUhzYVhZUVNjbnQwcHBtMnNRd0MrblBXZ0NSVjJpb25tTVpQQzRIWEo2RDFxRFVkWXM5SXM1cnUrdUlyUzFoUXlTVHpPRlJGQXlTU2VsZk1ldWZ0VzZ6OFhOYXZQRFh3SThQeCtLYmlGakhONHR2bTh2U2JOeHdTclkvZk1QUUdnRDNYNGtmRjN3bjhKL0Q4MnNlTE5kczlFc1UrNjl3L3dBMG5zcTlTZmF2bEh4SiswTDhidjJrN2w5UCtCbmhiL2hHL0NiSHluOFkrSW96RTdnOVhoaVBHUHJudFhvbnc2L1ltMGxQRWFlTWZpaHJWejhUZkdiZlA1bXE4Mk5tM3BCYi9kWEhxY212cFNDd2l0NFk0WTBTS0dNQlk0bzBBVlFPbUIyb0ErVlBobi93VDM4SWFicTBIaVQ0bGF0cWZ4VDhYSDk0MTNydHcwbHZDL0JJaWk2QmM5am12cWJTOUMwL1JMR0t5MCt6Z3NyT0lZanRyZUpZNDAraWdBQ3JKUXh0djNISGNldEswMjBOOHZJeDNvQWNJZ0I3K3ZlbUdSbEdNRE9lT2M4VndmeGIrUGZnZjRIK0hXMXJ4anJ0dHBGcmdpTkpHSG1Tc1A0VlRxVFh4aHEvN2ZIeE8vYUcxYWZRZjJlL2gzUFBGSVBMYnhKclVaalNML2FYb0IrT2FBUHU3eFY4UVBEL0FJSTB1WFVkZjFpeDBleWlHWG52SjFSVit2TmZJL3hVL3dDQ252ZzJ4dkpORCtGK2lhaDhVZkVUTVlvbDAySnZzbTdzZCtEdStneFhCK0F2K0NZdXYvRWJXajRoK1AzajYrOFRhZzhubmYyUlkzQkVDSHJnbnAxL3U0cjdmK0d2d1g4R2ZDUFNZN0R3bjRkc05HaVJRcGUyZ1ZaSHgzWnVwUDFOQUh3bkQ4THYydy8ycEpsUGk3eFRCOEtQREV3My9aTEVHTzVDbitFb3BEamoxYXZXdmhyL0FNRXcvaEI0Rzh2VS9GRU41NDkxcFFYbXY5Y3VHWlBVbllwQVAvQXMxOWl1bU04NDQ2anJYbXY3UTNpeC9BbndJOGNhOUZsNUxEU1o1VUJJUWs3Y2ZUdlFCK0t2N1pueFVYNDFmSGwvQmZnYlNiT3k4TGFUZGpTZEpzTkt0bGpTV1JXMk5JUW9HNGxzNFBwWDdCZnNpL3MxNk4remI4SnRKMEN6dG94ckUwTWMycTNlUDNrdHdSbHh1L3VxVGhSNkFWK1ZIL0JLUDRiMi93QVFQMnByWFZMOGZhSWRBdEpiOENRWjNTazRqSitoeVRYN2xMRVZZZENPNTdtZ0FXQlY0QklYMEJwNFhDZ2VsTFJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFEU3Z1Ulg1VmY4RnR0TGhTNCtHK3BlV0RQc3VMYnpPKzBuY2Y1VitxaGtHY1YrVVgvQUFXMThSVzhtcy9EalFsSk02d1hGNCtCd0YzYlIrcG9BK3p2K0NkdXQzV3Uvc2cvRDJXN1lPOEZuOW1SaDNSRGhjKzlmU05mUG43QVdnUDRjL1pFK0dzRWloWG0weExrajAzODE5Q1VBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQURIN1YrUW4vQlRacnI0d2Z0cCtBdkFHbW85NzltaHRiZG9VR2NOTkt4bC9KRUJyOWVHSWRzZHM0NXI4b1BnUDRoMGo0aGZ0NGZGcjQxK0xMeTFzZkRIZ295cXR4S3dDUnlqTWNZQlBCSkNTZ2U1b0EvUzNXL0V1Z2ZCbjRiUjNtdDNzT202Um9Xbm9ra3prQUJJMEM0SHVkdkFyOHl2RTJ0L0VUL2dxUDhBRlpOSTBCYnJ3OThGOUl1UjUxMUlDaXlBZFdQOTV5T2c3WnJTMUtmNGkvOEFCVUw0b05ZV0QzUGhuNEc2VGRDUlp6RVZGM3Q0UFA4QUU1M0g2QTErazN3dStGL2g3NFErRDlOOE1lR05NVFRkSXNJdktqalVmTTNPU3puK0lrNVBQclFCUStEZndWOExmQXJ3TFllRmZDZW14V2VuVzRETytQM3R3K09aSkQzWTgvb0JYNDdmOEZPTGM2RiszQlBmRnR2bXJZM1FiR01CZG80Lzc1cjl5RkcwbGlwNllKeDFyOGJmK0MwSGhvV1B4MjhMYTFIOHEzMmhyRXdIWGRITEljL2t3L0tnRDllUEEycUxyUGdyUU5SRGJoZDJFRnh1em5PNk5XL3JXOERrWkZlWWZzMTZpbXIvQUxQL0FNT1owQngvWUZpakUveEZZRVVuOHhYcHFNQXVNODBBUVhWekhad3kzRXpoSVl4dWQyT0FpZ2NuTmZrMThOTklsL2JVL3dDQ2lYakR4SE5FbXErRFBEeVRRS0pSbVBaR0RGQ3FqMFpsTGZqWDI3L3dVQitMbytEMzdMZmpIVTRKZkwxRy9nL3MyeklPQ3NrdVYzRDF4elhtUC9CSjM0UEo0QS9aeGo4U3p3bVBVL0ZOekpkeU93d3doUmlrWS9FTHUvR2dENUwvQU9DZC9qRzUvWncvYlE4VGZETFhKWHNyUFZaNTlMRVQ4TDU4Ym55bXgvdGNjK2xmc1BkUzR0WGZhUVJHVzlPMmEvSkwvZ3E3OE5MdjRUZkhyd2Y4WC9EOFp0VHFMUnROT2d3RXZJQ0NEbjNRTFg2ZGZDSDRoV3Z4WCtFUGh6eGhic3V6VjlLanVwRVhrSTdSNVpUN2draWdEOGxQMkkyaThaZjhGRS9GRnJxMXZiNnZZYXROckJ2SWIySVNyTUNKR3lRZmV2cVA5b24vQUlKTStFUEZmMnpYL2hoZXY0TThRS1RPbGtKQ2JSM0hJMjU1VG4wT0JYenQvd0FFMTdPUFVQMjkvRnQ2Z0R4MjhkKzZzQng4eFpmNjEreFpVdUd6a2ZUcmlnRDhtdmhMKzJGOFkvMkt2RjBIZ240OTZacUdyZUdtK1NMVVhVelRSQWZkYU9YL0FKYUw3SG12MFVzOWUrSC9BTzFMOEpiNkt3djdQeEo0WTFxMmUzbmFQREdQY09Rdy9nZGYwTmRCOFQvaFA0WitNWGhtYlFQRnVpVytzNlpLTUdPWlJ1VDNWdW9QMHdhL1ByeDMreEw4VWYyUGZFRjE4UWYyZjlmdXRWMGkxVHpycnd4ZGt1OHNZNnJ0NlNBRE9NZ2tEb2FBTW45bWZ4TnJuN0EvN1RPb2ZCengxZU9QaDk0Z25aOUd2N2pKakxzY1J1cDZMdXlGYjNJcjlTN2VWSGpWMVlGV0hVR3Z5eDhiL0c3d1Qvd1VOK0dMZURmRVJnK0hueGowZHZQMDJLK1Brd1R6S2VZbGR1UnU1R004SG50WDBsL3dUeS9hVW0rS25nS2Z3SDRvbGtqK0lYaEJmc1YvSE9mbnVJbE8xWmZjOU1uNlVBZllRT1IvalMxRkU2c1RnOC96cVdnQW9vb29BS0tLS0FDa0pBNjBGZ08vdFVjMHFJbTRrQWRqNlVBTEk0Q2srbnRYekIrMVArMjU0ZCtCY2FlSHZEaUw0dStJZDk4bG5vbGxtVW94NERTYmZ1ak5lYS90Ty90cmVJTlo4ZS84S2IrQmxtUEVIalc0YzI5NXF5RGZEcCtlQ1FSeHVHVG5QVEZlaWZzb2ZzTTZEK3o1TEo0bzF5NGJ4aDhSdFFYZGVhemUvTjVUTWN1SXM1eHllVDFPQlFCNVQ4QWYyS3ZGSHhjOFcvOEFDMmYyalpqcld2emtQcHZocDJ4QllwbktoZ09Cais3K2VUWDNsRHAwVnBDa01FU1F3eEFMRkhHQXF4Z0RBQUhZZTFUSXUxeVNnSko2NDVxVHpGL3ZEbWdCb2xWT0QxQXpYSWZFL3dDSzNoYjRRZUdMbnhENHMxYTMwblRMYmt5eXRndHgwVWR5ZlFWeHY3U2Y3VFhoTDltWHdaTHJ2aUc5VTNMcVJaNlpHUVpycVR0Z2RjZTlmQW53OCtEbnhLLzRLWmVNb3ZIZnhIdTUvRFh3enNweWxqcGNRS200VE83RWVlT09oYjhLQUsvam40c2ZHYi9nbzM0NnV2QzN3L2h2ZkRQd25ndVJEYzNtUEk4NlBPRHZjL2VKSFBsOUsrOFAyWi8yUmZBMzdNdWpDRHc1WUM0MWVhUHk3eldiazc1NS9iSis2dnN1SzlKK0hQdzA4UDhBd3M4SzJYaDd3eHBjV2w2VGFSaU5JWWZsK3BQcXg5VFhVb05qZ0g5YUFCWTJWK2NiZTJLbFoxVmR4T0FPNXBwa1U0TzRZUFNzVHhmNHUwVHdSNGZ1dFgxL1ViYlM5TXR3RExjM01nUlU1NjVQZWdEYU55Z1F0bkFBeUNlaHJ3RDlvRDlzcndGOEJ3ZE9tdkg4UmVLNWNDejhPNlArOXVaWGI3b2ZHZGdKN212bGI0Zy90dmVQL3dCcXZ4Wk44TlAyZDlHbnQ3S2RqRGQrTGJsV2phTkRrTzZrZjZzWXo4M1U5cStpL3dCbFg5aG53djhBczQyNzZ4Y3pIeFg0NHV6dXV0ZDFCZDhpZzhsWWM4cHozNm51YUFPSThML0F2NG9mdFVYRnY0aitObXBUZUdmQjdPSjdUd0JwVWhpRWtmVWZhbUhMSHA4dGZYSGhUd1RvdmduUmJmU2RCMG0wMG5UTGRBc05yYXhpT05SL3VqalB2V3lxN1RnNC9YT1BUTlRiZ281UHR6UUF5UDVQbE9lUFhtbm1SVkdTY0QzcXZkM3NGdEFaNVpZNDRsNU1rakJWQTduTmZFbng1LzRLSjI5dDRtdVBoNzhGL0Q4M2oveDA4bjJjelFveldsdStjRWtyOTdIWHJqMTRvQSt0ZmlaOFYvQ3Z3ajhLM2ZpRHhYck52bzJtV3d5MHM3RGN4N0JWNnNUNkN2aEh4YisyL3dERlg5cFhXTG53eCt6bjRSdWwwMHNFbThXYW5FVUNBL3hEZHduVHZuclhSZUJQK0NlL2liNHQ2L2IrTS8yamZHRjM0bzFNbnpVOE9Xa2hTenRnZWRtRndCNkVKalBldnR6d2w0UTBud1ZvMXRwR2lhWGJhUnBscXV5QzJ0VVZGUmZiQW9BK09QZzcvd0FFMnJPZSt0ZkZYeHc4UTN2eEs4Vmd0S2JTOHVIa3M0U3h6dENzVG5IcDA5cSt6dkQvQUlZMHJ3anBGdnBlaTZiYmFWcDBDN1k3V3loV0tOUjdLb0FGYWF5QUxuamFPK2M1cXByT3U2Zm9GaExlNmpmMjJuMmNLYjVKN21RSWlyNmttZ0N5cS9LVGpodU1jREZPa3VvcmFJdk5Ja1NyMVp6Z0Q4VFh3VjhmL3dEZ3JCNEU4QTMwK2llQWJGdkhlc3F4aU1zZVJhQjg0NEkrOXo2VjR0Yy9EejlzTDl1SFNZcjNWOVJQZ0x3aGRObU95YVEyaVBINnRHdUhrSDFPS0FQc2Y0OS84RkN2Zzk4RGtlMXVOZmo4UmEyamJEcGVqT0paRk9jSGVSd3RmbnYrMHIrMjk4WWYybXZCZmllejhLZUQ3M1NQaGdJbSsyWGFXclBKNUE2bVNYb0I5SytxZmdOL3dTUitIL3cra2cxRHg3ZXkrT05ZUnQ0UUZvYk5HLzNRZHpmOENKcjY4OGJmQ2JRL0VId3AxendUYVdGdnAyazZocDhsajludDQ5a2FncnhoUngxeFFCK1dQL0JGeTd0b2ZqYjQwaGFRQ1NUU0l6Q2hPU1FIWW5INTEreHU0VitJUC9CTnlWL2d6KzNOTjRXMWFlS0dWVnZ0SGxlVnRpdEloMnJqUHFRY1YrM1N5RElIQTVJeFFCTFJTWnBhQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS1FrRHJRQUU0Rk5FcWs0Nkgzb1oxS25CQi9Idlh6NSswRCsyUDRRL1o5OFE2WG9lcFd0N3JlcDNNVXQxUGFhUkg1MHRwYnFCdWtrVWNoU1QxUHBRQjlDZVlNWkh6ZlNuVnh2d3MrSitnL0dId0ZwUGkvdzNlZmI5SDFDTHpZcE9qQTVJWkdIWWdnZ2oycnNGWmNEQkdNVUFPb3BBYzlLV2dBb29wQ1FCazBBTFNGZ0tNajFxT1YxVUVsZ0FCa2tuQXhRQlMxVFY3UFE5T3ZOUTFDNWp0cksyaWFlYWVaZ3FSb295V1k5Z0JYNFcvdEtmRVBVUDI1djJ4clRTdkQ0ZTYwazNZMG5TUWk0eGJxL3dBOHA5aUFXUHBYMWIvd1V2OEEyNWRKdHZDV29mQ2J3SHFTWCtyNmgvbytyM2RvMjViZUxQelFBanF6ZEQ5YTNmOEFnbFYreU1mQWZoZGZpcDRuc0dYeEJxMFczVFlaMHc5dGJuL2xwajFZZC9RMEFmZXZ3NDhIMnZ3LzhDNkQ0YXNsSzJ1bFdjZHBHRDZLdUs2VE9hamlERGR1L09wQjBvQVdpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdEZy9qZjRyWHdQOEFDUHhscjI4bzFocE56TWpMMUVubGtJZnp4WDQ2ZnNTZnNtK05mMnFacjZiVzc2KzBuNFZ2cUJ2dFJhSWxEcUUvSjJKNmtiams5Z2ZVaXYyTCtOSHd6dGZqTDhOOWQ4RjMxMU5ZV21yd0NDYTR0emlWRURxeDJuMzI0clk4QWVEZEwrSHZoTFN2RHVqVzhWcnArbTJ5VzBNVVlBd0ZHTW4zUEpQdWFBSXZoOTRIMFA0YitGOVA4TitITk1qMHJTYkNJUlJXMFNBREE3azl5ZXBQcWE2ZFBmQVBwU2lsb0FheHdwSjZWK1hIL0Jibnd5cDByNGFhK2crWlpieTBrT08yMk5sL1V0WDZqdjhBZHI0Vi93Q0N3SGc1L0VQN0wwR3FRd21XYlJ0V2hrWWdmY2ljTUdQNXF0QUh1LzdFMThOUy9aVStIRTNtZWFCcE1hY2RSdEpYK2xlNEFuTGZNSytZZitDYkd1SnIzN0czZ0IwRzAyMFU4RHIvQUxzOGdyNll2cG83VzBudUptQ3hSb1pISjdLQmsveW9BL0x6L2dySjR4dWZpWjhVL2hwOEd0Q1pyeTlrbkZ6Y1F4bmd5U3NFUlNQWlYzZmpYNlEvRER3TmEvRFA0ZWVIUEN0bGo3TG85akRaSXdIM3ZMUUx1K3B4bjhhL01IOWxXMGwvYWkvNEtTZU1QaU5PR24wZnc3Y3l6VzAyTXIrN1BsVy9QMFRQNDErczhBSWlYSnlmWDFvQSthZitDaHZ3ZUh4ay9aZjhVMlZ2YkNmVmRNaS90S3pJSHpCNHZtSUgrOEJpdksvK0NUM3hUUGpQOWw2OThPVHZ1dmZETnpOYTdUOTR4dURJdjVic2ZoWDNOZUlza0VpeUx2alpDcFgxQkdDSy9LNzRBbWI5a1gvZ29aNDErSEV3K3krR1BGYVRTV1lmaENyZ3l3QmZVOGhQd29Bdy93RGdrell2ZGZ0VS9GUzZCVlV0clNRbmQxRzY0SXI5Y3lQbUhHZmV2eTMvQU9DUE5qYTMvai80dmE4SWlseExLc0sraW9aTitLL1Vuc0tBRnF1d1VCaWV3Nm50K05XS0tBUG0vd0RhRy9ZZCtHbjdSTVV0M3EybW5SdkVaTzZMVzlMSGx6STNYYzJPR1B1UWErQm8vd0JrejQ5L3NSL0dDSDRsZUdMVnZIK2lXYnNzNzJraGFhNXRTRHVXYU1mTjBIWDF4WDdFMGhBSXdSeFFCem5nUHhkQjQyOEthVHJrRVVrRVdvMnlYQ3hTb1ZhUEk1VWc4Z2c4VjBZNjRvQUFHQU1DbG9BS0tLS0FDaWlzeldkWXROQjA2NDFEVUxtTzBzclZDODA4N2hWUlFNbGlUUUE3V05SdE5Jc0xtOHZiaUswdFlFTXNrMHJBSWlqcXhOZm5wOFhQMmsvaUQrMlQ0MW4rRi93RVc3MHJ3NURNWXRhOGFJU2krV09HV04rdytuSnpVSGo3eGY0dS93Q0NpUHhNdVBCUGdiVUx2dy84R05JbDh2V05halFvZFJiUCtyai9BTDNLbkErcHI3cCtEL3dvOE9mQmZ3VnAvaGJ3dlpSMldtV2lZNEh6eXY4QXhPNTdzVDFOQUhHL3MwL3N5ZUZQMmFQQ0NhUm9VRFhHcFhPSmRRMWU0SWFhNmw3a3NlY1p6OG80SDQxN1FuREhnQWUzR0tjdjRmaFRMaGQwZU1rRFBPS0FKQ1FBVFh6cCsxaisySjRZL1ppOFBNc3dqMWp4YmVqYnAraHduTTBySG9XQTZETmNuKzJuKzI1cG43T21tUitHZkRhUitJUGlScWk3TFRTMGJjTGJkd3NrZ0hRZWk5Njg3L1pHL1lrMWE4OFZRZkdYNDR6M0d1ZkVLNy8wbURUTHdaV3lQUldaZTdnQWNkcUFPQS9aMS9aQThjZnRRZkVFZkdMOW9DUzcreU5ONStuK0dib0ZReVp5b1pEOTJMMFh2K05mcFRwZW4yMmxXY0ZuWjJ5V2RyQWdqaWhoVUlpTGo3cXFPbUJ4V2dnd294eFRxQUdSSEtBOFlQSTR4eFNTNEE2N1Q2MUhPRDVnS2pMRGpyeCtOZkszN1puN2NPZy9zMmFPbWthVXNmaUh4MWZLVXROSWlmZVlpVGdQSUIyQjdkNkFQUS8ybC8ycHZCdjdNZmcrWFdQRWx5c3VvdXBGaHBVREEzRncrT0FCMkhxZlN2aFh3UDhBQ3o0dS93REJTTHhWRjR5K0k5N2RlRXZoVkZKbXgwZTIzSUowQjZJdmZqcTVydVAyYmYySHRkK05IaWhQakYrMExjVDZ4clYrd3ViSHcvY0hDUXBuSzcxNkFZNkoyOUsvUkd4c29kTnRvN1czaVNHM2lBU0tORUNxaWpvb0FvQTVINFdmQnp3bDhHZkRFSGgvd2xvdHRwR214WUxMQWdEU04vZWR1ckd1N0FDclFSOHZ2VmFlWklZV2xkZ3NhcnUzczIzQUhYSjlLQUxCVU1jNXJ4MzlvSDlwL3dBQS9zOGFXYnJ4WnJVY042Nk0xdHBjTGJybTVJSFJFSEk1eHpYenArMFIrM2RxdDU0eG0rRmZ3RjBwdkYvam00WXh2cWtLNzdheVA4UkI2Rmw3azhldGRGK3o3K3dsWjZINGdnK0lmeGUxS2I0Z2ZGQ2NDYVNlL2N5MjlxUnlGalE4RWducWVuYkZBSGo0OE5mdEEvOEFCUVcrUzYxbTR1ZmhaOEdwaVhTMGpieTdtK2l5TUJnTU0yUi9leXRmYm53US9aNThEZnMvK0dJTkY4SWFKQllKRU1TWGpBUGNYRFk1WjVEOHgrbWVNOFY2VmFxRVVLRjJxQmdBOWhUcDIycVRrQUFaSmJvUGVnQlB2QUtPQi9Gbm45YXlQRmZpM1J2QldpM0dyYTlxZHBwV25XNkYzdWJxUUlpcU91U2ErVy8yby84QWdvZjRLK0JNRXVrZUhKb1BHL2pWbk1VZW1XVW05WW5QSDcwcjBPZXdyNW04Ty9zMC9IUC9BSUtBYTJuaWo0emFsZCtEZkNFT0pkTzBtT0hZU3BQSVdMR1J3UHZ0elFCNmY4WWYrQ29sbHJPcHllRWZnWjRidmZIZmlpZDlrVjB0c1doQkJ4a0pqTC9YcFhCMnY3Q1g3UTM3VlRSNjM4Wi9pSEw0ZHNMaVR6UDdBaWRwR2pUMmpVK1dqZXhHYSszL0FJQ2Zzc2ZEcjluYlRmcy9nN1FJclMra2lFVStweS9QZFRnSFB6dWVjZTFlMEwwb0ErYVBnQit3SjhKZjJmWGp2dEowUWF2cnFnWjFiVnNTekQzVlQ4cWY4QkFOZlNjQzdSamdZNkFVT01uT0F4L2hCcmwvR3Z4SThOZkR2UjdyVi9FbXQyV2s2ZGEvUEpQY3pxZ0F4MEhQSjlxQU9yYXNqeFA0azB2d3BvdHhxT3M2akJwZW53SVpKYm00bEVhUnFPcEpQcFg1MWZGei9nclZKcVBpTC9oRy9nbjRSbThUWDBzaGlpdjd1S1JnN2VzY1M4c09uV3VZdFAyUnYybVAyeXJVNmg4WHZHaitGTkVhVHpZdEhrR0dHZXY3bGVGNHg5NFVBZUZmOEZHZmliOEpmRlh4UDB2V1BoTE5BUEVFY3ozR3NhdnBmeVJUUzUrVmxZZFRrWnI5RnY4QWduNysxalovdEkvQ2V6dGRVdll6NDUwYUlXK3B3U0VlWk9GR0VtQTlDTVo5ODF6dndsLzRKVy9CZjRkSXR4ckZoUDQwMUxhTXk2c3hFTzd1QkV2eVkrb3J4YjlvbjlodnhkK3puNHZsK0xuN08xMVBiU3d1MHR4NGZ0azNPaWRXRWEveEo2cjJGQUg2ZStsT3I0Si9abC80S2tlRHZpUGFSNkw4U1RENEc4VlJiVWFhNFlwWnp2MEpCUDNEbnFLKzNkRzhSNlRyMm53M3VuYW5hM3R0TUFVbXQ1Z3l2OUNEelFCczBWVkZ5Z0JKZGVPY0szVDYxbDY3NHQwVHc5WXZkYXJxMWxwMXNvM05MY3pyR28rcEpvQTNjMDE1VWlBTHVxQThaWTRyNDQrT1gvQlR2NFEvQ21DNXR0STFML2hOZGVUaUsyMGRnOFc3cHpMMEg4NitlYnpTdjJtUDI5TEdmVzUvUCtHSGczVElIdTlKc0xjdkZKZXpxcE1Yekg1bXljY25nZHFBUDFQb3pYNS8vczgvOEZHZE4wdTdpK0h2eHN0Wi9CSGpMUzQxdERkMzRjdzNMTHdIWm01VmlPL1ExOTI2SHE5aDRnc0xmVU5NdkliK3ltUU1seEE0ZFpCNmdpZ0RVb29vb0FLS0tLQUNtU2NJVDZVMlk4RG4zNDYvaFh6SCsyRisyMzRYL1pmOEp2dWFEV1BHRno4dGxvNlNnay83Y21PZ0grRkFFMzdaZjdZT2dmc3MrQmJsbW5qdWZGMS9DNjZWcGlOOCs0ai9BRnJqc0FhK1pmOEFnbG44SzlmOGVhcjR5K04zanRXMUs2MTlIMCt6bHUyeTh5TXhNNXdmNEQ4cWovZHgycjR5K0dmZ254NS93VUMvYVJTODFtYTR1b0xtNTgzVTlRWlNZYksyQnpzQjZEajVRUGV2M2M4RGVDOUo4QWVGdE44TzZMYUpiYVpwc0NXOEVhOWxVWTU5VDNKOTZBUGlEeFRwSGpIL0FJSjdmRUM3OFU2RkRkYTU4QmRadTN1ZFUwZUpQTWwwV1Z6eklub3BJejZjNE5mVy93QUhQajk0RitQR2kvMm40TTFxMjFXREFaN2RUdG1qSjV3eTlRYTdyVjlJdE5mMHE1MDdVcmVPN3NycU5vcHJlVVpXU051b05mbno4WWYrQ2FuaVB3WjRwbThhL3M5ZUxMbndicWhCWTZRSjJnak9DVHRWd1FNZXpjVUFmb3ZHMmMwK3Z5Q3ZQMnIvQU50ZjRHVEdQeGQ0WHU5VnNiYzdETGRhT3JSU0FkL05SY3Q5YzFITC93QUZtUGluWk1pM1B3MTBTTmtHMWd6WEtsajY5ZUtBUDJCcU9mQWpKTEJRT1NTY0N2eHQxbi9nc0w4WTljL2RhTjRPMFRUSlc2R0dHV1p2eWJJTmNUcW54ei9iRC9hUG5sMHUxWHhJOW5mankyZzB1d050QnNQVUZsQUdNZXRBSDZtL0d2OEFiWStFWHdKdHBVOFFlSzdhZlU0d2NhWnB4RTl3eEg4SlZmdS9VMStYUDdRLy9CUlA0by90SCtJYmp3NzhQL3QvaDdRTGx2czhHbmFXQ2JxNkI0eTdqNXVmUUhGZWhmQjMvZ2p0NDA4VGkzMUQ0aStKYmZ3L2J5bmROWTJ1WmJwdnEzUUd2MEsvWjcvWkErRy83T09teHI0WTBTT1RVaU5zdXMzaUs5MC8vQWp5bytsQUh4Tit3OS93VFAxVzA4UTJuajc0d2FmekVSY1dmaDY0TzlwSFBJZTR6MVBmYWZ4NHI5U3JTSVFXeVJwR3NTS05vUkJnQWVnRlRMVHFBRUF3S1dpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQWJzSG9PdWFVQUFjREZMUlFBVVVVVUFOYzRYSjZDdkNmMjNQQ3ErTVAyVnZpUHB4Skx2cFR5b1I2cVF3L2thOTRyamZpN3BBMXo0VytMZE8yNy90R2wzQ0JmVStXY1VBZkszL0JJelZvOVIvWk50b0ZrTWpXV3FYRnV3Sis3a2g4ZitQOEE2MTdQKzJYOFVrK0VIN052anJ4Q1ovSXUxc0h0N055Y0JwNU1xcUQzNjE4d2Y4RVlicVNENE0rT2RKbS8xbG40Z2NzbmNFd3hyLzdMWE9mOEZjdkcxNTRzOFRmRFg0TzZQbWU1MVM3Vy91WUVQMzl6K1hHdVBZcXgvR2dEMGIvZ2tqOEdKdkFQd0V1UEYxNk0zL2l1NU53cW5xc0NmSXVmeFZqK05mZGtZMjRVZEFNQ3VhK0dQZ20yK0hudzk4T2VHclZRa1drMkVObU5uQUpSQXBQNGtFL2pYVUJRdlNnQ0taOW1UemtjbkhwWDU1LzhGWWZnN3JDNkQ0VytNZmhZaTMxbnduS3EzTnhHUDNpUjdzcEpuL1phdjBSWlF3d2E1WDRuZUE5TStKWGdMWHZDK3J4ZWRwK3Iya2xwTXBQWjFJL0Q2MEFmbnY4QThFV0RKZStHZmlacUVrV1dsMUtFTk1FQ3J1TVlKWDg2L1RLdmxiL2duLzhBc3c2cCt6RDhOTmMwblc5aDFYVTlXa3VwUEtmY3ZscmxJL29kb0ZmVlBhZ0JhS0tLQUNpaWlnQW9vb29BS0tSdWh4VkMvd0JSWFQ3YWE1dUpWaHRvVUx2SytBcXFCa3NUMjZHZ0NQV3RidFBEK2xYZXFhaGRKYWFmYXh0TExQS2NMR2k5U2EvT3Z4bjQ3OFcvOEZIdmlWTDRGOEUzVjVvUHdjMFdmL2lkYTVHU2phaWM4UnJqcURnNEhwelRQaS84Vi9GdjdmOEE4VzVmaFA4QUM2N2tzZmhucFVvLzRTRHhKR0NxeWpPREdEM3pnZ0FkZVQwRmZlM3dxK0UzaHI0UCtCZE44TCtHdE5oMC9UcktNUjRpVUJwV3g4enNlNUo1T2FBSC9DajRZK0d2aEg0STAvd3Y0V3NJckxTYk5OaXFneVpHL2laajFKSjdtdXdDZ2RBQjJvU01SakM4Q281NUdRaFVHV1BJOTZBRXVYS0JDRzJqUFB2WHh6KzF6KzI4ZkFGNlBocDhMNHg0bytLMnB2OEFaNHJhMlh6aHB4WWNNK00vT1FjaFQwSEo3VlQvQUd3djJ5OVkwZnhQYS9CNzRQMmkrSXZpWHE0OG1hZTFPOWRMVnVNa2pwSjFPRDBHRDNGZHAreDMreGhvbjdQRm5OcjJyeW54QjhSOVRYek5VMW01eTVWMk81bGpKN1pKeWU1elFCeW43Ry83RTBudzV2cC9pSDhVWGo4VWZFN1VwUHRCdXJwdk5ObDMrWFA4WFBKN1Y5bXFvVk9BQlI1YSttUHBUc1lHS0FGcXZLNVY4NVBYSEhZLzFvTXpsdU1ZSFhQQitvcjRML2JWL2J2dk5DMVgvaFZud2RCOFEvRUsra2EwdUo3T1B6VFlITzBxZ0hXVDM2Q2dEcHYydWYyM1p2QjJxbjRXL0NtM2J4VjhWTlRjV2lKYmZPdGt6RGxqaitJWjZkdTlSZnNkL3NFcDhNOVVsK0lQeFN1WS9HSHhLdkQ1L20zWjgrT3lKNStVdG5ML0FPMFB3cmMvWVEvWTlId1E4TXY0cjhad1JhaDhUZFozelhsL0svbXlXNk9jN0F4NkVnOGtkYSt1eEV1ZVJ6NmRxQUNORlE0VUFEc0FLR1VJdnlnREpva1BseG5hT2UxY1g4VS9pNzRaK0RmaEc4OFNlTGRZdDlJMG0zK1V5eXR5ei8zRUhWbTlxQU43WC9FMWg0VjBXOTFiVjc2T3gwNnlpYVdlNW53cW9xakpKSjQ0QXI0QThlL0czNGdmdDllSzdqd0Y4RlpycnczOE9MU1h5ZGI4WXVER1owN3hwNkE5Z09UMzR6WElhWGYvQUJSLzRLWC9BQkNZbVc2OEgvQVd4dWNtT01tTnI0STMzQ1J5enNPdllWK2pQdzErR1hocjRTK0Q3SHcxNFcwcURTZEpzMTJ4d3hJRjNzZXJONms5eWFBT1AvWjcvWm84Ri9zNWVFYmZTUERlbDI0dkRHUHRlclBFUHROMi9xNzlUelhxek44eHlDQ01IT2VCVFM1akIzY3FPU2NacjQvL0FHd3YrQ2hmaDM5biszLzRSendxdHY0cjhlenQ1VVZsQTNtSmFFOEJwTWRXeWVGb0E5NCtPWDdRbmduOW52d3VkYThZYXpEcGNPNGlDMkRadUxuQTVFYURsai9LdnpkK0pIN1cvd0FhZjI3L0FCVi93aFB3WTBmVS9EM2hCNVBKbnZWWXh5T09UdW1tSENEQVB5NTU3MXBmQnY4QVlOK0pQN1dXdlIvRVg0ODY1ZjJlbVhMZWRCcExFaWVWQ2M0Q2Y4c2xQb01IaXYweCtHZndwOExmQ1R3emI2QjRVMFcyMGJTNEFBSW9FQ2x6anF4SFUvV2dENTkvWlEvWUE4RGZzOVc4R3JhbGJSK0tmR3NvRWsycTZoR0pQSWtQTGVUbmhlZjRoeWErc1JHbkEyakE2REhTbXRHcURjdlhqazFGY1hZdG9tbGtaSTFVYm1aamdBZjAvR2dDd1ZBVThEZ1ZsYTU0aHNmRFdsWFdwNnJkdzJHbjJpR1dlZWVRSXNhanVUNlY4Zy90TWY4QUJSN1IvaHBydi9DRi9EZlNaUGlGNDdtSVJiYXhVeXdRc2V4SzUzdDdDdkx0Ry9aUitPZjdZczl0ci94NThVeitGZkRlUThYaFBUY1JTTW5vNmpBWDZuNXFBSi9qL3dEOEZKZGI4Y2VKSmZoNyt6dG9zL2kzWFpRWTIxbTJoTXFyNm1GUjF4L2VQRmMxOEwvK0NYM2pMNHM2MUY0ditQbmpLK3ZMcTVLelNhVkRPenlGU1B1UEpuNWZvdlN2dnI0Ti9zOCtBUGdUb2E2YjRNOE8yMmtvUUJMT3FnenpIQUdYZnF4NHIwWllFQzRBSTRDOEhzS0FQSXZnaCt5djhNdjJmbzVSNEw4TVFXRnpKa1BlVFptdUdIcDVqWmJIdG5GZXZoVjQ3NG9DQlR3TWM1NHBRQUtBRTJMNkQxcEhpUmdjcXArb3A5SVJrWW9BK2FQMmhmMkN2aFArMEMxeGM2bHBFZWplSVpCeHFtbWp5cFd4MDNLT0cvR3ZqelVmK0NUWHhVOEQzRHpmRG40dENHTlQ4c2J6UzI4bjVyZ1YrckpRRW5QT2VNR2xDZ1p3TVpvQS9KaFArQ2UvN1dWLzVsdmRmRnFhT0IrQ0pOWm1jRWZRTlZ6US93RGdqMTQ0OFJYMGMzajM0cHBORU9xMmF5U3kvZ1pPRFg2dEZBVGtqUDFwQkVnNktLQVBsTDRIZjhFNC9nNThFZkp1azBWUEZldHhrUDhBMmxycWlSa1A5NVUrNnArbGZVMFZ2RkRiUnh4SUZqUUFLRkdCZ2VsV0VqQ0RBNlViUjcwQWZNLzdYdjdFWGhIOXFyUkVtdWtpMGZ4VGFBclpheEJHQXg5RWx4eXkrMWZuTDRkOFdmdENmOEUxZkdYazY3cDkzcS9ncDNNU3dTeU5KWVRybjcwYmppTnNjNDROZnRqNVM1SkdSa1k0T0t5ZkZIZy9RL0dlalhHbDY5cE5wckdtempFdHJlUXJMRy8xVTlhQVBsVDRHLzhBQlQvNFAvRnlLMHR0VTFUL0FJUXZXNVBsZXoxYzdZdDMrek45M3QzT2ErbHRPK0t2Zy9WblJiUHhScFYyei9kV0M3UnMva2ErTy9pei93QUVpZmhONDMxR2ZVUER0NXFYZ3k0bmN1WXJMOS9EbjBDTndvOWhYZ1Bpei9nakI0c3NZNVpQRFh4RXNycDE1U0s5amVOeitLakZBSDZYK05majE4Ty9odnVYeFI0MjBQUTVCejVkN2ZKRzMwd1RtdkJmaUQvd1ZHK0JIZ214bmV6OFJTK0pyMWY5WGE2VEF6K1lmUU9SdEg0MThhNkYvd0FFWmZpVHJRRSt1K085R3RIWWNvVWxtY2ZpUml1djBiL2dpWEl0d0RySHhKL2M0d2ZzTm9TMy9qd3hRQjU5KzBSL3dWNThZL0VPd24wajRkNlUzZ3V4bEJSNzJlUVNYdUQ2RWZLdjFGZk9Id0svWm0rSnY3WFhqU1diVDRybTh0M2wzWDJ2Nmk1YU9QUFVsejk0KzFmcG44TWYrQ1Evd2o4SVBiemVKTHJVdkZsM0ZKdkt6U0dHRngyREluQkgxcjdTOEhlQS9EM2dMUklOSDhPYVJaNkxwY0l4SGFXTVFqakg0Q2dEemY4QVpmOEEyYy9EMzdNM3d6cy9DMml4UXkzSlhmcUdvaE1TWGt4L2lKNmtEb0s5bUVhZ0tBb3dPZ29FS2ozK3ZhbllvQU5vSUl3TUdqQXhqRkxSUUF4NGtrR0dSV0hvUm1zclV2QnVnNndNWDJqV04yUFNhM1J2NWl0aWlnREhzZkIyZzZZUWJUUnJHMkk2R0szUmY1Q3RRVzhTOUkwSDBVVkpSUUEweHFRUVZCQnBkb3puSE5MUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJWRFY3WjczUzcyM0FHK1dCNDFCNzVVaXJ4R2FSbHlRZlNnRDg2ZitDVkJUdzlyZng0MHFhVHkzMC94REtaQTNDcXF1NHovNDZmeXJndmdyYkg5ci93RDRLV2VJZkhSWXplRi9CamhyVnVxRXg1ampBejJaMWtZL1dzSFZ2aUZQK3luOFRQMnZiV080aXRMdStndDVOTWprT0RKTmNiM0pYMXdITmZSbi9CSnI0UG53Rit6cTNpYTdnZE5VOFVYVFhaYVFZZnlWTzFCOURndC93S2dEN2tpejVZeWNudWFmVFl4dFhIcFRxQUNtdWdjWU5Pb29BaFMyV01zVjRMWXp4MXgwcVdsb29BS0tLS0FDaWlpZ0FwQ2NDa1p0b3pUSlR1UVl5RGtZeFFBZ215b0l3UVR3VjVyNEIvYjYvYUdQalR4UHBYN09mZ2pVakI0bThRWDBVR3FYOGN1MUxPRTh0RVNQNHNja2VuMUZlZ2Z0MS90ZTMzd1ZzdE84RmVBYmIrMmZpVjRnekhhV3R1QzhscEdSZ1NsUjBPZW1mUW5vSzUvOWhYOWlHZjRYdmNmRWo0bWorMlBpZHFwTXJmYW1XWVdhTVEyUTNQN3ducjZZeDYwQWZSSDdPbjdQZmg3OW0vNGEyZmhUdzlIdUNrUzNsN2o5NWVUa1laMlBYMHg5Szlaamo4dEFvSklIYzAwUjV3MmNFZC9ha2U1VkpBbTA4bkdmd29BV1dWazRWTjN2bkFGZkJYN1pmN2JXcDNuaUEvQkw0THhTNnI4UnRVY1dkMWZXdklzTTlWVmgvR0IxUFJSVi93RGIyL2JkdXZoMUxiZkMvd0NHcUxxM3hGMXovUjJhQnQ3V0FmNVZ4ai9sb2NuQTdEazlxN0w5aHY4QVlzcy9nQjRkUGlmeEl4MWI0bGF3bm0zdC9jamM5cnU1TVNrODV6OTQ5elFCcWZzUy9zYzJIN04vaFNiVk5ibFRYUGlEckRHYlVkV2t3N1JrL3dETEpHUE8zT1NUM0pOZlVDUUJNZk1UajFPYUk0bVFBRnR3QTY0NzFJVGptZ0FZN1ZKNC9Hb1B0RGJHSlFaR2ZsenlCNzA5NTFSU1crVlIxSjZDdmdQOXJiOXBmeE44WXZHVUh3TitBdDBkVDErNzNSNjVyTmszN3V4akRGV1F5RGdFWU9UbjJvQXVmdFRmdGc2MzQxOGFYSHdNK0NGbWRaOGI2Z0RaMzJxeE1SSHB2T0grY2NjRHFjNEZlc2ZzZy9zVStILzJiZEduMUMrbFR4RDQ4MUg1Ny9YcGx6S0MzTElqSGtMblB1ZTlkQit5Myt5TDRYL1pwOEt4cGFScnFQaXU3VVBxbXVUL0FEUzNFcDViYVR5RnowcjNlR0ZrVWhuM1pQYWdCZklVaGgwQkdDQlE3bUlFWTNIQkk1NisxSTA0aVlJVkpQYkZlV2Z0RC90RytELzJkUEF0ejRqOFVYNlJmSXd0TEVITXR6S09pS281NjhFOUJRQmMrTzN4NThKL0FQd0JlK0tmRmw2TGF4aStTR0JmOWJjdWVBaUwzSlBmdDFyOC93RDRkZkREeDEvd1V3K0k4ZnhBK0lMWEhodjRRMkVwWFM5R2pZZ1hZVnNFQUgxN3YrVlpId08rRFB4Qi93Q0NodnhhaCtKdnhYKzFXUHcxdFovTnNOSlp5c2MrRDhzY2Fka3g5NXUvT0svVXpRUERWaDRYMG0yMHpTcktIVHJDMFFSd1c5c3UxRVgwQTlLQUdlSFBDV2srQzlBdE5JMFN5aDB2VGJPTVJ3MjhDQlVqVURBd0JVdW9hN1o2UFpYTjdmU3JhV2NDR2FhNG5iYWthS01saVQwcXY0cThaNlI0SzhOYWpydXQzc1duYVJZUXROY1hWd3dWRlVESjY5ZnAzcjhxUGk1OGF2aWIvd0FGSWZpZmMvRDc0VmlmU1BoeGFObTV1M0xSck9nUCt0bkk1d1RqYW5YdmlnRHNQMmsvMitmRlA3UUhpdVg0US9zKzJ0NWMzTjQva1hHdndaVXV1Y01Zai9BbnF4eFh2WDdIMy9CUGJ3NThDNGw4UytNQkI0ditJVTdMTzk3Y3I1aTJqZHhIdTZuUDhSNXIxRDltRDlqendUK3pCNFlXMjBHMFM4MTI0akgyL1dMbGN6WERZNUFQOEtaN0N2ZFVVUnJobUp3ZUNmNWU5QURSRUVIeThEUFFIaWxHNkxHY01XUEZObnVZNG9pMHJDS01Bc3pPY0JSNm12aUw5bzM5dTNVcGZGNy9BQXcrQk9rdjR6OGJTSHlialVvRTgyMHNTZURsdWhJNjU2REZBSDBiOGRmMmxmQTM3UFBoczZ2NHoxYU95RGdtMnM0aUh1WjJIWkU2bjZqZ2Q2K01ienhWOGQvK0NoVnBjMm5oU0ovaGI4SlMrdzZuZU15M0dvcG5rQWprL2h4NzE2VjhEZjhBZ254YTNlcVFlTi9qbHExeDhSUEhVLzcxNEw2UXlXbHR5Q0ZVSDcyUHlyN05zZEhnMHUyZ3RiS0tLMHRJVjJKREN1eFZBNkFBZHZhZ0R4TDltejlqUDRkL3MwYWJJZkQrbkcrMTI1UlJkNnpmbnpKNVdIWGFXKzZ2ZkFyM2o3T29Vakxjbk9TZW4wcHlvUjE1ejZtbjBBTlZkdE9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FpYTNWc2NEcm5wMXBSQ0IwSkhzT0trb29BWXNRVTV5U2ZlazhoQm5BQXljbmlwS0tBSTFoMm5PNWlmYzhmbFR3TVV0RkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVUxdnVudDlLZFRYKzZhQVB5aC93Q0NnWDdPdHo4VS93QnVEd1ZwT2hDU2FUeE5aMjgycG9pa2lLT09SbDN0L3dBQlhHT3RmcVA0VzhPMm5oTHc1cDJqYVpicmIyT253TGJRUktBQXFLQW8vTUROU2YyUlp2cXk2aTlsR2RRVkRFdDAwWU1tekpPQTNVRG10TkJoYUFGVVkrbExTRHBTMEFGRkZGQUJSUlJRQVVVVVVBRkprRHZRU0IxTk5mMkdhQUVrWmVBUm5QcFh6YisyUCsySG8zN01uaFdPR3g4dlYvSFdwQVI2Vm9zWjNTT3hPQTdxT1F1ZW1ldmF1aS9hbi9hajhNZnN5ZUFwdFYxbWRKZFl1a2VQVE5LUTVsdXBzSGI4djkwSEdUL2pYenAreDUreTNybnhLOFZqNCtmR3lPVFVmRmVwdUxuU05LdUZ4SFlSSDdyRk94eGpBN2RhQU8xL1luL1pwMWpUTGkvK01YeFRBMVA0b2VKejUrMjRHUnAxdWVWalVmd3Q2KzMxTmZZU3hNcFBBQUg0Q2tSU3JnQUhBNDNFWS9EL0FPdlZnMEFNVmdCZ25rVjhkZnQrZnRvV3Y3UHZoWnZEWGhXNFRVdmlUcXFHSzB0WVBuZXpSc0F5TUIvRjAyanFlVDJydS8yeWYyc3RFL1piK0hNbW9YRWkzZmlPK1Y0OUswMEViNVpCL0dSMlJlTSt0Zk1uN0RIN0crdCtQZkY5MThlZmpQYkc3MXpWWkYxRFNiS1ZpVEdEeUpYVHR4amFwN2M5NkFPdS93Q0NmSDdFOTc0SkRmRm40bHEycWVPdGJUN1RERGVqZExhSzV6dWZQU1E5ZllFRHJYM3RDaFRJT1RqdVRrbWt0OXhRRnM4K294VXVRRGdubWdBWmdveWFpbHVJeDhwWVp6akhxZlNpWndmbEIrWWNuQXlSWHhYKzNSKzFycW5ncTJ0UGhaOExDMnEvRkh4Q2ZJamdzUjVrdGhFM0c0NDZPZmZvT1RRQmhmdGlmdFhlSXZFdmpxTDRCL0J4aHFYalhWYzIycWFoQ2YzZGdqZFJ1NktWQjVQYXZkdjJUUDJUTkIvWmI4Q213c0QvQUdqNGcxQXJQcXVxU2pMenliUnVWU2VkbWM0eitQTmN4K3hCK3lSQit6bjRNYlZQRUMvMnA4UXRiUDJqVjlSbUlrbGpZLzhBTEZXN3FPNUhVNTdWOVREZ1k1b0FTTlNzWUJPVDZtaHBWVGdubW5GZ09wSDUxNWgrMEY4ZC9DZjdPL2dXZnhYNHIxQmJPR1BjdHZBT1pMcVRHUkdpOVNUNjl1cG9Bci90SGZ0QitGLzJkUGg5ZWVKdkV0MG9qQytWYjJpbjk1Y3luN3FxUFRQVTlCWDU5L0FyNEYrTlArQ2lueE9YNHZmRnRaYkg0ZjIwbU5NMFlaUkxsVlBDS1A3bkhMZCthZjhBQTc0SCtPUCtDZ3Z4YmorTFh4VVNlMStHMW5JVHBtanlncXM4WU9VVkY3cjB5M2ZtdjFHMFhUN1RROVB0OVBzN1dLeHM3VkJGREJDZ1JFVURBQ2djWW9BVFNOS3R2RHRoYldGbmJRMmRqQkdJb29ZRUNwR280QUFIWUNvUEYzaXZTdkIzaGpVZGExbThpMC9UTEszZTRudUxrN1VSRkdUbi9EclQvRkhpSFRmQ3VoWHVzNnZmVzlocGRuRVpyaTZ1WEN4eElCa3N4UHRYNW1lT3ZIUGluL2dwaDhaMzhCZUNyaTYwbjROYUhNc21wNmt1WXpkN1QxYk9Nay93cjlDY0NnREg4V2VKZmlUL0FNRlFQaWpKNGQ4THRkK0dmZ3RwRjBmdEdvc20wU0FaQVp2Nzd0MlFaeG5KeFg2TGZBNzluL3dqK3o5NExnOE9lRWRPU3pzeDg4MHA1bG5reHk3dDFKUHAyclcrR1h3dDhQOEF3ZThIV1Bobnd0cGtXbTZUWlJpSllvaDh6NC9qWS94TWVwTmRvaEFWUm5uSFNnQkJJcUVJYzVJOUt6dGMxeXc4UDZaZDZwcVY3RlphZmF4bWFhZWR0cVJvb3l4SitsWm5qN3g1b2Z3MjhLMy9BSWc4UmFqRHBXbFdTR1NTNHVKUWdQY0tDVDFKNEFyOC9iKy84ZWY4RkwvRzB0cHBVdDE0VStBMmszYW1hZHQwYzJzRUhrTGpxTVo5aCtWQUZyeFI4YXZpTi93VUo4VjZ0NEMrRXp5ZUZmaGpiU21EVnZGY3VWZTZRSGxZdS96WTZEOGNBMTloZnM3ZnMwZUVmMmJ2Qk1YaC93QU0ybTZUY1pMclVad0d1THFRZ1pabTY0NDZkSzYvNGJmRFR3OThMUEMxbjRjOE1hWkRwV2oyY1lqamlnUUxuSGMrcFByWFhEdlFCRkZFVS9oVUFkTnZZVk5SUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUF3amNUN1Y1cCswRDhjUERuN1AzdzMxUHhmNG1uMjJkb3VJTFpPSmJtYkIyUlJqdXhQNUFFbmdWMlBqRHhQcGZnM1FMM1d0YXZZdFAweXdqTnhjWE03N1k0MFVaSlByOU81eFg1TWFqUDRvLzRLZS90U3cyOXY5cnQvaE40Y25BWVNaVlVpQnl4OURKSmpBOUFUUUIybjdNWHc0OFEvdC84QXhxYjQxZkZPM2tnOEhhTktJOUQwbFFUQkxJamJsVWVxakdXUGM0RmZxSmFwSEdvU0pCR2k4QlFNWXh4akhwV1g0SzhKNlY0SThOYWZvV2pXa1duNlpZUmlDQzJpVUFJbzdjZC9ldDQ0R1RqOGFBRmJnVnczeGkrS21oL0JYNGZhdjRzOFEzRWR2WVdFSmtYZTJETEpnN1VIdVRnZmpYVTZ2cWR0b21tWFYvZjNVZHBhUVJOTEpOSzJGUlFNa2srMWZrSjhjZmliNHAvNEtTL3RHV1B3NDhFdmMyL3cvd0JMbkpsdU5wQ0dORGlTNGs3ZXlqMW9BMC8yZS9oenIvOEF3VWYvQUdoOVMrTEhqcnpJUEEyaDNLSmEyUFdPVGFkeTI2ajI0Wmo3Z1YrdUZqYlJXZG5EQkJDdHZERW9SSWtHQXFnWUFIMEFyaC9ncDhJZEErQm53ODBmd2Y0ZHR4QllXRWV3U3NQbm5QVm5iM0pOZCt0QURxamxHUi9NK2dwWDZDdkovd0JwSDlvWHc5K3pkOE5kUThWYTVLSlpvMTJXZW5LMzcyN2xPZHFLUDVuMm9BODIvYmYvQUd1YlA5bWJ3SXNHblJycVhqaldCNWVrV0FHU3JINVJJd0hKd1R3TzVyZ2YyRC8yT2IzNGNYRng4VnZpSklkUytKZmlCRGM0bUJQMkpaZm1Jd2VRL1BJL2h4aXVQL1pCL1p5OFJmSEg0azNYN1EveGt0bmx2THVYei9EZWlYb08yMmlQTWNoVTlBQmphTy9KNzEraE1XRmJCR0NUa0FkdTUvR2dCNktFSTlQMU5UVTF2dW5uQjlhNW54dDQxMFg0ZWVITC93QVErSWIrTFR0SnNZek5OY3pNQWlnRGxSNms0b0FvZkZmNG42SjhIZkErcWVLdkVWNHRwcDFoRTBoODF3dm10amhGOXpYNTMvQ2I0YitLL3dEZ3BKOFh2K0ZsL0VtMm0wbjRVYUpNWWRHMFFncUxzQTVVRHN3L3ZONjVYdFVObnBQaTcvZ3AzOGNJTlZ1WWJ2Ui9nUjRkdWlzUWtZcDl1WWM4TDNadlhzTURxSy9UZnd4NGUwN3dwb0ZscE9rV2NWanAxbEVzTUZ0QXUxSTBVWUFBb0Fmb0drV2VnNlZhNmRZV3lXbHBiUnJISERHQUZRQWNBQVZZdjdtS3pzWjU3cVNPTzNqUXM3eUhhaXFPcFk5Z1BXbHU1UWtiTUNSdEJMRUhHQmpKNXI4M2Yyc2YyazlmL2FuOGJ3ZkFYNElYVXQya3NtN1hkZnQzMlJMRUQ4eUJ2N2c1eWUvUVVBY3QrMEI4Vy9GdjdmdnhyaitEbnd0bmt0L2gvWVhRT3I2OURueXBRaCtlUmlQNFFRZHEvd0FYRmZvRDhBdmdKNFovWjM4QTJQaFR3emJLbHZBQkpOY3N2NzI1bFAzcEhQcVRuQXF0K3paK3o1NFkvWngrSGRuNFg4TzJrYXlScXJYdDhWL2UzY3VPWGMvWG9PMWV0U0Q1VHgxb0FWdStEajNybFBIbmovUS9oajRVMUx4RDRndjRkTTBxeGpNc3NzckFBWS9oSHF4N0NvdmlQOFJ2RC93cDhLYWg0bzhUWDZhYm8xaEVYbW1sUDN2UkZIVXRuRmZuMXB2aGJ4ZC93VTErSm4vQ1E2eExmZUd2Z1JvVnhpeHRHQlI5VGRUeVNPK1IzN0NnQitpYWY0dS80S2NmRXNhbnJLWFhocjRFYUJjNzRMUUFvK3F2MjU2Tm51ZWdHZTlmb2Y0RzhFNkw4UGZERmhvUGg3VHJmU3RKc0VFZHZhVzY3VVQvQUJQdlUvaFh3dHBYZ3pRTEhSdEVzNGRPMHF6aUVFTnZBb1JJMUE2KzU5NjNFKzZLQUVqR0Z4endjYzAraWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpa05BQzFUdmJsTEdHVzRtbkVWdkVyU1NPM1JRQmsvaFU3U0VjL3dqdjYxOEMvOEFCUzM5c0IvQWZoK2I0VCtEcEpKL0dldHd4cE85djk2MWlkZ0F2Kzg0T1BiTkFIZ3Y3WFB4NjhXZnR4Zkc2MStDL3dBS0xsN253cGJUcUxxNWh5STUzQitlV1EvODgxUFQxcjlIUDJZLzJlZkR2N04vd3ZzUEMyaDJ5aWJhSkwrOEkrZTZuSStaeWZUMEhhdklQK0NlbjdJY0g3T0h3dy90TFc0a204YTYvR3M5L0lSazI2RVpFSVA4L1d2cmlHTll3ZG94azU1NzBBTzJMNkNrbE9FSjdld3pRN2JSbk9BT1RYeTUrMzUrMWRIK3pUOEg3bHROdUlXOFc2eXJXbW1RNStkQ1JocGdQOWpQSHVSUUI4dC84RkkvMnB2RVhqdnhqQjhEUGhmTk5lenlzSXRYbTA5dDd6TzNTM0dQNFIxWS9RVjlVZnNMZnNsMlg3TVh3dWhndklvNS9GdXFoYmpVN29MOHc0K1dMUDhBZFhuOFRYaC8vQkxIOWxtNThOZUc3ejR2ZU1yZjdUNGw4U0F2WU5jak1zRUxObDVEbm96c0J6N1YraHF3aFFNRStuSm9BVllsNStVY25OT2JnY1VvR0twM1Y2TFoyTXJLa1FCZG5iZ0tnSExFKzFBR040NzhjYVg4Ty9DbXJlSXRldTQ3TFNkTnQydVpwM09NS0IwK3BPQVBYTmZuNThGUGg5NG0vYjkrTVIrTFh4SnRMaTMrR21qU24vaEdkRVpTaTNRRGNTTXZmb01uMTQ3VmQrS2QzcmYvQUFVTitOLy9BQWhmaG05bXMvZzU0U3VOdXVYMGNoVk5UbnlNeGpIVURiZ2ZVK3Rmb0Q0VThNYWI0UjhQNmJvbWtXeTJPbFdFQ3dXMXRHdTFZMFVZQS96Nm1nQy9iUVJ3ckhHa1N4S2loVlJWd3FxT2dIcGowcXpzVkRrQUQxTk44c0puYjFQcWVwcUdlNlNPSXZLeW9pZ2x5VHdvSEp6NlVBUTZ0cTFyb21tM1Y5ZjNLV3RwYnh0TExPNXdrYURxU2EvTW54LzRsOFovOEZML0FJc1QrQ3ZERnhOb1h3WjhPM0xEVU5YV010OXVrVmo4dzZaeVB1cjJCeWV0ZGw4Wi9pcjRxL2JyK0tsOThHUGhsTSttL0QvVEpRUEVuaW1OdUpBRGhva3gyT01EMTloWDI5OEt2aFo0ZCtEdmdiU3ZDL2htd2pzZE1zWWtqWHkwdzB4Q2dHUnozWW5uUHZRQkw4THZocG9Qd2s4RTZYNFc4TldTV09sV0VleU9OVGtrOVdaajNZa2tuNjEwMHNoUThONWE1OU9UMi9QTlRPaWhXVnVoUFN2bjc5dFg5cGl6L1pvK0U5enFzVzI3OFRhaVRaNlJZWncwa3pEQWJIOTFjNXpRQjREL0FNRkJ2MnROZnM5YnNmZ2I4SzVHdlBHZXY0dDc2YTFPNlMzVnp0OHBTUHV1UWNrbm9EWHR2N0UzN0lPaS9zdStCR2pjUmFsNHUxSDV0VDFVcDh6SHI1U2svd0FJUDUxNXQvd1Q0L1pEdmZoN3AxeDhVdmlJRHFQeEc4Ulp1YzNZM3ZaUnVjOVQvR3dQT09uU3Z0cFZLWndDVDZIdFFCSVVBT1FPY1Z6M2pueDNvZnc5OExYdXYrSWRUaDB6U2JOQzAxeFB3b3gyOXpXcnFtcVFhWFlUWGR4S2tWdkFwZVdaemhZMUF5V0pQWURrMStYdnhjOGRlSWYrQ2xQeHRIdzQ4QlR5MlB3cDhPeUNYVnRXSUtMZFlZRGNQVUhvcTllUVNCUUJiMGlUeG4vd1UwK05MWGQ3OXMwVDRDNkZka3dXMjBxZFFaRHdEMlptUFhzb3oxcjlLZkMzaFhTZkJtZzJXaWFOWVFhZHBWbkdJN2UydDAycEdnL21hemZocDhOOUQrRlBnalNQQzNoNnpqc3RIMDJCWUlZb3hqT09ySDFZOXpYV0NKUU1ETzNqQTlLQUYyZ25PTzJLZFJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQWhwaGt6a0wxOTZlVGdack8xYldMTFF0TXZOUnZaVnRySzJpYWFhYVRoVlJSbG1Qc0JRQjVWKzFSKzBMcFA3TmZ3aTFUeFpxRG8xNEY4dlRySm13MXpjSGhVWHI5U2V3elg1N2Y4RTkvZ1Y0aC9hVStObXFmSHo0aE1ieTBodlhudGhPaDIzTnljN1NBZjRFemtmUVZYODY2LzRLaGZ0ZVhGbk5kWE5sOEwvQ3ltU05Feis5aERZempvSGtQVTU0QlBXdjFVOEUrQ2RJOEErR2JEUXRDc0lkUDBxempFVU52Q01CRkhiMyt0QUc5SEVCeDZZNUhlbkErV01aM01mV2xSZHRObGZ5d2VNbnJpZ0RJOFcrSzlOOEYrSDcvWGRZdUZzdE1zSVdtdUo1U0Fxb295ZXA2bm9LL0d2d2tuaUwvZ296KzJ6YmF0cUZ2ZHY0SDB5Nnl3UVpqdGJPSWxrVDBMT3dBUHNmYXZXditDcVg3U0Z6NDM4VWFQOEFBandWSTEzY3kzY1g5cC9aWHo1a3puRWR2a2U1eWZUQXI3WC9BR01QMmM3VDluSDRLYU40ZWVDRWEvTEdMalZibUljeVR0eVYzZGNMd01VQWU0YVpwY0dsMmx2YTJ5TEZid3hpT0tORjJoVkdBQUFQb0t2SGhmWEZNVlN2MHB4a0M0enhRQkc4NVU4S0QrTmZHdjdiSHh1MWp4SHIyay9BYjRhWElsOGErS0g4clVycUZzblRMTGplekVkQ1Z6L2tpdlh2MnJQMmk5Ty9adjhBaGRkNjg2L2E5ZHUyRm5wR21wODBsemN0d29DOXdPL3B4NjE1WCt3Zit6UnJQdy9zOWErSi9qOXZ0ZnhGOFlPTHFjM0h6dll3RWxoR005Q2R3eVA5a1VBZThmcy8vQWp3Nyt6MzhNOVA4SWVIb2YzRnV1NjR1WkIrOHVaankwakg2OVBiRmVsSXBVQWs1UHZTb3VBZmVtVFNMRXZ6SEg0VUFMTGtzbzJranJrR3Zndjl0MzQrK0l2aUY0eDAzOW5yNFFYWG5lS3RhNDFxL2dmQzJVQlBLRngwYkhKOU9QWGoxUDhBYmovYTVzdjJjUEJzZWw2U1RxSGovWGthRFNMQ05keFVrN2ZNWWRoa2tEM0hTc3o5aFA4QVpOUHdUOE8zdmpEeFpML2FueEg4VVl2TlJ1cGhsN2RYNThwU2VjNUpKK3VPMUFIcm43TnY3UGZoNzluUDRhYVo0WDBTM0gyaFVFdDlxQkdaYnU0SStaM1A4aDJHUHJYck9OMlIwSHJUQkdZaGxlUXZRRHY2ZmxVTjlxVnRZMmsxeGR5cmJ3d3h0TEpKSWRxb2c2c1Q2Y1VBY3I4V1BpbG9Id2M4RjZyNHE4U1hrZGpwbGpDem1TUTh1d0dRcWp1VDA0cjRlL1pXOEVheisydDhYcnI0Ni9FcXdrSGhyVEhOdjRXME82RzZCUm5QbTg0M2M4OU9hOHQ4Y2VJL0VQOEF3VXIvQUdwTGZ3dG9rczlyOEtQQ3R4L3BOekVUNWNxQnZta0k2TVd4aFFlMkRYNm9lR2ZDK24rRlBEdGhvdWsycVdHbTJNQ1c5dmJ4cUFJMVVZSFQ2VUFhRUVSU0pRbkFVYmNZNEg0VStWekdNNTVQU2dTQ055cEdCbnI3bXZrRC9nb0orMkdQZ1A0UGk4SitGSmhjZkVUeERHSTdDRkYzTkFqSEJrWWRqZy9MNm5IMW9BOHAvYmcvYVMxejQyZU83YjluWDRRTytvYWhxa2l3YTVxZGsyVWhqemlTTWtkQUJuY2ZUSUdhK3RmMlpmMmN2RC83Tm53MHNQQ3Vob2ozRzBTYWhxQlVlWmQzSDhUbjA1NkRuQXJ5NzlnTDlrVmYyZS9BUjE3WHZLdnZpQnI2aTYxQzhkQ1hoVmh1OG9NZWVwNVBjMTlZeHdGU0N4QklIWWRUNjBBUFdQQUh6Wkk3MUpTVXRBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCU013WEdUakp4UzB5VElHUjI3VUFOa2RXUWpnZzhWK1hQL0JUSDlzblhKL0VsNThGZkFNZ2I3UXFXdXEzTUJKbGxsWWdHM1QwNjROZmFQN1luN1J0bit6UDhHZFU4Umd3dnJNd2ExMHEyazZTWEJIR1IxSUI1cjR0LzRKOS9zWjZsNDk4UzIzeCsrSjhqWGR4ZnpIVXRNMDZUNWpjT3h5TG1UUGJ1Qi84QXFvQStyLzJGL3dCbFN4L1ppK0ZWdERJclNlSjliaWp1dFdsY2pLeTdPWTF4L0NLK21vMUtvQVJnMHhVSEhHQ0QxRlM1SHJRQWhrVmVweFhpSDdZZng4dFAyZHZnZHIvaXI3UkV1cmlJd2FaQTdjdmNQOHFrRHZ0enVQOEF1MTdSTSt3c3pPRlFEcWVucm44Sy9ILzQvd0N1YTUvd1VSL2E2dHZoNzRWbGxUd1Q0ZWthQjd4UG1qVkF3ODY0UGJKeHRBOTZBT2svNEphL3M1Nmo4VGZIR3NmSEx4dEMyb0lzc2cweDdwZHpUWFRITFRqUFhhTWdlNUZmckJHbTA5TWR6eDFQZXVjK0cvZ1hTZmhwNEwwbnd4b2RxbG5wZW1XNlFReElnWGdEa24xSlBOZFJRQWg2VnpIeEE4ZDZSOE5QQityZUo5Y3UwdHRLMDIzYTRtbWM4QURvQjZrbkEvR3Vsa0kyTno3Wkhhdno0L2FtOGFYWDdXSDdSbmgzOW5Yd3ZMSW5oL1NMcGRUOFdYOEpPeGtqR1JEa2NZNXdmVXNQU2dEcWYyYXZDMnMvdFlmRU4vanA4UTlNamowU3gzUWVEdkQ4Nm55b1l5M3pYYkFqbDJBR01qdDlEWDIxR25scUZDOERwdDlNZERWRFFkSHROQTBhejAyd3R4YTJsbkNzTUVLZ0JVUUFBRGoySDYxcUp3dlBIdFFBME9zWVZTZHBQYXVLK01ueFYwSDROZkR6V1BGL2lHNkZ0cHVtUW1SaC9GSS9PMUZIY2s5djhLNis3bFNHS1dXU1FScEdDek8zQ2dBWk9mcDFyOHp2aU40cDFIL2dvOSswaEY4TjlDbmt0L2hONE51dlAxWFVJOGo3ZElEakhwMURBZmo2MEFibjdIM3dhMWY5cWo0c2FsKzBmOFRMS1NXMmVZSjRXMG1jNGppaVVrQjhIK0VkdlZ0eDlLL1JSRVpDeFlIanF4SFgzck84SWVIN0h3cm9GaG91bFdxMldtYWRDdHRid29NRFlxZ0Exc3lNQXVmVDA3MEFJMHFoZW80NXhYNTQvd0RCVHo5b3JWWkl0SytCdncrbGx1dkZIaUtRSnFVVmlTWkk0Q2ZsanlPaGJKSjlCaXZzTDlvSDR5NlQ4QlBoWHIvaTdWWjRvUlp3c0xlT1RyTE1SOGlqMTVyNHYvNEp1L0FYVy9IbmlyV3YyaVBpTkJJMnRhM2NTTnBFVnh5ZkxZOHlnSG9QNFY5bEI3MEFmVEg3Ri83TUZoK3pGOEh0TTBoTGNTZUliMk5icldibGdON3pFWktEMlRvUHBYMEdqTEVOcE9NZFBwVDArN1ZTK3VvckszbHVKNUZpaWhCZDVIT0JHdU9XSitsQUhubjdRL3h3MFQ5bjM0V2EzNHkxcVhFZHBFUmJ3QWpmY1RZK1NOUjN5Y2MxOEdmOEUvOEE0TGEvKzBwOFR0WS9hRytLY011cE9aeW1qUVhTWWlkaHh2VlQvQW5RY2RzMTU5OFlmR21yZjhGR1AydXRIK0hQaDZlVmZBR2dUc3J5b1RzZU5EKzltY2pqTEFGVjVyOVp2Qm5oWFR2QkhodlROQjBlMld6MHpUYmRMYUNCRndGUlJnRDY0SFdnRFlnVmxKNUpYQUhQOUttcEZPUjB4UzBBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVtUjYwWkhyUUF0Rkp1SFBJNDYwWkhyUUF0RkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGVnRRdVk3TzBrbmxjUnhScVhkMk9BQU9UbXBKMlpWeW9MTjF3Ty90WHhML3dBRlEvMmwvd0RoVFB3Y204S2FUZEdMeFA0cFJyZUhZL3pSVzJNU3Z4eUNlVkh2UUI4aytOdkhOMy93VVQvYmMwbndpcnp6ZkRiU0xxUm9vYmZqOXhGbnpaaWZWOEhIMXhYNis2SG85bDRkMG14MHZUN1dLMHNyT0ZJSUxlSVlTT01jS0I5SytEditDUy83TmY4QXdydjRiM2Z4RTFxeWtoMTN4RmhiVHpCZ3gyblZUZzlDM1g4YS9RZmFNRGdjZEtBRkhTbTdRU2ZXbjFoK0tkZXMvQ25oN1V0WjFHZExldzArM2U3bW1ac0JFVlNXWS9RQThVQWZJZjhBd1VnL2FWMUg0YWVDTEg0ZGVEWkhrOGUrTDJGbkNsdjgwa0VMTUZaZ1A3eloyajAzWjdWNkwreEgreTlwL3dDemI4S3JHMnVMZUYvRjJvUitmcTk2b3k3U056c1Uvd0IwVjh1L3NUNkJxUDdYUDdUM2l2OEFhQjhWV3JOcEdqenRhYURidU1vcjUycVFEeDhpWnlmVWc5cS9UQ0lEakE0SFEwQU9qSEJQVDJ6U3lES0g4NlhHS2JKbmI4djN1MUFIaDM3WUh4NHRmMmYvQUlLNnpyb2tZNjNkTDlpMHEzakdXbHVuR0V3TzVIWDhLNS85alA4QVordGZnMThNN0hVOVVnaW04YytJSVYxSFhOVFlzODBzMGgzS29KNUFBYkJIcUsrYi9pVmRYWDdaL3dDM3JwSGdhenVpL2dMNGF1dW8zeng1S1MzS01wSXowSjNiQVBiZUsvUjhLZzI3VkFDakE0NkQyb0FldjNhUTlSVHE0MzRzZkVIVHZoWDRBMTN4YnEwNlEyV2tXa2wwMjQ0RE1COHEvaVNCK05BSHlsL3dVZS9hVDFUd2ZwR2xmQ1R3STVuOGRlTUdGdXdnNWt0cmRpRnlQZHNuOEZOZXovc2cvczA2Vit6TDhKYkRRWUkxbjF1NVJialZyNDh0UE9lU3YwWE9QelBldmxuOWdINGZhbCswZDhVUEVmN1NYajIzWjd5NXUyZzBLMmNaU0ZFR01ybnBnRUFFZDkzcWEvUnhQbUFKQTNmeW9BSTFJems1UDZVVGJSR3hiR0FNbkp4VFp1QUNEMDZEcHpYeVQvd1VEL2FQMVQ0S2ZEZTM4TytFbmVUeC93Q0xaanArblFwODhrY1p3SGtWZnh3TTk4K2xBSHovQVBHS2JVLzIvd0Q5cnUwK0granpNM3dvOENUcStyM0NFaU9hWUhFZ3ovRWNnb0Ivc2s5Ni9TYlE5R3N0QTBpejAyd3QwczdDemlTQ0MzaUdGalJCaFFCN0RBcnd2OWluOW5hSDluejRNYWRwOTJubWVKTlZJMVBXWnlkelBjdUFkcEo1TzBZSFBmSnI2SUFBSFNnQnZIdlh3cC93VlkvYUpuK0dQd2p0L0JXZ1hqVy9pWHhNeERORTJHanRWKytmK0JIS2l2dVc0bEZ1a2pzeEFWUy90Z0N2eGowalJ0YS9iay80S0kza090VFNYSGg3UWRSbUJDcis3UzB0bk8xQWVnTDdmeEp6UUI5dmY4RTFQMmFJL2dUOEViVFZOVnRGaThWK0pGRjdjeU12N3lHSnVZb2lmVGJnbjN6WDJJbU9jREhOUjI4U1FxaUlxcXFLRlVLTUFBZEFLbUE2MEFMUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVamREanJRQXRGVTcyOGpzYkdlNnVKa3Q0WVl6SkxJNXdxS0Jray9oWHhIOFYvK0Nzdnd6OEErSVo5STBMU05WOGFTMnJiSnJxd3drQ24vWmJCM2ZrS0FQdU5qaGpsZVBhdUUrSlh4czhEZkIyelM2OFkrSkxMUTRYQlpVdVpQblllb1VjbjhLK0dOYy80Sy9XbXVhWmRXUGdqNGRhemUrSnA0UWxsSGNIZWl5azQrWkZYSi9NZmhTZkNmOWdqeFgrMGJycS9FdjhBYVIxUzZ2ZFN1UnV0L0RNRCtVSUl6eUZmKzZNSDdxblBxMmFBUHRINFcvdE5mQy80ejNKdHZCbmpMVGRkdVRrbTNoWXJKaGNFL0t3QjdpdlVrS3N4S25PVHo5Y1YrWVA3ZVB3SzhML3NqNmY4T2ZpaDhLTk1Yd2xlNlhxYTJkNTlsa2NpNGpPM0FjTVNUbkQ1eWZTdjBjOEErSm9QR2ZndlFmRUZybDR0VXNJTDFDZU1ySWdjZitoVUFkUFJWU1M0amlRdkpKdGpVOHU1QVVmanhYS1MvR0x3UkQ0amkwSnZGbWtqVjVTQWxwOXJRc2ZZWVBXZ0R0cUtoaWNGZU9uWEpPUVI3R3BxQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpbU81WEFHTWs5NkFLK29YU1djRWtzamlPTkVMTzdIQVVlcE5manhmK0U5Ui80S0YvdDZhcHFWdXBtK0huaDY2U0M0dVhKTUsyMEJ4dFhCeURLVnp3ZjRxK3NmOEFncWYrMFRkL0N6NE5XM2hMdy9kbUx4RjR0a05vQkRreXgyL1IyWEhPVys2RFhkLzhFOXYyZUl2Z04renpvc2QxQVlmRU91eHJxZXBGZ0E2TTR5c1RlNnFRRG51RFFCOUs2WFpRYVpaVzFsYlFyYjJzRWF4eFJvQW9WVkdBdUJ3SzBEMHB2bGdFWTRweDZHZ0JNbXZoSC9ncXg4ZEI0UitFZHY4QURQU3BwRDRtOFl5SkFzY1JHNFc0Y2I4LzczM01kOTFmYzExZExad3l6U0ZWaWpHV0pPTnE5Mko5QU9hL0xUNEM2UW43YnY3ZVBpbjRpNjJ5MzNoTHdaTHQwNjBKNFlSdGlESTduSURIR01rVUFmZnY3TVB3YjAvNEdmQS93djRSc1l5clc5b2ozTXY4VWs3QUYzUHVUWHF5S0FEaW9yV05VaUcza1lxZWdCck50K3ZZZXRlRi90bS9IYUQ5bi84QVovOEFFdmlRekNMVVpZRFphYXBQTFhNZ0tyai9BSFJsditBMTdqT2NMd000NTQ2MStabjdVdXRTZnRmL0FMYnZndjRJMmNnbThJZUdadnR1clNSSEllUlFXa1YrM0FBVC90b2FBUFp2K0NYWHdmdVBBbndMazhWNnpibi9BSVNUeGpkUHFWelBNUDNyUmY4QUxNRW4zWmorTmZaNFFFaHNmTUFRS3A2UnBOcm9samEyTmxFbHZhVzBLd3d4SU1CRVVZVUQ4S3ZkQlFCRzhvWGd0Zyt3cjg4UCtDaEhqaS8rUFB4WjhFL3MzZUVwcEhudmJ4THp4QThKd0k0UnlxdDdCZDVJOVN0ZmMveEs4ZjZmOE12Qld1ZUo5WHVJN2JUOUt0SHVYWnlCdklCd28rcHdQeHI0cC80SnovRERVdmlCNHA4WWZ0RCtOSTVHMW54VmR5UjZPc3FrTkZhZ2pMajJJQ0wvQU1BUHJRQjl1ZkRud0RwSHd6OEU2UjRZMFNCWU5OMDIyVzNpVlJqY0FPV1B1VGtuNjEwcEd4Y0RqRk5penQ1Nm4wb2xMY0JjYzlhQU03eERybG40YzBPKzFYVVpoQlpXVUwzTTBqWUFWRkdUbXZ6cC9ZNDhLNm4rMXorMUg0cC9hQjhTaDdyd3JvOTNKWmVHcmU1enRSbHhza1JlZ3d1RDlXTmVrLzhBQlJyNHRhM2QyZmhyNEcrRGxGeDRtOGR5bTN1UkVUdmhzOXd5L0I0emhoei9BSFRYMC84QUE3NFQ2VDhFL2hyb2ZnN1I0VWp0ZE50MGpaZ09aWkNQbmtKSFVrNW9BNzhScmtFRHBUK2xKZ0tPdUFLak1wWE9Sd0IxOVQzb0ErZGYyOGZqM1ovQWo5bnpYNzM3UTY2M3EwTGFicFVVTEFTbWFRWURqUFpjNU5jWC93QUUwLzJjajhGdmdkYmExcThTeWVLZkZKVFZibWFRRXlSeE9BWTAzSG5PM0JQdWErWi9qVmRYUDdiL0FQd1VHMGY0Znd0SmNlQi9Ca3VMenl2dWZ1enVtWW5wdUxaVWV3RmZxcFoyVU5qQkhEQkdzVVVhaFZSQmhRQU1BQVVBVElvQXpUcVFEQXBhQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0FwRzZHbG9vQTRUNDI2VmRheDhJL0dkblpxVGRTNlRjaU1Ba0V0NVRWOFcvOEFCSmp3WDRPMXo5bmpWbDFQUU5Mdi9FRnRyVTF0ZW04czQ1cFZBVkNxa3NEMzNWK2cwOEt5eHNqZ09qQWhnM1FnamtIMnI4NHZoL3JGeit3cCsyaHIvaExWMEtmRG40alhLM2VuNmdVeEhiM0JKK1F0MEh6TVFmYlpRQjkvYVQ4TmZDT2kzeTMrbmVGdEgwKzlBd0xpMXNJb3BGK2pLb0lyb1RBaEpJR0d6bk9lYVJaV1lFQURqamQycVFuT08xQUh3UDhBOEZqMVVmc3lhYVQ5OGEzQ0IrUnIzTDltdjRnNmY0US9ZejhFZUtmRU55TExUZE04T3hTWEUweHdWU05Oby9NS01WODgvd0RCWnZVM1Q0SStFdExDSC9UdFkrOFA5aFIvOFZYbi9pTFVkWCtQZW9mQno5bWp3dkk2K0hOSTBiVGI3eGRlUUUvS2ZKUnpFemRNWUlPRDNKRkFIb3VwUS9HUC9nb0p0dXRMMU80K0V2d2UybjdOTHNKdjlWQVBFbUFSdFU5c0g2NXFUNGxmOEV1Zmgvb0h3ZDFLODhMcnJOejhROU90SkxtMDFrM3pDZTV1RkdWTGRRQmtkZ0srN2RCMGEwMExSN0xUTE9OWUxLempXQ0dKRjJoVlVBQUFEb09PbGFKdGxBWTVPU01lMlBwMG9BK1Mvd0RnbmgrMDVkZkh2NFJTYVZyU05CNHI4S2lQVHI4eUFscHRxZ0NVajFPT2VuT2ErdWxPUUsrQ1AyVE5MdHZoMSszMSswTDRXaGlXMHNidUtEVklJUnhocEc4eHR2b01OMEZmZTYvZEZBQzBVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVUwdGc5UUJVRFg4S01RWlZCRkFGbWlpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtxM3N3Z2llUnlxUm9wWm5ZZEFCbk5XQzREQmVwcjVvLzRLQi9IcUQ0RGZzOGEzZlEzQWkxelZsT21hZW9QekIzR0dZZjdvT2Z4b0ErU3ZodGJwKzNmL3dVRTFYeGJPeXplQ1BBTG9MS0Z4dVdieTMrUTQ2WVp3V3g2SEZmcVBGQ0ZJSzloMXI4OXY4QWdqcjhHcjd3ajhLdkVQampWTGVTM3VmRWQwSTdiZWZ2MjhmOGVQZDkzMUZmb2FpbFNjOVQxTkFENlE4RG5wUzAwc051YUFQbEQvZ3BOOGJQK0ZNL3N5NjJMTzZFR3VlSUQvWk5vUWNQOC9FakEreWJqVTMvQUFUcitBdGw4SFAyY2RCdXpIR2RjOFFRTHFkN2NoTVNmT055b1NldTBjVjhsL3RrZjJqKzJoKzIxNGMrRDJnWGZuZUhQRHhCdnJpRVpXRmlNenN4OVZHVkhxVGl2MU44UGFMYitIZEVzTk10RVZMYXpnU0NNS01mS29Bb0F2eHFVVUFzV1BxZXBweE9LQU1DbXNRalpKUFBGQUhuWDdRZnhic3ZnajhJZkUzak84ZEUvc3l6ZVNCWE9QTW5JeEduNHNRSytNUCtDVEh3a3ZicXk4WmZHZlhrZVRWUEU5eThWbEpPTXQ1SmJmSTJlK1cyRC9nTllYL0JXbjRpYXI0MjhRK0FQZ2Y0WnpjYWhyVTR1N3UzUTQ1SkN3aHZiNWl4OU50ZmZQd1UrSHRyOEtQaGQ0VzhJMmFCSWRLc0lyY2dZKytCbGorWlBQdFFCMjZvVkFHY2dVdTlzNDIvclRqMHJQMWZWWU5EMHU4MUc3bEVkcGFRdlBLeFBSVlVzZjBGQUh3SC93QUZQZkdsNzhRUEVQdzcrQXZoM2ZMcVhpVFVJN3ZVRWhiQlczVWxRR0E3RUdSditBQ3Z1ZjRmZUNiVDRmOEFnblJQRGVuaFlyTFRMU0syalZGd1BsVUFuOFRrL2pYd1Yrd3phWFg3UmY3VXZ4UytQT3NXbm0yRnJOL1pPaGViOHdqR1RrcDlBb1AvQUcwTmZveW1kdlBYdmlnQUEyMWorTFBGRmo0TzhPYWxybXB5TERwMWhidmNUeU4yVlJtdGQzQzhZSlBYaXZpRC9ncU44Vk5RMDM0WjZOOEx2RFRtWHhQNDN1MXMvSWhPWlBzNEkzY0RwazR3ZSsxdlNnREUvWVUweC8yay9qUDhRLzJodGV0QzlyUGRMcG5ocFp6bHJhR01mTVZIWUVGVDlTMWZmQ1JGUU1rY2VnN2RxODIvWnUrRkZyOEZQZ3o0VjhJV3NLeE5ZMkVmMmhnUG1lZHZta0pQZjVpY2UxZW5VQUl4d3BOZlAzN2JQeDNYOW4vOW56eEY0aXQ3bElOWW5RMmVtaHVTWjN5TWdkOFY3K3pqQjV4NzErVS83ZVBpRzUvYTEvYTg4RGZBL3dBTlhaZlQ5Sm4vQU9KaExIOTJLWnorOVk5anRUYVBZNW9BOXEvNEpUZkJpNjhKL0NUVVBpRnJrWmw4UWVNcmszWDJpWC9XR0RQSFArMGN0K05mZDZucldGNEo4SGFmNEQ4SmFMNGUwdUVRMkdsV3FXa0Nqc2lxRkg4cTNWR00vV2dCMUZKUzBBRkZGRkFCUlJSUUFVVVVVQUZJVGlscU9Za0FFREp6K2xBSEtmRkg0cWVIdmc1NE0xRHhWNHF2UDdQMGF5VGRKTGpjeFBaVkhjbjByNHhtL3dDQ3lYd3ArMWxMYnczNGl1YlVQdCswQ0VEajEyOC9sbXEzL0JXNi93QlQxbndyOEwvQkVNcjIrbitKTmZqZ3VaSS9YY3FMbi92NW44SyttUGhQK3lYOE12aGY0TTAzUWJQd1pvMTYxckVxVDNkOVl4VFRUeVkrWm1kbEpPVFFCNTk0RS80S2NmQUh4NVA1RGVLNWZEcytRdTNYYlkyNExIc0RrNXJ2dmpyOEtQQ2Y3V1B3aXU5RWgxQzF2UFBVWE9tNnZhT3NodFp4OXgxWmVSejIvd0FLZDQvL0FHTFBneDhTN2FTSFd2aDlvd1poeFBwOXVMT1VmOENoMmsvalhqTUgvQk1yUmZDSG12OEFEejRuZU9mQTVKTEpiV09wL3dDajg5aXVNbkh1YUFQV1AyUFBpUnFmalQ0VXlhUDRoWXllSy9DTjdKNGQxV1IvK1dza0dBc29IKzFHMGJaOXpYdlBJQUpyeEQ5bVg5bXVUOW52UzlkRjM0bjFIeGRxK3QzbjJ5OXY3OXhsMzJLZ09NZGNLSzl3MkhhQjNvQStDLzhBZ3JWOExmR1h4UDhBaDc0RGk4SmFaTnFiVzJyc0pvcmRkemhuQ2lOdllBcWVhOVUvWVgvWlltL1oyK0cxdzNpS1pOUThiNjVLYnZVN3dnbVNQSUdJZHhKeUZBSDQ1cjZja2hMRlRnSGtENmU5RU1USW9HTUFlK1QrSm9BZnNPUmtqTlBZa0tTQmsrOUhlaHVWTkFINTIvdGg2aHFmN0tQN1duaGY0K1cxbkxmZUU5WXQ0OUsxMUxmaGxLZ0tDZXZHekdQZml2dkx3ZDQ1MGp4NTRYMDN4Qm9WM0hxV2xhaENzOXRjUU51VjFZWkZabnhNK0dHZ2ZGdndoZjhBaHJ4VHAwT3FhVmVSRkpJcEI4d1A5NVQySTdlaHI0Ni9aN3NMejlpLzlvcWY0TTZ0clYzcVBnRHhMRUxud3pkMzQvMWR3T1d0eS9UT09BQjFvQSsrQWNqTkxVY0RpU05XQ2xjak9HR0NLa29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb3BDY0NtZWNucm5uRkFFbEZjdHFueFQ4SDZKZUcwdjhBeE5wVm5jZzdURk5kb3JBK2hHYTI5TzF2VDlZdHhjV0Y3YjNzQkdSSmJ5aDEvTUdnQzlSVWFUSklBeW5La1pERHBTbVJSMU9LQUgwVTNlQU05c1p6U0NVRTQ1OXZlZ0I5RlIrY3ZIQk9lTTQ2VkpRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQU5JeWUyUGVvemJJeHlVUW42Vk5SUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFFVHNBK09qRWNrZWxmajkvd0FGQmZGT28vdFJmdGwrRmZoQm9FNWxzZEpuanNTb0dVRnk1RFNzZm9wQ242VitwSHhzK0oxaDhIdmhmNGo4WWFqTWtNR2xXenpBdC9HMkR0WDhUWDUzZjhFb1BoK1BpdDhTdmlIOGNmRWFKZGFxMm9TUTJ6UHo1TTgzN3lWaC93QUJjQWVtS0FQMHU4QytGYkh3UjRUMGZ3L3BrUWhzTk10WTdXSkZYQUFSUVB6NDVyb085UlFqYVNDU2NjYzFOUUFoSUhXdVErSzNqaTIrRy93MDhUZUtMbGxFT2tXRTEyUXh4dUtJU0YrcHhpdXZZWlVqT0srTWYrQ2tuaWk2MWp3VDRQOEFoSnBWeVlkWitJR3RXK25GVSs4bHY1Z0xNZlk0d2FBT2MvNEplL0JtKzAzd2Y0bCtMWGlLR1A4QXQzeHpjbTd0WlA4QWxvbHF4TGMvN3h3MWZlQzhLSzVyNGVlQzdMNGQrQjlDOE5hZWdqc2RKczQ3U0lLTWNJb0ZkS3RBRHFwNnBkdzJOamMzRncvbDI4VVRQS3hPTnFnRWsxY3I1dS80S0MvRndmQjc5bHp4aHFVRno1R3BhaEIvWmxuZzRMUEw4alk5d2hjL2hRQjh0ZnNYNmRKKzFaKzJwOFEvamRxVU8vUnRBayt3NlhGTXVkcE81WThmUlZmODYvVEpVd2NnZFRrazlhK1VQK0NZdndxbCtHWDdMR2l6M3NIbGFucjh6NnJNeEh6Rlh4c0IrZ3orZGZXZEFDSG9lOWZLZi9CUjM0cVhIdzEvWm4xZTAwNS8rSjE0bG5qMFN6VUg1aThwTzRnZjdxbGZ4cjZzYnB5Y1YrZlA3U2s2L3RGL3Q1ZkRINFdRaHA5RThKYnRjMWhNNVhkd1Z6OUdXTWY4RE5BSDBqK3hoOEUxK0F2N1BIaGJ3dkxodFJNSDJ5K2RSOTZlVUFrL2d1MGZoWHVpRENnYzlPOVJBS2lLdTBMR280QTdkZ0tub0FxMzF4SGFXOHR4Syt5S0ZUSTdlZ0FKUDZWK1luN05zZDcrMkQvd1VGOFQvRkM2YVJ2QzNnaC9KMDZLVEpBY2JvNHdPM1VTdC93SVY5cS90bWZFOVBoSCt6ajQ2MS96a2p1aHA3MjFyR1RneXlTWVFLUGNCbVA0VnkvN0FQd05zL2dmK3puNGVqK3poZGQxbUJOVjFPYzh0TkpLTnlaUG9FSzhldWFBUHBTSWJlTTdqNm5yMXFTbUljaitsSytOdk9QeG9BNGo0emZFU3krRlh3dDhVZUs3NlJFZzB1eGxuK1pzYm1BSVVmblg1Ni84RWovaHJmZUwvRmZqMzQxYStobnZ0UnVIdDdXV1FaUG1PNWVabFBvZHdINFYxMy9CWC80clRhYjhOL0MzdzAwNllmMmg0bXZoTE5CRWZuOGhDQWgrak1XSDRWOWRmc3cvQ1MwK0N2d0w4SWVGTGVKWVpyV3lqZTgyakJlNFlBeWsvd0RBaWFBUFdsNlV0SXZTbG9BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ211T0FmVG1uVTF1bEFIeUQvd1U1K0ZsNTQ2L1p5bDhRYVN6cnJYZys5aTF1MlpCbHZsT0NCOU53Yi9nTmVzZnNpL0dKUGp2OEJQQ2ZpMHZtOW50aGIzZ3puRTBmeXRuM1BCL0d2UXZpTnBsdHJYdzg4VFdONUVzOXRjYWJjUnlSc01oZ1kycjVGLzRKSUtiZjluUFg3UlNmSnR2RmQvREdySE8xUXNYeWo5S0FQdUNrSkFwYWpjamQxb0FmdUdjWnBGa1Z5UUdCSTROZkVmN1p2OEF3VVkwVDlucDVmQzNoQ09EeEw0NVluZkVTVEJhRDFjcjFQc1BUbW1mOEUxZjJsL2lGKzBocFBqTFV2SE4vcGw5SFpYRWFXWXRZbGluVWtFc3JJdVBrQUs3VGpuTFpvQSs0Tnc5YVk4OGNha3ZJcXFPU1dPQUtSY0ZSakdPMks4dC9hSStEVS94eThCZjhJdkY0cDFYd25CUGNJOXhkNk9RSm5RZFV5ZXg5NkFQUnY4QWhJOUozTXY5cDJlNWZ2RDdRbVIrdFJ2NHIwU09ReHZyRmdyamtxMXlnSS9XdnhtL2FRL1lLOFNmcy84QWlzYW5kYTc0ajFid05jU0t6ZUpMRlBPbnNZd0J2TTZLTnh4MjI0Rk4rRlgvQUFUY2gvYUQwdHRYOElmSGJSTmJiSDc2S1N6bVc1dHozRWlGOGcwQWZzcE40dzhQd0I1WDF6VGxSZVNUZHB4K3RmRFg3VVh4RDhOL3RNL0hUNFQvQUE4K0gxOHV0K0pkQzExTld2dFJzenVnczdkQUM2K2FPcmNIaXZMUEIvOEF3UlZ1a3ZHYnhUOFRSSmJEK0hTTE14c2YrQlNGaFgzUCt6MSt5ZjRCL1p3MFo3WHdycHhHb1NqYmNhcmNIZmNUSCtMNWp5QjlLQVBaN1pESENpa2xpRkF5ZTlTaWtRZ29wQXdNZEtkUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkprZXRReTM5dENjU1hFVVo5R2NDZ0NWeGxUWHpGKzJuOGI5YThCYUJvL2dmd0xDdDc4UnZHTXBzZE9oQithM1EvZm53T2NMbnI3VjlOSmNSVEErWEtqNC91c0RYeXI0TjBDSHhSKzMzOFF0WTFSZnRFM2hudzlwOXJwWG04cENMaDVta3dEL0VTbldnRHdmdy93RDhFY05GOFEyQnYvSC9BTVFkZTFEeFJjcnZ1Yml5TVpRdjd0SXJFL25YTCtJUDJmOEE0bmY4RTJGUGozd1o0dW04VitBQmNJdXE2TmNxUTBVWk9ESVFQbE9CL0ZqaXYxTmorNks4di9hV3NZTlUrQXZqNjB1a0RXOG1rWEFZRVpIM2V2NTBBZFQ0YjhiYVQ0bDhCNlo0cWpuaGcwYStzbzc2T1dWd0VTTmtEZ2s5T0FhK0pQanAvd0FGUUliUHhNZkJYd1I4UG54LzRsWnpBYjFJMmExVjg0K1FMZ3RqMXppdm5uNElhWjhaUDI1L2gxNFErSG1uejNIZ3o0U2VIN2FLejFMVll3Vk44NkQ3b1A4QUdjWUczcDYxK2tYN1AvN01QZ0Q5bmJRSTdUd2pvcVFYaXBzbjFTNlFHOHVQWGU1NUE5aHg2VUFmRHMzd2svYnorTEZ4SHExLzRxaDhLSS96eFdrZDRsc1loL2RhTkZCL1BOZElQajMrMUwreU1iVFVQak5vbGo0MThEK1lrTXVyYWZzZVcyQk9BV2RBT2Y4QWV6WDZPU1RSMjZzWGRZVnovR1FvcnlYOXFiVXRDbS9aODhlUTZnOW5lVzh1bFRSUlFNNnNaSkdVaEZYM3pqRkFIcDJnYXRiZUlOR3NOU3M1UE5zN3VGWjRYUDhBRWpES245YTFSMHJ6L3dDQjJoVCtHL2c3NEgwaTlQOEFwbGpvMXBiVEF0azcwaVVIbjJJcjBBRWNjMEFMUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlRIcDlRek1zWWVSMjJvZ0pKSjRBeHlhQVB6Zy80TEVmR0dTMDhIK0YvaGRwTCtiZjY1Y2k2dklVYkxlV3B4RU1lN2JxK25QMkV2Z092N1B2N092aDdScDR5dXIzNkRVdFNiSHpHYVFBN1Q3cXVGL0N2emRXeTFMOXM3L2dwWGRQYkI1ZEIwclZjU3VDU2tWbmF0c0pIWWJpcFB1U2EvYWVOUjFHT2xBRG94aGZXblVnQUhRWXBhQUd0MC93cjREMUdXNStPLzhBd1U5MCtLTXlQb0h3MzB4dDhnWDVSY091U0NmOTgxOXkrS3ZFRnA0VzhPYW5yRi9PTGV5c2JkN2lhVmpnS3FxU2ErSGYrQ1dzZDc0Ni93Q0ZzL0ZMVVQ1amVKOWVkb0hjWmJhQ1NSazlnZTFBSDN5UHUwNmtIU2xvQVl4QTlDZTJmV3Z5ei80S3UrT0Q4UVBqTDhMdmc1YkFQRTk5RGRYU1I5Zk1tWVJwL3dDT3UxZnFOY2RjZzhxZnlKNEZmanY4S3RRUDdUSC9BQVZVbjFpY0M3MHJTNytlYU11TndTSzNqY1JZOU1QakhvY1VBZnJ4NFMwaVB3LzRjMHJUSUYyUVdsckZBaSttMVFLMkR5RFVVYmJ5cFBCSTVGU1B5TWV0QUdmcitzVy9oelFyL1ZieHdscFkyOGx6TXhQQVJGTE4rZ3I0Sy80Sm9hRmZmRWp4NzhXUGpscTdtYTYxL1U1TlBzNUQwTUtObHNmaDVYNVY2cC93VXMrTWYvQ3BmMllOYWp0blpkVDhRT05HdGxVa01kNEpjLzhBZktzUHhydWYySnZoYWZoRCt6SjRGMEdXRllyODJhM2QxOHVOMHN2ekVuMzI3UlFCN3l2UVUyVHFLZlVERExrYnZYUHQwb0ErQ3YyOUhuK00zN1Jmd1grQ2xsSmkzbnZocmVwN1A0RVEvSXg5dmxjZmpYM3BZUVIydG5EQkV1eUtKUkdpK2lyd1AwRmZFWDdOdHAvd3R2OEFieCtOUHhDa0F1ZE04UHhRYUJwczBuekJUdHpJRUo2WVlIcC9lTmZjU2dLY0NnQjlOY1pYSHJUcTVyNGhlS3JYd1I0STEzWHI2YnlMVFRyT1c0a2s5TUtjZnJpZ0Q4dlBpVnFTL3RNLzhGVnZEMmhqL1NkRzhMU3Biblp5REhBTjhvUDBrZHEvV0lqQVVLTnZIQjlLL0xEL0FJSkhlRmo0OCtMZnhUK0sxOUY1dHpKTzhOdE5JTXNza3p0SktBZTNETFg2cGpKeHVvQWRSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBSFBmRVJMaVR3QjRsVzBScExwdE11UkVpZmVaekUyMEQzeml2a3YvZ2xQTnB0dit6dnFOakZPajZ1bmlDOGZVWU1ZbGlrTzBZY2RmNGV0ZmFVaHdLK052ak4rekY0NStIZnhHaytLbndCdXJmU05ibkgvRTU4TFNnQzExVWJzbHNkQTU1K2JyUUI5a2NuT2VuYXZpUC9BSUtRZnRreGZBZndRM2hMdzNjdC93QUpycjBETEZQQzNObEZuQmM0NTNaeUFQcldYNHkvYWMvYXR1Tkt1Tk0wZjRCdnArclN4YkUxRHpHbWloWThGdXVENmpOY0IremYvd0FFN3ZGdmpING9KOFZ2MmdMd2F0ck1raTNhYU5MSVpIZVVIQ21Yc0ZBQXd2YkFvQStZclA0WEoremQrem5lL0Z2eHlQdG54RjhhaHJidzdZM1J6SmJSdU15WGpaNTNFZXY5NnJuL0FBVHB2dkVQd1YvYVQrSFYvcVVjMFdoL0VPMG10clZqa0pKKzhaTngvd0IxbzIvQWlzLy9BSUtVZkZnL0hMOXFHSHdub2pGdE4wSXhhTGJReGo1RE9XdzVVZlZndjBVZWxmVFg3VkhnaGZnbjRsL1pCczE4dUE2UmNDemxVY0h6QXNXLy93QWVadnpvQS9UV0E1WE9DQWVSazFJM1NtUnFxa2hSakhhbk9lUDYwQVZyeUJMbTFhT1JQTVJ1Q2hIVWVsZkEzN1hIN0lVL3d4dXIzNDRmQk9lVHd6NHUwY204djlNc2NwRGV4am1VN0IzUEpJNzVyNzRubFdKUVhaVlVITzVqZ2ZtYTVueG40ODhMK0Y5RXZyclhOYjA2eXMwaWNTdmNUS001WGtESjlLQVBOdjJQL3dCcEt4L2FnK0VkaDRtaVZiZlY0djhBUjlVdEFlWTdoUnlWSFpTZVI5YTk1ais2Sy9PMy9nazE0Y0VGeDhYUEVPbHhCUEN0M3Jyd2FjRVB5RkZQREFlbU1WK2lVZjNSUUFvNlV0SU9sTFFBVVVVVUFGRkZGQUJSUlJRQVZCTG56Umc5Uit2cCtQOEFTcDZvYTFjejJtbVhrMXRCOXF1b29Ya2hnSFYzQ2txdjRrWW9BK0cvaXQ4U1BqQisxZjhBRVB4RDhPdmc5TzNndndyb1Z3TFBWL0dEc3l5Tk9CbG9vaXBCeGc5cXFqL2dsbEpyMWhHL2lINDQrT2RUMVZWK2VYN1dIalZ2OW5ka2dWMWY3Ri83UlBnWFNmZ3JxMC9palh0SzhMYTNiNjdxQjFXM3ZibFk1QlA1cCtiRGNrYmNLUDhBZHE1NDcvNEttZkFqd1hjaTF0dGN1dkVjNHprNlhhdEloLzRFT0tBT0swRC9BSUo0L0ZENGIzelgvZ2Y5b1RYN2E2akh5UjZvR21pT09nZE9oSHRpcTF0TisweCt6YjQ3MW54djRoOEs2ZDhaSWRYdElMTzh2UERpZVJkSkhBWFpDSWh4L3dBdFc1eFYzUmYrQ3Yzd3QxVythT1h3NzRudDdaVC9BTWZDV29tQkgrNm95SzZ4UCtDcC93QURKTkx1cDIxSFY0TDJLSjVFdHJ2U3BveEtSMFhKR09UeCtkQUhkZUN2MjQvaG40bCtHTjE0djFiV0l2Q1RhZTNsNmxwT3JIYmRXY3VjYk52QllucnhYemIrMFgvd1V3K0ZYeEkrRi9pcndkNFYxTFVyYlVkV2hPbng2bmRXTGlGRlpzTklHNjhEcFVYN00zN08zaGo5c254UnFIeDkrSm1vMld2TnFzN3JhZUY0U0JIWXhJeFNOWmdPcllVSEI0NXIxRDlvVHhKK3liOERORWwwVHhENFQ4SlhPcFBFMzJiUmRPMHFLVzRhWG9vK1JjcVNlL3JRQnoraWZ0eS9BcjlrejRWK0dQQTNoKytrOFd6NmRaUmhvdEJpM28waklIZGk0R01zekVuUGNtdklkWC80S0xmdEIvSFhWMHMvZ3g4TmJpeHQySlR6NUxQN1ZJZWVHWXNDcWpHTzFVL2hoOFNMNzlqN3dUcE4vd0NQL3dCbnlCL0RlcVhjMTliYXpCQkZMZFdsdks1a1NLUTdTVjJLd0dEenhpdnZiOW43OXBmNGFmSDNSSXBmQWVyMjVlSmN5NllVV0dlRGpKQmpQUGZxS0FQaDY1L1lrL2F4K1AxOS9hUHhIK0tTK0hSS29iN0hCZHUwYUE5VjhxRWhWUDRWcDIzL0FBUjcxYWUyUTZoOFliK2FaR0RxMFNQdFVnNXlOeFBOZnBoRVNvQmNFbm5BQTVIK2ZXbjUzT01ZK2g2MEFmbnRaZnNpZnRGL3M0d1Q2OThOdmkxUDQyaGhYZko0ZDF2Zkt0eW9HU3E3aVFDZW55NE5mVDM3TVA3UXkvdEFlRFd1NzdTejRlOFY2WE0xcnJHalQ4U1drNjhNUXArYmFUMHpYdE1rdXdIY0R0SFVucGo2MThKL0RYNG4ybXMvOEZMdkdtbitENC83VjBTKzBXS0xXYm16UDdpRzRoUVlrT09DU3k3TStwb0ErODQvdWlsSFNrais2S1VkS0FGb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLaE14Qkl3QjF3VHdLQUpxS2lNMjFRVHRIMU5lUi9FLzhBYTMrRS93QUlZcGo0bDhhNlhhM01lYzJVTXdtdU9Pdjd0Y3QrbEFIc0RIQTlLajgwTGo1Z1FlOWZuZjR4L3dDQ3pIZ2kzMUNTeDhKZUNOYzhSUHUydzNMRVJSeUh0OG4zcTREV2ZqLysydjhBdEJ6ZWI0SjhEM1BnZlJYL0FOWEkxdjhBWnc2OWo1czJQME5BSDZsU1hxUkl6UElpS09kek9BQlhDZUxmMmhmaHY0RWpMZUlQSE9nNlNWNnJkWDhhbjhzMStjeC80SjdmdFFmRjlsbitJbnhhTmpITjkrMnVOUWx1TUE5UUZRbGE2Znd6L3dBRVU5QlB6K0pmaVBxZDR3NU1kaEFvQi9GdWFBUHEvVVArQ2dQd0RzSXk3ZkVuUjVRUCtlRXdrSitnSEpyaDlaLzRLcmZzK2FOSnMvNFNXL3V6dXhtRFRKbVVmaml1VThKLzhFZS9ncm9WMUhOcWR6cmV2S2h6NVU5MFlsUDEyWXIxR3kvNEp2ZnMrMk1TeHI0Q3RwUXY4VTBydXgrcEp5YUFPTXZmK0N0SDdQbHRCdmgxM1ZycDhaOHROSm1CK21TTVZONGEvd0NDcm53QjE4c0o5ZnZkSllFWUY1WXlEUDRnVjJmL0FBN24vWjkrYlB3OXNUbjFadUs1anhQL0FNRXNQMmZ2RVVUaUh3MWQ2VE13d0pMRy9sUUQvZ09jR2dEdTlKL2J5K0Eyc0NMeXZpYm9VQWs2Rzd1VmhJLzc2cnNkTi9hWitGT3MrWDloK0l2aHU1OHcvSnMxR0k1L1d2azY1LzRJei9DV1FzWXZFT3Z3Z2doUnZSc2ZuWEUrSmY4QWdpbjRjbDNudzU4UmRVdDVNY1IzOXNoUmZ4WG1nRDlKTk44UWFmclZxdHhwOTliWGtEY2lTR1VPcC9FVjVoKzFkOFU0Zmd6K3o5NHo4VXZNcXoyMWhKSGFoLzhBbHJNNHdxRDFKeWZ5cjg0cFArQ1dQN1FQd3p1WkpmQS94RnRwQURsQlpYOGxvNTlNN2lCWGt2eDQrRW43WUI4TG53NzQrdGZGSGl6UUlIRXc4dTRhL2czcjkxOXlrZzRvQSt2UCtDUEh3cXN0UCtHUGlQNGp1NXVkZDF5N2F6Wm01MlJ4c1R4NlpKSko3MStqRVEycUZIM1FNRE5mak4reHIvd1VPMHI5a2o0WFhQZ1B4UjRIMWUrdW9iNlNjU1dycENWM2RWWVNZNUJ5T0src1BCbi9BQVdCK0RXdUcyajF1MDFydzNKSW9MR2UzTXlxZnFtYzBBZmR0TmNrRGpyWGt2dy8vYXgrRW54UEVLK0hQSHVpWDl6Tjl5ME40aVQ1OURHeERBL2hYcVRYUG1JU2hHTnVSam1nRDVNLzRLWmVPYjdRZjJjNVBET2o3NWRjOFlYOFdqMmNjWDNuM09ONmovZ09SWHNmN01Yd2F0UGdMOEYvQy9nKzJqVkpMUzBWcnQxT2ZNdUg1a2I4V0pyNTYvYUg4U3crSS8yL2ZnUDRLbmpGelo2YkRjYXRKRjFVWE9HMk5qMkdEWDJ6R29CNXlCbnYzTkFFMUZGTlpzR2dEekQ5cGY0a1JmQ1A0SGVNL0Zjc25rbXcwNlh5bTlKV0d5UDYvTXkxK2RQL0FBUm0rSHgxeng1OFEvaUhkSGROYlJyWUlDZWZNbWJ6U2Z5US9uWHVQL0JZYjRnSHc3K3pqWStISXBsV2J4QnFrVUx4NXdXaWovZVovd0Mra1dxZi9CR3Z3dlBwbjdQM2lEV1pZeWlhcHE1TWNqRDczbGdybi94NmdENytqQVBPYzg4VTV3U3BBNE5KRmpid01BODRwWkJsZStSenhRQithZjhBd1V4MUdUNGxmdEcvQkQ0VTIwb1lUWHEzdDNGalBCa1FLZmI1VmtyOUl0TXNVMC9UclMwaU9ZcmVGWVYraWdBZnlyODFQaGROYS9IZi9ncko0dDFXNXhkV25oSFQ1RnMyUElCaUtSajhqTzFmcHJ0NmM5RG1nQjFjRjhjZkhNWHcwK0VYaTd4Tk5JSWpwbW5UVHEzbyswaFAvSGlLNzJ2a0wvZ3FKNHViUWYyV2RVMFNEbSs4VFh0dnBGdW5Rc3p0dXgvNDcrdEFFSC9CTDd3cGRhWit6WVBGR29wL3hNdkYrcVhXdFN2bmxnekJQd0dVWTQ5Nit3a1hBNTVOZWVmczgrQkI4Ti9naDRJOE9GZHN0aHBVRWNneDBjcnVjZjhBZlRHdlJhQUdzMjNIUFhpdmt6L2dwNzhRbThBL3NpK0tJbzV2THVkYWVQU2x3T1NISkxZOU9BSytzblhkdDlqbXZ6Ui80TFYrTDRyWHdENEI4TnJLZnRGM2V6M2JvRC9DaXFGUDU1b0E5Ti80SkRlRHhvSDdMQTFSMUt2cm1xVDNRSjZrSmlML0FOa3I3akF4WGhYN0VQaFAvaERQMldmaHhwMkJ6cFVkM2tEcjUzNzAvd0RvZGU2amtVQUxSUlJRQVVVMWlSMHhuM3B2bUVuYmdBK3BOQUVsRlI3MkFHUitocXZkNnBiV0VMeTNNOFVFU0FsbmtZS0FQWG1nQzVSWGhQalQ5dUQ0SmVBcDViZlZQaUZvNXVvczc0TFNjVHVDTzJGeWMxNHg0by80SzdmQXZRM2ROUHVOVzF1UmVOc0ZrOFlQL0FtQUZBSDI3VEdmYms5QU9wTmZsMzRrL3dDQzJ0cjV6RHc5OE43aVNJSEN0cUYwQVQvM3hXRC9BTVBnL2lkNHZrRmw0UytGTmxjM3JET0ZhZVpoOUZIV2dEOVlFazNucVBia1VOSVFjQUg2OUsvSGk1L2FJL2J2OFlYMHR6cC9oanhEcDFyT2QwY01YaDhwR2c5bVpNL2pUamMvdC82eWhmWjRpZzNmM1ZXRWorVkFIN0RITHJoc0VIdFNiQVZ4dDR4akFyOGZJL0F2L0JRR1pkLzlyZUlJK000ZlZFVCtiVm4zbmh6OXY2ekRicjN4Wk1Ceis1dmZNeitSb0EvWTRLcEdEZ2pPUXFqcFhPL0VqWDE4Si9EdnhKcTRZeG13MDY0dUEzY01FYkg2NHI4a0xMNC9mdDJlQVhpTjdvSGllOGdoT0Q5dTBCcGxmL2daVG44NnpmaTcvd0FGSC9qbHFuZ0hYL0NIalB3VmFhV21zMmpXcjNFMXBKYnl3ZzR5VkJBSGJ2NjBBZVcvc0hlRjV2alorMmw0YXV0VFUzcUMrbTFtN0VuTzRBbGlUL3dKaCtWZnBYL3dVODhIRzUrRzNndnh3c0N5dDRUOFJRWEV4SXlZN2VSMUVqL2hzSDUxK2FuL0FBVHkvYUI4SmZzMi9HeTY4VWVNa3VScDBtbXlXU1RXc0psYU4yWlRuQTV4eFg2MlczN1Rud0UvYWM4SWFuNFlYeHBvMTVhNnhhdGJTYWJmVENDZHQ0eHdqNEpJT09ucFFCNzlwR3VXbmlEU0xQVk5OdUV1Ykc4aFdlS2VQa09qREtzUFhpdksvd0JwdjlwN3d6K3pQOE83cnhEcjBxWEY4UnRzdE1pWWViZFAyd095K3A3VjQ3YTIvd0FjdjJWUGhocDNoVHdYNFhzdmkxbzFpa2kyTjhMb3hYVU1ST1VSNDgvTnR6ajVld0ZmTXZoVDlndjQyZnRYL0ZXSHh4OGRMcDlDMFdTWHpYc1BOL2ZxZ1BFU1I1K1FZNHljR2dEd0R4cDhaLzJqdjIydkZGNitndytJTHJTdzNHbDZHSkk3VzJRL2RWeU9DZmRxOVErRFgvQkpUNG4rTmIyRysrSStyUitHZExkMWVXMVdmN1JjU3FPb3dDZHArdGZyZDRHK0grZy9Ebnc5WmFGNGIwNkRTZEtzNHhIRGJXNkJGVlFNYytwNDZubXVqV1BhQnorUXhtZ0RnL2d2OEd2RFh3SitIdW5lRWZDMW1iYlM3UlNSdVlzOHJubG1Zbmtra25yWGZBWUdCU2JlTVpPS2RRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQVZibWQwSkNNQVJnbmR5QVBmOWZ5cjg0dmp0KzJIOFR2Mml2aXBxUHdoL1ovdEd0WXJLWnJmVWZFZzVPMGZLMjA5RVVFbm43MlZPSy9RenhYbzdlSU5BMWJTbG5rdFRmMmt0cUxtRTRhSGVoWGNEMXlNNUgwcjg1dmdqTjR4LzRKejN2aWZSUEV2dzAxYnhqNFoxUy9hOFh4WG9jZm15Yk8zbmZUayt1V1ByUUEzd0QvQU1FY05OdTdvYWo0OCtJVjlxMTVNNWt1NGROVENTT2VXRE9mbXpudlgxVjhPdjJBUGdWOE9ZWUZzL0FHbmFqUEVPTG5WMCsxU0Urdno1cmxQRHYvQUFVMitBT3RXOGJYWGllNDB1WW5hME9vNmZOR1ZQdVN1S3Y2NS93VXYvWjU4T3hsMzhicmQ0NkxZMmNrN0gyQVVHZ0Q2RTBINGNlRmZDbHZKRG8zaDNUTktpaysrbG5hSkdHK29BcmhmamJvbndrMFh3YmU2NThSOUU4UFM2TFl4dHZtMVMxaWtBN2hRR0hKUGIzTmZPM2lIL2dxcDRUMWd6V1B3ejhGZUpQSDJxN2Nva0ZvOEtKN3ZrYmdLK0x4NDIrTVAvQlRINDEyM2d2VjdpMzBmdy9wczczRnpZMjBZV0d5aURiV0ROMWQrQ0J1b0EwUGdQOEFzL2VLUDJvdmpmNGc4VC9ET1BWUGhwOEhwdFFQbUd5dVRiaDR3b1VpSlFRQ1d4dXgwR2NWQi93VVAvWmQ4T2ZzejY5OE9kVThOM0dxWGN1cDNERzd2OVF1WGxlVjQyUTV5eE9PdWVLL1gvNFlmRExSUGhQNEUwYnduNGZnK3phUnBkdXNFVWVCbHNkV1B1eEpZKzVyNEMvNExYYVlzbncyK0hGNXZmZmJhbGRLQm5naGtqNi9sUUI5N2FMcHVsL0VYNFg2UkZxOXBCcTJuYW5wa0R5dzNpQ1NOMWVKU2NnK3VhL09UOXN2L2duL0FLajhHVWwrSi93QmsxUFJIdGxQMi9TOUxuZFpZNHo5NlNJZzUyZ2RWSGF2dVA4QVk5OGNXbmo3OW1UNGQ2cll6R1pFMGEzdEpPNUVrS2lKOC84QUFrTmV3ejI2VEpJSmdKVlpTcktlUVFlRHg5S0FQeCsrQ2NYN1gzam40VTJIalQ0Yi9FaWZ4WmF5U1NRM0duM2w2Sko3TjQyS2hXV1lua2dBNEhZaXV1aytJLzhBd1VLMDFWVTZQSmNsTzZhVGJ5TWZxUXRleS9zd1JMK3o3KzNMOFZmaFNzdmthSjRqUWEvcGRxWDRFakRlNFhQb3BBL0N2dlRPUnlNWTZidlgrdEFINU5yNFYvYnMvYUF2VjBmWHIyODhJYVRPNFM1bldOTEJWUThOa1JnRnVPMWZiMzdJSDdIbmg3OWxQdzNleFdzejZ6NGoxTlFkVDFtYnJKam5Zb1BSYzgvWG12b05tVXFRV1FqdnRiR0Q2MVZ1ZFdzckNONXJpN3Q3Wkl2dnlTeXFPUHJuaWdEUlEvSUtmWG5rbjdRSHcwdDdnVzhuajN3OGt2OEFjT294Wi9uUzNuN1FmdzAwOVZhNThlK0hiZFdHUVpOU2lHZi9BQjZnRDBLaXZMLytHb2ZoR0VESDRsZUZzSGdFYXJDY24vdnF0TzErUFh3NHZZdk10L0hYaDZaUDd5YWpFUi82RlFCM3RGWm1rK0k5TjEyMFc1MDYvdGI2QnVrbHZLSFUvUWcxZldRc0NSamFQem9Ba29xTDdRcDVISTlSeUIrTk9ESEE2SFBwUUEraWlpZ0RDOFRlT2RBOEYyUDIzWDlZc3RHdE1uOTllenJFbkh1VFh4TjhWLzhBZ3Fob0VPc1hIaHI0UStGNy93Q0luaU11MFVVc0ViZlppM1RJQStaeDdnWU5jL3BIL0JOVHg1OFpkZmcxL3dEYUErSmQzcjhzUUNycG1tU3RzMmYzQzV4dC93Q0ExOXJmRFA0RWVCUGcvcEZ2cDNoUHd4cCtrUlFvRUVrVUsrWTJPN1AxSjk2QVBnV3crR1A3Wlg3VlY0VDR6OFJQOE1QQ3R3Y3lXOXVmczhteis2STErWW4vQUh1dGVwZkRYL2draDhKdkROMEw3eFZmNnQ0NnZpMjhuVUpQS2pMZDhxcCtibjFyN2tFZUNTQmdtbEFJUFQ4YUFPQzhGZkFQNGVmRHVHQlBEdmd6UmRJTUF3ajIxb2lzUGZkak9hN3BMZFkyeWlxdkhVRG1wcUtBR2VYem5KL09rRVo1QlBCOXpVbEZBQ0RnVXRGRkFCUlJSUUFoR1JVYlJFa2NuSDFxV2lnQmdRZ2s5NmEwTzhZUFRwanRpcGFLQU9GOFpmQkR3SjhRcmFlRHhINFIwZlY0NWVHKzAyaU14SDF4MXI1cStKZi9BQVNoK0IvamRKWmRLc0wzd2hmdjBuMHVZN0Yra1orV3ZzK21zQ2FBUHg0K0wzL0JIangzNElSOVQrSFhpbUR4SUl2bVMwdVdGcmRINk53dWZ4cnlTeitNUDdWMzdJOXdMWFZKL0VtbjJFSkg3cldJWHVMUUFkbFpnVkgxQnI5MzNqWm1CQnh4ai9JcXJmNlRiYXJBOEY3YXczY0VnS3RIT2djRWZqUUIrQ0hnajl0alhKLzJ0ZEMrTkhqbUFhaFBiQVFYTU5wR0VWWWdubGtvT21jYy9XdjEyK0UzN2VQd1UrTGtkdW1sZU5MR3d2WmNLbGhxa2d0cGNuc0ErTW42VmgvR1QvZ25GOEZ2akNrazAzaG1EdzVxcmtrMytpQVc3TWY3ektPR1AxcjRlK0svL0JHanh4b00xeGZlQXZGTm40aHRrQmFPMXZTYmU2T09nQis1K3RBSDYrV2VvMjJvUXBOYXpKY3d1TXJKRXdaU1BZaW5lY3I5Q005eG12NStwYm45cFg5amJWby9PbDhTK0ZvVWZBM3U3MlVnOXp5cEZmUkh3Mi80TE9lTTlGaGd0ZkdYaEN3MTVGSTh5N3RKVEROai9kKzdRQkYvd1dkOGNQcTN4ZThJK0dRNmVScGVuUE95S2VTMHBCQlA0QTE5L3dEL0FBVC9BUEEwbmdMOWszd0RZekFKYzNOa0wyWkIvQzhuSkI5Ni9HVDlwTDQ1NlA4QXRRZnRLSHhoZExkYURvV29TMjlzNjNPSGEzdDFJVmlRdWM0VWs4Vis3UHdhK0tmdys4VytFTkh0dkIvaWpTdFd0WUxXT0dPTzF1VU1nMnFCeW1jZyt4RkFIcGFqR2F3dkhuaUErRnZCUGlEV1J3ZFAwKzR1OCtubHhzLy9BTExXMFpWT0J1R1Qycng3OXJ6VzIwSDltVDRrM3F2c0kwVzRpM0E0Kyt1ei93Qm1vQStGL3dEZ2ozWVRlSy9pTjhYdkhOMHBubWxtU0lYTC9lUG15TzdEL3dBY1g5Sy9VelBHYS9PNy9nakJwSzJ2d0s4Vlg0VUNTNzFqWTNISkVhZi9BR2Rmb2dUaGUvNVVBTHVyNFIvNEtHWFRlSy9qZit6dDRFaUt6eDN1dlNYMXpiZC8zWGxsQ2Z3MzE5MXNkZ3lhK0JmaW5kbngxL3dWTytIR2tORUJENFowWnIvZjJabjh4VCtoRkFIMzVHQXFBTGdLQmdBZE1VNm8wS29nR05vWGptb2J6VTdUVDRETmMzRVVFUTZ2SXdVRDhUUUJQSU1yNzErTlAvQllieEV2aVA4QWFUOEorSFVZbUd5MHFHTXAvdHlUUGtqOEN0ZnFQNHQvYWgrRXZnZ3VOYStJZmgyeWxUckMyb1JHVDhGQnpYNG9mdDNmR2J3OThUdjJ0TlE4VytHOVIvdG5Rb0d0ZkluanlvZFl3aFlEUFAzZ3dvQS9jMzRRNlJINGIrRlBnN1M0d1JGWmFSYVFESTUrV0ZRUDVWMkFtUVpHZVIxOXEvTWZ4Qi93V2g4TGFmcHNGbjRiOEFhaGV6UndJbTYrbVJJaTIwWkFDa25BUEhTdktMei9BSUtPL3ROZkhXYVd4K0hmaFEyRWNwSXpvOWc5MDhZLzY2RmVLQVAyUGVaWTEzTVFxOWNzY1lyaFBGL3g5K0hQZ0FQL0FNSkg0MjBMUm5UckhkWDhhUDhBVGFUbXZ5Z3RQMmZ2MjNmanF5cHJtc2E5WTZlNHc3YXBxNGhqQS82NTdzL3BYY2VGL3dEZ2pCNHIxbEJjZU1maUxhUnpTZk82V01Uek9DZVNOempINVVBZlRmeFQvd0NDcS93UDhBUnlSNlZxZHo0djFCUjhzR2xRbnl5Zit1aEczOWErVWZHdi9CWlB4dHJydEQ0TDhCMlduSzdIeTVid3ROSjlkb3lwcjZkK0ZIL0JKYjROK0FaWXJyWElyenhuZUljLzhUR1RiRCtNWTRQNDE5VitFdmhGNE04QzJxVy9oN3dwbytqUXIwanRMUkVBL0lVQWZqOGYyaVAyMS9qdXhYUllQRU50YXpIS3lhTnB4dFlnRHgvckZBSDYxcmFML3dBRTgvMnAvalplUnllUC9FdHpwdG14K2FiV3RWYTZjRC9jVmlhL1pSTFpZQUJDZ1JmUlFCVWdEbkdjMEFmbXA0Ti80SXFlR2JlU0tmeFY0KzFEVUdCQmt0N0MzV09OdlVianpYdVhoSC9nbGQ4QVBDcFNTWHc1ZGF6T3Y4ZW9Yc2tpbi9nT2NWOWRnSGpqQTlLZFFCNVhvWDdMWHdsOE53eFJhZjhBRHZ3N2JwSDBaZFBqM1ordUs3alIvQmVoK0h3UnBta1dGaGtiZjlIdDFUajhCVzVSUUJISENzUzdVQ3FQUURGQWpQY244elVsRkFEUExHL2RTbEFSL2pUcUtBSTJpQkdPTnZwaXZGUDJ3UEI4WGluOW0zNGhXS1djTnhkZjJWTEpDV2lCS2xjSEl3TTlBYTl2ck8xblRZOVgwNjhzWjBEd1hNRHdPcDdxNHdmME5BSDRFLzhBQlB2NE5lQS9qMzhjSmZCdmo2QzVsdHJ6VFpwTE40TGxvV1dkTnVPblhnbmoycjdLK0pYL0FBUmkwMW9IdlBBUGppN3RMNUZKamcxV1BlaFBVQU92SS9HdmpXOGgxUDhBWW4vYmFTNnZMVm9vZEExa3l4SS9BbXRKR1lobC92RGEzYnVNZGEvZXp3MTRnc2ZGdmh2VGRZMCtVUzJGL2J4M1VMZzlVZFF5L29hQVB4dWY0YWZ0cmZzc3NKOUtmWDlUMHUySmNKcDh4MUMzWkJ4bDRnVGdjZENLOU0rRVAvQllmWE5FMU9MU1BpeDRPQkViQ0tlLzB4REZOR2U1YUU0QXg2Q3YxWENoaTRJQkI1QUl4WGxIeGkvWlMrR2Z4MTA2ZTI4V2VGTEc1bWtYNWIrQ01SM01iZXF5RGtVQVYvaE4rMkI4SXZqT0lrOE1lTmRPdUx4MUdMRzVtRU55VDNIbHZoamo2VjdJSjBJNmpQY1o2VitXdnhVLzRJeDNGcEk5OThNdkc3UXk1M0N6MWpjcEhvRmtUUFAxcnpDMjFmOEFiTi9ZMXVsbHZMZldmRUhoeXk0TnZMSWRRczlnN2pia29QYzBBZnN5WmxHT3VEMEk1RlBEY1p3YS9NYjRYLzhBQlpyUmJpNFcxK0kzZ21mUkoxK1Y3clNtTXFnOXl5dGhoOUFLK3N2aDkrMzU4Q3ZpSzF0SFllUDlPczdtWWNRYWt4dERuMC9lWW9BK2lLS3p0SThRNlhyMW9senB1bzIyb1FNb1paYmFWWkZJUFE1QnErR0I2SE5BRHFLVFAxL0trM0QzL0tnQjFGTjh4VHhrRStsQmNLZVRqNjBBT29wcGtBSUhKejNBNHBHbWpRZk02cjlUaWdCR1FzM1hBcUthMldhTXJJaXVwNEtIbFNEMXlLNXp4VjhXUEJuZ2VKcGZFUGlyU05FalhxMS9leHdqL3dBZUlyeEx4djhBOEZGUGdENEpVeVQrUHJUVVhYb21reE5kay9pZ05BSHAydmZzN2ZETHhSTkkrdGVBZkQycFN5L2VlNDArTXN3OStPYTVhMS9ZcStCR24zTFhFZnd1OE5LemM3WDA5Tm8vQWl2bVR4Vi93V1grRytuSlBIb0hoUHhCclZ3TStWSTZwRkUzdWNrRWZsWG5sdjhBOEZjZmlWNHdqTVhoSDRMbS9rSitWbzJ1SmNENklwNW9BK3YvQU5ySHhIb1A3Tkg3TGZqVFdmRE9tV0doVEd6K3lXSzJVQ3hLWlpQbEFHMGNmTHUvS3ZPLytDWFB3RWsrRjN3S2k4VDZ2YUdMeEw0cmtOOVBMT015ZVIveXk1OXhsdjhBZ1ZmSS93QzB6KzBqOGJQanY4S3RIOFBmRUw0VDNYaERRcHZFTmhJTlNrdDVva2M3bUFYOTRvNEljMSt1UGhIUzQ5RjhMYU5ZUW9JNGJheWh0MGpIUlFpQUFEMjRvQTJWY0t2UFhPTVYrVzMvQUFXdzhWTEpEOE52RFNUQU9yM1Y3TEVyZk15a0txa2oweXJmbFg2ZDZscU5wcDFsUGZYc2dpdDdhTnBaSkg0VkFveVNmd3I4ak5YOEVOL3dVUi9hUitKSGptU081UHcrOExhZExCWnZHMjN6V2lRN0VHZW01Z3ovQUVZVUFkUC9BTUVuUDJsN2JRL0VOeDhIN3k2ODNUcjZNWDJseXQvQk9WQmxpNTU1T1NNZTlmcXVwVWtxRHQ5QUsvbmUrQzNnZlY3WHdKZGZGZndiTE5MNGs4QjZyRmM2amJxMk1XeHhzZEFPVDh3Y0d2MjMvWlovYWU4Ti90TS9EYUR4SnBVcVJhbkFCSHFXbnVjU1dzdmNFSCtIMFBTZ0R3WDl0QjR2aGQrMWw4QmZpUGJXVThrMTFkUG9WejltT0RMRzN6QWZVN3NjOXE3blhkRS9hbCtLdXBUdHAycitIUGhMb1htbnlyY3gvYmI2U1BQRE02Z3FwUHBtc0g5dml4WHhqNDUrQWZoZlRwUStyM2ZpeGJpT0lIRHJDb1hlL3dEdThIbXZzV0NGeHRCSkFIVEF3QlFCOFY2aC93QUU3dkd2aStlUzc4VWZ0RitOcm01bGJjMGRxd0VJOWdDZUtrbS80SlZlQjlYa2prOFFlT3ZHR3ZTZ1laN2kvWlMzNUhpdnRzY0Nsb0ErSWovd1NIK0JqTmtycnhQcWRTay94cDhYL0JJejRGeHlvWGgxdVpSbkliVTVSL1d2dHFpZ0Q0WTFUL2dqOThFN3hNV3MydTJEZGl0KzhtUCsralhOWHY4QXdSaCtHMHlPTFh4bjRpdFdJK1U0UjhIOGEvUXlpZ0Q4enAvK0NSUGlMd3ZEdThIL0FCcDFUVDVrT1l6Y0JvMVgvdmcxeVdwZkEvOEFicitDbHkzL0FBajNqRzU4WjZiQ2R5U0RVRm5EZ2RCNVVwM2ZoaXYxY2RkdzcvZ2Fac1BKQ2daL00wQWZsYlovOEZOdmpoOEdMeUxUL2kvOEtwZ2lrSkxmZlpwTFNSdmRSZ0kxZlZQd2gvNEtVL0JINHByQkRKNGtUdzFxY2hDRzExa2VSOHg5SFB5bm4zcjZTOFErRXRMOFVXY3RycTJtMjJxMnJqQmd1NDFrUS84QUFUeFh4MThiUCtDVUh3dStKbHplNmg0YmU0OERhbE9NN05QdzFzemRjbU04RDhLQVB0TFRkYXN0WHM0N3F4dVlyeTJjQXJOQTRkV0hzUjEvQ3B6ZXhEcTZnK200VitQMnJmczlmdFAvQUxCRjdKNGg4RmEwL2l6d2pFMjY0aHNtYWVKMEgvUFMzYm44UU9LOXk4RC9BUEJZNzRmemVHN1gvaEwvQUExcWxoNGdRYkxxR3pSWGlERHVwSnorQjZVQWZvdlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBaDZVemJrRUVjR3BLS0FNclVORnROWnRYdHI2enQ3MjFmSU1WeEVHSDVIaXZuejRsZjhFOFBnYjhVQk85OTRMdHRLdTVSbHJ2U2Y4QVI1QTNybGV0ZlRGRkFINVgvRkQvQUlJdEFRWE54OFAvQUJ1Zk1KSlN3MW1IYXVPeTcxeVQ5VFh5ZDQ2L1lCL2FGK0VFajNDK0ZkUXZZSStSZGFCUDlvT1BVTEdTdy9FVisveDYwMG5rOS9iRkFIODgybGZ0UmZ0RmZCeEJwdjhBd2xuaXZSb1l1bHBxWG1LRngyMnNLMFBHZi9CUXo0MmZFUHdGcXZoSHhINGd0OVIwVFU0aERjcTltbm1Nb1lOdzNYcUJYNzY2aDRaMHJWRmNYdWxXZDBHKzk1dHVqRS9welhudmlQOEFaVCtFUGk0dWRXK0hYaCs4ZVRxOHRrb1AxSHZRQitNUDdObi9BQVVGOGMvc3ZlQW44S2VIZEgwbTkwOTd1UzdNbDB1R0x1QU9vNjhMWHFjLy9CWmo0dE9DSTlDMEdJLzdoYitsZm9MZmY4RTJmMmZiNmN5ZjhJRmJ3RW5PMkdRb3Y1Q3REUS8rQ2Uvd0IwQ1F5dy9EblRicDhZMjNhK1lQMW9BL05XVC9BSUxDL0c1ZzNsMitnUkEvOU9RT0s4UXZQMnhQaWxyWHhudVBpZGI2a2tQaSthMSt4ZmFiUzJHRmp6a0FMWDdmYVgreHQ4RU5LbU0xbjhMdkRNRW45NFdTbjlEWGNhRjhJdkJYaGhnMmorRk5Hc0NPOFZvaW4rVkFINGJ5L3REL0FMVm54WExRMkd1ZU5kUmpsNDh2U3JhYmEyZlpBY1ZzNlordzcrMVY4VkdTNXY4QVJkWk1jbysvcStwSkNSMzVWM0I3K2xmdXBiYWRiV2pmdUxhR0x1VEhFcS95cTZoQkJJeHllMUFINHcrRXYrQ09IeGIxNmVGL0VPdjZMb3NKYk1nZVo3aVFEMjJnZy9uWDBINEovd0NDTG5nTFMyams4VCtMOVgxdHp5OE5yR3R2SCtCQnpYNk8wVUFmTmZnVC9nbng4Q2ZoejVUMlBnTzAxQ2FOZ1Z1TldKdXBNK3VXcjMzU2ZEbW5hRmJSVyttNmZiMk1FUTJ4eDIwU3hxbzlNQ3RlaWdDSUkzR1JuNkdwQjBGTFJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVXhnZDNTbjBVQWZuVi93QUZhLzJZSmZpRjRLcy9pYm9WaTkxcmVncDludjRvVXkwbG5ra1BnZGRqRThkOTN0VVgvQkpqOXFpRHhsNEJId3M4UTZsdTEvUnl4MHhaVHpOYWNIYUQzS3NXNDdBaXYwTHY0SWRRdDVyTzZoV2ExblJvNUkzd2R3SXdRUjlLL0dMOXJqOW5ueEgrd3Q4Zk5LK0tmZ2hwUCtFVHVMLzdSQktnUCtpeU1jdmJ5WTdIbkgxOXFBUDJtaU9UMUIvblVvUEpyekQ5blQ0NTZIKzBSOEx0SThaYUd4RWQxSHN1TGQxMnRiekx3NkVleHpqMUJGZW5qT09hQUVjRXJ3Y0dvSnJkWkltUXhLeW5raHdDRCtGV2FLQVBIZmlMK3lYOEp2aXFXazhTK0JOSnZMbGlTYmxZRlNiL0FMNkZmTS9qai9nanA4SmRlZWViUWRXMXJ3N0xKa29vbCswS2g5dDJLKytxS0FQeW0xTC9BSUpLZkZmd1pkZWY0QStMVWNTZGR0MUpOQko3ZmNCRlUxL1pHL2JpOE5rUjZYOFRMMmFJSEE4blhTcW44R0lyOVphS0FQeWFsOEFmOEZDdkNoTFJhdGU2ckduQVA5cTI4dWZ3TDVxSmZpTC9BTUZCTkhrV0p0RnViaGs0eTFqRktEK0lOZnJWUlFCK1Q5MzhhZjhBZ29CZFJmWmo0U1pOMzhhYVBGbjg4MUF1dmY4QUJRblc0bE1lblhGcXBJQVVMQkNmMVlWK3M5RkFINVJ6L0EzOXZ6eFhFSHZmR0YzcGl5OHRISHJNU2Jmd1Z6VmpULzhBZ20xKzBoNDlDanh4OFpqRFpOOStFM3R4UEorUUczOWEvVlNpZ0Q4NE5FLzRJdytGV1ZYOFEvRWZYdFdrUExJc0tvbjB5V3pYc25nZi9nbHg4QXZCelJTUytHTGpXNTBQek5xdHlaa2Mvd0M1MEFyNjdvb0E4KzhKZkFQNGMrQVdEZUhmQk9oNk93QUFhMXNVVS95cnNJOUh0SUh6RloyOE9EL0JDdnpmcFdqUlFCOCsvdHUrRnJUeEIrenJyMGwzQlBKRHBVOXJxUVcyajh4MUVjNkZpcWpuaGQzU3ZTUERIeFo4RStJUEJWdjRsMHp4TnBjL2gveWxJdlJkeCtYRXUzTzEyemdFQTRJUGV1d3ZiYUs4dDVZSm9rbWhrVXE4Y2k3bFlIcUNQU3ZsYlh2K0NhL3dUOFFlTUpkY20wblViYno1VGNUNlphMzd4MmtqRThnUkRqR2UzdlFCNWo4Yy9qbjRnL2JCOGJMOEZmZ3pjU0h3dkt3VHhONDB0bEp0NDRmNG9ZM0hCNDY0NjU5algwMzRHK0NYaHY4QVorK0Iyb2VFdkNsajlrMCtIVGJocFpId1pKcGZLWUdTUTl5MlB3d0s3L3dMNEM4UGZEclE3ZlNQRE9rV21pNmJBdTFZTFNJSVB4UFhQMXE1NG1SWDhONnZHM3pBMlV5c0Q2RkdvQS9JL3dENEk3SmFhcDhRZmlaNGMxQzNpdkxEVk5KaFdhMG1BS01xeVBrSDFHRGl2b2J4MS93VFo4UitCZkhNL2kvOW5yeDFKOFA3cTViOS9wY3p1TFlEdXFsUVR0ei9BQWtjVjh2L0FQQkpuVVZzZjJ2dGYwNVhFYTNHbjNhcW5xRWJQOWEvYU5PUlFCOHQvQVQ5ajNVZkF2eEFUNGsvRWp4amUvRUw0aGZaZnMwTjFjZytSWkxqRENJSHBYMUlGd2ZhblVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQld1SUZ1RVpaSXc2TUNyS3d5Q0QyeDNyNTQ4Yy84RS84QTRLZkVEeExkYTdxUGd1MkY5ZEVOS1lHTVNzM3J0QXhYMGhSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQW1LTVV0RkFCU1V0RkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFtQm5wWEdmRjM0WWFKOFlmQUd0ZUV0ZXRrdWRPMUtBd3NHVUV4c1J3NDl3Y1YybE5kUWNaSGZOQUg1cS84RTluOFEvc3pmdEdlT1BnQjRua0l0cmxXMVBTSFAzSmR2QmRUL3RKczQ5UWEvU2FKeTYrdnFmZXZrcjlycjRjWDJtZkduNE5mRmpRTENXNXZkSDFkZE0xSmJhTGN6MmtwSitiSDhJWWsxOVpRdXpkVzNBL3hiZHZlZ0N6UlNkeFMwQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCU1lGTFJRQW1CV1o0bFRmb0dxQWRUYVNqL3h3MXFWaWVMNzFOUDhBQytzM1R1RWpoc3BwR1k5QUFqVUFmaTUvd1M2dFRIKzNoY1J2d1lyUFUxL0lnViszVHQ2Zm9hL0NMOWdQNDArRWZnLzhidkdIeEk4WDNpUVJXdW4zTFF3Z1ptbmVWamhZeDYxN3I0eS9iNitQdjdVdDAyaWZCTHdiZmFOcDREUnpYdHRIdmxZbjFsYkNSL25RQitxOTVybGpwd1ZydTlnczFZZkkwOHFydUg0bXVkMVQ0eCtCOUNpZWZVZkdPaFdrS0hETlBxVUNBSHRuTDErVFNmOEFCTno5cUg0b3gybW8rS2ZFMEZuY241ZkoxWFYza2xqQjVKL2RCaCtScnUvRHYvQkdEeERlVE12aWo0blJ3MjU1WWFmQkpPVzllSDI1b0EvUlMzL2FVK0U5MVBIREY4U2ZDa3N6bjVVL3RpM3lUNmZmcnVMRFc3TFhMTkxyVGIyRFVMV1hpT2Uxa0VpSDZNdVJYNVAvQUJsLzRKOWZBYjluN3dkcWVvNjc4U3IvQUZMWDRZajlqMG0yZUpMbWVZOEtpeHF4SnljZE9sZldmL0JOYjRIK0lmZzk4QjRaZkVWNWZpLzF5VDdXdW1YamtpeVQrRlFEMHlPVDlhQVBzRmZ1aWxwRis2S1dnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtRak5MUlFCRTl0SElRV1VOam5rWnB5eEt2VDYwK2lnQktXaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUN2RFAyMWZpSmEvREg5bWZ4NXJGMVA1TE5ZTmEyK0J5MHNtUW8vSG12Y2QySy9Oei9nc2Q4UVpwL0IvZ2I0YmFjN1MzdXVYNXVwWUU2a0tRc1hIZkxGeCtGQUh3RCt5cmQvRGZ3RDR5dFBGUHhtOEs2enJQaEdWU3VudmIyMmJXU2NINWl4WWdPQjB3cE9DRG12MXkrR3Y3Y1g3TStsK0ZZSTlCOFVhVDRZc1ZYL2p4K3h5UVBHZXBCVUp6OVFTUGV1NStCLzdNbmhqd3YremY0UitIM2lUUWJIVnJlMjA5RGQyOTNBSC9BTklmNTVTRDFIek1SeDZWd090LzhFdGYyZmRhdTNuL0FPRVl1ckhjMjR4MmQyVVFmUUVHZ0NqNHgvNEtuL0FMd3JKTEhhNi9kNis2cVNScDFuSVFUajFjS1AxcndIWHYyMC9qMSsxMC93RHdqZndQOEMzbmhmUkxrbUovRWQ0cCs3M0lreHNUajBMVjlaZUVmK0NlSHdCOEhQREpiZkQ2d3ZaNGlDazJvRnBuQjllb0g2Vjc5cEhoM1QvRCtteFdHbDJrR24yVVEycEJieGhFQStneFFCOFgvc3YvQVBCTnZRL2hocmxyNHcrSWVzeStPL0dhTjVxL2FpelcxdkkzSktoczd6bnZ4WDI1RmJyR29BSndCZ2V3OUtjc0lVRGtuSFROUEhGQUFCZ1V0RkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGSWVSUUJWdTdoTGFDU1p6dGpqVXV4eDBBR1RYNXAvQmJTeisyeCszWjRtK0pHbzJEeWVCL0JEQ3lzRXVPVmtuakpDZ0RrZmUzTWVlakN2MG0xT3cvdEd4dTdTV05qRGNSTkEreHVkaFhCeDc4bXVQK0QvQU1FdkMzd044TFNlSC9DZW5mWWJHU2J6NVdKeTgwcEFCZGozNEFvQTc5UHVqSnlhZFNMMHBhQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQVAvOWs9XCJcclxuXHRdLFxyXG5cImRvdWJsZVwiOlxyXG5cdFtcclxuXHRcdFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFsZ0FBQUYxQ0FZQUFBQTB2SlNwQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFGUlFBQUJVVUJiQTNiZHdBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFBQVVkRVZZZEZScGRHeGxBRVJ2ZFdKc1pTQlNZV2x1WW05MzVFUldBZ0FBSUFCSlJFRlVlSnpzdlhtVUpOZGQ1L3U1RWJsVjF0TFZxN3FsVm1qdDF1SkZzaVZMc2cyeWpQRUNIcndBdHNFR2p6RU15enlHYlR3czgzZ3doMW5Bd3pMRFlUanczakF6d2hoakROZ1lZMk5yOGI1ZzJWcHN0ZlpXUzhxV3V0WGR0UzlabFV2RWZYOUVSbVlzOTBaRVZtVlZaVlhmN3puZEdYRi92L3U3TnlJamJuenF4aThqaEpRU0l5T2pEWkxqVEFDN2diMnh6ejJkZjhGeUJTZ0NwZEJuU1ZNbWdDYlE2UHhyQXF1S3NtQjVBWmdHWmpyL3BvSFowT2NNdFZwencvYUJrWkdSMFhrb1lRREx5R2lOY3B3TEFBZTRCTGc0dG53SW1BUUtIZS93aVNaVHlyYkt2b1FQWDFQQXljNi9aeVBMdGRveVJrWkdSa2E1WkFETHlFZ254N0dBeTRFWEF0Zml3OU1sK0NCMU1WQU9lVzgxSUcyR2ZaWWVlQVh3OVRqd0tMWGFORVpHUmtaR1hSbkFNaklDY0p6OXdJdEMvd0tvcW5ZODhrSkpQNzQ3eVQ0RlBBWThHdnA4Z2xxdGpwR1JrZEY1S0FOWVJ1ZWZIT2NJOEhMZ09ucEFkYUJqSFNabzJlNTJEMyttS3dDdUI0SDd6V3lYa1pIUitTQURXRVk3VzQ0ekF0d0l2S0x6N3haZ2Y4ZTYxUUJ5dnRwcndQMmhmNDlUcTdrWUdSa1o3U0Fad0RMYVdYS2N3L1JnNmhYQTlmaS93QnNtd0REMjZISWQrRFkrYkQwQWZJdGFiUTRqSXlPamJTd0RXRWJiVzQ2ekQzZ2Q4SHJndTRERElldXdBSVN4OTI5L0F2Z3k4QlhnUG1xMUJrWkdSa2JiU0Fhd2pMYVhIS2VBZjV2djljQWJnSmNDVnNoam1LRmhwOW8zdXEwRzhFMTgyUG9LdGRvSmpJeU1qSVpjQnJDTWhsK080K0FEMWV1Qjd3WjJ4VHkyR2pDTWZYUHRaNEN2QVY4RnZrNnRObytSa1pIUmtNa0FsdEh3eVhFRS9xLzhmZ0Q0SHVBYWplZXdBb0N4YjU3ZEE3NEYzQWw4bGxydExFWkdSa1pESUFOWVJzTWhINnB1QnQ0T3ZJMW9MbFZZdzNhQk4vYmhzVXY4UjBIY2hROWJ6Mk5rWkdTMFJUS0FaYlMxY3B3QXFuNFEvd25wS2czelJYMnI3TVBVbDJHMUh3UHV4b2V0MHhnWkdSbHRvZ3hnR1cyK0hPY20vRm1xdCtHL2VrYWxZYjFvRy92MnREOENmQTY0ZzFydERFWkdSa1liTEFOWVJwc2p4N2tjK0hIZ25jQ2xLWjdEZW9FMjlwMWhkNEY3Z1g4RXZraXQxc1RJeU1ob0EyUUF5MmpqNURnbDRDM0F2d0plQXdpTjV6QmRnSTM5L0xFdjRlZHJmWkphN1ZHTWpJeU1CaWdEV0VhRGwrTmNqUTlWN3diMmFieUc5YUs3SHZzdzljWFkrN00vQmZ3VC9pM0VXWXlNakl6V0tRTllSb09SLzg2L3QrR0QxWGRvdklidG9tcnNPOHMraUZodDRPdkFKNEd2VWF1WkFkTEl5R2hOTW9CbHRENDV6b3VCbndSK2hPUURRQU1OeXdYWTJJMjlIL3RwNEtQQXA2blY2aGdaR1JuMUlRTllSbXVUNDd3QmVCOSticFZLdzNDQk5IWmpINFI5R2ZnMDhESHpiQzBqSTZPOE1vQmxsRjkrMHZvN2dYOEx2RkRoc1JVWHhjMXN5OWpQYjd1SC8zcWVqMUdyUFlpUmtaRlJpZ3hnR1dYTGNTYUJud2IrRFhCaHpMclZGejFqMzFyN01QVmxNKzFQQUg4UGZJRmFyWTJSa1pGUlRBYXdqUFJ5bkV1Qlg4Qi9mdFZZekRxTUZ6MWpOL2JOdHMvZzUybDlrbHF0Z1pHUmtWRkhCckNNa25LY2x3Sy9qUC82R2p0a0djWUwzTTZ3bDZTZzVBa0tnQzBGQlFrMm5jL1lPZ2hjUE5wQzBoYkJaMmVaM25Lcjh6a00yN2Z6N2ZQMFFHc1ZJeU9qODE0R3NJeDY4bjhSK0Z2QW0wT2x3M0lCMjE3MkNkZGlUOXRtMHJVWjlTeEdQSXRxNTk5STUxL0ZzNmg2Tm1WcFVaQWlWRnUxcE80RkFFTHYzMGF5WXJWWnNkekl2N3JWcHQ3NVhMWmNGdXcyMDRVR3E1WVhpelNjKzNkNDdRdkF4ekNnWldSMDNzc0FsbEh3WU5EL2dQL1NaY0h3WGJTR3p6N2gydXhwMit4dDIreDJiWGEzQyt4MmJYYTVCWGExYllvSTRxZFdOaXpKbkg0ZGlmNzhwVHBLcE9XRzViSmd0NWkzbTh6YkxlYnNCck9GRnJOMjB3QllYL1lGNE9QNG9MV0NrWkhSZVNjRFdPZXovUGNEL2lid0x2eGJnVnQ5VVJvKys3Z3J1TEJWNUZDcnlNRldnUU90SXZ2YkJjcWUxZk5LbVVGU2xRMGJWQ2xqQ0xWbjNXcHp0bERuK2VJS3AwcDFuaTNWbWJOYnNkckQ4LzF0alQyOHZBRDhBL0FwQTFwR1J1ZVhER0NkajNLY2k0RmZCMzRNS0lRc3czS0Iybng3VVFvdWJoWTQxQ3B3c0ZYZ2dsYVJBNjBpVmM4Q1JRUmdEYkFUWGRvdVVKVVZ2MjYxT1Z1c2M2WlE3MERYc2dLNndzdkQ5LzF2dkgySjNxM0RGa1pHUmp0ZUJyRE9Kem5PUWVEWDhKKzhYdTZVRHNzRmFIUHRrNjdOWlkwaWx6YUtPTTBTaDFwRmJDa1NOUkpSMWdsVnVldjJQU3VXZmlMSGV4MEZSWjJYdm42d0ZyMmgzRnVxV3kzT0ZlczhYNnh6dXJqY21lbHFLbG9menVOajQrem5nTDhFdm1wZXcyTmt0TE5sQU90OGtPTlVnVjhGZmdtb01ud1huWTIxVzhEaFpvRkxHNlV1VU8xeXc3K096QWRWS3I5cytPa1B5RFovdGlvTDVOUlFsUmxmRWMySHJtWE9GSmM1WFF4dUx6WVV0WWYzV0JxTUhmem5hUDBGdGRxakdCa1o3VWdad05ycGNwd2ZCdDRQWEJRcUhjYUx6bUR0QjFzRnJsa3BjOVZxQ2FkWm9pZ2o5NzhTTlJKbDUxRmUxY0RpSytySkRKQmJ0aG84WFo3amlmSXN4eXVMdElUSDJyNy9mbnkzMmg1ZXZnZjRrSGtGajVIUnpwTUJySjBxeDNrSjhJZkFLenNsVzMxUjJWajdpQWRYcmZwQWRXUzFuSmloSWxGRHM3NEJ0d0MzSzFSSndyY0Exd0pWbWIyTHJMV0Z5M09sZVo0c3ovSm9aWTRGdTBYZTczLzQ3V24xWE9CTzRLUFVha3NZR1JudENCbkEybWx5blAzQWZ3TGVDMWdNendWbXNIWUJYTndzY3ZWS2thT3JaUzV1bG9pbW8wZVZDakxuUVY2Vk9uNnlOQXBWYWZWamEydUVLblhQL0cwL1Yxam1xZklNajFWbU9WVmExdmdQNC9HNTFuckwrSy9mdWNPOGZzZklhUHZMQU5aT2tlTVVnSCtOLzlpRlhaM1NZYnJvREFhcWpxeVd1TDVlNXRxVkNxTmVHbExsZ3lxVlh6Yjg5QWRrT3ptdkt1c1dZRit4VXJaN3lWN2xtZElzeHl1ekhDL1BoNTVRUHl6SDZpRGpuZ0wrajhuUE1qTGEzaktBdFJQa09OOE4vRGZnbWs3SnNGeDAxbThYd0JXckpWNVNML09DOVVJVjlBVTcyd3Vxc3ZxNHh2aGJDRlhLMjVaQzBzYmx1ZEljSjhxelBGcVpZU2x5S3pIZXpuWUVyR0Q1UzhCZlU2c3RZbVJrdE8xa0FHczd5My9zd2g4QmIyVllBV2t0ZG9IazhrYVI2K3NWWHJoU1ljeE5oNnA0cE1UNkp1ZFY1ZlUvSC9LcTFHdnBnMDVpaGszSTdxNk53NTBFcGdxTFBGMmU1ckhLREtlTDlWQjcyeEdxNG1XTCtKRDFaWXlNakxhVkRHQnRWem5PZTREZkJTWTdKY01EU0d1MU84MGlOeTVYZU9GS21mR1VKSFZWeEVTWnlhdUtsT2x1QWFhQzBBYmtWZW1rdHNsWVA2TDlGb3A2cy9ZeXg2cW5lS0I2am9ZSTV6R3Q5L2hjYTcxQjJSOEgvcHhhN1RSR1JrYmJRZ2F3dHBzYzUxTGdUNEhYc0RWUU5OaTJxcDdnaHVVUmJscXVjTEJWSkV0NW9FcmxsdzAvL1FHWnlhdktHYXRQcUFwbXE5TGhMcnVkdG5BNVhqN0RmYU9uT1YxY2p0Vlp5N0hlVDcyTnNyZUFUMk9lQm05a3RDMWtBR3U3eUhFczRQOENmZ3NZN1pRTzArRGZuLzNLUm9tYmwveGJnQVhGTTZyQ3lvUVk4OHFhaVBmNmJnRnVIVlNwK2hGNHEyYXIxUEdTUFR0WG5PZll5Q2tlSERsSFc4aVFaYnNCVnJCOEZ2aExhcldITVRJeUdsb1p3Tm9PY3B4cmdQOFB1Sm10SDl6WGJoOXpMVzVlcm5EajhnajcydUYzSUtxbHYzUmk4cXBpM2pzcHJ5cFl5ZzlWdmJwcDM5YXExZUtKeXZQY1Z6M0ZkR0UxNXJQZTQ3NGYzMEhadndqOExiVmErR240UmtaR1F5SURXTU1zeHlrQ3Y0ei8vc0RnOXRtd0RPNzU3VmV0bG5qNTBnalhyRmF3TW82M1ZEZ3llVldSc3JYa1ZVRVNhTllLVlg1SkdsQ21nTkNHUUZWOFRSTkp3T25pREErT25PTFJrV2s4WktKZWNubFk3V2VCMjZuVlRtQmtaRFJVTW9BMXJIS2M2NEUvQTE3VUtkbnFnYncvdXkzaHBmVUt0eTVXTTNPcjhrQ1Z5aThiZnZvRE1wTlhsVE5XbjFBMXFMd3FkYjM0bXU0N0RMVVVPcWJxMWlxUFYwNXpYL1VVQzZrdm94Nk84MHE5N0FGM0FKOHlEeWcxTWhvZUdjQWFOam1PQUg0Ty8ybnMyMi9XYXNTRFZ5eFZlY1ZTbFlrK1hsZVRLRE41VlJGdmsxZVYxVWZkbnV2MVI5WHo0SCtKeDdPbEtiNWRmWTdqNVZsRmpPRTV4L1QyWjRFUFVLdWR3c2pJYU10bEFHdVk1RGdIZ1A4RnZMWlRNa3lEZDdwOVQ5dm1WWXRWYmx5dVVrcEpXdGRmT3RsNWVWV1FtSzNhUEtqSzFidU10ZlRCWVJqeXF0S2hTbDBucXorTDlqS1BWSjdqdnRIVG9VYzliUDA1bHMvZUJqNEJmSTVhelF6dVJrWmJLQU5Zd3lMSGVSMCtYTzBMbFE3YjRKMWNkcHBGYmx1bzhvS1ZFZTI3QUZQaHlPUlZSY3BNWGxWVy85T2h5dTlILzFBVkxmR1hHcUxKdDZwUDg4M1JVN1NGcTRnM3ZPY2xQQWw4a0ZwdEJpTWpveTJSQWF5dGx1T1U4RzhIL2l6eDErd094MEN0THJ1MFVlUU44Mk5jMFNpalVoNm9VdmxsdzA5L1FHYnlxbkxHNmhPcTh1UlZxVUJtTS9LcVZQV3lvRXBuQno5UDY3N1JFenhRZlQ2V0VEOTg1MlYwZVJYNENMWGFmUmdaR1cyNkRHQnRwUnpuS1BBQjRNV2gwbUVabk5YMnc4MENiNWdmNDZyVkNuRmxRb3pKcTRwNG03eXFyRDZ1TDYrcUI2NXF5TlAxdFJjamFsdTBsL25tNkpNY0d6bXI2Ty93bktOSisxZUJ2emNKOEVaR215c0RXRnNsLzFVM3Z3ZFVHZTdCMlY4KzJDcncrdmx4WHJpU0RWYURoS3JNK0xGMjh2b1BTMTVWQ2NHSWhCRUVGUVFGUmRUVWIwd2tXNVA0dnl0YlJiS0N4NHFRTkRYUWtOWHZuWkpYRlMzSjZsZDYvTG5DQWw4ZlBjNFRsV21sejNDZXd5ZnhFK0ROTFVNam8wMlNBYXpObHVPTUFYOENmSCtvZEtzSFg3MTlYOXZtOWZOalhGZXZSaVpzVXVISTVGVlI3b0JUQlVFVndRaFFrWUlLSFppU2doRkVOMjh0cldkNXQwTVhRd0l1c0NvOFZwQ3NDT2wvZHVCckJZOTZwN3dWKy81M1dsNlZQa1o2L0VSOUlUbFhtT1dmeDQ3elRHaytaTi9xOHpiTmR3WC94ZEVQWVdSa3RPRXlnTFdaY3B3cmdROEQxN0QxQTNHNmZYZmI0blVMNDd5MFBvTFZ1Y3JtZ2FwTVArVjZmMEEyREhsVk5qQXBCWHNRVEhSZ2FRUVlrWUp5Q0p5MDI1QmhXeTlVOVJlN0p6ZUFyd0RHOEpnWEx0UENaVjU0eXI2a1FaVnVTZitkaDd3M01LOHFxOTg2cUVMMitoWE1ScDR1bnVOclk4YzVYVnhDdFkzUjVXR3dmeEg0SjJvMUR5TWpvdzJUQWF6Tmt1TzhIdmpmd0s1T3lYQU92bVVwZU8zOEdLOWNHcU1nUlRiRW5BZDVWUlk5bU5vakxYWjNvTXJTOVRXbFgvMlVaMi9EK3NwMWNLUGVGOUJHTWljOFpuR1pFUzR6b3MyOGNETlFLczlXOVFkVjZpZ3lCYnJDTWRZQVZhRjYwWitoUkdIdFpPbDV2aloybktuQ1NzSStUT2U0cjZlQkQxR3JMV0JrWkxRaE1vQzEwZklmSFBydmdGOEg3VTIyNFJoOFg3WTh3aHZtSjVodzdaUy8rOW5SZVZVMmtra3AySTNGSGluWWpXQ1hGSEhXR0FqZzZNclhjZ3RRcCt6OWxnNVZXVEZjSkhQQ1paWTJNNTJacmdYUlR1enBkS2hLYjBVUFRvUExxNHJZdTBsbkt1QlRyL2ZPTUplbnlxZjQydGdKNXUxVlJiMWhBU3lBSmZ4YmhzY3hNaklhdUF4Z2JhUWNaeFQ0bjhEM2RVcUdhWER0TFYvU0xQRG0yVWtPTjB2RTFidndEaDZxbEdXYm1GZGxDOWpkZ2FnQXBpWVVNSlhXbjdXVXEyeWJkUXN3WHFJRHE3N0JMS1IyRExwbVJKc0Y0U2EyY1JqenF0WUNWVkVmLzlNVkxzZkxOZjU1N0dtV3JWYkNybC9lYkxzRTdxQlcreUpHUmtZRGxRR3NqWkxqWEFIOEZkRjhxK0VhWENkY2l6Zk83ZUlsOVdxazczR29pdGZVbGFrdU9IbUJiTE51QWU1R2NKRzB1RWd6TTVXcnJ5bmwvZFFadGx1QTJWQ2xpQkVxalQvRkxlelhSbkpHTkRsbE5UbGx0VmpGUzNqbGdhck55cXVLeDgwRFZhcTIycUxOdDZ2SHVXZTBwb2d3VE9QQy9jREhxZFhDRDFRMU1qSmFod3hnYllUOGZLcy93OCszV3UvZzE0OXZQbnRCQ2w2MU9NcHRpK09VUFN2aHZaUHlxaXpnUUFCVm5XVDBMQTBDbnRMS2gra1c0SnJBcks5K3FiRmlSclE0YlRWNVRqU1o3endsZmRqeXF0U2wyVkNsNnNkMFlaYlBUVHpFdWNLeUl2NHdBQmI0ZVZrZnBsYXJZMlJrdEc0WndCcTBIT2Q5UlBPdGhtWHc5SmV2V2kzemx0bmQ3RzBYQmdwVktyODBxTXJydnhhb0tnSVhkbWFwRGtxcis4cnNMQTBDbm5TMnJiZ0ZHUDErQnhBalpFbWJyVXFybXl5WExBdVAwNkxKS2F2QldkSEUxWGdtWS9mUmczWGtWZWxnU25TWDAvb2h1L3ZLRXk3SFJvN3p6MlBQRFBFVDRhZnhrOStuTURJeVdwY01ZQTFLamxNQS9odnc3azdKY0EyZUk1N0ZtK1ltdUdGNXJPZTFnL0txcWdnT1M4R0ZXT3lYUXZ0ZXhNeStacFQzVTJjamJ3R200VnJ2K3gxQWpGRHBlcUJLNWF0YWF5RTVZelU2d05Xa2dSZXIyV2NQdEhsVmNWOGRya2R0SXVLbkE3TzBQUzJaSzh6eitmR0hlTDY0cU8ySHF2M05zNjhDZjBPdGRnSWpJNk0xeXdEV0lPUTRJOENmQTY4TGxRNFBZTDI0UHNLYjUzWXo1dG83S3E5cU1wUlBOU216Yi8ybHRaMWxHd2FvVXBmMUIxVzVZb1JLMDZGS1h6Zk5OMSsvL0QwNUkxcWNzaG84Snhvc2lIYkNPdzlVRFRxdlN0WHI1TzFHOVhrWitIbkM0OUhLazN4MTdDbGNrY3hIMi9weHd3VStUYTEyTDBaR1JtdVNBYXoxeW5IMkFYOE4zTUJ3L1BYWld4NTNMZDQ2TzhrTFZrWjNSRjZWQUE1SXdVVllYQ2o5SjZUM28wRUFqczQyVEhsVmE0b1I4eHZrTGNCQjlhc3UycHdVcXh5M1ZxaUwySHYxWXJjQU55T3ZLajJIS3dsVnZtTm9HVml3RnZqUytER2VMUzFvNjIvdHVISVBjQ2UxbXJsUUdCbjFLUU5ZNjVIalhBcjhIWEI1cDJSNEJzY2JsNnU4Y1c0M1ZXbXRHYXBVZm1sUWxkZS8zNW1xRW5DRnRMaENXaHNPVmYzVTJkeThxbDZwRHF6V0NpOUIyV2JjQWx4THYxUkx6MXNOVGxqTG5MSWFYYWhLYnlYZWhocW0rczJyMHNkU25KY2lXajlZbGtpZXFEekZsOGVlcEMzY2FCM3Q4bWJhandNZnBWWnJZV1JrbEZzR3NOWXF4M2tKL3N6VnZsRHAxZ1BXcEd2ekF6TzdPZG9ZeVFrN2FVc3BkVGNocjJvUGdpUFN3cEZXN3B3cVhYL1N5dnVwTSt5M0FIT0JXYWcwRDFUcDQ2NGZxdEo5MDJPQ1pGbTRQR1hWZWNxdWR4NzlvQWFuWkJRVlZPbDdrNVZYMVZ1S25hT0NpQzM1aThpZS83SzF6SmZIai9GTWFVNGJmK3ZHbU9lQWoxQ3JoUitlYW1Sa2xDSURXR3VSNDd3R3VCMFlaVGdHUDE4M0xJL3dwcms5bEdVVVI5SXZkdXJMaXE1c28vT3FCSEN4dERpQ3hkNGh5YXZ5eTlMUVpYMzk2UmVxMWhRalZLcUNxcWl2L2p0T2x2Y0RWdjFEbFNwR2R4dEMrOFZEY2txczhxUzl4RG5SVElXcThISWVxTXFiVnhXeHgyYXJkRkFWTGhINHMxa255alcrTlA0NHpjUnNWdGE0MEkvdld1em44Si84dm9TUmtWR21ER0QxSzhkNUovNnZCUXVka3EwSHJMSVVmUC9NSHE1YkdWWFdTcFlORjFSSllBVEJsZExpY21sUjBkYk8xLzVheWxVMjgyZ0ZYVnY5UUZWMnYvTEZsQW1vMGtWZW9NMVQ5aEpQVzNWYXlKQjlMVkFWOWxWQWxTS3ZLbjRMVUI5REgzL0ZXdVpyWXcveFpIbEdhZCs2Y1djT2Z5WnJEaU1qbzFRWndPcEhqdlB6d0c4d0RGRFY3Vk96eUE5TjcyT1BXOHg5QWN1K0lMSUJlVlhxcGYyZDI0Q0hwWlU3dTJvUThLUXJONDlXU1BmTjM2ODh4MDgyVkhVVmJJZ0krK3JiQUltTDVLUlY1NFMxeEt4b0tiN2JLREN0SjY5SzdhZUtvWSt2QXJobnlpZjUwdGhqckZwdFRSMTEvWTIxTCtORGxubFdscEZSaWd4ZzVaWGovREx3eTUyMXJRY3NBZHkyTU1GckZpYXhZMWRsMVdVckhiNDYycVQzQU5yQUpWZ2NrVmJ1eHlzTUFwN1N5b2ZwRm1DdTc2cFBxSXI2cG9OVlhnQks4OGdMVmFvWTZmc2xYNlI0ekZuUjVDbHJtWnBWeCsyOHBtY3o4cXJDYXlMaWxSUGdnRlZyaGErT2Zac1Q1Wm1Ndm03bUdMU0NuL2grR2lNakk2VU1ZT1dSNC93NjhQT2hrcTBkM0NaY2kzZk03T1B5eG9peVJsOVFCWnYySHNCUklUamlXVndtTFpLdmxVNkx0LzV5bFcxTGJ3RnVRRjVWZW95OFVKVzF0aGFveWw3cmdtR09XNEQ1MmxlWHQzQTViaTN5aEwwWXUzMFlyNk00TDllUVY2V3paVUZWZk5sRGNxejZDUGVNMWxKOE54T3dKTkFDL29GYTdSbU1qSXdTTW9DVkpjZjVMZUJuMlB6QlMyMi9abVdFSDVqZHg2aG54enlIRTZvUXNGc0tYaWd0RHVXOERUZ0llTktWYjlkSEsraDh0L3N0d0FoVWhVZ3gvajNsZzgzc3RhQ3NpY3ZqOWdMSHJjWE9hMnRDYlc1UVhsVy9VT1h2anVpczE3T2w1N2g3NHVFaGVweERHLytCcEU5Z1pHUVVrUUVzblJ4SEFQOEYrUEZPeVZZTVhyMWxnZVNOYzd0NXhkS2swaS9YeFg2VDhxcjh0bUFVd1lzOGkwdGs5a01XQmdFNHV2SmhmN1JDcmhpaDBzRTlYVDBMWXZRZWE0V3F5TGV4aHJ5cXJCYnk3b2VnRnl1MGVkU2U1MmxyS1FwWWlSaHB3QlJVVTkwQ0RKZGtqd0hKV01rNjgvWThkKzI2bnpsN1ZXbFBpNzh4ZGduY1JhMzJNRVpHUmwwWndGTEpoNnZmQlg0MFZMcFZneGVNZWhidm5ON1BaWTFxcER6ZmhacStacXZXbWxmbHQrTi9sSkJjNjlrY2tYYm04NnNHQVRnNjJ6RGxWYTBwUnFoMG8vS3FzdnZWUDFTcFlxVERacjVJK2ZxVmp0TzZZMlJKdEhqVW51T2tWV2N6OHFwVThmb0J0S2JWNE10akQvRDAwT1JsU2VBT2FyWEhNREl5QWd4Z0plVTRGdjVqR0g2SVlmanI4S0ptaVhkTlg4Q2tXMGg0cVdwMnRZbTNBQU5aU0k1S20yczhPelhIYXBpZ3FwOTJjMTM4Qi9ob2hld1kvZFRWNFVtNk5RL1U2ZGE2WUtpRXpmUzZneWxYdGFRL25nVXdKeG84WXM5eTJsb0orYWppNjgvaDlkd0NUSTBsWk1MMjdaR0h1WGYwWkVwYm16bUdlZmlRWlc0WEdobGhBQ3NxeDdHQi93Rzh0Vk95dFlEMTB2b29iNTdkVDBGeGhSb1dxQXBLTDVFV0wvWnM3YXRzQmdGUHV2Smh2d1dZaG53cTMrMzhkUFhJNHc0U3R3RFQ2MlljZGRxMTlVSlZzbCtTV1d1Vmgrd1pwa1JqMDZFcUVrMmt0eW1BazZWbitkejRJME9TbCtVQm42RldPNEdSMFhrdUExaUJmTGo2RStCTmJNMWZmNzFsUDk5cUR5K1A1RnVsUTVYS3ZqYW8waTBSQW9uZTVlcWd0TGhPMnV6T0M0RVp0djdBSncxZDhwZXJiT3VGcXBRWVVzS3NWZUNzVlJUbjdDTG5SSkZ6ZHBGem5mVVZZZlZha0wyV2dwZEtpazZaNklUc0xZTUFXWkllKzkwVys5MlczTysyTzU4dDluc3RPZWE1ZW1USkMxWEprdlhuVmFWNTVZT3FXRCswSmVweWxaOEV6bG5MUEdUUE1pZWFvVmFscHA3NnZBN1cwdktxSXA1Q0gxT1hiRDl2ejNQWHhQMHMyQTF0L00wYjExeDh5SG9hSTZQeldBYXdBam5PN3dIdllxc0hwNm9uZU9mMEJhRjhxM1N3eW5kaHp3TlcrYUFxV0pxVWd1dWx6VUZGQXZzZzRFbG5HL0tucTgrSUFzL1paUitlckNKbjdhSThaeFhGV2F2SWxGWGtuRjBVMDFhQk5pSUNSa0dnTGlnRmwxcmluMUUvcFkrVTZuS1E1UTU4N1hOYmNsOEh2dnpsRnZ1OXR0em50ampZYXNvUjZTVzNMaFdxRW43WmtOUnYrWHFnU2hjaC9vQlJudzNqMkNRNWJTM3pzRDNEVXVLQnBXa3cxR2ZpZTJLMkt1cVhsUmZXRUt0OGVmeGIxRXF6dWZxM3NYWVAvOWVGTll5TXpsTVp3QUp3blA4SC8xRU1zSldBZFdHcnhMdW1EekxaVmorVmZTdHZBUWEyS29JWGVUYVh4aDY1TUFoNDBwVVA2ZFBWWjZ3Q0R4Wkd4WU9GS3NlS294d3JWc1h6VnFsVFF3czVzWWh5VFZBVnJPZUJxbWdkMlcxTDNZN0FRdUswR3ZLcTFvcThxckVpcjI3V3ZhdWFLM0pFZW9xOEt0bUxzTjY4S3AyWEdvdmlKZXBZdWx1QWNhaUNKRmpGSTBza0o2MEZIckpuYUdodXgrbWhLaHdyRGFxaWZ2bWV0eVZEUzVKdlZ4L20vdXF6MnJpYk44YTV3RDlScXoySGtkRjVLQU5ZanZPendMOW44d2VmNlBMVnF5TzhmZVlnSlM4Mkl6UUVVQVZRQks3MWJJNUtHenVsL2JTKzlWTStaSGxWTTZJRFU4VXF4d28rVEoyeVN4RW82Z2VxSXVWYTJGRkRWYlN1MUVLVjZGeWh3MUFWanhGQWxZanRrTGl2aGVUaVZsTmUxVnp4ampicjhxcm1xanphV3ZHcXJwZUdTOUdTZmhBckQxU3BTdE9nU3RWbUZsVEZleWlCbG1oenpKNmlaaTExSXc4NnJ5cGFJeDJxVkcyZExEM0w1OGNmd1JXZTBwNHMyeWg3QzM4bXl6engzZWk4MC9rTldJN3pJOEQ3TzJ0YkIxZ3ZXeDduKytZT1lBWFRBbHVjVnhYWEVXbnpRcytpM0UzN3lXb3JYN25LTmdSNVZiT2htYWtIUXpEVjlVcUFTZytHK29HcXVGOC9VSldzbXgrcUFyOUVPeW0raWZJT0ZCNXVON3lqelZWNXRMSGlIVzJ1eUNQTkZXL1U4ektQdXB4UTVaZm1QMGJVVUpWMUMxRGZVNW40UDJ3NWF5M3hMZnNzZGVIRzdBb1FXa05lVmR3L0M2cmlaWFAySEhkUDNNK2kzZFRVU2E4L09Ic2JmeWJyREVaRzU1SE9YOEJ5bk84RC9oaXcyTXJCNTdzWDluRGJ3bDUvZGRObnE5SkJiaFM0eFN0d1FGcmFsdm9CSEgxYi9VRlZmN0gxWGgxYlMxaDh0VGdoN2lwUDh2blNMdkdzWGNvQkh3cm9JQXBaZWFCS0ZVdnBrK01XWUI2b2lzOVc5UU5WTXVZdk9rODdqOWU5cXJIaTNiS3k2TDJpdnVoZTNsenR6YUFNR3Fwa3QyTkpzRkpCbGJxOWVMbDZYV2tWL3F0M0hyYlA4YlMxb083ck92T3FvcENZRFZqeDNqZkZLbDhlZjRDVHBUbEZIWFcvTnNhK0NueVNXaTNjRHlPakhhM3pFN0FjNXpiZ2RsRGU3TnFjd2NjQzNqcTduNWZVZHlVOFZKRjZaZXVGS3Axbk5QNFYwdVlsWG9GQ3puNWwyZkpDVlQ4eDBzb3pMcVR6b3NqZDVWM2lydklrWHlqdEV2WHdML2M2NmdlcW9uVTNKNjlLTlZ1VkI2cmkvZW9IcWpwK01sNFh6WFplMEc3S20xYVczSmZYRjkzclZwZmRRakRlcUw2ZlBNZDdQMUFWYk5TZ29VclYxeW14elAzMkdlcWluZXNXWUQ5NVZmcFlZWENNMjN2cm5uQzV2M3FNWXlQUGEyTnR6aGk0aEE5WmRZeU16Z09kZjREbE9EY0NId0pHMk56QnBWZFdrb0ozVGgvaWlzWm9vbjliQ1ZVQUZRUTNlUVV1M0tCZkIyN2hMY0NhWGVITzhxUzRzelRKTjRyandndHV5TVlxblM5NVZhcmJoWG1nS3JJTmViYXpFMnZVOCtSTFZwZmNXK3FMN2szMUpXL2NjNzJ3blo1L2ZxaUtLNEFPM2JHZ1d0S2ZRK2xRRmZXVXVIZzhhcC9qU1hzK1lSdEVYbFh3djFEMlcvMFpqbm1zK2dqM1ZaOU5qWi9WL3ZydE0vaTNDMXNZR2Uxd25WK0E1VGpYQUg4RFRIUktOaCt3eGwyTEg1MitpRU90aXJKR3J5d0xxblJMSkM1dDZ2aEp5OFhTNGthdjBNMjEwdFZOSzFmWnR1TFJDb0NVOEVCeGpEdEx1OFZkNVVueGVHRkVEemxKb09pdWI2ZThxamhZOVp0WEZmUFJRbFhtZHVyYmxRQzJoS3NiSzk3TjlVWDM1dnFpZTFHekdmd3FMeW8xS3VXOUJiZ0dxQkt5Vnh5NlpTOVF4VkFmalRPaXpnT0ZNeXlKWnN3dk9UYjBtMWVWQjZxQ3VLcmJpazlVanZPMXNSTUovODJGcnVlQXU2blZ6cU9MajlINXFQTUhzQnpuQVBBSjRHQ25aUE1IbC8zdEl1K2VPc3lrVzB4NDlEeXp3RXB6Q2NtUlY2V0tMNEV5Y0lOWDRCSnBhK3VseFZTVmI5R2pGUnBZZkxrMEllNHM3ZWF1OHFTWXN2eGRuUytwV3dFZHhHNkY1WUFxVlN5bFR6OTVWWjJtKzdrRk9NaThxaFJnaXZSUDR4T05HZnYrQkhCUnErbTlyTDdvZnVmU1F2dks1cXFuT0U0M0w2OHFPSHJWVUJXdnIvWnc4WGpDbnVJSmV6WUJPZXZOcS9LWDF3WnJVa2hxcFdmNHd2amoydTNZZU1DU3dKUFVhbC9GeUdnSDYvd0FMTWVwQUI4QnJtTnpCbzlrMlFXdEV1K1p1cGhSTDVuVnRKbTNBT05RamRLbEFBQWdBRWxFUVZRNktDMXU5Z3FNSks3Uml2WnlsQS9xRnFBNnRycEV3c09GS3JlUFhDQStVZGtyZWs5Q1YwQk9IMUFWcmJ1OThxcDY3V1pEVlNlbTdOVUpLUWVvaGRHa0g2anF4cElnQklqT3NYTkZjOVY3M2NKYzYxV0w4NjFTeHg1dWgzeDVWZkd5ZkZDbGlxbTJxbVBIL2VaRm5RY0t6N01nbWdvQVVrRlNHQnp6UTVVYTFoVCtuVy9pZFBFNVBqdnhNRjRPS05zNCs0UFVhdC9DeUdpSGF1Y0RsdU1JNEkrQWY5RXAyWHpBT3RRcThTK25McVlhZ3F1dGdDcEo3d3BiUVBJU3I4Z1Ywazc0NldMcWJGdHhDMUJDRzhHbnkzdkU3ZFVENHB2RmNTQUZjaUlRa0IrcUl1VjVZRU1YY3lCNVZlbmJwZXRYSHFpS3hPNFRxdUl4KzRFcVpQUlYwT0Y0VmRlVnIxcGFhTDkrWWJaMXVOVjBNd0FvdXFROWg0SmJnQ0xxMWM4dHdDeW9pdHM4SkUvYVV6eG1UOGZxcXFBcWFVLzZwMEdWd2wvemlJaHpoVFBjTlhHTXR2QlM2MmZGWDUvOUhtcTE0eGdaN1VDZEQ0RDFpOERQaFVvMkY3QXViSlo1OTdRUFYxdVJWNlc2ZU95WEZqZDdSY1lTMSt0K3dHY3pvYXBYS3VHY1ZlUkRJd2ZFWDQ3c0YyZXRVaC93RVlVT0ZKOHFxSXI3YlVoZVZhZnBQTE5WYTNtMFFoNm95dHpPRktpS2JuZTNxL3EreFk2ZktNUW05KysxSy9YMjZ4Ym5XamN2TDdYczVDOFJNNkFxMHZ2MVFGVjhTZWVyT2djbEMyS1ZCd3FubUJlTmxIN3JQa0dYVjZYMVZ6NGlJbHBuMXA3aGpsM2ZvaW5hS1RIVjhRY3pSa3JnaTlScXB6QXkybUhhMllEbE9HOEMvcENOR3h6UzdZZWJGZDQ5N1ZDT1A1MDk0YTI1S01RdmJRblBvRXdOVmZINEZ2QmlyOEJWc2hDNWVxMFhxdnFKa1ZhZUxJdnNuZnVMWTl3K2NvSDRWSG0zYUFrTGsxZVZEbFV4UHhtdm13Sk1rZjVwZkxSUUZaUkhadVJDdHdERFB1RzZtdjByd3o2VGJsdmV0ampmZXMzQ2ZITi91eFgrRmFMcUhBcjN2cCs4S3IwdEwxVHBZcmg0Zkx0d2ltZXR4VmliU2ZpSnhzMDNCaVdoS2g2N0Y5R25mTW1pdmNCbkp1NWoxV3ByMmtsdmMvMzJObkNYZVVhVzBVN1R6Z1VzeDdrZStDdjhGTzZOSEJ6VWRxZFo1a2VtTDFIQ1ZUNm8wbmtHbGl6WWlkb25wZURsc3NpdXp1TVgwcjcydkdDMUNWRFZGQmFmS084VnQ0OGNFQThXUjlVWDRUNmdLbHIzL01tcmlteEREbEFMbzBrL1VOV05KWW5rVlNWOWduNW85NjlVZ1ZmQVNKWkVYbGRmYm4vM3dsenordnB5TzNiRHI5ZENEeWI2Z2FWOGZubGp5TkJHQlA4L1pVL3prSDJXNkJrUWhTcjFiRlVhVk1YOW91VkJQMVRQNEZxdzUvak1ydnRwZEdleTFHMXQzQmk2Qk54SnJkYkV5R2lIYUdjQ2x1TmNDSHdNMk5jcDJWekF1clF4d3J1bUhVcWhaMGx0RkZRRlY1eTArRmRLaXh1ODVPUEpsWDFKYVV2WHJ5eWIvdktVTE9rc25iTEwvR1hsZ1BpcmtYMWkxdkpUMTlKbXEweGVWZGRIQzFYaHVzcnQxTGZiWDE0VlViRHFCNnJDYlFRemxESlNsOFQyN1d1MXZGY3Z6amRmT3ovWEhQRmtiMVpMUFZ1VkQ2cVN2bnFvNm9GTE5GTGFveU1ra21scmlYc0x6OUtpOTZ0Sk5WU0ZsL3VIS2wvWjd5U2M3MEJXVS9NaWEzM1pvT3huOFc4WDdzQ0xrdEg1cUowSFdJNVR4Zi9GNE5XaDBzMERyTXNiVlg0NEJGZnhJVGF5dTJPWE5qVlVKUzI2aTBmY1UrQW5zaCtWcXVleDU0Y3FYZC82TGRlQlZlaFMvSTNpR1ArcmVsRGNXWm9VbnNnREgxSG9RUEdwZ3FxNDMvbVNWeFhFekFOVjBlM3VkbFhmdHo3enFqcnJDYWlLMkRWUUZlNjg2TURHbU92Szc1MmZiYnh1YnE1WjhnYzJIVlJCOU5qVHc1TXVSaFNnc3M2a3VGL1BXaGNON2kyY1RPUmxSWmREL2RPK2VxZjNHU3hGWjZ2MFkxaTR0L1AyTkovWjlTMWFXNWI0L2ppMTJyY3hNdG9CMmxtQTVmOWk4RStBNzJZckJnZW5XZUZIcHk2bEtPUHZONHhBUktLK2V2aFhRMVhQWHhPL3MxUUVYdUdWT0JUN2xXQ2V0dEo4K3kzUEFWVUFUeFJHK08zUncrSno1VjJpVjlyeFNJR3ErR2MvVUtXS3BmVFpUbmxWcWUxSGo3NStvQ29vMzRpOEt0VXRRR0pncFlBcUFLbUtQOWx1ZTk4M083dDYyOEpDdzQ2T2IrdURxclFZY2UrMFYrTEV6OVcyY0huUWZvNVR5cndzRlZRRnk5SHlBUHJ5UFZ0TFo1T2NLeXh5OThSVHVLSUlGUEJmS1dhSGxndXhjZ3MvajZvTnREci93c3ZoOVhyblg3ai84YjdlUTYxMkVpT2piYTZkQmxnL0JieXZzN1paZjNINW54ZTB5dnpZMUtWVVBEdnBIYi84eFNMMUxQb3ZJdzlVQlJwRmNLdFg2dVpicWRvYjFDM0FOVUVWQlB2a3JGWGt2NDFlSkQ1UzJTY2l2OWNuTVVzVHFxWC9oR0hMcTFLMG8ralhadWRWaGRyTmhLcHVMTW1HNWxYRm9Tb2FRNlpDVmFqdjNjUG9RS3ZsdldsMlp1WGxpNHZOeEd2VUI1OVhGZmFWa1dqeDZHSGZIaFRCVS9ZNUhySFBkclpDRDBEcSt2cXhxUzBzNXUwcUMvWW9pMWFWaGxXbUtjbzBSWW1XS05HeVNyUW8weElsMnFLRUZEYmdLWjZSbFhhMjUvRUpsajFnR1ZqRXo3MEtmeTREYzhBWGdFZUFaNm5WR2hnWmJVUHRITUJ5bkp1QVB5ZjVBdWVOQjZ6ZDdTTHZuYnFNY2JjNEVLZ0tyamo5UUJYNGw1WjkwdUk3M1JLVnhHUkpIb0JiZTNrYXJpbjJ5Ykt3K0grcmg4U2ZWUzhRcTZMSGdhclpxanhRRlNudkIzYmluLzNrVlhXYVRnTWwvWFlsKzdVV3FBclhWVzZudnQxdXpGU29DcTl2WWw1VnVQUEJMY0Q0c1JEYVZ6TGFaeEdxaTd5bzJYVGZPak96Y3YzeWNrc0RJc2x6SXd3K1VhalNlWWRMMDZFcUdiKzNKODZKQmU0dlBrZUxjQjVVRXFwOCtYbFZiV0V4YTQreFlJK3laRmRadGthcFcxVldyRkZXclZHYW92ZGFydVNva055T1hnY2xIcXBYR0dXTmpXbCtPcHRxUkduZ2IrTTU0Q1JRNjN3Ry81NEZUcHIzR2hvTnEzWUdZRG5PZnVEdjZTVzF3MllCMXJocjg5NnB5NWhzbC8zaStLVU45ZENoQWllQnVwWU9zWURJWXhvdmxSWTN1U1dzeURWcTQ2QktYYWFGS29DMkZIeDRaTC80dzdFTHhYU1F2SzZBcXVoNlBxaEsxc2tQVllyMmNrTlZyOCtia0ZlVjBuNC9VQlh1WDJyZkJwaFhGUWFySUc0ZXFJcTNvWWFxTkx1dnkxZFgyMitabnFsZnZiTFM2alNsUDZLejhxclNua21sQTZzSVZBbm9mQit4MlNxb2kxWHVMZFJZRE9WbCtaZ2xtQzFVbVNyc1lzN2V4Ynk5aXlWN0Z5dldPTkVubGlTM0t4ZFl4YjZ3b0c4ZWVmS3gxbXBUajQ2K1hLQ1owWFlUZUJSNE1QVHZVUU5kUnNPZzdROVlqbU1EdHdNM3NSRUFsV2F2ZUJidm5icU0vZTJSaEYwOXZLaWhxdWV2UXlrRnhzUXVweS95aXJ6QUsycmJTdXRYditWOVFsVmd1Nk04S2Y3cjJHRnhvbEJaNDZNVnNxRktGVXZwTTdDOEtnVmc1UEJObTYzcUI2b2lmbW9mTFZRRjVibnpxcnB0S1BkdkpsUjErdGZ0andLcWdIeTNBSFZRbFlqZDI3OWRZTHU2dnRKODYvVE15aVdOUnZUaG1zbHpVQTFWMGZKNHJSU29DdnZIdjRtdXpmZGRFcEpQVnBkNW9saGl2ckNMQldzWGRXc0NWOWlxMHl2V2JyRFIrYUZLN2QvcnE0ZnFsNFh4dHJOR2k3WEFWNUM3bFJVcmJHc0NqK0hEMXJITzUyTUd1b3cyV3pzQnNINEorTW5PMnNaRFZmQlpsSUovT1hVcEY3WEd1dVY1b0NwcVM5YnFCNnJBVHk5OXVWdmlZcWwvVW55T1lYWk5aVmxnMVNtL3J6akdiNDhkdHU0dGphMDVyeXBZTjNsVlNhaFN0SnNKVmQxWWtpQ3ZLaFF0SDFSMTF0ZVpWK1gzTUc5ZVZmZ1dZQnlxSXZVajdTcEJWRjYvdk54ODAvUk0vV0N6MWU1R1NnSlVZT2tmcWhJK1FqVWUrTEZQRjRvOFVxcnllR21FNDhVcXB3dGx3bk5rQTRXcTBLTGFYelgydUoyWkxKV1BHc3lpeS8xQVZieXNpVCtibGNkZloydmpROWV4MEwvSHpYTzNqRFpTMnh1d0hPZFYrTDhhak00RGJUUmdXY0M3cGgwdWIwemtocXJlZFNFZU15OVU5ZXlCMXdpQzczUkw3SkhxSjhYcnZ0cCt5dFZia2dsVkFNL1laZjdyMkdIeDZmSnVFZlpjYTE1VnNKNEhxcUoxdDE5ZUZVMy9zV1ZDU0QrZWtJallqOG02ZFVYSHZxUHpxa0x0NjI0djl2WnhJbmJTNXN1U1V0NDJ2N0R5cHVtWmV0R0xESWJCY1M1ajY3R0lNWnNxcnlvK0hyakFFNlV5ajVSR2VLSlU1VVJ4aEhtcnFJUW9rYWdkYjN2am9DcCtvTG5DUlhZaEt3OHdaYldUMTEvU3k4ZlMrZWNGclhCWkczaWNIbkE5akpucE1ocWd0aTlnK1E4VC9TZ3dFU3JkSE1ENndabkRYTHU2TzlJZkhUZ0pqVjJIV0pBT1ZVSFpibWx4cTFkbUpQYmJ1NjJBcWxpZE9hdkFmeCs5VUh4NFpMOW9kM3dIbFZjVnhNb0RWWXIyY2tOVnI4K3h2S3BVMzJoNUFBdGhtSkd6azhpeisvSE83UmYrNXo3azJYMys1OVJlNFozZGp6ZTlGOWtvZGNFcDBuQ3dZMFJ5V1FnUTFUcld2aWxwNzUvQzNuOE9lOTgwOXY1ejB0bzNSV0hmRlBiK2M3S3dkMXFLYWoyNTcvcUVxc2gya2dJK0NxaUt0eEhhekloUHpKNzJ1aDkxYkFYc0laTysrMXB0OTUxbnppMGVXVjFWSjhMcndDb0NWUUowZVZVbkN5WHVxNHp5WUhtVXg0dFZXcDFmZHVpZ1NxVTRhcTAxcnlyaG95alRqU3BSeUFyYmRHT216dGF2djRzUFdhb1llZVBuc1MwRFh3VStoLy9RMDFtTWpOYW83UWxZamxNRVBnaThpSTBBcURUN3JZdjd1RzN4d2xCSmZxaUtyaWt3SmpHUG9hNTlXTnJjNHBZcEtIMWlNZGRjcHVpRGZyWXFXUDk4ZVpmNDl4T1hpck5XVVFrZHljLzhVQlh2UVI2bzZueUd0aUFQVkNrQW93K29rczhld2oxMkxkNkRMeERlOGN2eHp1NzNvV3A2RDdoMktJZ0trbEtnS3Vicnoyb0ZQVlJEVjlEeDhMNUdTRVMxTHUxOTA5ZytlTW5pNVNjb1gvV1lMRi8xbUxRbUZpTDdiWDE1VmY3L0c1MVhSZEllaFRFRlZJVStaWEFzdkdKaGNlVXRVek5MWmM5TDNoSU0rU1pucXJvOThwZnJ3dUtCU3BWdmxVYzVWaHBqeHU3bFIrYUZLcFZma082dVZoU3FkSEhUZ0NiK0JhcjhYTkVtUHJPWFBxcGtqYkU2Vzd4ZUcvOTJZVjcvckxJc213ZDhHL2c4OEhscXRST0tQaHNaYWJWZEFldmZBKy9xckEwS3FySjlqNnlPOG82Wnl6VURYKy9Lc3hGUUZlZ2FyOGlMdldLb0xYVmYxbHFXMklKc3FBTC9ldktmeHk4V0h4blpKOEsxZEo5aHNGcExYbFd2YmpwVXFXYXJzaExzdSswbytoWDNsYWM2TVBYdGE0Vjc3RnJjWTljaVp5ZWpRVEtBU2NSZ3FCTTVIMVFwN09IMmhOYkhyeTlpZlFFb0hEd2p5MGNmazZXamo4dEs1N013c2FDRnF1aSsyN3E4cW1qTWJublhYd1ZWNGZWZzIzYTMyKzdiemswdlhydGNiM2FqUkZvSmJXd0FWUko0c2xqaHZzb294OHFqbkNpTzRNWTJQUTlZS1gyNkx2NkNwM3hHVm05eDdiTlYrZXY1a09VcGJjbDY2NFd3c0cwVk1uL1ZPRWpRQ2krZkJMNkkvNHl1KzZqVnd1OXROREpLYVBzQmx1TjhCL0Nub1pKQkFWYTZmVSs3eUk5UEhVMDhTSFI5VU5XenAwRlZzUFpTcjhSUkw5OXJiOUxLRlQyS2xtZEFWYXpzbnRJNHZ6SnhxZldjWFlyVVRvTXFpSEpIUDFEbDE5Mmd2Q3FGYnpmbTZZTjREMTZMZCt4YTRUN1lnYW1aM1NTVUE1aTBVTlV0U3k0THpheFhLbFFwZkx2TlJjdTdkS09Fcmd2T1VEbnl1RmM2OG9Tc0hIbGNsbzg4SVF1ZG1hN3U5NXFkVjVVQXBGQlh0RkFWcjZlM2RjdVZFQmFhWDRwQ1ZXZnpPNTN0eHJwaGNYbjFyV2VuRjZ2UzgwTGRsWkZJajVZcWZHVmtnbnZMNDh5R1pxbTZHNVlvVVFPUWp1N0RXeHIyOGZEODNxOGJxbFIrMmZVa2tyYm85OWQ5cXZoNVlDY3NqeDVrclNYV29QeVhnSzhBWHdLK1FxMjJnSkZSVE5zTHNCeG5GLzVMblBlSFNqY2VzSXJTNGlmT1hjbSs5a2dYcW5wZU9wUktBNnY4VUJXc1hlZVZ1TVpMRHVEOURhdkpra2g1dnRtcVFBMWh5ZDhmdThqNlFQV0E4SWlEVXJTU0NxcWluNXVaVnhYZFVwMHZ5MVhjTDd3Uzk2NVhpL2FYYjBGTzcwR3JuTUMwbHJ5cWlJL1NOMml5YitnS3lDaFVQK29UblFHTGJtdnA0cE55OUdWZmw2TTNmZDJ0WHZ1UXhQS2krelVicW9DTnk2dnF0TkhMd0NkMnpQVEdQaG1yZ3hSK0Z0VzQ2M3JmZjI1NjRjVkw5VVkzcityUlVvV3Zqa3p3elFGRFZkQjRlQytvWS9uYjYyTmYvM0NVNWFkYVY4MXlTVHphb2gwcVM0T2pmbUZIVlRmNGRQRWhLMitzalFTdG9EOFA0TVBXbDZqVmFvcHRNRG9QdGQwQTYzZUJOekJvZ01xeXYzM21FcTdxSkxXbm8xRTJWS1hWMW5tOTBDdnh3c2d6cnBMS1c1YllndjZnS2loNXNEZ3Fmbm5pVW5HaVVCSGhLQ0pVS1E5VXhYdVFCNm82bjZFdHlHcFBmYTFTNVZWeFpqL3R1MjdEdmVzMjBmN2FUZEJLWGorVFFkS0JhYlB5cW5MZEFzd0JWWDQzWTMzV1FwZS9iRThzeU5HWDNpdEhYM2FQTi9hU2V6MnJXaCtLdktyd2VnK2taYVFQUWIra0NQdjAraU1sZk5jM1Z0elgva1BUS242ak5NNzBCa09WeWs4SFI2NzJWMzNwY0tUeWk1ZmxxZWZoNFNwbnN1SjExd3RWOGJJbWZrN1dSc0xVV21NOWd3OWJYd2ErUmEyMmpTNnlSb1BVOWdFc3gva2U0UDJkdGMwRHJGc1g5M1ByNGtYRUI0R05ocXBBMTNoRnJ2TktmUUNVRm9weVExVktERmNLL25qc2tQalRzWVBkK1FyVmJOVjJ5cXVTajExSis4NVg0OTcxYXVFZXU0YllMZHlrdG1GZVZmUVdZSmdnZWpIU29TclpmeEdPRWVxVEtMUmw5ZHFINU5pTjkzaGpOOTdqbFE2YzZUcW9acXY2Z2lxL3ZPdmZGMVNKY04xZ1ZROVYrMnZTdXZualh2bTZPNzNTN3RPYVI2SGtBYXUxUWxXMExMcHpaRzhEOEhBVFk4ajZvVXJscDY3bmluYnNsVHI5QW9wcVBRL3NyS0IvZE1Nd2dCYjRyL2Y1ZStCVDVqYmkrYWZ0QVZpT2N3RDRPM3FQWk5oWXFBcVdqNjZPOGJhWkt5T0RXdEszVXhJWm1hVENxNTgxZi8xcXI4ajFYam5aVnFLa2Y2aFMxY21JY2J4UTRWZDJYV1k5Vkt3SzNiaS8zcnlxWkYwOVZNVXVpdW50aEgxZEcvY2JMOFc5OHpiaDNuMGIzc21MRWh1ZTBBN01xMHE5QmFpRXJoaFV5ZmkyOU5ycnJBTlFQbHlUWXpkODB4dS84UnZleUpISHZOQXhrd0NsRUNCMVFhaFRyb1F3a1lTcVhsMUZYbFczNjUxYmdIR29LamJoeFhkN3Bacy83cFl2dTA4V1FwdlQwMXBucTZMQjFBZHJ0Q3dLWHhLMVA4ak9URlplZUZISHorT1hyT2Z2M2Jab292OWxZVnEvOHZxcmJCNCtaRzBVSEEweVZnUDRMUEQzMUdvUFlYUmVhUGdCeTNFRS9zTkVid21WRGdhZzB1eDcyeVYrYk9vcXlwR2s4alN3eW9hcWFJbksxaXM3NGhXNUlRUlgvVUJWWkNsanRpb0Rxc0FmeFc0ZnZVRDg5N0VMTGYveFBYcW9pbjZ1TGErcTh5a0huVmZsM25NRDdiOStxM0EvZHl0eVB2ejROSTF5QXROMnk2dENkRGdvRGxYZGVwbys5d0ZWdmJKb2pPTGVLVGw1MjkzdTdsZmY2UloyejBiT25qNmdLbVFsQVBJZVZIVWpxcUVxRmtzaTRlQ1QwcjdsWTI3cEpmL2tsYXNMQ293SmxRUXRDQkZaVGZqMXlxSjl5b0NxcUo4T3FsUkE1K0pHeHBCb2Q1UHI2NFVxRWJGNnRFV0w3R2RrcGRueUFFMTh2VVh5K1ZoNVkyMldmOXgySFBnNGNDZTEyZ3BHTzFiYkFiRGVBZndhZ3dhb05IdEpDdDU3N2loNzIxV1NKM1lTcXVLUjlHdnBVQlhvQ2xua1JqYzVjNVVXSlZMZU4xUXBZdmc2YVpmNXRWMlhXdmVXUmtVNGNqKzNBUHVCcWlCR0FGYjY5dFRYcXRpc0JOUkhhSC84ZTJuOXhROEo3N0VqcXUxT0tnY3diWXU4cW5pZmlmVTVMMVRGK2lSQzdYVjNXYml2TWFpSzd4c2hKTUoyR1h2Sk45MDlyN21qUFhidE1hL2I5MEhtVmZrRjJsdUE1UlhFOVhkNHhacy83cGFkQjZYNjE3bmRocVByUWVOQ0lrWDhJSXp1R3hYUXFOYWpHNndDcS9SWk10L1dWa0pXTXY1YW9DclpyK2pCSVpHMGhBcDIxUDc5bGFYWjZrUWYzYkJkUUtzTzNBbjhnM25HMXM3VWNBT1c0MXdDZkJpb3NKbUE5ZmFaU3prU2YxTDdCa05Wb0V0bGdadmRpcUtPdWlRdlZPV0tFYlY4dVR3aGZtbnlNbXZSc3FQWFkrS2ZHdGdKZmE0bHJ5cTRLT1pxSjNvQlJUNXpNYTBQdmtPMC8vYk55SVZ4eFFiR2cyUUQwNWJuVlNYdDY4cXJTdHBUOHFwMFVLWDBUZTZiR0lESmNEdWxDNTZYZTE1MWQzdnlPei92RmtZWDR6bFhmVDFhSVF1cUJMRC9HV25kK2lHM2N2MW52RkpsV1Q5YkpWVmw4UU80VTJ6SnlMN1JRMVcwTEJ1cWZMdU1yVWZhVHZpMjhBZy9rRFROUDJ1a1NNNVc2Y1pVWHg3dDBPTWJkUDZEZ0twd1dmeFc0YkNEbHFyc0dQQUo0QXZtVlQwN1I4TUxXSTVqQWJjREwreVViQ3hVQmN1dldqekFkeXdlOWtzaUk1TUtSdnBaUzkvUkVza2xzc0F0N2toa3dJMTdKY3I3bnExS2hhcEFINnJ1Rjc4OWNiSGxpdGoxdWR0cU5sUkJGS3o2Z2Fwb0xNMnR4cml2WitGOThSVTBQL0JEd3YzaUsrUGZYMUk1Z0dsajg2cVM3VVZubFZDVkQwVmVWU3BVcWZhZC94M0tDT1FSOWJHS1RTWnV2TWZkZTl0ZHJlcmxUM2pkYlNSMHpQU1ZWOVZ4N2pSeHhYMWU0VlVmOU1wWGY5a3JoVGFwMjBDbzk5RXlvZlJMbkFDMmY2d25EOWFvbjR5VVJlRWw3Sjg4UTlObW4rSncxeGJobWF5TXN6M1JMOVVMcHZNRGtFc2JWN1NWTm5WWlZ2L3l3RXNELzNaaFh2KzF3dEVnWTZuSzVvSFBBSitrVmp1RjBiYldNQVBXdndSK0xsU1NENURXWTc5cWRZSWZtTDJTNk4rVTZlQVVMVkhaOURzNGJMdFlGbmg1Q0s1U28vY05WYjNTREY4WHdlOU1ITFkrVk4wdndpMWx3azc0czkrOEtxSVFGN1FUWHU4dXkyUmM1c2RwLysxYmFIM3c3Y0tyWFV5cWNnTFQydktxZ2c3cWZMT2dLblJkelhNTE1CWkRTS0xiMWU4dFFBMVVKZllIOGUwT3RaTURxcEw3TitpZjZHN3Z5RVVuNVo1YlA5dmFmY3RYMm5hcG02WWlPN3NwMkYxSTFMTlZRWmRzVi9MaXU3M1NyUi8weW9jZmlkMEdEQjFjOFZNckZhcDBmb0F0WmE5SUJTZ2JDVlZ4LzVhSTN5N1VuLzNyaGFxNHJTMmFlTXJiZHZuNnN6WjRXWUhVWHpNT0VvNEdHVXRWNWdIM0FaOEUvcGxhVGZYVWZLTWgxM0FDbHVNY0F2NEcvOVpnb0d4QVdvOTliN3ZFZTZhdW9TeHRoVFZ0TGJrRDgwSlZvQXV4ZVdWN0JDc3l2TVdBS0FPcWREM0o3OHNTTnY5MjkyWFdWOG9UTWJqU3dFNzRjNFB6cW9MeXNLLzN5RlcwL3VJZG92MFBiMFN1Sk8rcUpvSmtBRk1TcWpwK3VobW1mcUZLWXc4WUpCZFV4ZnRNck05NW9LcmJWZ1NNWksrYzVQNUlnU3FGcjFTMWt3cFZkTUF1Qm10V3VTSDMzblpuNjhCclA5VzJSK3JCczh0VGJ3RUNsRmVrdVBsalh1azdQdXhWRW85WWlNOVdoVUZMSkh3UzhLS2FHSldkNzFrS3NEMms1VmVMSHRCSmdGa0hWQWtnZHRMRjQwcWdGWGx2WURSbWVsNlZxdjE4TnI5dFNWTTBRdVdxOFRkZWQ3Mnc0K0pEMW5waXJiWHRqZlNmQmo2Ri93dEVreFMvalRTc2dQVUh3SzBNRXFEUzdDVnA4ZDV6VjdQSEhkazBxSktkS1lkRHNzQXJ2UkhzMEhzdlZDTy9ybVZWVDlUbDZySk8rWE4yU2Y3clBWZllKd29qSGJoU2o5M2g2ODltNTFWMVl6NTZsTWI3ZjBHMHYvaEt6UVlGempINENEWTJBa2x4MkVuNmFLRktZZGZPUnVtZ0ttbnZQNjhxMWI1cGVWV0k3cGNaTG92dWc4ZzJvNFlxUWo0QmVOclZ1cmYvTmYvVTJuZmJuUzI3MkF3MlBRSlZBc25FRk9JN1ArU1diL3A3cnpLeUdEcXM0bEFWTGt0TWlZYkFLZ09xQXBlNDNRSnBTNm1hRmVwMVZ0R1hYdk54ZnhtMXBVRlY5TTgwbVlDc2Z2T3E4c0NSQ2hROTJyUkVzNCtZZzRDZEp2NnR3bUdCbzBIR1dnQStndjlNcmZCTHI0MkdWTU1IV0k1ekcvQzduYlcwQTI5dzlyZlBYTTRWalQwS2U5WmErczZMMndPbzhwZmhBbWx6cTF2RkRzb0N4NHpacW1TclVtdlQ5VEJVNC83U3FQajUzWmRiYzFZaE1uTVY3NDFxdHFvZnFJckd5cGxYUldqc2Z2NENHbi93czZMMXNYOEJudnE1ajBtUUNZSXFMdUp4bjI1WmN0bmtWU24ySGRsNVZhcnQ2b0pkcDgrUmJRNzYwK3UzN081WElTbE96TWtEci8xVWMrL0x2OUFTdGh2TWdzbXhXU20rNi8rNEl6ZC8xQ3NYRzUwOWxBZXFvbjR5dko3d0M1V3BvQ3JpMzhrSEswalpmVFJFcnRtcTNwOVpTYWlLOWEwYlV5WnMwVmcrWkxVaVVEWGlDY1pkR1Bjc3hsM1IrV2N4NXZVK1IxMkxVbnhzQ2kxTDFRNG1tZmtsa1VnQks1YkxvdVd5YlB1Zmk3YkxvdDFtd1haWjZId3VXN3Jjc1g0QUpmaFZZVjcvdGNET29QelhFbXNLK0d2Z0xtcTE4QzFSb3lIVGNBR1c0MVR4Q2YxQXB5VHRnQnVNL2RiRmc3eHk2WENpTDNwa1NRZXJ0SjlJaDBmazNkTGlOZTVvRjY3Nmg2cFEzRnkreW0zNng4b2U4WnVUanQyTy9kWThEYXBpbjFMM3gzaGlraVY1L2NxRUtnSEl4VEZhZi9yam9uSDd1MkJWOGZTS25NQms4cXBpMzFOc0Jrb0hrNFBLcXdydkp5VlU5ZHJvZnZraTFFWjR1YlIzeWp2NCtrODBManI2eis2clB0Q3V2T0p2dkVxNWpvak5RaEhFZ1F5bzB2blJLOHNEVlFtamdLSXJwVkMwZytwTXpRTlZRVnRTRWFzZ1lXKzdBMHdlakxtaUEwdDA0RWt3NmdvS2taclJmdWhITU1XNkVySlVVZFh0aElFU3dCV1NaY3RsMlc2elpMVlp0TjNPcDcrOFlMZVlLclJwQ2pjVUpkNnJOdnAzRlc0V09HMjB2d1JPQVIvQ2Y5bTAvcHBrdEdVYU5zRDZCZUNIUXlYWmdMUWUrOEZXaFhkUHZRQzdkNDFUK0FjbCtoMlZkZ3RROVV2RUVvTFh0OGVvS29aTzdVQVdLOGt6Q09wcWRLNHFmengreVBxZjR3ZTdVMEg5UUpYL3VZNjhxazQvUklxdmFCZG9mUER0TlAvSFR3azVPNW5jcmh6QVpQS3FRdlhqK3lNRnFoUytBOHVyQ2g0Z2xRZXF1bTBRaWllZzRqWjQ2N04zMkQ5NDZwK3MwZVpxRjZ6aTEzMWdJSGxWS2xzb2h0VGFPaXBJNmRrOXIraVpHcHJpSWs5ZVZXQXJTTGlnSmJpd0pUalVzampZRk94dlc5Z3l1U09TNDRwdVpNbXhycUpZYmRTb0pkeC9iWjl5OUhtMjBPVDVRb1BUcFJWT0ZSczhWMXFsS2NLelZ1RmZGWWFqNVlHWGZ2MEhHV3N0YlQ4Ri9DVzEybjBZRFpXR0I3QWM1eWp3NTBTSGxyUURiSDEyQWJ6MzNEWHNiNDhwZklJUy9jNUpneXAvT2RwZTRHMEJ0N2xWRG9SKzBaUTFzQTBJcWdJMWhNV3ZUMTVpM1RFeWFVRVVvTFlxcnlwY0pvSDJKMTlQNC9mK1RmSlhnVG1BeWVSVjBmT0Z4QXlVY3J2VlVEWDR2S3BvR3pJNElIb3dHdXBINzNvcmd4Z2xyOG1iVHQxdHY2MzJhWHVpdFJRS0dteEhwNWZ4ZzZ6YldLd3NkcENtNVZXbFFWVmFyQ0Jnd1pOZXdRdkRYWGRSZmNJRTdVaWdLQU9Zc2pqVUZCeHErVEJsaGJvaGU1V2k2OFI5bE9OQ1JoMTkzUFJ4VXRkeXJHNXFuOVh4WmV6L21VS0RzOFZWVGhkWE9WVmM0VlJwcGdOZGE0V1hmdjBIR1dzdGJUK0tEMXFQWURRVUdnN0E4cDk1OVdmQXRRd0tvTExzMzdsNGtGY3VPVEZiK21DaHNxZEJWYkFrUXZWZTZsWTRLc3U1QmpiOW9LVHJtN3BlYUJwK3lpcnk4M3N1dHg4cVZVVmdnaWhZNVlJcUZEd1FCb3hRMHpxb2lxNzdjcjkrQTZ1LzgwdkMvZllMdXpHU0lCTUVWVnpFNHo3ZHN1VHlwdVpWZFNrMFhFL1I1N3hRSmVQYnNrVjVWYjBZc2hzMzJDZjZtYk5JWGxVVXFycjdTdlpnVkdKTGwrODkvUVhyaDJxZnRQYzA1bnVIV2JlejNZTVZJYnp3OVRyVzJTUUlCV1daczFVNW9Dcm0zKzFXb0lLVXN1QkpHU21QeHloSzJZV3BDNXYrN05TK3Rvak9UQVdOaFZlMEFCUmZUNDRnMmpycmdxcjRlakF1aFR6NmpLOGFFWFZiNHduSm5MM0MyZUl5enhmclBGZGM0cm5TQ2kyUjkvRVI2NEdkUWNWYWkvOTl3SWVwMVo3Q2FFczFMSUQxL2NDLzY2eWxIVVNEc2U5cmwzblAxSXNvaEg2K1BZaThxdkRwSDRhcVFKZDZSVzcycW9vbzZoanBmdm9hdmZZamV0cXVpSi9lZDRWMXhpNTFybTNSYTA4WXJCZW9vcnNBQUNBQVNVUkJWTmFkVjVYRE4raWlrT0E5ZVRtTjkvK0NhSDMyVmJIS0lmaFF3TkJXNVZWMUwrdFJ1d3lXZFZCRndPTnhxT3JXMC9RNUFoL2RiUjk4WGxXb0xMbC9OemF2U2dTeldzSDJTdC8zaHBtSHJKODYvbUg3Y1AxNUVjU0lRRld2UmI4c2FFTjQzVzNhU3FpSyt4YzlLUXRTOXA1ck5PRUtqcTRLRGpjRkIxc1dCOXBDUFRPRm9pdzNWQ1hYdEQ3YTJhUzBXNEM2OWZpU1RPbHovakZZTzI3R2RyYVFYdVFQWHduTWRxRHJaR21SUnlxekxObnRVTVM4MTVLTjhCOUVyR0JaQWw4RFBrS3RkaHFqTGRIV0E1Ymo3TUYvSFU3OFZsM2F3Yk4ydTBEeTdxbHJPTlNhNkJ1cTB2S3FBbThWV0Vra2U2VE5hOXd4Yk5XUXJSbndkR1dxR2hrRDM4bENtUi9mZDhTZWl2MVNNRzIycWgrbzZxNEhUS0h4RFVNVmdIQXRHbi82RTZ6KzBVOEoyZ1VseUhRN29ZV3FvT0drcis1V1dBS3FTRUpJRXZLMlkxNVZ2Q3ppTzFSNVZZRTk4TDF3OVl6NHlTZisycjVwK2tFclNvRFJFeHFpcDJUWFQ0Q3czQWlFYWw1MWs0Z1JQMHR6NUdGRnVxVjhpVUFQOW1ScGY1UEMwUlhCVlNzV2gxb3E3LzRCS0gzOFVJOHg4WmhKbi94UWxhczlFZmZLUHdicnhzMXUzTTV4R3E4cjhMU1JKSEMyc01SVDVWa2VIWm5sZExHdWFDM3RtcExIMXE5L3Y3SFN5anpnODhCSHFkV21NZHBVRFFOZy9TcndmYUdTdElObi9mYVhMeDNnMXNWTGxYMVphMTZWQ3FyQzhjb0lYdGNlcDRvVnNhcDZyMXBYdDZyM2kzbWRza3ZpSi9ZZHNjL1l4VGhjU2Y5VGZ3dXdINmlLeGs3bVZjVjk1WWxMNVBMNy9vdmxQdmlDVEdEcU42OEtzb0NwMTU3SnF4cGdYcFVNOWcwaEdBMzFveHVqbDFjVkFWY2hxYlpYNVE4Lzg0K0ZOejM3V2JzbzI0VFFOV2l0dTlSN1VrQ1NVYnFkc0R3cExGYzVXN1hldkNwaVoyRUNySUoxQzZ4TEd0aEhWNFI5ZEVXSVhlM0JRRlZxSFEza1JLeHJtazNxczcwRXZFbHQvSHhqWE1jci91Vm8reHpQdzlLM3NHaXY4blJwamljcU16eFpYc0FWbnFMV0lPRm9FUDU1L0ZyNEw1YitCTFhhQWthYm9xMEZMTWU1bk0xTWJOL1R1VFZZREQydDNiZkdUcjRVcUFxV3NxQXFrQUJlN1k2eVh4WWpjZlNEbEs1YzFYNm03eG1yeUUvc1AxSTRIZHdXREVGVnZKdWc0QUhGcFNzTnFxTHJ2ZDZFZkNSUzBQekFPOFhLNy8yOGtJMVNQcWdLTnh5VUtZQnB5L09xZXBDUkM2cTZmZTRjY2tYWHB1VFpsTm8yUmMvMkQ2ZkVEdStCaXV4QWxRUmN1MDJ6MEphdFloTzMwSTc0ZGllQVVxQ3F0MTNkYlFsT2d0NCswYytjOVoxWEZiRUxpWVdVcjNuK2EvWjdUbnpVbm13dXhxWTZRbnM5QzZxQzVkN0dnSkJTMk8xdWV4dDVDN0RyVjVKWVY2NVFPTHBpV1ZldUNsSFJ2TzBrZFN6SU9WdWx3b2ZNTVNVV2U2QlFwWWdmOVUyUG9CcFpvUitvaXRxaXMxalo0elpBVTdSNXJqVEhrNTNacldWTDk2NURWVm5lYTFhLy92M1dqZHVXOFJQaHY0VFJobXVyQWV2M2dadlpTS2dLTC8vSTlOVmMxSnpzbEtnMlhIVVM5MDcvTEtpS1FvKy85RkozaENPeW5PaVJhbDNkYW04OUoxUUZTMU4ya1grMTc4ckN5VUpaQ0RZL3J5cFlGNTFiUlFMd1RoMmkvcXUvSlZyLy9ES2hBNlp0blZmVjNlaWVYU0FSVWpEYUtsSjJiVXB1Z1pKcmk1SnJVMm9YS0xrMnhYYUJvbXNyditJZ1Z1NXlKSjRsYVJWYXNsVnMweXEwYUpWYU5BdE4yU3EyYUJkYk5Nc04yU2cxdXYzclFJZ1BJcUg5cElTcWJ0bmE4NnBDKzFRQ1hMUHdwUFdUVC95MWZXVHhHU3U2UFZHbzZnVlRyNnRlQkNoN05JZXdYSVRkVHJEWm9LQktqTGxZVi9telZQYWxEWUdkL0hhUzBlSmxPYUVxV3BZQ09vclljZC8rSDl1Z095ano5MHZpeGRiVlBlanU3R0FRMVBSWFZSNnNDZVVzVnI0WUFKN3dPRmRZNUtueUxJOVZwamxUWEFuRld5djg1UFZmVDEyZDdVSGcvNWpiaGh1cnJRTXN4N2tKK1AzTzJub09ybnoyRzVmMzgxMExWeVQ2c1o2OHFxU2l3OHJsWG9tWHhaTGE0ejNUdDVvSHdGUzFBSml4Q3Z6VS9pc0xUeGNxYkZwZVZjaTM0eWNEdXdBYWYvZG1VZi9QLzA3STVkRmVKN1JRRlFSVEE5Tm01VlYxdHpkek5pcnNEMk90SW1PTkVtUE5zaGh2bEtrMlMxZ3lkS1dPM1dMVHdaUE9wcndXaVRpSGgvcmQ5ZXIxMTdWZHVUSlNaMldrTGxlcXkzS2xXcWRSWHBXOW1UaEJjaVp4ZlhsVkhjaVN3YXpkYUh1Rkh6Lyt0NFhYbnY1S2FGWTVDVXhwczFWcFVCVWttVVhBVllCVmFFbXM1SXpTV3ZLcXhQNFdkZ2VxckF1YktxOXdwelhyR3dsVnVlS25nVkNHandhcWRPMkZEMURWNDBpN1M1R1JwVDhnVXZYQW44WEtIeU1CZUtIdFg3SldlYVk4emVPVkdVNlU1eFI3WnIxQXRKNnl2UDRyK0EvMi9yeDVVT25HYUdzQXkzOHN3LzhHTHUrVXBCMEU2N2Z2Y292ODJOUjFsRHovMlZPRHlLdFN0Uk5lMmlzTGZKYzczczI2U2g4RWsxZmJQbWVyd3BvWEJYNTYveFdGSjR1OUZ5QkgrS0JiSmlPMmlHL0VyK2ZmRDFRRm45NzBIdXEvL2h1aStkbFhDZTB0d0lFQVV3OGVOaXV2U2tqQmFMdkFXTFBFZUtNc3hwb2xSa013RmRxcURZT3FhSjFlMzZLZU1sYlc5WlBoZXA3dHNsS3RzOXFCcnRYUlpScVZGVW5xTGNCZUxGMWVWUmVxUXZWdm1mcVc5VE9QZjdpd3B6RW53cDNyRDZwNkd5dFRvQ29TcTdNb2JCZkxic2swcUVxMjVmdUljWmZDRFV1Vy9ZSTZZcmNtbjZyWGFjMjZCbnBTNjJSQVZaNzQrckZJUDhJa0Q4ajhmWXVPWi9HVElEcDJyL1VXb0tvZnFqYmkwL2k2OUpCK3Jnc0w5Z29QVjA1ei8ranpMRnZoWHlTR2EvWUxSSG45QnVIL0tIQTd0ZHBaakFhcXJRS3NOd0svSENycDkwRHJ6LzZPbWF1NHBMR25XN2Jldktwd1hkVkpYVUh3dXZZRUZUUXZ6TlBVWGdkVUJlV0xsczNQN0x2Q2ZydzBFcjJlb1FZbGlOa1V2dEgxWGx0cFVCV29lY2RyUlAwMy8yL2h6VTRxWmtNQzUzUmdHcmE4cWtxN3dONlZFZmF1aklpSjFVb0Nwa0s3S0xxdDhmS1lYVld1T2hoRG5ZMGVGSDFBVmRjZWloV1BFL1RLczEyV2RzM0xwWWxaYjJseVRucUZWdGkzbDFlVmNnc3dnQ29CN0dvdGlKOTYvQ09GN3poN3I5WGQ2em1nS3V3WGh5cmZsbEpYRjE5SXJGSlRDdUZGZHJWdXRzcHlHcUx3c2lWaFgxVVhLV2QzQnRUa0JCL1ZZWk55N3FmR1RxK3JSaVNsdjJhMlN0VjNvZkZJSUU3aUJORmZsUEpDbFQ2TzRsWmh4bDBNMVhWQjlZZTJLenllTGszeFFQVVVUNWNYWXUwTUVxYnl4dTNIdndsOERQLzlodnI5YjlTWE5oK3dIS2VDLy80azFjdVYxM05BcXBldnIrL2xkZk5IVTI4QjVqODVWWU5KdEUzL1NlMFQ3QXM5cVQydDFYU28wcldwOHBYTGxzM1A3cnU4OEhDcEtpTDhRaEtVSXJZTTMrNXNWY2d2RGFvQVdCaGorVC8rcW1qODQvZjRFeG1KVzREcHdEUnNlVlhqclJKN1YwYkUzbnFWMFdZcHZyVVJ5WEI3NGJLd1VxQktXZDdwWS9TUWtmbWhDanBmV2l4eTVMdFFIR3dpdWk2RlpHVnNRUzVQem5wTGs3T3lPYklpMDZHS3lLemZxODk4M2ZxSngvK3VNTjVhRm9QSXE4b0RWY3I0c1dwV3NTbUY3ZllPL0dDVEJWQ1UyQzlhRm9VYmw0UjFRUE5JQlZCOWFkbmdrMXFuVDZqS0cxOFh1VGVpcWc2Uy9QMVNlYWo3NVg4dHNudlFxeU9tUDY0aHZxYUpFWjVhbGIxbDM1YnNkUnBVUmNkczlaYk9GcFo0ZU9RVUQxVFAwaEJ0VFgvVHJtRjViUDM2NTRsMUF2aHo4K3lzd1dnckFPczl3SHNZRkVDbDJjZThJdTg5ZHoxbFdTUitJdVQ3cXlRYVV6MWNST1BlNkZhNVFsWTAxbmo3NlMxbERxeTlwYnF3K1BsOWx4Y2VMSTMyWnE0VVVOVmRENWhDNDl1RnFwQnZ4MDhHOWtUY1RtKzhaeHdXZnVZUExlK1ppNVAwbGdKTXc1UlhKYVJnZDZQQzNwVVJzYWRlcGV4R2YzZ2Fsd3kzRnk1VDdTQ05MZmwxeS94UUJkRjkzSTBidlFXWThCRzY2Mms0UnZRVmVPRUpoMVpsUlM1TnpzamxYYlB1NnZoaUtLOHBNbHNwRDZ6T2lKOTU5TVBGRzZZZnRqWWlyeW9QVklYaitqbUowZS9CS3Jha1piZDYxZmEwS2Q2d0pPenJsaTN0THdBaCtXVjIxL3VIcXZEd29CeVBJaVY5eE8rVlp4eWtRYnNhcU5LMUZ6bEFVMlBITE4xMjRnbnZhZHVlWjl3bU1UTVcrUHFEWGZUNmtkWnJYVnFJN25vUVhtdUxOaWZLWjdodjlCU25pOHVKZHFQTGFXV0Q5TStLMVFJK0NYeUdXaTNsd0RmSzB1WUNsdVBzQlQ0SVZOZ013UHFCMmFOYzN0Z1hnNXI4SjVCdVNWZnJNcS9FVGQ2WWRpRExBMVdxbGpJOFZySDR4WDJYRlI0b2o0bk55cXZxeG8xZHQ5djMzTURDTC95dUpSZkdjMEVWWkFGVHJ3RnRYbFhuczNkTmp0aXo4Nm82dDY4c0tkaTNVbVZ2dlNyMnJGYXd2YlI3UUJzTFZkRTZjVGdLYkRKVzF2WFRRRlV2ZnFKWENxaUsxSXBmcXhUcmJxRXQ2NU16M3Z5QjU3M202SUtVbmR1SDMvUGNsK3gzSC8rSHdvaTdLdkpCVmEvVE1nOVVoYll4L015c0hoQkdiWkVZc1hjSENkdWxkUFVjaFpzV2hYM0ZhdjdacXU2NkJucFM2aVJjZTErSjR1RHBFNnA4VzhaQkdwUkhEandkZ1BSS1ZWQ2w3MXY0NElyN3laQ1hMbGE4WEwvRnFsdU84Vm1uOEdNYjh2MnhIZCtLck90QnlMUFRuNm5DUE1kR1RuRnM1Qnh0NFNyaURBS08rdkhQaWxVRC9vSmE3Vm1NMXFUTkJxejNBZC9iV1V2N2t0ZHZmOEhLYnI1bi9wbytvS3BYUC85SjFQTVp3ZUlON1YwVW8zOXlieFJVQld0TklmaTMreTRyM0ZzZVM5d3NDYk5FWkQwR1lSRU82dmxJcFk4aVpoQ3Y4WGR2RVl2LzhWY0ZicUhYd2JYa1ZYWExRcGZaRGN5cnFyZ0ZEaTJPaTROTFl4VHpRRlc0bi9IeW1GMVZyanVFbE5lZFBxQ3Fhdy9GaXNkUlgrdGtjcGw4VU5WclFJYUlRTktzTGt2MlB1Nyt4UE4vVUxoKzV1SEVUdDNRdktwUXpBeW9vbHRjOFNpOWRFNlVicGtUMXA1bUlsN0lVN09lRTN5a3VqaGEySTJsU214SWo5OHJ6emhBd3piTmxLZ3FoZ2d0cDQrVXNkTEVYdzFSTC84TDhqS2k2c0VxRzZyaTdlVjViRVBXU0swL21lTlByQS9iR3FMRjhjcHA3cStlWXFvd0RFK09UL1AzZ0R1QVQxR3J1UmoxcGMwRExNYzVoUDlRVVp0c2FBb3Y5MjhmOFFxOGQrcDZScnhvc3N4YTg2cVM5bWlKRkpKYjIrTWNrcVgwZ1N3enB0cFB2UWJBYit4eDdMdXJrOTBMV0Q5UTFSMHZBLzdvQTZvaU1UMkw1ZC8vT1ZIL3dMdEUxMUUxdzVSblJpc1RxbnliaU1WZVMxN1ZaS1BDUll2allrKzlxcmhFUnlYRDdZWExGRHNvZDNrSVNpS1RBWG1oQ2pwZldoeDhRajVDY2JDdGE3WktocjRnbVVoZkNXSmYxZjY2ZUZmOVA0aHhPZDNkZDVFb01hanFCaVFmVkVYS0VqRjlXeFpVU2NDK29FSHBsbGxSdkc1QmlKSVg5VkQ5Y1VTNHJJL1pKS2t4SldQcERwLzArTDN5ekRIREw5ZEFWVnBaUEw2Nlh6R3dVYzVXcWZadlVDNFRrZnU1QmFqcnBXcnI5STl0U052U2pKdVhtbStydDczaHFKSXp4Um0rWFgyV1J5cFRpbmhwMThBOHRrSDZQdzk4a0ZydEdZeHlhek1CNjMzQUd6cHJxaTgwdkx3Kys1dG5yK1JJNDRKT1Nlb1FxVDJKNGlVSjc5Q0pkS2xYNWlaM0xOZHNWZnJnbUdldEcrbEQ0L3Z0UDU0OFpFTWNsSHdOTXE5S0Y1UGxLdk8vOHA5RTg0dmZvWVNyRGM2cjZoaUNQb1UzU29aaTk4WnNHOEVGeTZOY3VEQWhxcTNnNGZwcUJXQ1FLQXRyQitaVnhiY3JEbFcrdjdwOVc3UjU0OG9maTlzYUh4Szk5cnFWL1hhamt4bitsemlndktxa0xia0RwUVhGYXhaRjZaWlpDcGZWWTVTV0NCRXIxMENWcWt4cVhPT3gvRElOUkhRODA0YnB0ZHdDek5sdUFuank0RWdXVk9sc3ZvSlpMUDAzb1lKRE5heXBlOXJyUzNnV0sxNG42M3FndmhiRS9YdmJHNDNYR3dEODhwbkNBbDhmZlpJbktqT0tOdEt1ZTNsc2cvS1grTzgxL0NTMVdndWpURzBPWURuT1FlQjIvTmtyV0M5QXBka3ZiSTN5enVuck0wK3VaRjEvUGJXZVlwZ3JJL2llMWlTbDBJKzJkUzNsQVRCOXp5S2wzNmlNVysvYmQybkJGVUlKUWYxQVZmZ1RzcUVxdUx2bVBYOEI4ei8zQjFiNzhTdjdCS1plQSt2UHEwSVpPLzVvaFdxcnlJVkxZK0tDcGJIVTNLb0FBaEpsWVoxSGVWVzlBRUViOGZaNzYvdTlHais2L092V1lmZlJya01VZXVLZ0pmSHp0QlJRRldwanZYbFY0WVhpdFV1aThycXp3dG9YdWcyb1BTY1RYMDVTbXJvSjEwaUJmcllxTFdic0s4ODRTSVB5TlVCVmRGMHFheVNRUXdOVndWSS9BQlJQZUlma3dicFdxSXBmTDlKZm9aT2RWNld5cVd1cm56SVdYejlUbk9GclkwOVNLODByN0duWHY3U3l0ZHAwL21lQi8yV2VtNVd0elFLc1g4VFB2VXI3QWhtSS9ZZG1ydVdpNXA2RVhUOGNaVUZWc25aNC9lWHVPQmQ3WldWODdhQ243RWZhQUI2eG5DcVV4TDg2Y0tTNFlObXBzMVZCelR4UUJWR3cwa0ZWc041KzhJWE0vZUovdGJ6cFBmbWdxbHNXdXN6Mm0xY1ZzWGMyVEpOWEZRU1phSmE0Wkc1UzdGNFpRYWZlOVRUajY5ZzJlVld4M29TQmNCMTVWYjArSkpkZjF2eWsrUDc2NzRreUt4M3Y2RkVXYmFVSFg5THlvcU5RNm14VTFLYUJxbTV6dlpnQysrSVZLcTgvYXhVdXFZYzg0alZDSFZENTZNcGxpbnR5dzlSUjllZCtaRjNGMGVwNHVpblJ2dG9Odm5vWldldEt1YTk2WHZrQVNHWHJ6R0wxbVZlbDcwM2NJOXpIZUM3VzJ2S3FldHViN0hPeS9YamRaTXpuU3VmNDZ0aVRQRjljU3ZnUEIyaXRBQitpVm5zSUk2MDJIckFjNXdEKzdGVW84MW41eGJGdSsyV05jYjUvOWpyQ0IzMWFITzFWRWNXVktGWlBBQmQ1UlY3aDdzcUltWWljWXN2czNhcXc1RTlmY0VYcFJIRWs4WXRCMVd6Vm12T3FVRng3TzUrTnozdzM4Ny94RzVac0ZZY3VyeXF3ajdTS1hEWTNLZllGcitWUlNJYmJDNWRGTmxyelpXeDVYbFdLUGRTL2J2UjEzd0pVTEFNVmx1VGI2dSszWHRLOFU4U2hLdXFabk5FSzN3S1V3cE5ZSG5Hd1drdGVWYTlKZ2JXM1NlVzFaMFh4Qll1SzF6cUhLeVJJT0xJdW8xNUtXMHBNL1NDcmFTL3AxOXR5SmM5M2ZTS3g4clZiQmlwU1VBRkdrRlFRakVqL2dja2orQ04zdUk1dUpFMGJ0VmVSckFqSkNyQWlKS3Q0MUx2TDhjd2tRSGlKYVBFeFZEZVNxc2RhblMwK2k1V3MyMDllVlhnYmREWlN5c00yS1NTMTB2TjhaZXhKWmdvckN0KzA2MkZhMlZwdDhUS0pud0J2SGs2cVVmSmhtSVBYTy9CdkRTWlBtT2h5MnVtWnovN0twVXVJSHJwcEoxalNKdzlVQldWRkJDOTF4Mkx0Nldvblc5YWZzcW9ZM2ZMZjJYTzQ4RlN4SXF4Z3NBMTNUZEs5VDdtZXZLcGdJaWptSXdIK2YvYmVQTXlTbzdvVC9aM0l2R3ZkMnBldTd1cStYYjIzSkxSTENDRUpCRUtBd1NBTXhvQnR2SStYTVhoc2o2M0hzNzluZS96NXZZYzkrQnZzTVdOamV3d0ltNGNOWmd5RGJSWUJBb3d3bS9ZRjdWS3B1OVhkMVYxZCszSnZacDczUjI2eFpkNjh0NnJWWXNudnE4cU1jMDZjT0JFWmNlS1hFZWRtcnJ6MzUyajVMMzlPQU5CZUhxcGRBODlhWEJWRXFxTVVDT3crTTBUYmx3WkFsdTBSbHN1VGFiWUd5dUJadTVBRlZHWE9kK1lPVnRyQWhveXNYeXZaQXFya2JycFZjVldHdmRFOW12U2Z3RTh0djBPTUIwOFRXM2ZJVFRDVitab0dkZ2krQTRpQVFVRm1YQlVEdVZ1QUNlTHY4MUY5eVN4VnJwZ25DRlp2WkNxc0c2eWtyYnRySEg3VDArZ0R1czZRbGpXZTg5T1pQSXJ1bHZ5WlI1dVJVUzRId0FDSElLbUc4T1U0dFFSSXBhREtvcUt3amFyclVNczNaRFFsc21kZko4WWFvajlpckZPQU5UQldvL01TQldoYlcxUWZySGsrWCtyYzhrMU8wR3ZlWEdDZkIxaTdsa0dWM2JJOHo2OE9abUtnMmRxR1hYTVRlS3h5QkY5dFBJRkZaOFBJZTNhQVZsSDVHd0hzUUxQNVljek15TFo5LzhEWlhzRnFOc2Rncmw0aDQzcHovRVByUTNqMS9JV3dkZURjUVZrUVZPbGFydkliYUFaVnk1TDFWb0VxUTlPSEJzYWR2eHlhZEcwclZVRCthbFZSVUtYbkphU2ZhbHQ2OTl2RnlnZC9sSklNNXppdVN1WUxKdXhjR01DdWhTSFNZNnhZMWlmVDVPTWN4VlVsZkNNZmExT1NMS1A2WVNYWEZzZFZhV1VsK1M1c2Y1SGVzdklIb3NKcjBLUVNSYm1naXN4ZXlqS1AvR2hGUzVkUGkwb3U1SldzVW9ES05YTlV1ZmEwK2F0QXVieU1VYThFaEtYR0duTEtVNGlxTjI4OFo2ZU44cVRSbUU3Y3FZU2VYNEF4eElRUkFDTk1HRVlJcm16Z0thdjhvalptMDNNR1VSZDAvVjdGbXBmQU9FTSs1c2lQemdGYUdqREtCRld4UHJhREorTGdyTVZWNVVld21ZTTVsdGZ1T1h6NGVMZzZnNjgybnNTYWtJUE05VG15NlB5NWxmSW5BTnlDbVJuNTE1RGY4OGZaQmxqL0VjQnJvcFIxQ0NIL3BoWGpFNENmUEhVcFJyeEdRclBPaUhJcVp6Q2xEczJVWVFEYnVZenJ2RUdOWXkvSFJqRUdWZ1pka3ZoNnRWKzhZM3k2RlB2NkZNOXNMcTVLa1UzT21rNEdsdDd6aTdUOC9wOFF6NFc0S2dWMGdiRnR1WUhwTXlOVTl0SUYyZFJIYTdkZGE1L3Z4MVhGTmxpdXc3d3MyMFlJOE1xMXY2WWIxbTdSZmlsZ2dpbHp1NDhzOG1wYXpzY0VodkRET0MzRTdSYUxhOEJNQU9WTDU2bjYwbGtTL1o3RVVIVm5UWVBHdmJhdkRObVB6Y1JWS2VYRmprZVNreGRiNHBNQWFJaEJ3eUFNYy9qUnNVRUpUR1hiV1l6ZWxkMjZYOTJLY2p1c0FzcVVKUVNZajBEWEhQazRUVDdhTXVqS0FWV3lycXhmRk5ybWdWN2pxc3hTNDhJNXNWRUhWYmI4SHJYeFFQVkpmTDB4ZzViMU16eDVjMlllYmJQeTZ3QStqSm1aaC9EOUE4RFpCRmpoVzl2L0JrRDhXM2pialpLdmUrZGZ1RGFHR3hmT016aTZiSkhWcWl4UWhZanZBSGlsTjRJNk83cjJqRkwxVWpyVE5hbGpiZ1cvT0xtdnZFUU9SVUNKWTNQa2MzemtyVloxQTZyaVkrbXZmb2FXLytwblJTRlFKZkdUcWJLWHVDcTVJWFRRRmRGSDFtcVluaHNsK2R1QXJCc1BTNk4vUDY2cUU2aVNDT205clBJeWZuejU5OFhoOWxkSnlvZzhVQldXcS9aVTFXcnJLaGZMTkJZTWRyeXdIbVRxS0IwS2Z4bm9qRzlBWldhc1ZyR2RIQmxybFRYVFNVL0lCd0NaQmNWbHljNEZlaWNET3dBTk1tTVlSQ01NRElNd2FQYTl6SEl5eTk1VTNnNERyQXVkK3IweTViSUdwYjNsR2NBS0JUZ0RIM1BDUzRCWHl3S2VWQzFwTEZiZVBKREZRdzdkeXBOQVZYYXRzbTBGZ0ExcTRiNzZZL2hXL2FqMFpuaFR6azdybGRkSlBnRHdPUUMzZlQ4dTYrd0NyRjhBOEZxSlV2U21kY2NYSVB6TTdPWG85K3RXMlY2M0FOVmwycFIzdWQrUHZVRXRrVEsxMmtxeFdWQUlCYXhENEpjbjk1YWZLRlhGVnNSVmtTckRhaDdWRGdLdy9QNjMwdUtmLzBJQ3JwNjF1S29NVUFWaWxIMEgrMCtOMDJnVXdNNXllZEdSMFp5WlBPc3NhU3g4bUJQYmQxdGNsWlZQd0RiL0NmelUwbStMY2YrSXhMR0NvNmhjRS82bmxuWUdWVkVuVXZLeDQ0T0ZuNmh4ZHE2aDl2SlpjcWRYcEFEMkRxQ0tiTHlpb0NwTHY4V0o1cmxWbTYweXFCcGkwQTZBZG5DNFFtVURVNTNLeWZaNlc1VTN5NjkxMXFuWDM1VEpIc3haTGQycGJ2UGs0eGkxY0VTME1hZXQrc1N5V2I4b3pBZFYyYVViUEcwTDBHNnRta3NOK0dPTERHTlZyT0gyeGdONHBIcmFxdXZjQUszN0Fmd2pabVl5UG92d3ZYR2NIWURWYkRZUXZyVzlJbEdMM3F6dStGZXNUT0s2cFVNS3YxZFFsVCtnZ0FsMjhXSnYyS0xWcGlYUGdveThKZ3I0TDJPN1NsK3FEd2piYWxVUlVLVm9UK1ZZMGNkV0dTeC82TTIwOEtkdkUrRnFsVFFSUDB0eFZVbWRwSHpqS3czc214MG4xM2VlUFZBbE4wekMweWUrUkk0VHZwR1BFYStFYVhsVUM4OVJYSlVPcWppcXpvWHRMOUdibHY1ZlVlVlZiQlpVYVhsWlNWTjRyV01ncFN6QndQZ3ExMjQ4UWVYemw2UjFSVmh1Y2tqckNWUXBOTHQrMlhVU3FWamExQlViWVFGVkJHQ2NnU2ttMnNGQTlnOWZzMjB0U3Q5TTNwVFdZZUJsMEJub0NWVFp5OGlIS1hsbHJDSEFNNktObzlUQ2NlSEJoL1NGOGc3dnhlcFV1dEVMNHNIS3lOa0N0SlZvQnk5bUwwdXZuNndjd1czOUQyRk5lQmt5ZWJSZWVYbnlKeEcreWtGK2VlcjMxSEcyQU5ZYkFQdzB0Z0pBNWZGZEp2enNxZWVqN29kQWJqTnhWV1laS2syQThBcHZCQTFqYTFDV3NzN1pCajBMQ1dqMHZ4c1lkOTgzTk9Ia3JWWnRKcTdLSXBPa2x6LzZCbHI0NDE4VDBBRE9zeFZYcGROS0xMQjNkcHpHbC9vTEF5c2JQZXNHbVhPb0REaGlpazVMOG5MQ2wzVHBlcXk3QkJucFp6T3V5bm9kMmZEeTFmZlRqYXUzQ0VxMHE0MlNIMWNsMDh3bHZqVFdxZ09vaW1rQ3FGNS9BcFdYbkNCeVdCYldCTzNrUW5GVlNib3pxTkp6R2JYUGk2dHlBR3huWUFjVGJXZEEvYWlYL2NqMlRwM3BtOG1iMHZNOVpXNjVWbUNWUDVDTGVOUE9kdVNYNFlGeGt0bzRKbG80S2xwWWh3NU81SEx6dkw1bGdISWVxTExsWklPZXJtQmwyeVRyWHhmcitGcmpBVHhZUGFuSTJmVGJhVnNwendqanN2NFJNek9QNEh2dzJIcUExV3c2QVA0YXdCak9Oc0I2NGZJVW5yK3l6MktGM0VIelFWWGU4cThzZVluZndJR2d6eUtWNVhKN1F3R1J6WGRVR3ZTT2lkMWxNNmc5UG5PU0xneXF0UEl5QUJxdi9OTk5kT1pkdis2QVNRTlhvUUxMYWhUSDExbWdDa0RoTFVCbE81SVlRNnQxSERneFFXWGZFc1NlVkNialpudy9ya3JXdzZvZWV6NEd3NEdQSDE1K0YxMjUvaWx4VnVLcXlJekpOcjgva05MRWVBdjFOejVKN3M3OEY0VmFCMk5YY1ZWMkpabWJnSnJ1c0IvTHpnVnBKNnNDMk1IaFN0VUVBL25mRmMrMEpaT2U3Y1c2ejV2U08vaXh2SEo3V0szSzhJZVpVQ1JQdjVvMzM0NzRhbzdhT0M0MmNKUTJNRTllaDdsQnMyUUw0cXBVR2J1ZWJKdFMrcEh5TVh4aDROdFlFUzJEOSt3RHJRREFGekF6ODIvNEhqdk9Cc0M2RnNETlVhcm9UZXBldHNJT2ZtYjJLbFJZRGFLUEIxVjRyUS9rYU9hMjhGUWRLbStFUzNpcE53eEtaZzU3by9VS3FqUWRheVR3Y3p2MlYyYWRFc1htaHVmVS9GaGJYTjF1UUpXdVMxN1lXZm5uVjlHWmQ5NmNncXNzVUJXZXR5eXVLcUZKT3B5QU1IMTZqQ1lYQnUzTjl2MjRxdHdWcUU1eFZick5GT3JtQ3EvaUp4Yi9pM093OVEyMWRtY2pyc29HM2hKNUFnaW9YRFdMNml1UEVibUJMcWpab0JocmxiV25DNjlXeVRjZ1d4L0ZMNzhGTU1qQURvQ21vbmlxSWtlV1dCSDZadkttdEE1K0xLL2NIa0NWVFpjSmpMTGZOOGlhVExlZ3lwUUwvNitTaitPMGdTTmlBeWRvdytBRGtIeDZweHFsbENKeFZXWmVlZTdLbDRuVExkSENOL29leEgyMTQwWTV0ckx0dEsyVWZ4REF4NytYdm1ONE5nRFdId0U0RktXSzNweHUrT0gxOVV1N2NjbnFkTUxKQWxYcW9Nc2JVdG04bDNnakdHWDdsNEgxem01dHp2elZLcjNzL3o2OHZmVEovcEhvSTg3cHVKSTBwWnFUYzdHNEtrMlg0aFpYUDNNam5mNkQzMHJBVmVJcXozSmNGU21WQytuOUcxVWNPRDVKVmYyRHpNL3B1Q3E5MFUwL25PUTZ4M0ZWTXFpSzdHRUMwQi9NNFdjV2ZzdVo4aDRKdFQ0YmNWV2FmRHdvYU5CRC9mVlBVV25mRWpSaE5VOFJBR0RRQ29PcVZLb29hS3NCdEM4QVRRZlVNWjRxUzFlMzlOeTZGcVozOEdONTVScUR6SlF1WXJOTzd4eE1uMTJHVFNhL25XeTZ3djhyNU9NSnNZckh4Um8yNGwvc01jNTZYSlc2QldqS0tFNkI3UTdzbWRJSmZLSC9maXc1cll4eTh1YmVJcnh1NUdjQmZBUXpNMmZ3UFhCc0xjQnFOZzhDK0NPSlV2U21aUEh0OUw3QXhVK2R1Z291dXhuQXFWaGNsUzVwOG9BZFhNWTExc0QyZk9mUkphaUtlZmRXNnVMbXllbHlMQ1pwU2pVbjUrN2lxaUlaUlZ0TVg3dnR4WFQ2OTM3SFFmeVN6bDdpcW1TZXBpTnZDekJzRTQ2ZS9BbTc1MGF4NDh3d0tSUGFkM0ZjMUVIZlFRQUFJQUJKUkVGVUZTR01NWE1aS0RIQkRVUjRab0lqdjk3SVdEaEoyOFFYQWRvaTRIWjRoaWNDdElYUG5naFVXYW5NR0ZURi9MSGdDUDNjL0R2RWNIQkNibmk1VlRTYXVjVFhkVndWeUxxeVZiNTREdlhYSENHcXBuT1pvaU5yMU9hdVhweEZVQVVBWXd3NndFUTdnMkxiZnpaOVdiUk9aZmV1czRNZnk4dGJZTFdxTjV2ekhuZHQwdmx5dmVteVN3UmdIQlZyZU54WnhVbkszbjR6YzZmMGJ1T3FUQjJXZVZOeVNPcjhFcDdiMU1JZDlZZHdkLzFvcHMzUEh0QmFRZmkrckJQNExqKzJHbUQ5WndEWFNwU2lONlBJZFVxN2NYRXZ6bC9icFpYZWZWeVZqYTkzL0pkN294aU1WcSsyYUFzd3k2b1dFWDVwKzc3cXNWS1pDb01xclR4Q2NWQVY1MjAvdko5T3ZPM1BCTGZLbEZUakxNZFZKWlZQOWJBYkNCeDhaZ2NOcnZTUlhFYnhabVpwbFVhNmxVVkJWVmdIOCtkZ2NpT1RwZnNVWEsxeW1GQVBCT3FCZzVvdnFNSUNwWURnYUFZV25ZUHlGbkFTVDB5QUp3SnVDeDhiam85VjF3dlczVGJXSFk4NStTUU5ZN3I5QVAzVXd1K0lPaS9HaUVmVGE0Q3FSS1RYdUtwMDZUSmRTNk82ai9wTlQxUDVnak9kUVpWQ2syUmkwSzdUOWF6V0RvVE9vRXFtT1FUYUhZRDJCMmRuQzdBM2dOSkpad2MvbHBlM0FLalNVN1k2MklHdzNSTFdaSEpCZEtaRkppZmJEaGtFYWRaSjlWOUVHNDg3SzNoU3JFS04xc3FlNnpZVFY2V0RwazZnU3RVZjF1bWtPNHZiQmg3QXZMT1dLYnUxWUNxTHQ0RndKZXNJdm91UHJRTlk0WXRGM3d2MTJhM29EU3B5SFo0SC9UTGVldW9GY0tKeWVvMnJVbmw2bVFDSTBReXFlTDQzWk1taHltWHlFbnFXODFIb2Z6MjByZlN4Z2RFa2tyc2JVQlhKSldrZGcrZ2JQY212eWhjRzhjelB2OWZ4VGs1UXd0aE1YSlc4SXBYUUpCMVFaRG0rcnJiS09IeDBwNmhKVzRLMnByYk9pY2J1aEVvTEthcFB5Z1ZWbHRXcWJ1T3FCQkNDS2Q5QkxYQ29IZ2lVZzdqTDV0bHUxTTZ3SlVzMnBSdDYyWkFnWU1QeHNGWnFjNU0vajllcy9iNXdJWWVaSkpYRTFzWlZ4Zi9rRGNyd1hEcTBnUHJyWmtnMDJtcWVYSkJCMlExbm1UeDdqcXRTMGdRMEF0QStKdG9iOVA0THdLTDB6ZVJOYVZrK3FFaGVkT3lvZVJBaGoxYjBmVm8ybjVsL3BlZk5yNzkxRHBDdGl6c1RtYkllR0VmRUtoNFZLNWludHNUTG1sL1VPWWtLeUdTQktxdU1vVTJsZTlUR1BiV0g4SzIrSXdiUEpsOThIdStXMXdid1Q1aVplUnpmcGNkV2Z1ejVWUWpubGFJM284aTFTYnRtZVRlYzZQbEM5dXUyNGRNTHFFckpqUFA5aHBiTGxMVU5WQnZZNjVCNnVGSVQvelFReDExRkpXeEJYSlhLVTJYaE96ajVlNy9yZUxQajRVZDJZMTVXWEZWc3JBMTBJYjJHeUFaVmtTNldjZW5nV2cwSGowMEoxM2Vzeld5ZEUyMmdTcWxjekdPTmxzaHh3amZ5c2RXUGRscXA2Z3NFQm4yWEJqd1gxY0RjSTByMGRRdXFKUHR5TzdTcGx6VUpSVmZGZDNHaDk3L3BHdjhQb3RxS0tPYUt3U1I3OExpdFVwRFVhMXlWQ3FxaTYzS0ErcXVPVU9YeVV3alhQUzJnU1VrWEFWNElmN3RFMktJdHdOQittZ1J3d0F0ZnJXREJaQm1sZEtibGx0MUQzcFNlRHl4eWFZVlg4c3lwUEsrTXpZQ3FvbVhtNTdYck1laDYvVFVIRUY4NUlPd082dGdkMURGSExUd2hsakVqMXVCbjFFZ1pXa3ByYVBNV0llMjl4cE9odnMyWTFTcG1qUjEyY09ucStkamQyb1l2OXQrSDArNWFydnpaQTFvT2dCOUNzL25QbUpuNU5yNExqNjFad1dvMkt3RCtFa0FEblc5Q0ZyM3p6UnZ6YW5qTDZhc3lISnZjdFRvTlZjc3N5VkNDWlBZRmRWeXFmVyt3RTZpeWxkMTVvTE5IaEYvWnZxZjZsUGEyOXVTc0RiRnV0Z0FOVUpYeWVPNDl2eXdXUC9aRElzR3B0dFVvbVJmUnU0MnJDdWtxcUlwMWp5OE0wcDRUazBSYXZGV1cxelBuVm9zZk5Hank3WlplcldBQlZVbCsrY2lJblJJQStuMFhBNzVEQTU0TDE3SUtZdlBWeGVaSXR0VFZvamVxQitzc1hVcXJLd000SEh3VUx3emVTWElIbGdFUVJ5dDMwWm56NDZya3gzQ3lybXlsY2luTm5WNUczK3VmSWpIYzZqQlJGZ1JWU2xTWmNjVzZqRldIWG00Sm9Pa0FkQ0FnOUJmd2w4VnVzSjIybWJ4MmVxZDRKbzFlb0cxMHJWbitzQmM3T3Z2TGJIMDJMMjlaeFRUbkFKa205VFBieWxKbjd4NWV0UkJnUnF6Z01iR001ZWgxRDJUTkVaZGdtZiswMWFwT0sxWDV2MDYwejY4KytiaXpmai91cWgrejVyUFQ4bmk5eUFjQWJzWE16RDM0TGp1MmFnWHJXb1R2SDJiWUd6UHJ1anYrNVN0VHhrTnlldFZwSHJMTWtwem1rMStZNkFBNEhLOWVGWWlyeXVxK0JZZmozdytPbFdaS0ZSSXl1Rkl3UVhlZ0tuUVRxbngwelhHTmxtOTltVmo2Mk9zRXFjSHM0V216Y1ZWQXRJcVZiZ0VtTmtqNW1pY25hUHZjS01reU5qOGFHNjc0T3h1b1VpcXNOT0NXeEZVeHdpRDBRYStFQWQraGZ0OEJGUVJWOXJwWk9rZ1hvRXFpczFYS0Fxcml2T2NISDhZTGduZEZ0WlJYMnloWm9RcFRJZ2JwRkREQ2xTMlNqWkN0SXFoeFZaSk92VTR1VUx2aEdGVmZlTUtjQkZuTmx6T1JTalN0RE92bzZLUkRreDlnMEFHZmFEcm83Q216L0VNUittYnladEc2eWxzWVZLbmNQRHZTczEyYjNkNHNmNm1uYlhMcGY3ay9zVVhHbWpkejFiVElJN041VllMQXZxQ0JQVUVEUjhRS0hoQUxXRWsrMFdPYnQ5U0JyWU1xMnd3VDFqVmJWeGFva21tQ0JhNVllUjVHdkg3YzF2OFFBdDJSNStyb3JMODQ3MlZvTnN1WW1ma212b3VPclFKWUwwVitJMlpkRitlWFdXRHZ4cVJDNzNVTDBBYXFaRjM3L1Q3VUlES1dVa3g1dGFROEoyRlk5V1M1SWo0Nk9Pb0tqVzViclNvYVYyVmJyVW93RWhnYmp4eWcwKy8rVlFIQkJVRlZWR3lYY1ZWSitUS0lBME1FQXZ1Zm1hTGhwWDdxWmd0UUJ3MmJqNnN5OG1qcE5LNnE0VHNZODBvMDZObUhqSEw3TzZ4V0dWMGlCMVNsZEVNdld5U3NLM2VLWGdLZUYvd3RydlQvaEpUVkp3bFVtUnBDaUI5M2kvREhuc3hCdkkyWXJGYko5MUpvT3RKeXhPUWFOOTd3aEhBbTF2V0NVcm5PRFlkOFVKWHlzeFhJcEdoV1pnTDZHWFJSUUxRck1PVTcyWFEyYUVYcHhYeVFSQ3Y4QkpDbE9jc091NVJ4ZjNLdjhqbFcvNjVKWnNub0E4b21rWk9yZzNYcUZRSFlGZlJoS3FqaktiR0VCOFVpMW5TZ3BZRXExWWFzMnVoem9NekptMTlqcDhZS1pjOUdFME4rSHo0emNEZVdsZGM1NU92cXpPdEcvbG8wbXhYTXpId0YzeVhINXJjSW04MHBBUDlOb3RpSGZIN2pkdVpmdmpLSmE1YlB5eGk4YlB4UERtMEwwTDVNbTE2N0lQeEFleHZLMmd5aHp4K21odnloWjhrWmdQQWIyNmVyajVhckFyQ0RxcWdHeWpTZzhsUlpTWTZqdklsT0F1RFBEK0hvMjk3amVyUGozY1ZWNVlBcUFKbGJnTHBzeFN2aDROTk5VZHVRUDFNcE5aRGk4MVJhS3NrYVRhb2twTnZVSTZpS0R3Rmd5SE14M2k2VExhWktzYk5iVUNYWmw5dWhUYjJzU1NpNllwNUpEeWtYQnJmZ0N2L1B5QTZxNGs2dTA5S3pEc0lDWWdURW5PNnU2NnRWbEp3WTRQTDU4OVI0L1pPRVVxQlZ2T0JxVlNkUUpjbGs2T0NVRUR1RHlMZ3FJQzd3aWZaMWVNMUNsc3ZzWkhzM2VYc3JKOHNiU2JTekJLcUsydEhaWDlwdHNNdGsvYUl3eTA5enpxREw4dE82dnZ3YWRMTEZRNEFueENLKzdTeWlUZG83VkRLQWlGbWlhVThSVUFYSXdNcVVaekEyeERwdTY3OERSOHVMR1dYYTlXZlRldUhkaVptWkwrTzc0TmlLRmF5WFJ1ZThSdHM4Lzd6MXFRNGRYZXZhMmhhZy9KU2dIbXJ1UTM2ZkFxNXN1VG83aWV6Qkt2SCsxK0JJNmJGeVZYUzdCZGdOcUlybEdBRDdEazcrMzcvdCtLZkdRQlJrZ3lxZEZpOWRzRTdQQTFWUkpTVWQxWFlKaDUvY0kwckpLcEIrYTZRbUtncXFJcU8zS3E0S0NCZEx4OW91alhnbE9OOWhjVlZRNkdvM3ZDVDRHMXptdjVkQU1keU9oVE9DejVYSGFiVWRraTNFOEYxZHhCTFFTdGI5U0VZemhOcUxucUhhUzQ5SkNLazdVS1d3Y21Tcy9GU0dFdk1qRzlnQjZGQUE1enlmWUgrZGNIR1FZYlh0ck9yTThrRVNyVURiaFBRQ3VqcWtiZlNpdHRyazhyMTFOaFJKK2ZtRHpqWWptUFQ4R21TVWFxVTRJT3dQQnJHYkczaFVMT0lSWndGZTZKNnRPc25ha3JGTTUvbVRGUjE1QWZYaHVjSmwzTGg0SmU2b1A0QjdrbmRtMmZSM0xydDMzaVZvTm4zTXpOeU83L0JqY3dBci9PN2dkWUNsZzJSZmQ4L2YyZXJIc05ldjBLeGRPd1pWTWpMSUtVc2ZMSlZvM3p4TVpUbURQQ2VSUGVBMEhVZExaZkhob1RGWG1lbzJHVmNWcGxNWmxtUUZnRlB2L1FXeGZ1K0ZKSU1rNDlVS200eXJDZzJWZFFRQUV5cnRFZzQvTlIyQkswNE1UeDlBR1REbWdhUlNxaDFSUlkzR2xsZWp5T0xsY3JZQUFhQVJDSXkzeXpSZzJRYk10dEU4akM3UkJhaVM2R3lWNmdpcURLMEFnTXVDOStMaTRIMFUva3FRTkJuU0ZOaFhxMVNhSnNNRUVmNjBrTU5WclFBY3ZWbWFYRWI5dFU5UTVhSTVLZ3lxSXAwS3k4aFRHRlNsN1JrM0lpUHN6OU1CbkFzRFF0MlMyVDd4RmdNZTNkQ0swb3Y1SUlsZStBa2dTN09kWnRmVk9lZzhYMWQrbllwdTJpbjBMcllBVTJkazJxSHZlaFN2ZjVZdWhzc0NoLzBoN0FrYWVFUXM0REZuRVFGMFFDVHJZSXRPKzV3WjYyQ0ZrcUhERW5NbElIRDU2Z1VZOVJyNDRzQkRDQ0R2bFp2eW5lenBqWGRwQkxLK2h1L2dZN01yV0pjQUdFRFlNSGtOaUUzeEwxcmJnYlJiNkxPbTJtbXk0cXJ5aDN0NFB1dzM0TUwrVzR4T3JxRHo4RS9uQ1FiK2JIUjcyU09LY1l3eFR4YlpBaXdDcWhEcFg3cjFSckg0eWRja2NWZkp0RlBnMVFxRlFGVWlxNllCb09xN09CU0RLeVdRN056R1ZjWHBhaUF3dFZHaGhxOE9CK1hXZGJzRm1QdlFiTTRCVVlvdEVoM0JrMXhIbFI2bUx2UC9BaGNISDlCYXRIZFFaWlBqMkFnR2lBVWNFdkNKaWZwYjNIanpvK1R1V2lFekprbzNHT2crcmlwWFI5YllCRzFuMENVZTBaQ0YyZmtHYjU3V0RkMVdpOHk4dlc4QmVpRE1PaVhNaWhKT2loTE5pbEtTWHFYUW02UStoWFUvUXhTMXVOU3oyR1hHYU9EUnVOL0d1Ti9tTWIrTkNhL05ZMEViSlQwK3hheTN2WmJaUGpsdjRKbXRHRHNDMjZhWkNsRHMrVzAyNW9FcXRZendxc3dPenZkSHNDZm94OFBPR1R3cGxvMlNWYjMyT2RPME9VZEhSaUM3SGxnLzNXcGk0RXdmUGpkNE41YkZaajZ6MDZ2ODVXZzJBOHpNZkFQZm9jZG1BZGIxQ0J2QzFsanlkU2QrdG13MWNMRjdZeHVzcUpzN2RmRHNvU2hmTTRBNkMrd0orbkprcmNQWmN0amRseVI3ZTkrQSsxQ2xKblJnVlFSVWhmdzRiVTZITXFpS2RiU2UzRU9uM3ZQTFR2SXJ3QzJPcXlKNTZsYUM1b0d5NStMZ2s5T2k3SlhVaGlpNkJYZ1czbGNWTjA2WkJiYXZWMmpZVS9lRmRGK3RhY3VncWZibHptdW1YdlVVWDNXNUJSanlWTnFGd2QvaDR1QURwUGFVakZVb3BiVEM0Q3V0dUZKM1FtbGlIZlVmZTBpSW9ZM3NVUTlnQytLcVlJQXFxeDRDRFVmQWF0TCs0V2l6M0E3cGJ2SXFOSFZaSktlY0xCOGswVHFEcWxVU2VNaXA0WVJUeGtrVFFORXBVY0laa1U0SDhoMlJYWVR4QUFnYi9JNkdyZXhlcEhNOFpBY0REekh3R3ZmYkdQVTlIdmZDNnpHL3pYdThEZlFGNnFlU2txdThUcSszUkJFL3piQ0JLbk4rc1ZHelM5ZkxVR1BHNGpJQm9NWXVMdmJHc1k4RzhXMW5Ea2ZFaXNVYXUyV1VsR1BLZHdKVmRwMXBlc1FmeG12T1hJVXZEdHlKWXlVOUxzdW1MNC9YaS96bDBVcldIZmdPUEhvSFdNM21JTUlWTEdtMkJUS3VlK2RmdkxZTkRrc2Z5R1BiYkd0M1Qzb0gxSG55M3ZUNXdTQ0V0bnBsYWk0NmtEUGxBZ0FmSGhvcnlkYkxXNEJGUUZXY2grWDhVRUZWWWtZZ2NQTGQvOG5oZGltS3U0cnlSMHRuWVR0d1FWQVZHeXJyQ0xjQWs2M0dSSlpSOWtwODhNbTlvdHd1d3dSUXNOQ2tCdHZpdUNvQXlpZHJKdHRsR211WGt0Y3NKRGZzTEc4QjJxZFVTU3BydFNvUFZBSG1IRVBnUS83SDZRci9QUkc0S3J3S3BjaDFCNnJTZk83QmVkVGYrQWhSSlo0Z2RVQ2g5RkpkaVNGajVVc3luTjB3NGFuR0VCZDdSTk4rMmdUMmliZklUZTh1cjBLWEd5d1RaT1g1SUlsdWZ3SllJWUVIM0Q3Y1c2cmpQcmRPOTVmcWVOeXBJdHJCbGEzbzJET2tPNjJBS3AyVzFJNU53Q1dES3RrVkw1R0RKZGZCRTI2VklqblM3ZHZWYnZIQjFpb2ZicS94b1kwMVB0aGU0MzdmVjB1dytXTjdtMlZ0RGVxd3d0NER6THlkWndjZFZBV3dBN240cW85THVOemJodjIwam52Y1V6aE42NXJPN3VPcTFKSlNHVkp5bTN3Z2JPSUtWL0N5aGVmanpyNzdjRy90R1VQV2xuOXJnZGFWMFVyV1hmZ09PemF6Z25VZDBqZTMyeHBIdnU2ZGYyaHRDZ0QzSEZjVi9yZnJqK245N0tJWjlDRmZoMzdvOUh5NTZPcnovVVB1c1ZLWjVLVjJRSC82aTV4UjR0eFNHWlprbzFjN3NPcm9KSDBNekgvc0RXTGo4WDBFRVd4NVhGVkNFNEVzeTBSQXlYTng4TWs5b3RJdWthejMyWTZya3Q4ZFN3REcyeVZzYTFYSWlWN21aQWQrNW1GMGlTNUFsVVEzWmxQV1pJd2FkckZhbFJSQndIVHdCYnJhZjFlS2dBcXRWaFVBVlNUTEdVYUNRYWhjL1F4cXIzZ3FlaXVwRGlpZzVqVW1MYlBzTEJtMk5vcGFEbHhBWE9BUkhmTEQ5OXRaNWM4Q1RhSG5kWlprOXJWNW5RejU5RmlCZy90TGRkenIxbkZmcVkvdWRldDQwcWttMldWUUpHVGZBQjBncFR3WlZLVnladDYwZGttM3M0RXJKcTB5aFZmQ0dEanFsdW1vVzZiYk1KandwcndXSDloWUR3NjIxdmhRYTQwUHR0WjRJUEROdmhBN0F2dTJYWkhWcXU3aXFySmtZbEFsNTVHdmJPa0JMdU1hYndlZUV2TzR6emtORDZ6WnpGb2UxUW5xTll0bFpGdXpWcnhJeXdPRWs4M2xLOC9EaU5mQWwvc2ZSaEM1VHoxL01Wb3Z2QmhrZlVlOWpIUXpBT3RGS0FLUU5zUGZzekdJL3FBTzZ3eXR5WnBYcHB6ZEhUTXU4QWVzT2t3blYyU1FaTkhaSThKSGhrYkxZb3ZpcWxRZFNSUk00czdiUjZkbzdzTnZjVkpneFVubVRGQUZteXlVTkdDQUt1blJrK0g2RGc0OHVVZFVXcFVvcCtheEZWOXdkdUtxbE50QmpIN2Z4YTcxS3BVQzZST1c5Z1dBREpyVXNCYlpsRzdWeTVxRVdVOWRMMlhSRFJxcjdRUk1CZC9BaTczZmoyNkpiVjBVc0czc1pNWlZ4WElVMDFqSm0rUVRqUG9QUGs3bHkwOHF0ZGFxQ1VRcktVbHlpK0txOUJ0RXV3T0lLenhDSmNyVjZTYm4zOWhpZEttT3hmTkdiWm9wbTg1NGQ1ZjY4QTIzSC9lVzZuU2YyNGNuM2ZSMUovcHFrdzIwNkZCYW9iRk5MbmNMMEFyVzVMeFp0c2w4QmVncGNwcDkwZDh6YnBtZWNjck9sK29EaWR5azErWURyYlhnUUd1ZEwxOWZEZzZ0ci9tS200aUhnam1kMis4aVo2WlNoNXkxQmFqS0dmT0FkcFhOQndPNy9VR01CM1hjNVo3RUxLMWFkS2lPV1ovL1RGQmxsOGxQcC9XWTNtaGkwTy9ENXdidXdZcG9XY3NzVHV1V2R5V2F6ZFozMG1kMWVuc1BWck81SDhEdkliOHhzR24rYStZdlFMTTFtY20zZGtxdFU5amRjWnF1c2NBcnZSM0d3TERKMjRkR25weEMrK1RnY09tV2tRbmxCVkR4dkpnWFZ5VTVRRzF1NXBpZTZFcGxDVS8vOWp2ZHRRZk9GOFczQU5Qck5IZ2l5SlJONWx0cGJKY0NCL3NmM3lkcTZ6VTZ1M0ZWYWxwZXFaSWJSWUN3WTZOQ282MlNVVmFuK1JhYWZkbnliTk9ybnVLcnJOV3E3bGFxb3I0dHQxVW9NY0gzNHhYdFgwcyszS3lXcGs2UkppMlJTeXR1MU4yZWoyb2UrdDcwTUxuVGl3cmRVa0ZMeStpeWNWb0RWZFpNbHB0VEJzU1ZiYUpteG90Q3M3MUJQcTBRbllybk5UcWJQTGVHOVdvUjRkOUtBL2hzWlpnK1Z4bkVyQ2laL2tIcWZqYlFzbFdnS3BUUDNBSlV5bzkwc3luSFJsN2REV1FDUTFPTzVYckVPSlVBalBnZVg3VzJGTHhnYmNtL2JIWEZyN0RVRjNyZEFyVFJzdUtxdXB0RGRDZkJzU0tseEtmRlBPNTFUcU1OWDZxMW5OODJEOXBsc3VqNXNqR05zUzdXOE1YK08zRzh0R3pSVVhTTzc0WEhDRCtyOHpTK0E0NWVWN0N1QnF3LzNaU3ZiYlRpL0ViZ1ltZHIzSkNQVTBYaXFySTdlVG9vOWdZTlpZRFlkTnJUcHUwNXN1c2s2SjhHUitQWXEyUVl5VlV4MXdaeVFGVjBHVTh2eXRUSndQeS92RnFzZmZ1d0NMY0d0eTZ1eWdhcVlwMkNDZnVlMkN1cUcxVmlZK3lIRmMwRVZVbkRhQTFjTUs3S3hxOEhBczIxR2xWWWRBK3Npb0NxeE9iazNyRlZxaGRRSmRWRmtsZEJsVGJyRFBQanVMRjlzd0t1dGhKVTJmTVNhSFFkalI5OWtKeFIyNXZaVldXczhET2Vhb3B1QVZwdURtMFBJSzd5Q0RXTmFVNmU5cU56NTdEUU8zYVdyTFErc1FJQTVvV0x6MWNHOGRueU1IMnhNb0MxS0tCQUFUTFNNRHFIY1ZWSzNrZzM2M0t4akdFVDU1ZWZJY2VLbk94ZUpMbDV4NkZQTjRhY3p6U0duRXJBZlBINlNuRFY2cEwvZ3RVbGY4VDNVczNtL1RIdkVHbjBidU9xN0dsYlQrQ2tWdWFxTG1OWE1JZ3hydU1lNXdTT2kxVkpoejZ2MlVHS0hGZVZEV1JzTnJKbUw2TWFWUEhTeFN2dzVmNXY0dWxuNWFXazh2V0wwV3grQ2pNenAvQWNQN3Bmd1dvMkNlR2IyNGNsYXRHR0tjNi9abmszTGxuZGIzRHo4dHZkc2RtNVlnb0JlRlY3Q2hVdE9pT2o2MXZ0emI5S1VoOGRHaTEvWkhpczNHa0xVQVpXM1lDcUtBOEF3SnVkb0tkKzdVL2RZTDBLQTFnVmphdlNaT1V0UUtKb25wZGxpREg5MUxRWVdoaFdIK0hQY2x5VlV2SFVWbXpicUdDaVZaRytqR2NleG0zcUFsUkpkTFpLWllFcWhXZnBXZ1cyQUcxMk5QZ29YdDErdTZqejZVaENYN2V3Z2lycHBIcmRmRkNWMHR3OWkyajh5RU5FTlM4VGNDUmtsdStHdmJIWjJpaXFQZFlSWGdMRVpSN1JQajlmem5aMFE4K29ZMjVlVTBhcEl3T1ljU3I0YkdVSW42a00wemRMalNTTC91QWswN0pXZW14K28yaGVTUHg0U05qTFVDckYzY1JWRlFWVlVsbktrTkxjaDJHVERpUmxtZ0R6L28zMTRNclZaZjhGcTB2KzN0WjYvUFlwcVRZd1FSVWdBNWhZcHNoOGtUMDNtVTZGcGJMejhqS09pZ1hjNDg2aUJUOFhWS2wyMjJYaXVyQTF2eTZycG4xcTQ4djlkMkNtUEcvVUxIK3V6Nk1Wa1Y4SDhDK1ltVm5DYy9qb1pRVnJMMEp3bGVWQzhocXBHSjhBSEZqZlljNG9sangyZDZ4MkJ2VkJPZFcxTTZoSDRDcHZVTmowbW5ibnlDNExCLzg4T0ZLU1k2K2tLYWFydUtvc1VKWHlHU2YrNGorNndVWUZ0aFdvK0xyYnVLcDQxWm9TMlpBVzJ6TXhPMEZEQzBNVUdmdXN4RlhwT2dGd05SQm9ydFpFTFhBZzFWaVd0T1d6M0Q2Wnprb2QySExTYmh3c05WVHFhS3VMUkdPN2Jkck5qdElsV3NITFcvK0hxUEVjMUY4TUpqMUlxNU82V3BVYlY2VWM2aFJXdWV3RWFxOStuRWd3MUdCMjdUTG5GNFI2T29UNDhsTmZ4ZzJTMHhNTWNYV2JxSTg3eStiUkZMcHVjNDR0V1RxTnpwYlNBZ0QzbFBydzJmSVFmYVl5akVmY21oMXdhRU5vYzF1QTJYa1RQcXM4RzJoSzVDVi9sVmVHM0czelZ0c3NjcXpJc2VvM3MwQVZ3N0NKWlIyUGxhdmlzWEpWZkhob3JEVHV0Zm1LMVdYdjZwVWwvK0wxRlo5TW1HRmZyWkpsOHE1eVp4WXJxRW9IdGkzZU9QNi9JeGpBYUx1T2U1M2pPQ1pXbE54cTNxeTBmRFAxWHlMbTU1WHI0N0NENjVZdXcxY2EzOEtUbFhtRlo4cm44YnFWcndDNElWckprcGJPbjF0SEx3RHJTcWczQVJuWHZmTVBySStpSHRRTTJiaFRXT1lvSlcwR0c5bzZLbU5QMExCMnZHeTl1bzQ4MmVUNjQwTWpsZlhvcGFMeGtRZXFralFuamlLUllWaWRibExXd3VkZkp0YnV2WWpTMWFWWXVQZTRxa1JHL2pnMFVwbUI1WDVNSHQ5TzZQYlZDZ2FvMHRONW9FcEpNOEFZYTFkbyszcVZ0S25SZnB0eTVrcldaQ1E1OVFUb053OUtEYldadzFZWGxRWnJYSldzeTJ6ZkFDOXEvVDgwd0VjU1l2ZGJnSEhoblVGVmZGbDUvbkhVWC9rRUpRUzlaWEpBbERVTnhGVUhZTnhDdzJBR2dSeUFMdkpJSFBiTUNtWGZXQXRkZStSUmJxQ05ucU9UTTFMUjFRbFJ3dC9WSnZEMzFURTY0WlNqVXRKZitDVWxTOTF2cTBDVnJJTVYrZWRvWEpXRkwxSTVBNFRLZHV1Z1NqNWttK2RjbHo3VFArUit0bi9JM2VhMStjYWwrZmJMRnVmYkE0R2ZEdVROYmdGeWJHWFM2a1ZCbFYxbkxGTm1CNWQ3VTVnU0M3akhPWWwxL1NQU3VmTnVNVkJGR1hubHN3RGhtdVZMSVhBWEhxK2NMbEIybnM1dWVBMEExNlBadkJVek14NmVnMGN2QU90eVpBT3NMQmZYSGYvODZOVU1NYVhidUNwVFV1NUs0WFUvdXhqbGlsS09YVjR2eDE2K3pUb0d6amd1ZlhaZ3FLUTlpV256c3RTWHBibGZlYnFNTkVzT0p0SEJFZDg3TTBLekgveEpOd0ZXUGNaVlpXMEJ4cjlLaTFhMG1BQ1VXMlhzZW1yYVNhcHZlUnd0c2dXb05GdmVGcUFHcXBqQ05wbGFxOUZJdTZ6RE9qVlZCRlFsTmlkdHkxYXBYa0NWWkw4a254dFhwV2czZGZObDNpM1VETDVLYlBrNk1Tc2RRTTZwVnNBV1YyWElVU3BidWV3RTZxOTRJaEdTNzRnTmxhcEc2VUJMdFlIbGdzbmNYWTU3UG8wRzRhclZnSEY3TEdWbTJaRk1lS1pkV2ZiYWRIYndIUXpnbTZVR1BsRGJScCtxRE1NamlnQ0NGaUVuM2ViTnhWWFo4MHExaFlBQ3VTMWxLSlhxY1Fzd3RURmZMaWV1eW1KVERtaFNlcUJ0aTVEaWVsUHFoMlArU2JkRUh4b2FMMzlrYUt6OGd1VWw3eFZMWjFxSDE5ZjgyTjdVOHN5MHJTZEljeHZwL1lhVnN6MW4xdnlTNXQwVzlPTjZydU4rNXppZUZrdHFtWm42R0xvMXNUN1MwbFpkMmhhQ2dNRFZ5eGREOEYxNHRIcmFZb09wdzA3cmxqY0M0SVZvTnIrTW1aa3NEM0RPanU0QVZyTTVEV0FVV1RjbjIrMFU1dy82Rld4dmp5bjg3QTZvZXBKT29FcW03ZU9HcHRWd2pNYVY2bXV6QmdFaW14Z0FQalk4V21scm44UXhuanBUWjVPN0JXZ0RWU2tQZlBKLy9yd2JyTlVBQ3V4eFZUbGJnRHFvaWcxV1FCVUFvb0JqMndVVGRqKzUxM0VDeHdBR1d4MVhsVGFhV29iTGhPbTFQdXJ6WEwwRXRXRmhIc3F0VTNFQjYzeldaSXdhNWdHclRuRlZ0a2QxdVFTSnp3azBZRFNEMitsaTc0TkNucWFWdUNvbXphZm5nU3BsdWpicUZmTXFGNTlFL2RXUFNUQTNIWHlaamQwQlZHWG1ZU0tBV2RsaEpFQmM2RUU4enlQbGdjcXNUQTVkcW1kMngxRFR0ckp5cGxNR3NFNENuNmlNNEFQMWJmU0FXMDhBZ3J4YWRiYmpxdVJya1hhN2pES1VDbTBDVkdseUZsZGdpNnNxdWdXbzE4djROYUhGRmpCQU1xaFNmV2RVaDVEb0EvaEtvOS85U3FQZjNkM2E4RzljbkcrOWFIblJxL3FCNnBRc1E5M2lWSXJIVmRub25lYSttRkppZ1l1OUhkZ3VGbkduK3d4YUNOQnJYSlZ0dmt4NFpOTVJkMnpncXBXTElIQVBIcTdPWnBSWmxOYU4vQlRDaFo5djRqbDJkTHVDRmE5ZUFjVWJvRHYrSmFzN29xdjhqa1VLeDlTdnpFNHNYU1BzQ0R1anorTFl1clROUXQwbWUyQ2trdmRrcVNTKzFEOVFzZ2FzcTA3Sk5oOUxvTXZ1a09YNWVmR3IxNGpsTzY0UWFuQjZQcWhLYVJGSmk2dXlnU3A1Qld6bmszdEZkVDNheVNXeklUdUJxcUp4VlhKYXZxMlZ3TUdlbFQ1UkRvVGE4RG1nS3FXejBvZlljbEptQUoxdXFhT3RMbG9uWWRNMjdXWnJ2am42bjJLTXFNMEdlUVl2YXYraE5NZFo0cXFTOW93YlVwNjZVcDR4b0RSUUZSL2w1ODJpL3BySEltVWE0dWhpQzlEU0NGSmFxaElESUlvbVhnWU5SckZXSTRIczFyWDhsaU9oZDBUYm5kUG1xRSt1NHNRUlVjRXR0UW42aDlvWUZrWDQrNWxuWXd0UWIvRUVvS2kreGdxR0pMdllsTE9Vb2ZpaGNGUVhXR0VDa0I5WEpiVHk0dnJLZWlLYldOYVJXZSt3dzdIc2l0UjJOS2VUeEs4eThIU3BJdDQzT2xIOThQQVl2M0I1cWYzeXhmbFdjMk1qZ0hidk5lM2RiUUdhTTFEKzNLZlRZdzREbUFnYXVMWWhpSkR4QUFBZ0FFbEVRVlM5Rzk5d244WVN5ZStwVW50d1hseVZJWnNEcW1SZE1hcStjdVY1RUxnWDM2N09XdlJubDJPbkZaWGZoMlp6RVRNekQrTTVkSFFMc0M1RDl4VXZ6aGNBOW01TVdlV0x4bFZaOVpPYXZ4bjBvY1JDeTJHYkVVMGJzamh5T2lycm8wT2o1VUJ6UEpLelM5N0F6akJBVmVKQWtocG84N0RTRkswU1pqLzA0MjZvdk5pckZSUVpTMXhWOGlMU1dLZHNCSUR4azl2RTRNSXdoUjVaOTRCNTZlN2lxblJRRmJNYW5vdmRxdzNoeUNzb0hlZFBhYVpKNWRSVGZLVUJxNFNyelRDMnVxZzA5QkJYeFZIbEk1SklQbWZQQUtqRXEzeEQ2M2NkbDlmQVNuQ2RYdmVzdUtxa1E4aWlFdDJVTFo5M0duMDNQU3FCSyttY0NIWUdWY2FQbHRYR05odVFRNzNpUEIvaWtqWkJzSG1EclRjOEdWblpNalk2V3k3MTI2WFI0OW5tMzBvRHVLVytqVDVmR1V4S1ZpWnVxZnYxQXFwU2VUYmt0ZHAyRzFjRlFBTStsakwwYnFyS2NZNGNwNkRGd2k4U1Z4WHhFeDE1Y1ZXU2ZjYlFTdHZSK3I1QjQwWFBjZDUxRXZTRi9zSFNGL29IU3dmWDEveVhMUzYwcmxwZWFydkp6L0NwTzFDbC96Zmx1c3NyVTJwY3dqWGVOTzV4anVDWVdJYXVpNVM4OW5NblVCVnJJNGt1Njc5ODVYa1FmQzhlcUozTUxhYzRyWWo4eFdnMnoyQm1aaGJQa2FNNHdHbzJkd0tZUUxHS2Q4TlByM2R2REtFYXlIRlJhdWNxdkFXb3pLTHBubklzTmUwM2toSjBTM1Q5blVDVm5pZWlQbDJxME5jYS9TWHRDZEwyZHBQY3VDcXBObXBlanZzMjhmeXRMM2U4TXlPVXJsWnRMcTRxVkc2Q3FoaVVOWllHYU9LWktjb0hWbHF6ZFJsWEZUMTRtcm9KR04wbzA0NzFlbWlPZGFVSUVzM1dKY3hwbERVWjVjYm5nU3JKZmttK3E3Z3FyN3p1K1gwTHkxeFpXYUxLNmhtcXJCd1g1WlhIUlhuMVhxZTgvTlczZmVCbjdrN0tDbCtUOGw0QUx3VUFKaEllbFNvK3VSV2ZTcVVBanN0d25JQWRBVGdDN0lyWUNIWEswTnRFN1psU21zdUg1cWp4dW9lenQrU0t4MVZsNWJGTUkxRmVBWWlyV3lUMmFER3M5akdyM3NnaThWT1dOR2ZJeFBPbnpGNkJnNC9VeHZEQjJnUTlFYjFWWFFFeTBtMS9qc1ZWeVlDUFpSbkRKamJ0Tk9TTWNoTjdsZTI3MkY0cjBOUmRCRlNmQ0UxR3NTVjFZOGF3amUzckJsVEZaWkhhbzBBQUhxMVduVWVyMWRyL056SlcrY0g1TXhzdlcxalljTk5PYjU4M05nT3FPRExPZEQ4MnlaRGlNT0ZTYnljR25Gazg2TXdxb0twb1hKV3VVd1pWWmozVnZBVGcwdFVMSUFEY1Z6dWVvZGZNMTVuV1NmNEZhRFkvaDVtWlZUd0hqbTVXc09UdFFTQy93cjN4OTI2TWdhT0hkY3JOazNGanBkbExucUhsLzBOY3dsQVUzQzU3SnhpUzlrNXVIdFk4L3pJNFhJMGNVNkZYSzloQWxaR1hWY2NGQUx4ZXdhbFB2aTRKYk45c1hKV3lBZ1lZSzExdXE0U3BwL2FtYno1VW1uOXI0cXFpUm9GTWovUHNXS3ZUV1B3Sm5zejVVOC9YQTZqU3lwV3NVZXFpS3RVOXN0azEyK1UxejIvTUwyUGcxQkhSUC91VlN0L3NlMy85bHArNk80elZMSFM4SFNHNENvdGg5a3AreXl1aFpmNVVPN3B1T1pYK2xsTnZlRnl1QkZ4Mm1SMG5EclBXRDNWNlo1VDJ6MVBqOVErWkswZTl4bFhKM0N4KzNJWVZodk9pRnRGRS9NRm93MXlKbmxPdTFaYU1aQkU1QnRhRndOL1V0dUV2NnR0cFdZaE1VQldlbnpOeFZUMkNxbkJVRjl3Q1ZJYUFQZ3k2MlFMc0JLckFLQnhYcGJVZHAyMlI4bVBmSlcrVHB1ZllyVkwwbjdIc09QVGgwYkhxWndlSHlxODlNN2QrM2VKaVM5Z0JrOW9LM1d3QnlweDREakpuSm5NK2pGTjcvVEgwY3hsM3VrZlJUclJvZVhOWHErVHlBa3NKZXJscStxTFY4eUFZdUtjdWZ5VGFsajliWjNFZUFKUVJncXd2WW1aR2VpbmV1VG02QVZqeTlpRFF1YUxkODNlMHh5U3V5YytMcTFLM0VMT0MrNEM5ZnI5bVJYYkgxenUwM09Vb1NSdDVWb1NnYi9ZMVNpVHg4dUtxNG53eHFKTGtvcnltNDRyem5QclhIM1NENVliMnR2YmU0Nm9TTVNXV0svUkVCR0RIa2QyTzR3dXBRbHNiVjZYSlFiWnh4MXFkUmxzVjNiZExVcXcwSEZ0T1J1TkdWTlZtVFY2cmkzYkRjK09xQWhGd2EvRFVFc2FldXFNeSt0VC85ZXUzdlBYMkVFenR0ZFNpdzlGc3ZnekEyNkE3UUwxNGpWYjJOeGJML3NhQ1RGc3Y5UTJ0VTJQWTUycUZBemZxZXNwU0lrcDdGOUQ0NFcrSDRBb3dRVlZZKzJnb0dJMGdwYVdiR1hjV3hWcEtPM2VVaHdZRGlCZTNpUG9EVTFaUm5sR3UzaElXR2M2Z1czUWxOejRBOEkrMU1meTN2aWs2NFlTZlg1S0JnSFZsSnFISlo4N0ptK3FRYVhGdGU0aXJpbm1jWjU4OERFMVF4VDJES210OTdQeFVSMzVaYVptYTZ5Z1NWeVhia3ZRZ0JvVFNQbW1qeUtBcTd1bEpYZ2JtSEpjK01EWlIrL1RnVU9WMWMzTnJ6MTllYmtWWnMrY1dFNURZNmZFY0pIUDFCUVRUV2FuMHNhQWYxN1NuOFMzM2FTeFIrSm1IYnVLcXNuMk5YZ2RURndGNDN0cGhFSUM3NjBjMU9adk83SEtLeXcwQnVBVEF0M0NPajJJQXE5a2NCWkQxVGNDaWxjL25qM3QxOVBsMWcxNDBya3J0a3FwOFRIRkIyTUVOUmFab1hKVXViVVp2SVI2K1grNGZMTGVqNE56STB1amMyeFpnaGhOa2Y3bWY1ajc5S2ljRlNER1RVeUFsbWRZcHJzcXlmY2p4dkV0ZzlNK05VbU5oaUV3UHVqVnhWV2xhMGMwQU1MbFdvOUdOcXQ1RWNVTnBOTzBVWDJtNTA5dG1hTFRXUlpMUGphdnkzWGJRR2o0KzU0dy8rZm55OE5PLy9wdnYrOWxuZ04zWTFORnM3Z1h3UjFISzlwbXFyaHhVdGIweVY4WEtIQUJ1TytYYW1qTXcza2E5SGdRbEZ4QW83VjVBL3hzZkZPUUVlcy9jc3JncWtKUTNPUk5vdXcvbnVnMUNpUlc2Y2ZTd0JjZ0ZaQlNxUlA5aWVSRHZiT3lraDB1MWhIYTI0NnJrbzVzdFFKdHZPUXR4VllsdXVjd011WjVBbFVXSE1XeDdqYXNDaDZBcXJYZDhSUFZtU2tJbUZMQVc5V2c1ZGd3QVRwUks0aThudHZYOTY5Qnc1ZlduVDY5ZHVMcmF0czVmdmNSVnhXbDlhODdpbmhLdXZEaFE1ekt1OXFaeGozc0V6NGdsS1k4OVh6NTR5cHFYVmI4a2grZGNzSFlRQW93NzYwY05YVGI5bTZNeGdGMW9OdWN4TS9NWXp1RlJkQVhyZk5odWhuck91aTdHMzcrZTlXb0dmU2FHY3VQTURxWjJQSGxVVGZzTnVNbmlrZHJKV1pOVlN6UHRUNGU1WWZOdC9ZTWxrVmh0QjFYUjRNd0JWYXFUZ3pTZngzbE9mL0sxYnJCZUJaSDBTOEVlNDZvU1VCYTFRN3FpRllDSTRYZ2xUQjVwT25yc2xOSmdtNGlyMGdGYlNtQnNXNi9UK0VaTnBFUmJsNUFWU0ZLOWdDckpma2srTjY2S2liRXhmSHplMmZuQTMwMDA3dnZOSDMvL096YUFnN3JXM281bXN3SGd6d0gwUVIySHZUZ2VnMWZ5VzZzbC85U1RBQkNRY0ZmM1ZacTFIMzY2bnh4T2UyaHlOekpBRldEMlptTWFrV0dHYmszSUV3YzhpQ3RhMFpaa1FRQmxvM0ZHTXNzYnlWU05mcjlieHpzYnUrajJTaitBNHNCSVdRV0phUVh6UXBLM0FpTk5oeW9mRm1vRktLbEpGbjA5eEZYbHk1Mnp1S3BZcjdFRmFQR2pDdmlOWGs0UjZyVzJMYWQxakI0eklsY1I2enRhTGp2L2ZmdjJ4b0cxdGZZUG5aNWIzYisrN2tWRnFQTkhOM0ZWK3N5VGxVL2RjWWt0RGlrT0JDN3hkbUhRT1lsdk95Y3QrVmlpbVBydFBOVWZaZWRsbkxkMkFNVEFIWDFQVzNTZ0FNM0d6K05kRUlHczB6aEhSMUdBZFI0Nk8zWnNpcit6Tlc2L09ZbUR6NDZyMG9HUHVxU2FYdThPK25NNnVRbWY5RTZzWEVsMlNjY0R0YnA3c2xRU2NReEJQS2pqbXNqT0thbWhzUVdZekdZYVBaN25pYjB6d3pSMzI4dWNPTEI5TTNGVmNUdFE0cDA1bFl2NGswODNoZU83V3hCWHBUYWZiR09hU08yWVdLL1R4SHBOcU1Bc2tXSWxCYW1oSkxwaWNSNnc2aUd1eW5kYlFYdjc0NDlWdHQvMzl0LzgyN2QrTnR6NiswRnMyUkVHdGY5WGhFdGdXYzZsNkJqc3lCTzcxOXpHRzQrV1VXYVBtWWhaT014Q2Y3aVhjaGNEVlVrYlp1VWxRRnpXSW5ISU0zbldjcEhPbWhreW5FRTNEYkhaRFJ4MXl2amp4aFI5b2pvYW1paDEyODNGVldXREppanlXV1dveG5ZRHFsUWRXeE5YWmEyUDZjRlJLSzRxdFVVWmpISzV2Y1pWbWVBM2tyTnNBU1o2SmRkbHRydjJnbFRWWG42c1duWGZOYlZqNEhrcnE2MmI1dVpXZDIyMGZNampqUk1EdTR1cjBuVVlvQW93SFhWU0dyREhIMGNqaXN2eUlMOUkxZTRuT29HcVdDWnVWSFdlanVYQzFhMUQ2M3V4NnF6aTI5VlRtZVZsWC9maTA2NUFzL2tsek15czRSd2NuUUZXc3lrQUhJS3RVYk92dStQWGd4S0cvY0dVcm9HcU5HWFhvVi9abGk5SHVZSitMbHM2cEZxV1pkNU5VeVJMNndlRGdTOE1ESlMxVlNmRCtZV2FUTWNsbDJVOFpURWpmbFlTWUp6NnhPdGRlSzZ5cmRkdFhGVzRaVWpoSjNCaVoyTUJYWTM1RWRHWUh4SHBXcnZ1aVZteW5CVlFaZlh1NE14ODh2WFllbzBtMW1wQzloVnNPYWtObUVvcVZwSW1yOXF1My9DTzc2dmFhTXl2WWVjRG42OVBQdkpqdi9xWHY3Z0VYS29ic0ZYSDJ3QzhSREtsRnlkVFRINVhxNFkzejAyakhMN0NoTUJNNUFjZ0h3RTdMZ2RDbW1la214WFBZb28yVWtFVlMzVDVZQUFsaG5OdGkyaUhiL0tLcE5raTBpbXZyVE5FMXd2Q3daODN0dE1INnR2UUJ0a0JRRUtUejZ6UzJPVGI4c2F5bmNwUStKS2Z5TE5QN3JhWmNWVmtrN1A1SU5tT3RNeE9vQ3JScTdzTnplWklCOHY4V08vV3gxV0ZPYlBpcW9Bc1VLVzFTVlNPWW84OGJURndmNzFlZXJCZUg3eHNlWG5qcHROblZzYmE3U0RsSXA1Wmk4WlZJWkZTOTJJNEUxU1pPamlKeTdyRGZTcDZYNVplcnMxSDJMY0F6Y1VQdHNySDU0dFhEMlBSdVFQSFNzdld1dG5QUldrNnJ3VGdNalNidDUrTE43MFhXY0dhQmxCRmZMUEN3MVpCOU13L3NENGE5a2hLYjFiTXkzS0RXUjFQcDhVYTl2Z0Rscnl5aEwwcldyWUF0U09oempzdTNWUHZjMjFQbExGT2ExeFZ3dE1IYjdoYUZZK2orR1dGN1JPVG1MLzl1amoyaWxNRjNjZFZNV1FnRmhwSWtXY0NNUnpQeGJhbmQ0c2ljVlZKWStTQnFqQ3ZaTFBhQVBIMTZFYU5KdGZxUXBxazFSTzB4a3BMbDhwTTVSWHJlNGlyaXJXM0dndnJZdi9YMy9NYi8zRFR6Y0IyQURmZ3JCM041ZzBBZmduMnNiZTFUbW1xVmNXUG5nN0JsV1cwQ2ZodGlBaG9zU09zR25QaXFvd2o1dlVCenZYclJFUEc3YlduYytoc3M4a21sbEZHaXdnZnJHL0QvK2licEVVS1hXUGNHTm1nS2xTZ2d3d3JlSURXWFdFSEQzcFo4VnhhT0s0cXFwT3FMNWFUNUZPM2tQQVMzYTB5Z3RreDhNa3hCTE5qRk15T0FhdjFVRTRLU1VqOFMreDd3b2MxSm1LUTQwR016cEV6UGd0bjdEU0xzVk1RbFEyOXJKNjJBRGNmVjZYbFRmcDVOcThUcU5KNHVqemYwZGNvMzErdmwxNTkrc3pxUytjWDFxUm5PTmxKMlVOU1lucmVGcUNzejlSaHpxVjFMdU1GN2IyNHg1M0JDYkZzMGFQYUI2aWdDcGF6elZmcFlFMkFjUFh5ODNEcndMZXc0Smpneml3L2kxYVVONGd3WHVNaFBNdEhFWUFWYncvQ2NzNjY3bzdmYkkwaEJWYmR4VlhaOU9zZGhVRFl4blZEcjk3aDBtRXUwMnh1MnJvbi9xV0JnVXFBZElESGRQT0prQ1ZlNmd4aW5nMVV5ZmpseE1mZlVBWW9YTEhhUkZ4VlhCN0ZLMGtVNW8zSE1RQk1IR2s2amxkS2ZVSHlxTDY1dUtvc1dTYkdVS3RDazZ0OTJvc0JwSnZWQzZpUzJraVN6NDJya3JWN2xUVXYySHZYSjMvajR6ZThBYmhKMTd6MVJ4alUvczRvbFJmVTNxc0RTcThIZlJkdm1kdURDanNTVlcyK3NGTkF3UGNnZkFTQjZ6S0VLQkpYWlZnUUhUUWFRTHg0ZzZqRzVzMnlqem9qYlJPekVETkJWV1FKdmxidXh6c0dkdE1ScDRJNC9pWUw4TVFLTmdPcUFCaGx5UEx5R0JSc2xNKzJ2RkRrUWcyMnVDcGU2WVAvNEVIdzhXMFJnQm9ubmgwRHo0NXhjSEtNZ2xOanhJdjlVQjdNbEFjMXFRRWxnSlhLU284cEdrLzBMOEVaUDhYTzZHazRZNmZZR1Q4RlovUTBPV09uMkIwL2hkS2V4OWxwTEdsdExRMVIxWi9HM2RLK3NoVExiVUZjbGRiR2loKzNBeTRrdlU2Vzg0am80Mk1qOWJzYmZhVWZPekc3dEszVlR0OEt6MUFOanpWUXFnbWNPQ3hiajlibnBVNHhYZ3dIQWhkN1Rkemp6dUFac2Fqa1RlV3pmSWVjMWxmbHREekVpQis5R0VBNUtPRkZTeGZnMDROM29VVnEzdUtZb2h2ZUhqU2JzNWlabWNPemVCUUJXSWRoTm1iUkJ1ak1keGdZOThMdkczS0d2T3h0QVBubXBYSjI5QjFlVHdSVnVNa24zSFMrUE9QYWRObEtOUVpFQU9EZit2dVRydzEzc3dWWUJGVEY2ZlduZDR2Rk81N3ZoTjhiVEEyeWdTcUtYK2NzZVFDeThhTjhKTXN3dUc5eFNQU2ZIaE1wT0pLTjF6eVE3TjNsTVpVa0dMb25zbDFYQXhjN1Z2cEpMazl0UUtWSkRMcWtWYlpCcHJIbUpWV3UxdWlCMnc3YXUrLy9scGg4OUdXLzhiNmZXTWF6Y1lSQjdYOEtJUDVWN1dhZFRMYTh5NFEzeisxR1BYQ05mcC9PTjJGS3lpbklhNE9JL01BdHFURmErYUFxNXRPMEIrY0ZHd1JIczRoZ3QxcExHd1BVSExHMnFVVTdDQnNrOEs3R0R2cEFmUUtBTWZic3F5RFFzRVlpWitaTlNrcmtld1pWeXNSdThTY0txSXJsc0ZKRDhPQmgrUGRjQVAvZUM4aS83M3dFVCt4RzhvMVNGVFJSWXF3SU5KOGlGeWJuNHhoVXBRWlorQUJBQlBCS0g3elZPbmxQTlFGaWt1WGlCMFYzeHpFdUgzcVlLd2NmNHNxaGg3bHk0R0VXRXVpS3U4bTVpS3N5dGlwMVZ4TFNERGtaRWhHQXB5b1Y5Ny91bWhwNitkejg2c3ZtNWxkRjJsOXQ4NS9FTXh5ZWJWN0sxbUdUSVFBWGVUc2gzQmtjRll1S0RFa3kyVnVBYlB5SEpoTjNiazVhbjlFWDlPSEZTd2R4NjhBREdYbDc4Mm5adkF1anJjSTJucVVqSDJBMW0zVUF1NkE2ZVdSYzk4YmYweHFCeTdHYjFidEtldFV0cUpLdko3bHVuVHdBcEo3QWtKRExzZW1WOC9EZGZYMmxCY2NSRVdiUkJ4eWl0RUxYNDZva25oSENGTk5QZnVJTkxsRzZvTkZyWEZYc29jSVlETWtKUnBrRUMwek03SEZDRDhTbWg5QXFwamhmZVJxMGVDS1M5TVZzSm1hWEJacEwvVTY0ZEtYN0VxVlpqSEpWdW9VR0RmRWE5dXYxWTZ4dmYveXBTdk91Vi8vbUxXOTlFSGloYnN6WlBINEx3RFN5eDEydlRzYWszVFEvaFlsMlRYS2VkbENsYW9udkx6dWl2Y0VzaEIrVVN1SEhtYUhmakpBZ3JYU0o4OXR3TG0xWlpETXNqdExHOEV6SHNDVVBXeTlsMlh0S2ZiaDVjRGM5N2xhVkNkVTZZY2MwdHNsbHZBeVVVMzdNczhwRi9QU1h4M1pRWmVyVlFOVjZCY0VEaCtIZmV3SDhlODhuLzk0TEVEdytEUVFDUm1ZUlpJS21kTnN2enNUSUEwMEpYK1BGT2tndlF3ZFZLbys5NDVQd1RteWp0UzlkbHdBd2Q4Y3hWQTgrek9YOWozRDF3TU5COWNBalRJMWxCZnlHb3M5T1hGV3FLNkVaY3JKYmlhK1Q1Z0xEQi9DdkkwUDFlL3ZxNVRlZlBMVTR0ZDd5b0FhOGE0NDNLYjNZRm1CTVMyTzFzdnhCYVBRRjNpN0FuY0ZSc1pBNDV5SnhWVm1yVmVuRFZnU3lwRzJUT01lb040S3JsM2ZqOXNZVGh0NWVmVm8ycjRMd2pRaDM0MWs2T3ExZ0hVTGFSKzJ1TnI5U25mblRHK25yR2N4T1k4K2Z2VmRzU2hBWUUwRmRsZWhoQzlEa0tCUFNGd2NHS2dUdCtaM2xBWnFhazdGYWxRV3FFQWVLcmgvZEtaYnV2OURKaTZ0S3hvc0V1aURGVmVsYmdCQXBJRXllUmhrWVBqSGx1TzF5NUgwMFo1c1lKelZOZ2JpcU9BL0gyU245c2I4QVkrZHl2eWo1VHZZUDAzUVBKNHNwdHpSdHVGNitBK2hWMWp3Yy9zcWYzUHdQTjkwTVhJaG45V2cycndQd1dwajllcXVjVEVwNzRmSW96bDh6WHlGdjcvM2FPRWh2RW9GOVY3UjhQM0RMSERpT0NhcFNVQ1BPYThPNXBLWFBjYllTT29DcXNHU3JudEErZ3ZreVlnQ0FCOEwvYUd6SFh6UzJrUStLM2k2dVNNcFdhNEFtcWJOQmd5VGZZMXhWTEpkTTFySk9WWTVCdmdQLzY1ZkR2L1Y2OHY3OVNnU1A3QWQ4Q1V3WlJ1bmpNZlVqMWkxQUhUVHBvTXJDUzBHVldVWW00QXF2MDNDSDJGZElmUC80TnF5Y21LQ1ZMMTlMSUFnUW83VGpLTmN2dlpNYnovOWFVTC9vcm9CS2JXdWJpZXoyM1BJdFFKdGJTZkp3NHZ1VVgxTWVyWlNkUDVuYVB2eVMrWVdWbDg4dExEdUtodVN3djBYZGRJVm1yRlpnOVEyc2FJZ3Jjb0czRStReW5oYnoybHluNnVnRXFoS1V5eW13U3ZPcXExcTdXbE40M3RveTdxdWROT3BpUHhlbDJYamphRGFuTUROekZNL0NVUVJnNVJtTFRmTW4yMk5KUStmbDc3eGFsWFkxV2RjQWwxRGpFcFRuaUF6M3JrOG0wV2pJS1JzQStLUmJFZy9WYXFYMDZVUWFoTWdGVlVxNW1nT1hodzRUZ0xrdnZ5UjVMVU5jVDF0Y2xRU3dySEZWUkJxb2lubngwNkx2WXZEa3BFaWJUSE84OFZGd0M1Q1ZKMVY1K1R6Tk03SFNML3JhNWVRbHBwektKM1V5cjFMN0pmbkNjVldHblFCdmJIdnFXTisrcjF6N3krLzdEek40dG85bXN3L0E3NkQzbUt2aTh2czIrdkNTeFNtSmFtdGdjNXl3ZGtNa0NZZThEUmErNHdlbHN1M1ZEdUtnQitmeVZ2WklqOUsyd1dsMENQc0lObTBsVmVFamJoVTNEMDdUZzZVNkNGREFWVGVnQ2tvK1dYNHpjVlc2RzFReEVRSGc1VDRFWDd3bUJGVzNYUWRlN0xjMGhKeFpHNC95ZzVtTkwrZFRaR09sSnM4S3FqUmUwcllXVUJXM1d3S3E0aktoMmFmeHZPT1R0UGl2UDBDTG4zcWxFTFUxMUMrNUsyaGMrYldnY2ZrM0FuZHdnUk85VW5NQVd3K3FFaG5OelZCVVJYa09pZnNiUzdBamZPVWI4ZWVHaHVvUDFPdmxIems1dDdCcmZjTkRER3pNZWNrYzQ3cU1IVlRaZFRCa0d4bm5lVk1nbHpFajVqTHpoRFZseVBOVURLckMycXRuWTZ0UUdpZ0E0L3kxL1ZoMDFqQlRWcjQ0a1Z1SDRqU2RkeUQ2S1BSWi8xN2haZ0ZXbHFzc3hwOXNOMUFMYWdEa1FMcVVYM1FMTUwxcE1pVThkZ1IxSk1zd3hwRzVjU2pab05NTnU3NDBNRkJSQjJuVTE2UzhSYmNBNVh3eUw5aW9ZT0diTDNERHdIWW9IcUNidUNxeU9iRlVCNE9Cb2VNN0hRb2MxYnZMWXlwSk1IUlBwSHFsMkttQzQrdHdHejUxeGt6QTBFYVZSdGRyWkRTS1ZLNXlBM1JRRlUvTE5sQWxONjdGVG83YTJTdHYrSHp3My8vbTVuOTgxUytGcThqbjVQaDFBTnVRR3I5WlIyTG5EZmt1WG5kbVdubDR5QjRIeUFOVmVpcGF6VnJ6QTdjY3NPdEVQWTdGL2pZNVYyNVFucVhHQUUwSU9hREsxR1cxUFdEZy9YM2I4TzcrSGRRbWd0QXlLOE5DS25XclFaWE1pNjRaa295cU45THh6Q1Q4VzE4TTc5YnJ5Zi9hRlVDN2xORVFzSU1xaWI2cHVDcFpUbC9OMHZuUmRRS3FVcDRKcXVReW9kbG44VldHZmNUZ2pRcFd2bmFWV1BuNjg4VkpFWER0NEVQY2QvazNnc2FWWHcrcU8yY0N2ZDFsTjdWVmNWV0FCS3FrVXVLcXhMNEdqTFQvU1J0cEFvd1Q1Ykx6bnFsdHc5Zk5MNjI4NHZUOGlzc0pnTEdQSEhXV3locnpPaitQRjRBQUhQWjJRRGdCbm5ET21QcmkxU3JFRGoyZXNVeWQrb2lYMDJvY0dPT0tsVU5ZRm5kanpsMjMxTUZXcit5NjV2TUV3cGVRZmdzek0vTEQ3SllmMlFDcjJSeEcrUFBHYml0YW5MOXZZOHlRM1FwUUpldWM0RDRyancxWlhVOFdYZEhoRWRIWEdvMXlzZ3d0eFZYcDRFa2JqQ3Fva3JUYUhNSDhONjUyZ2xaRmNteWNnQ3BJY1ZXVTBDUW5HR3VKdjBzWThhVVZyMlNHS0xYTDFEODdFYjJ4WFJwUDhqUm84VVMydUtyWTA1QlNjZG14RTZxK2krM0wvZkhjbzRPZjlEQkJWV2kzVWtGSm9nQ29pcjNmeHZDSitlcWhMMTMvOXZmLzlIMDRWMGV6ZVNXQU4wUm1kZU0wYkxSc25zdkFqOHp0UVMxd05VbXRhWXVES3BzT1IzZ2JGTERyYzZrczlucmtQSCtEdEZ6aGpZQkpDNDh1UUZXWVZxMmdWT2FJVThZN2hxYnBXK1dHSFRSSlhUbzluOHU0S2lDNC96QzhXNjhuNzlickVUeHcyTm9FWm1aVytybDFDN0RUU2hRNmd5YVFQS1pOUGRMNFQwR1Z6TE9WQ2MyK0JIQ1p0cVlQaVZLWlVoa0FzUDdJUVZwLzVLQnordTkvMUNsTm5PRCt5NzhaOUYvNTcwSDl2UHNEdWYzMVhxNzVYa05PZGlzNjBJcmFSUFg5c1hQa0ZGU3B3Q3gweHVtRGRjajQ4bEIvMzROOXRmS2JqcDlhMkxYZWFpRTk5TGxQaS9sSWFpTnoxVm9DS2pDenl6TU8rRk1BR0U4NGN5bW9TbXFteGxXcCtnT3BjdW1rd0ZJNXFwOEwweVYyY08zeVlYeG00QjZzQzgrdzJWYVBiRm9uWGgrQVBRRE82cWQwOGxhd2RzTnVwSHk5T2Y2T2xoeC8xVGwvbkRLRDlsVFptRjZGd0NCWGpQeEZRWldOcCttNG85RlhYbk9FZ1BTRTAwMWNsVHl3Wlg0MGdKTUJQbmY3aTZUZzluQTBkeHRYbFc0TEFKQUNBaVJueVVQSGRqb1V3NDlOeGxYSlc0RHBxbFVvdzJBSUJuWXREcm9Fc2dNbzBobzdWdHBEWEJVbmJSbnFqZk51VEQzOGlQL0laUmU4L2F2N3p1cVRUTzdSYkZZQi9HNlVPcnZiZ3pmTk56SGVqbDlab28wRGdpR2ZQV2JzOUpEQ0FDREliOU0raitpcW9DSkxteG1nM0dDN2dLVWsyL296cWJML1VCdkRIdzFPMFNvNTZrUXBkUkVaVk9rMFNQS2Q0cXJpZ3UwclllbFlsblVxZWVjSDRYL2tKclQvN2tjb2VIb25PaDRkUUZPaHVLcm8rbHpFVlZtM0FLMDhUa0VWcDNJNnFGTHJuT2IxVG8zVG1VKy8wam56NlZjNmxSMUhlZmlHejNoRDE5M21pL3BLWEhUcUczcUlxNG9yS1BjdEpyQ01kd25KQ3haazNkRVlNMzRZeFdCZ3puWGR2NXJhTnZMYTJibjVLeFpXMWlSUVpXNEJxa3NONnJpUEp3ZDFSTE0xcjFwVHhnRi9PMENNeDUzVHlJdXJ5dG9DakVHVjZpOVVHK0lVZ1ZFTnFuangwZ0Y4ZHZEQnFJNWI3d1BUODg3bzFRMkxPRXRISHNDYWh0MDQrYnAzZnI5ZnhxQS9ZTnhjVy83NHBxVmNNNDhhV0JOZWIvZmxpU1RQUGV1TzJ1eWdHWEozMWZ0S1lIQ3ZjVlZTbnFTZWtzOWhBckR5NUg1bi9kaVVFd0dzekxncWFGdUFzcE9pY1BWS0JWVVIwS0xvTWF1MFhxVyswK09PQ2F3MEp3MFVpcXVLS3hrREw0NmNJMFhlWkdLbElVcUJNQnJjQXJZNDhWS2FIVWFENjNiRzdhenBaQkd3dC84Ym43cjVFemU4QnVmK2VEdUE4R2x4ODA0alcvNmE1WEVjWGh2UlpGRjR0U3FMSHFiMDhRVTAyYVdyL0hJb1N4TDAxalhrckZibGpkcVlMNjFXeGVkRmNuRHowRFI5cVRxUWdLTk9vRW8rQS9MY243MEZtQlRLdXQ3a3pLU1pySytZQlE4Y2d2ZkJOMVA3RTY4QzFpdklQVHFBcHUvMHVDcXJmVEZnaW0yU3lnQ2cxam1TMCtzV3I5YTNUa3pTaVErOXRUVDcwVGU1ZzFkOTFSKzU0VE4rYmM5ampHNjNBRlB3a0RRSFN5TXBpckhqRkg5Rkgrdld4aGlsZWF3QUxnRHd2OFpIQm8rVnkrNFB6czR2aUhBUTJjZDM5cndvajVyQUtpdURLbkJLSVREMis1TVFZRHpxekVhdHdKb3VGVlNsSmN0bDZQNUpuc0JVR3diOUFWeXp0QnRmN245Y3kyTTdGNlZsOFE2ZzJienpiRzBWbnJzVnJQMGJZN215NlUyVEthb3VHNmlTOVV4eUgyeDZ6ZkpNL2ZtVERBT0FSOFFQMTJvbG9lWFJuS3djVjZVL3FaaDBvMlRHM0ZldWMwbkl5K3pSWmVMSW90bURMSHdKVkNrMFFIdHFEWGpvYU5OTmRDbVZrWTBzRmxlVk9HYUFXWEo0OGRqc2E1ZG9lSzB1YlEwcWZpZTY1TFJoZEs3Tks2VTNKMzNwbVp3L2F0ekFiZnM0NzB2ditvMS9lTjF2NDF3ZnplWkZBTjZFYklmUWk5TXdhZnMyR25qUjBsVEtLUWlxMUZUZW1GSHB1OWpGQy94cVNtT21zTlBFUGRHbTBXNUJRVkFWbjU5eUsvaWxrWDMwbEZOSnQraVV5U3NaTjhwWmxTc09xblJlT3NaVHN3MXc1N253UC9WU3RELzRGdksvMmVFelN4MUEwM005cmdva3Z3NUc1ZVhGVmNuMUtBS3FiTGJMSzFxRTJHRXgyQ3RoL2l2WE9RdTNYK3ZVcGg4UFJxNy9uRGQ0MWUyK1U5NG9IRmNGaVErMmJ3R0dEOTZVTlFmWTVneW1jQ2N1RFNJcktyd0FBQ0FBU1VSQlZJSUgrQnNEamZySmNzbDV5ek9uNS9wOFAyMmNicllBWmFxeG9rV01PSzRxN1VTYzFHNlB2dzBFeHNQT1NhbGpTemM5S1ZjdFU3Vk5udGQxKzlXVisrM3RiYmgwZFFWMzFvOWI5TmpPUldrNnI0YndWVlJQNFN3Y2RvRFZiSllRZmdla3FQSGQ4M2UyeGd5K2V1TTdkUjVZUVZWOExRQ01KSzluc01ucDJsaVQwSzhNdVlkck5iY1ZMc2ZvcTFHRjRxcVVnWVowemlCT0I2Vy8ya2NMOTE3bXBqRUtyT1RWSFpndHJrb0ZWVklUU0RGUzVkVStxcDhaRmJFVGpHK0ZBcXEwUEdtRkpjY1p5YVRnQytCNHRZMmk4cGw0Y21uUXNZQ3EwRzZsZ21xRGhTbXQ3UEIvK3NOOEhhV21hZlpyeXkzMy9DKzg5VC85N1k5K0RPZjZhRGJMQUg0UDZhMC9PNDVrMkMvaHBqTjdRYUIwT29EUjhCa3BuVzZPSVowM3hTNnU5cXNLQ0FvRklwQkZaTXR1YUxhVmxkY3FBTDVlN3Nldmp1eWhSWExrQ1M4Njl4NVhKVDB3Wkt5RXhXUFlpT3RSZ2Ruc0tOb2ZmZ1BhSC9vUjRwUHhNNmJsS0FDYU11T3FaTG1Db0Fra2oyazIrTkw0VDBHVnpMUG9WZUtxS09VbGJhbmJad05Wa200RlNNSlN0elNmUERXb1AreUJEa2daNnpPN3hiRmJmclo4NHFOdjV1R3IvODBiZWRIbnZPcjJZMkZndkxSaXBHQy9hSjVTN3IvU2owaWFBNVF0UUN1b1NteU5yZ1Fucml4eGUwOVhLNlcvMkxWdDdNM1BuRG85dGQ2S1g1YVpWb3kxZERyT1RSbU9hNkxFVlRIMGtTWG5uZmEzZ1JEZ1llZGtNaWt3OUR5NlR6Slh6MktlRExSczVlNWYzNDBGWnhXUFYrWTFHVk4rYzBCckI1ck5VNWlaV2NFV0gxa3JXRHNSUXBTaVJuZkhGMHdZVTk3ZW5vNXVPNmlTdTJWMm1USVNtQWpxRUFsY3k1b2sxQzZaUDVrWTl0M1hWeXVyVHJhN3VLcHdFS3FnS3QxcURBdWErL29MWGZiYzhNM0tlYUFxZnN3S0I3L3NMRGtDTllwampKMWY3T3lHampiZDFIR2xGWTJjWjFMblRuRlZBS0l0d0RSL3RNSVZPeEZNclBZNzVjQWhSZWxXeFZWSnZpSXBNRXA3dGVXTjhnV2Z1L1pYYm5uclhYaHVIRDhQb0ludW5FVjNqcVRFaERmTzdVV1ZYYVI5V0pmVlV5bzlwSmcwRzMwN0hMelFyeUo5b1hpcUw1eXJJaUJzZXltcFJWL2NpYks4Q3BDTXRJL1ZSL0Q3UTd1U2Qxc0JkdEFVSCtHd1NmbTZuTHhhcFN3Z3BYTFNXTlp3a0NMSDhPKzRCTjR0YjZiMnY5NEllRGtiQjFtZ3lWaVJrUXJNV21teUFUTURWSmxsWkFLdThQbzVFVmRsQlZWSlBnWWxOeVhOWjN3M01hMGJFeGpCZWhXbmI3dkJuYnZ0QnJmdjBJUCt0aC80ZUx0eDhFRS9yZ3BqODNGVmVhQXF6WnYycnlSdjFBZVhYT0c4ZjJwODdGVW41K2N2WFZwWjBVWjBXdGxPVzREeVN6OFJ1MUxLemh1RHFkMytObmp3OEpnenE0MXZtdzJwZnBMMGNzNDJwYjQ2ZHZIcVBweHk3OGFpMDliS2dIYmRxOCtNei92UWJONjcxUitFemhycHNkTXZXcEh1K051OEJnU3JBQzU3L3pnNktMdlJVbUNWNXBnTStnd1pXRk42ZzVvOE51UVlBQjZzMTh1aXg3Z3FCaVc0Ulg0Ulh0VE5HUUFFRSthK2RtMkpqQ1g0NkxwQVhKWGtQTk1ZQThWWmdhdkxBNks2TUN5ZzBYdUpxNEtSSjNJT1VmNWF1eHh2RFhMaXBaSUdTeHRKdnhGSytYRTc2eXRnRmxBVkgxNTFaYU44d2EwMy9zb3RQL0hjQUZmTjVtRUFiOFhaY1JycDlXdm5kMlBNMDc5a2tOWDc5WlRkMmRqcGpFbDJjVTFRZzVBZ1VYcHpGTmtRVTVNK2FsTXJaRkJscTUyVURzQjQ5OEFVdmE4eEFZTDljemVKRlduM052Z3FDRXU2cDAxT2lkZUpweVpUamhGOC9YS3MvK0d2a1g5WHpndHJPNENtNzRpNHFpU1BoV2V6VDE2Rkltd3FyaW9CVmJIeGNWN1c5SkJVTjBSbHhyb2tPZ0NzUG5MSWVlTFIzM1FhaCsvM3RyL21ZNjNhcmllQzhCMVc2cE5nZDNGVllWNTVDekEzYitUcFNDdkRJOEwvbmhnZVBGNHBPYStZblY4UWVsd1ZJNTVNOURFdnh6MUZPV0lucXMydk1xaEt3VkdvYzQ4L2lSVmF3M0d4bUtsZjN3Smt5N2NLMDhHVzhsalNCUUF1QzF5MU1vM1BEanljdHRKWjhaazFoTHQyeDdDRlJ4YkEyZzI1a25hRHNxNDc4N2UxK3hIZkxKMmZENnBVT1JVVnEyV01kL0Y2QmoydlRWcVY1Nk9Wc2p2dk9nTFNJQ0ZOTXFGTGl5c01BTXpLRjkvbGVrdnZZZWFsUnc4N3Jia3hDbGV2RXFlZ2dDcUZCaGh4VmJMems3YjFXSDZkUStPWm5TNG9YbVhxTGE0cUdiY1V1d1ZXRzRRWUZHNE51bkYrdlZrTllHVUJWU3czdU55NGNWYkpTY1lrcjdyYUtsOXc2NnQvNVphZitDcWVDMGV6NlNKOG9hajhrTEgxVHVPYTVRa2NYQisxOUdYN09BaFRlZ1BtOFdMbkRFeXdnMnVDR2h6V2I2Q3R6Q2dYczdLU1ZRaFV5VUtFTlJMNFA0ZDMweGVxQS9Ga1o1VGNDVlNsNTNCTTJBQlhPc2JOTFVEYm0rRDUwVDFZLzhOZkplL3pMNGIxNkFDYXpMaXFTTVlDbXM1K1hKWEJpOGF6WmwreU9wUmhuN0VLdGJWeFZYRStaZXRVVzYxS1FKVlJucEpPT3NMS3crYzVqLzd4YjlVR0w3clRtL3lCZjJwVko0K3hzZ1dvKzNwTDd5ZkljVlVoVTBqemxwSTM4blRTdzIxU3NRUUtSZWx2RGpiNlRwWkw3aHVmT1gycTdnVkI4b1NlMkVBTTlaTTFZYU9wWVFLczhHS2FEcXAwMmZPOFhWZ3JQWW9GV2t1Y3Z5bVgvWXRvc3E1aXBkZkpkZ2dZZzk0Z0xsb2R4VDMxV2F1dXJmT1pVOUVMU05ld1JVY1d3TksvUDJnelNEZXVPSC9VNnpmMEp4SUZRSldheDVRZjVnb3FIYlpFZEk2cHp5eGJPdTd0cTVkazRHUWRhRWpuREhNTE1OVXBUUVpLZXU3ZnJ5MFJLUjlkVFZ0SkFWV1NhUmxiZ1BHSVZWYkFDT3kwS2xSZEdDSjVoU3Z4RXVvc2xSdFh4WkpUTXA2UW8zcU5yamFja3UrcXpkd0pWQkU2eGxYRmFhVVpvem9FbGJWVzZZTFB2L1pYUHZqV0wrSzVjL3drZ1AzSWZ5V0RqVmFjdDJlamdldVdkaWwwMjFXWTB2dDhObzhwL3BsMktqSElBdGY1OVJCYzVZSXFJMjJBTEdzZTBoamg2RHJwbFBEMjBUMzBVS21tclQ2cG9DcktrUTJxRlBsaW9Nb093aGg4Y2h5dGQvOFN0VDc2UStabmF3elFKS2ZqTWNsMlVDWExGUVJONFZpMDU5V0JSd0txWko1RjczTXFya3JLcDhkVlJTQklMVFAyaVhIL2xmWEdUanIyWDVyZXhYc3ZkcGNldU5BWnZ1eHIzdVFyUHJGUkhqNnRQMWgzM0FLMHhWWEpxMVZTbjAwcUtvT3FxRVlSc0F1TmZycGFMdjNQWFJNVGIzaG1ibmJIZXF0dGdpcjVCaGh6bVVrUHN3V3dnU3I1TEFCYzVPM0cxOTJIc1U3cE82czZ4VldaZk5WdnFkdUVRTHp5dFg5ako0NlVGNktYa0VMS2J6c1hwZGw0dTlGc2Zoc3pXL01oRHhOZ05ac2pDRi9DWmQ2WTdPdnUrRU8rdG9LbHo0N1NPUjlVcVhKeGVqTG9nM21UZFIyMnZEbzlzNndIYTJIOFZkVHJwYzljZEk2clVvQlpQRWdUZnhBdUkvdkxEVnA4NkFLWFJLQnVBWWJDaGVLcTRrZE03ZVdqVEV3QUJTQUNHaWNuSFZ0Y1ZRU2lDc2RWbWZFZWFXVUJvT1FMR2w1dENDUmxTYzJ1elY0Y094NnRvWXFCS2dDUmcvTEw2MTdsL0Z2ZjlQWVB2dlZ6ZUs0Y3plWmVBRCtOenVPclc4ZVFubDBtdkhKaFdsa1JNc2VCcmQvYjZUcW9rcCtBWFJDdTlldWhKNUY3dE1WQ25aSk9LSkNpWnVReS9uLzIzanpNc3VTcUQveWR1UGN0K2ZLOXpLek1xc3hhdWw1WHIycGFTd3RhdXl3K0dSbGpNR1lHMnpBRzJ3UGVQcy9ZTFByQUhvek5qTUY4MkdPRC9aa0IyY0NBemN4Z0FVSzJCekFEc2xtTkdHRWtZWkNFV21xMUduV3BxcnRyei9WbDVudnZ4cGsvWWpzUk45NVdWZDJVNS9QOXZzeDNiOFNKRS91Slg1eHpidHdrY1ZpMlB0N280QnMzTHREMW9sRURWaStQWDFVb093RGdvSVBoRDMwdERYL2t2d2NmTHNXMW5RR2E3bG0vS3Bjbmt2TGxBSmNzWHl4di9rRDlxbHc3U01BbzA4QTZTNlZna0h5ZWJBcGw1OUwyYjcraDNQbmRKNHVOTjc1L3RQV08vK2U0MGQyVmJpRk9QTTN0VndVbWtKbGUwVHdtanJZcUREaXRseW1QYUFyZUt3cjFZK2RPYnY3eEs5dlhYN2wzZUloRi9hck1iMnBtck11bkZCZzF1Y0JyeDMxOHNQRXNLbFJUOGdsaExOS0hNQWU4WEVoc1RqU1ZKN3orNEg3OCs5VlB4TklqdXI4YjhuUVp3Q2FBcTdnTFYwNkROYS9UN2UzRkt3QzlxbXVha3libkU0QlZIUkNsSFo3dWY3ZDB0MWFPbE1la1RxcUgxL0xiS3dwMXVkVXEvZm92a01KTXY2cUVwNW5Yd1Ridm9uWSsvdXJDcTRvdFVlUlhCUUFxbUFCVHY2b0FxclFWY01tT0Rjd0t3TklOYzJyN25maFZ3VFpDSUJSaHRvQWJCNzNDZ3JiUUFxbTJ5alV4aVE2WUJhcmcxL3NRUVFDclNwZVAvY2R2K3ZvZisvUC9EdmZLMWU4ckFOOEdNKy9xQXV6T0JFTUllOGZ1T2F4VzdleFluaGRVcGZ6VHR3L2RPSGhMMVVIWER1djhySW1mcHM0c3VYZDFtVkF0elMrMVYvRnQ2MzA2SXBPdDJQbG50VlFCMTNBdFRDNk84L2xWQ2ZERkFLb0N3NS80VXpqK3Z2K0IrUHBHS09RTTBEVHphSVVhcUJJOFV2Q1ZncW9rRGhBQUl3RlZydDJ5b0VxV2J5TGcraS9IcjByS1B0Y3ZVbTRtOXl6N1JXaTZHRnJoeG0rK3JYSHJ3MjlzbkhyenJ4NXZ2ZjAvRE12MkFkK2VYeFVITVpZQlZSUkFWUUQvMHQ1ajUwNUZ4UDl1NjhSR1JYVDlOYnVEZ1cxUU43UENMS1BrMS95UFoyRituV1YvNXhjMWFDeHpHNjhlbjhYdmxCY1IxbXhnbWwrVnpEUGtFVTUvNTVTSDdjU3VYc2JuRGpieDI1MHJ0VExteW4zNzh2UU0rdjJidUhoeGpEdThjZ0JMSHM4d3JWQzNGNzg1V29hQ0FxaHVIb2s3UGhYSkxLaHpBOEJjTFNoMHVaVk5HNGZWODU0ei9QZVdPNDJ3MDNYQzJQeVBCYnFoeVlFcUlFd1VnUTg5L3RoNytwWG11NFBBYmZsVjJYVHNCWlVLZ3NVSmt2YU56YUlZTjhpQm85dnhxL0lGaXdTbks1U2hiNDVMNmgxMWFoK1BaamdUb0pSS2lDVUlFQWxweWRkTEo3a2kybWJuaHo3MDNuZisrRmYrQU82dDY2c0FmQTVpWVFOeGY2ZUNBVGcvN09DSlFYekV5aUltd0NEdWsrYzBIc0FUdW8zVFhHWkxOaTJIREIwUk0ydUNHKzJaVWpFQS9NdmVKbjNmeXBtQUY5endReDRNU1ZDVm9iUHpiejYvS2orZDdEWCs5Ky9BMGZkOEErbG5MMWdDRHZNZ0E1cnVDYitxeVhFbTNNMGpDWnBxZ091bDlLc0N5QjB4STlMVi9hcU1kUEo1eG1YSTVlOWxCYVY4VXhrYXhRR1FSejFRaU9OeGlhdnZmMGZ6NW0rL3FYSGZIMy92MGZvVEh4cjZhdHFFZGpEenZINVZOaDdPQkRnTlZGbXh4eVRXalY4NHRiWmVnZmh6ZHc0T1FzVkN4bGdFVktYbVBOUGtPZ2tCMXZVS0hxMU80ZW5peFF4UFNSM0tFWmRINWh1REtsa09BbkRoK0F3dU5iWnh0WEVZcGJzVG1Wa1BJd0NuQVZ6Q0hWNDVnTFdKeVF2QXJBTE9qbmNPN25GSEJycFluSE10WmxwZURPQ0VibVU2clM2dWJ5dmNkUHBUblU0VENLQXFOUUVpdHhPeEQxNWJKYk5nZjA2V1NUNHVzZi83RDVlcDc5VlVFNkFyZ3dSVllvV1JKNys3SmF4ejdVekJwTmt0YTk0RVNKNCtDQ1dmcDYrU0Y5YTJFdEdPVCs2VU4vWlg1SmxYZGIrcUZISFdlSWU4V2VidDAzckJ5d3lnT3ZQTVUzL3ozMzdSbjhPOWRQWDc1d0g4RlN3MjBSY1RHb3FCTDk1NUFKbkQ4YU5ybGdsUXppZEFkTDY0em5PSlY5aFA0TlJ6NG14NHJrU0Mwb0FzOC9HblhGbmZ0WEthZnFTM1JYY0lxdXd2dTRYTFgzbjYrbERrNS9vNC9GdmZUdU1QUGhtRG5nbWc2Wjd5cXdwelJRSWFBVjVDWENSblpQbHlvRW8wMHN2blZ4WDRaLzJxTEY4dnYxSytwaTN5b0lvQ3VNbVVKL0pYclE2WDZPSy8vblB0blk5K2Jubit5OTR6YVBaMmJNRWNZSjBNcW14MDVGY0YrMHpKUENYMmFkaVZUUjV5N1VEYUw1NWFXZGNFZm5MN1lOK3ZyenhEb3lSajVBbnRnWTZUMURJdDQxeDFFdnMwd0dXMUxmZzZ5cnhmVlMwL09ZQ1Q3eGxLUGs4TytuamY2aWRmNGsvcHJOdXpzYVRQMThMWHl3K3dKanU0MStubkFWWHB2Zm4yb0VUR0tjODBiUzYvbUVhODhqWW1vbWVXV2czRkFmUXdBalp3TzE4M1hZdzhTRUVWQXdHRXhlOUZNWGozMDY4bzliakJYcWhNQWxVTWdMU1o4TUt2eWd4RVRuWnFGcDhZWWNIbDRiSnE3cThvdHFDRjRBU3RLOHBzdnlwNGVpbFFFWVE2Z05hNFFjdkg3ZUQrZkZ1Z0NrQmlBaFI1aWdoR3RYcjkxb1d6UC8xRzRBMjR4NjV2QU5EQTVBbCtPMElnRG52NzNsbWNHQzlseG40NnRqSFZyOHFPMitoWjhsampBcSt2T2xIYzlKbFZ2eWJNUmlMV3JFbWx0UC83eWhiOWk5NG15WmRFVXRBa3p0YWRCSmJNMEpQNTVla3dpVzc0N3EvQTBULzRadUtqTnFEMFJORDBYLzJxWk4xQzJWOVd2Nm9jWHlSK1ZSQjh5TXBsQVNJcHlqdTBaZVFQYTJsMlAvVjQ4WWwzL1UvZGMxLzRzMGNubi96QWtCSXdRbHpmZUUveXF4TFY5cDNpWnFvS0hNVHNaVENiZFlFWS9Dc2JLeWNxa0g3RHJmMDlKT1VJSFJTdGs1eUVRMmlyVWdtUTBwcjdSNnF6T01RUmJxb0JndWJKVWRYOXFsSVRvSHl6MEsxamFWNEEwTkZ0dk81Z0U3KzEvSUxnZFhzeWMzcmNXUUR5Y3owTFh6SEE2dmM3QUp6L1VpN0RXUVdhSGI5V3JZakdydE9IQVRXTFYxNUVyM0E3TTVEcUMweWFuOG1VZlpMNnVTQUF3RTh2dDVzVlVZUVZVaE1nQUtpTVgxVThJZUt5aEcvR01POCsvWGhKWGhCNElUaVhYNVUvZE5RTEZiQVFqdDQ1dm5QMVRBazRRUnNLbU5GQ3hZTFVBUzJYSkFoWWptanNkWEovdFhBQ3J5NDFrblN5b2FVcXd0UWZVWmZKTXRnYjNSNE1seDc2d0R1KzRrZS82eGozMHRYdnZ3ckFXM0Q3RTMwMi9lblJFcDRjbkFNaXluVE14N3h5b0txdVE0NTVOT0djMmlsS204OGhGODVUNlJnZzBwcTE4dFBxUjN1YjlJTXJXeFFPRDQxQlZSb1dnNmJwb0VyUVlScWR2bklLaDkvNkhUUjYvNXROb0xKek13VlZqc2tNMEhSWC9hcEMzSFMvcWdna0pYRzF1c0RmRjVyUUhKZG9qa3VVN3NVYSs1K0lZMUZwZVRNeGo4b1JSbzBSeGtVVmdTOXloUStnNXVYMXEwcnpsS0RLZ1NmYkpreXhhNFNOa3k4WmhZMHdBQjYyNk5MUC9hbWxuWTgvVWZhLzlEMkQxdXJOS2dWVjg1b0FIVk9TcTVFVGZ4UUFtUTB6bHBTd2YrVmYzK2lkcUFCKzg4MzlYZDhJVW9nNnRPcnlNcjlhVUNDNXE1OWxKYkVDTWVPVjFYbDhpSjdCZ0VZK2JwcGZWV29DWkZHbXVNd2hId2JqdnVFbUxqVnY0Zm5Hb2FCTDAyQkczQ3o2RHZyOWxUdjVHSFNxd1hMYXEwbUZtRlhJNmZFRVFxL3FabW1tbS9WQ2M5UEVlUFBjc3hxc09zMGsza2s0MWNQRURIbXFzOVEwZ3psT215cGtKRDRVWVZHWkJUYUplT3c5ODRxU1NBZFFKWG5OOEt1S2FJd3dEYzd4bGtheDR2YU5Vd1c3SFdGOUYrNExIc0pkMlIyOUY0WmVhRGpVU01RTVppeU5XbXJwdUtXY1VCT1ZuK0pYWmZQMytuTXhSS0xQQmJOb1pBWVRjL253Qjc3MTYvNlByLzA5M0h2WFg4WGRQWkloRGlNQVg3THpBSlRmWkU4WTM3V3hQZWs1ejRNQXZMbGF4dklFSTJUNlBDa255dERXU3NBTUVMMjdlNUxldFhvNkFsZnptZ0RUSVRhQnJqWVVBNTJwOHZCbnZ4aUQ3L2pieEh1OUd0ajVMODZ2U2dBYkFxUFVDdDNqRmxwVmdXWlZvbGtWMUt3S05NWWxtbFdCNXJpRWtrdTV6QU9vaFl0bnQ1ZUVWb3hSWThTamNvUmhZNFJSWTBTamNzVGo1aEREeGhDSFM0ZGNGUlZ1dzY4SzhHOEJpdW1RMjVoR2NRQ1UyUE5ac0Z3ekFaSnJzdERPVXFNbGdXbmtDd3ZHL21jZUtqLzVROS9VTy9QMlh4aHN2dTQzam9rMFlsQVZtd0NkNkxOVEkvS3JRcnd5dWZPM09HbHliemFFV0c5K2M3MjNwb240clRmMmRpREJqS0R6bWlNWk5pK280c1NVVjdMQ0UrUHorR0RqV1l5OVJtbzZxQW81aTQ2cjVaT1dCM2p0d1hsY1czMGFvMlNSak84WGw2Zng3Mm4wKzN1M2U4TDd5d3V3aklPNzNQbk9ycWlaYzhsUXkrYkRhS0pBbTh0RTlLZDVKZUU1OVFsWWxGSU9Panh0am1kd2c5dktnOWwrVmU0S0V5SUdWUzU4OE1KOXhXaHZsY3pIbmQzNFJ3QlZZb1hKK1ZWNVRSWUFCTFVZaUxTWHRPMGJtNlhTaFFkY0FqQjVZZTNMV05kb1pVRVZ5QzVvUVlEeCt0NWFJU3NjODRiUG0yWGV2bEhjZ2hDYkFPRXlsdDFQWUgzMm1ZOTg4NDkvNWJ0d3IxMzkvdXNCdkJaM1B0RW5oLzJodlRNNE9lcEdZM3lTWDVXN295VE1QRTJZSS9icE5Yb0pXek9kMnV0Z0tjKzFUaUhvaUZpL3AzT3krS2RyWncyNGVvbjlxaUxBNVFLM1YzSHdkLzhPRFgvaGo1ckNHWE84SzE4ZVZEbkdDNEFtcnpYSnBQWEFLWTdqT003UGxaQW5SUGxzWE1tRTduRUx2V0VUM2VNbTlZWXR0RWVOMFBRSjBxeDFrMThmeFpVTDgvUGFaVTFvRGh2VUhEV3dmT2dvN01DMGxSczJqL213TStERHpnQ0RwUU0rN0J4QU4wYVkxNjhxYVF1eGNaemhWeFhhTmZLcnN1bUNqSFliendoVWlmekNodGJLUW9JZWwzaitGNzkwYWVjVHIycjB2K1M5QjB2cjF6UnhyZm1rWHhVQXYzbXZnNnJRVGI0aHBBYk10N2NESnFiNC9NRzE1VlVONkxkZDM5c1dNNDFkSHBCZG5jYUhVQlowQUNPY2Z1MmVUUUVZYlc3aE5lT3orTS9sYzlCeUFFL3dxNm9QdGRoSGl5YlF0TG1KMXgxczRRUGQ1NU80dXlsakN3QWJBSzdqTnE1RkFkWWswVHBmL0paWUJDaWJMcDkrR3FpU05DZXMwNjJNeTRFdEFCa1RZQjVVaWFlYmpWTHRGWVVLNi81MEU2Q0xDUm9zbGhNcDJmQ1o4TjJuWDFuUWJmcFZBWWlkUFNQdGxtdDNqYVZyV3cwdjhHL0RyMG9LVmZQR2o0MFNLMkY3MUZTdFVkTnUyWkl1Q0ZzdHdUTVVjUmFvRXRpQlFRemRHaHgyem4zc2p3SnZ4ajE0T2NmMk81M28rYmlUNHpiZWNIRGVQQ1dnNm5aTWdQR2NDbmQ5M2NSakU1M2FKVDNQUVRPVDd0OTBOdFQzbkRnYjNwYkhSTERrRmhoL0xRNnFBbzJMSC8vYUg4TCt0LzFkMHRjM1BMQjZPZjJxZ01RM3lOelA3VmVsUUZnWk9qRFZvdTZ3aVNVTHB1U1ZObDZ0TzdJQUNqWGhKZWFwZUJJYk1FL0ZvY0VGaCthb2ljWk9nMVoyVmdFeUZLUG1NUTQ3Qm13ZEx1L3JRVytQUTN2WS92UWJUeGFOTnI5ZmxTbXk2NC9RemxsUUpmSnpBUjVzcFM0YlRpNFNZL0Q4K2ZMcEgvMzZsVE52K2FYQjFodi80NUVYYnptL0tyY3lVZDJ2U2phYTFYQjVVT1Y1ZU4vZ0lIT0l3Yis5dXJ4YWdmRDI2N3MzSmtpQXVvd3lNVks3cFJNWkVrQVZDeG9BV09WbHZLTGF3aWZLNXoydmtEWW5EME5ZcXEzS1BUdGVaMGJydUgrNGplZWE5YmNtcDh2VFhOaWt1SFgwKzl1M2MyeERDckJPM1ViaDVvOFBEdTUxQUNOLzYzT2FNOCtTaC9tZDZlQ2VydlFJblpVclV6SVFMN1dhVFRPd28yenJoOHJaU09sWDViSlFHVkFsZWV3KzgxaURuRmxQQWljVm1tQ1NYMVdZNkZ6YnJUa0JvVVpORklNdU9XSHQ0b04wRVFJZGlHbnM1VXlBQnVHRk1zcDBLNE91aWtDYnI2eFFSWEJJdzBqS1VNdmZKUFZiT2VYTHhZMEhQL1QzL3ZvUC81VWQzR3RYdi8vNUFGNkJsK3JFZGdMalM3WWZSQ0h3L08yQnFqaE5tczhhSzd4ZWQrWk9SVm1hU1hjMXVwOWRYcWQvZU9JK2xkZFMrV0ZTUDFJdFR6YzNxQ0lBUE9oZzhMOStNNDUrNnNzSnhDQWxyQnN6UU5NZnRGOVZneFhXQngxc0REcDA0bkRKRG92NnhXbWpJT21PdVVHVnE0dmtFWjREUlJybUc5d2ZaRnlMSjZBY05kSGJhVkJ2WncwQUNsMVVPT2p0OFA3YUxUNVl2YVhIalZIZXI4cnd1Qk8vS2tpTlZzM2tLUHJQYlhCVFVBV3grU1V3dUNydy9LOS80ZExCQytlTEMxLzhVL3RsODFoSHVOYUkwN0MyMklaUnBvblk1MlhqNnRvdUwrODlWekowekhhdWZHUzEwOVdBL29KcnV6ZVJncFo0VFdYeFBEMCs0a0VTQURGTzZ6WGMwanQ0VWUyRkdrVnlqQk8rK2ZKRWI0Y0JvSWlHOGFyQldWd3BQNFVqRmRQTkowL25vU2NZYkNTZDZ1ZTZVb0IxOGpZS05YLzhhc2IveWhRL2JXUVhVK2N4VFFPMndwa2pHcWFBcWtDWjN0WHJ3K2I3ZyttYkhpbW9FaGpEeFVmME1rMjZLeG52OTlUUjFkTkZPUDhxTkVFV1ZBbUJIczZmSVpZNzdjUi9nRnZiNjQxMEZ4YUVvaGZjN05LbWZsVmVMZUNCbkUvbm4wdE50SHpVS2R5ek53RW1vQW94V2hYbHNMeENtQ0VTSmsrWHY5NzYvWTkvODQvLzZYK0tlKzB5aDRyK1JjVGorRTRuZWh6Mnh2MHRiSTFYYXFCSzBzVWM1TlBrTlBLK0FjSmJxeTRLc1FUbVVzWHpLZVZXTDBzOVJ3YUFuKytjVUg5LzdYd2hobmNZZ25mRnJ5b0dYbkpkSDMvOE1kNS81ejlTK3ZKWkE2eVNPWllEVFF2NVZXWGl2RVlxQlZXVDQweTRuVWRMVlltTlFRY2JoMHUwY3RTdVlWdFJ1cmxBVlM2ODNtMmljekpoNWlscFhGOS90OE1LTWtDbXI1VkN0SjFpaGQ3dUd2VjIxNGpwZ2pwYTN1ZjkxVnQ2Y09JbUh5OE5PUEtyaWpWYkFUQ1JHd3VSWEl6QTdDUy9Lc2ZYQVNjcjByS2dDaTRQc0R3Z212ZWVmYlR4cVIvL3F5c1BmdG03ZDl0cjE2c3d4dG5QVDdrdXlMWENjZ2xuWmxrVG9HdzJrVmE3cG5PSFhvUEJIKzh0OVJqUTc3aTZld01pSEZKT3BYNVZMbzV0bVBuVm9yUStUMC92T0QxY25jWk4yc2VRdE1pREk2cjhCalF1USt5M0pjdkNhSEtKMXgxczRmMjk1MFY2eWV0dXlOOHUrdjBtTGw0Y1lvRXJBS3grZnhWQTh6WUtNMTg4Z2REVDdoTTVzdk5rUStkL2M2QXFwd0hyY2R2RUxBU3FKdWVmeUpZWG1rMTNlbnUwTnd4Z2E3WUpzSzdxOWZLQWR6NzFlRWxXZnp5WFh4VUVxSUlUMmxJdytGMlpQeXVydWIxUmVIQmtNM2Ewdmc1aUJrY0NYdFhNaEdJaENEdkQ3dUZxQWJDUVNnaUMwb0t6akNEMVpiTEhvZFJ0UDBLd0FZQnVEUTZYem4zOFMrNVIwK0FmUWYyajZYZGpvcHY3RStNbTNuUVF2cnJnWkhnS1kyYURxanAvOTBRQTNsSjFzWXlpeGl2UHRiNUNwblE1R252OTR0S2ErczRUNXdzQWlMN1pDWW5UWTBDVkEwMUFqaTZPbDFpQUFBeC82ZTIwOXkzZnFYRFVGbk9NNWZ6SWc2WTAzdDlEenNNNk1QT0Y5SHpGWEhLODQ3UnVqdmVHTFd3Y0x0SEpRUWVkak5uUFYwem1rWVlsY1R3cnpKYkhEVE1XWVRHVkRKTnpPeG1LVWg0Z0dTd1NrS2JsRi9mdGd5NjFCOHNGWHJnUDQrWXhINXk0cWZkUDNOQkh2UjBIZXU2Nlh4VklSeURLQXk1L0wyUTErVEQyUE1FNHZyV2hudjZKdjdMeXdCZTlkMy8xZ2FlUGJWSS82REtnS2dBckl6b2p2eTI1MldmYlJBSjBXVjdzdFZtZjZDMTFWNGZWOGV0dUhleEVEZTFNZ0tFN1loUGdORkFWcjJ0c1F4Z2xGM2lzT28yUGxCY2p1a2wrVlk2Ry9HOE1xdEk4WE5wVDQxVThlTHlEWjF0N0NVOTVmNmZ5ZHgzQWkxamdraG9zNlg4MUsrUEY0MCtOT2loWStlZFpvTXJSekFKVjdyZUJBbTAwN0F6TWwybUdDVEJERXoxZmFUWktPWEROUUk1QjFUUVRvSHZISzlXQ3VjdThQUmp0a014d2RvbjlaRVhOcnlvSHFxVGdBSUZWVmFDeHQ2cjhJZnFUL0tvaUFBWmZqaFJVU2FFaDQzdURiZ0c0dmd2bGl1Y0g2cUNLUStNSUY3bVlqK0JWM1BkN1AvWjFQL0tYN3NvM28rN3ExZStYTUI5MG5qUVc3M1NpQTErODh5Qktqb0ZQb0lySHNFeGI2NFNKS1JpdjBHMXNjcU1tMmxJMVNjb3psL3Vrdk8zZHJ5MnRxdTlZNzBmZ0NpSXJDWXptQlZXT1poS29ja04wOE1OL2dRYmYrOWZKTTVzQW12NUEvS3JzUEN1MXd1bURIczd1OWFnOXpoMWZLQ3FYTkVxdE83SUFDbldCaExqaHZJQ2NCMVNaZEZOTmdGRXA1Z1JWYVp5N0wwZE5yRjdkVWl2WHR0U29mY2g3bXkvb3ZaTlhLeTVIams2OFRZZzc5cXN5cEJUeGdUUkxNcndsb1E3QUFEMXEwTE0vOTJlNlo5LzRLM1Q2ZGI4K3NFMndrRitWQTE2TUFLcGtWemxRSlR2R2ZuQ2FQN2plWFZzZmpvOGYzRDgrOEdER1VOWFBxL0lIZy9xdnIwd0dyMVg4REFBQUlBQkpSRUZVVlhHNG9WdlhYWnpWUFZ4V3U1bTBlVkFWOHczM0RuRGxlRHg2ZEFxZmFlMUd4NlRlWGZuYlFiL2Z3c1dMY3g4REpHZnErZ0laTGg2L05lNmhEcERxOURVVDM0eTgzT3hiMDAxSUhsUkxLN21uZWRnSlVLUHpOTGNhcFRvc0ZBVVpGUERDQkZCVjAxYXBnRk04dlo4QTQ1TDNMejFRMmtuTUNhaVNnbGhNVnN0YW1BRHQ1SVk3NXNHRW03VGwzbnJwem00aDBYUUE1dktya3RvanR4TzBieDR6eUFpcXBhT2xvcXdLOHB1Y3JGK1ZLN2ZKcHVaWE5RVlV1WEx3MHU3dU43MzNUM3dqN3MzclMyRSt0WkFLQ0NUM3R6ZlJuenc0aGJPak5jU3pKVm1GQkgweWxxZWtDQ0hMVUhpbDduaTZXUHM3bTNzOWpDZUU0M2VieS9TL3JQY0xqUmdncGNBb3A0bEs0NEZab0VvTXlWRUQrOS8rZCtqb1ovNDQyWGswQVZUWkFrOEFYeE8xV1Ntb0NuRnorMVV0ajVvNHQ5K2x6ZjJ1UDRVamQzSGFLRWdhZkc1UTVlb2llWERVa0NZa0RmTU5QZ05VSmJrbG9KVkZzdGpKTHBrT1h2Z2xmQWxvSExkcC9iTVhpaE9YenhlRGpldlYzdWFMMVhGM0YxS2pkVGY4cXV6MFpqRkdnbnNHQmF2Q05JdkNDNy8xOXM3aHRkUEZoWGY4OUs1cURCbFl3Sy9LMGlrclpobmtQQzUwRExROHZUQk9nSDlwYzNXak43bzFQSFU4T29iTXgzUkMwRmFGL0RYaU5TMDIxVGtha1ljUGUzQzhoUnVOUFJ4UjBFaUpNaUwxcTByNTFrOS9yOHZXdGk3eCtPRUtQcmEwVTR0YlZNWk9qbHNEY0FWelhoSmdyUzVRaU1YajE4ZVREekRObVFDbjhjK1pBTmVjZWRDSDF1L3FTd05IUWtCbjgyWUF1TnhxTmluc0pFeHhSWHFwMXBVOHBMWXFuTkhuVmJzK2o0T3JaMG9lbHlDbDJTV1AvS29pQWNBMVVDVlYyMFlRU0pNREF3QTN0OWNMSXUxMTBJdjRWVVhPb2ZDRkQ3dENxNDNxSFhTTG1yWktDa05SVGdheWZsWGlZdEdnVEE2MGdWQ2VlK29IZ01kd3oxMzlmZ3ZBVjJQeU9MNnppYjVTTmZEVy9RZEVTTlJnbnI0KzVuTnhDYVdZVjI4WUc4UGc1TkpJWVR4SkNrekt5VDlmTFJyNHRvMzd5ekZSaEx0cldpclU4TU5FYlZhS0JTSmc1Z0p2cm1Ibm5kOU5vOTk1Z2hBNXNzL25WK1htUkQ3dXp2eXFpSUNUaHgyYzNldlI2bEVia3k2V2ZHU1liNkFKSFRFWHFJckR6RlBhdUdIdWMvd2NwYStWZ2liY3AyWExhNjY4akdBNVlHcmxaUkFyTE44NHBaWnZuRkxENVgzZTMzeStHcHk4VXJFU1p3eTZOcmV5QnBEM0NPZGxTZGtyL2Fvb1dCVmlvQlkyeGhtTFFwRFJ4Tmo1ektQTnAvL04xNjQ5OU1kK2FydTFjbFBicXNsbUNMTGVkb01LOFd3VmJWcHhzS1pJVUFXNEY3eU5DZEFwQkNvaXZHOXI5ZVNmdkh6eitjNVlhOHhyQXBTbU84ZFh4c2wwN3I0QTRYT3FMZnpuOHJOKzRrd3lBWElDdHFTR3JlNEVIOVBlZjd5QnA5czdHQkpIZEhkTC9nSkxpMml4Sk1CYVdTRHp4ZVBYcXZvM0NJRVlWRTB6QWVaQWxlUVhPN2pIQXlMaWs4aVdPcWlLK2RvMHp4dnpZQ3Fid25lbGhJU1pCS3JDaTIvK3RVSy9KejE4OFd6aEoyc05WRTNmQlZrQ0Q2UWtxRExoWmd3MmR0WUxwcG9BQ2ZYeEFnd2VtT1ZBbFJTc2JoRWlBcXVxcEtYanBhRFF1dzIvS2xkSGR1M3I0K3dNSkdiZHZYbmpiL3prbC84OTNKdlhsd000Z1hRTTNhMkovcmE5ODJod2taMHI4Y2lPNHlmRjFld3ZBQjdXTFp6a1JxWlV1WHh5cGMvZDFUZ01pZkMzVDE1bzNDcEtqN056WUVpdTZkTzBXWFZ0RmNjZ3pOS05QLzBnZHI3K242anErVFAyY3plV3p5Uk5sTC9QZ0NweDcvTVBvRW5NSmNjN1RpdE0rR2pxQW1mMnVqaXoxNk5tVlNCMytlYWNCSjVFSE04S3MrVmhTSXpNZFlRYWhjbTVMUVpXUFQ0ZUxCa2c1VlBrZ1pTOGQrSWdlcDlqSWxETHVENDBCeDFhZis3aGN1M1NoV0p3OGtxMWQvYXpWZFU2MGdTQ1B3b24ycFRHY2hBei9Lb2kydHJtbHlOUXhZRFhqcGtqZUJqSDIrdkZKLy90MTZ3OThBVS92Yk55L2xuL21SMnZyV0xScEc2ZEVYNVZZaDJLM2pCa3dCMWE2cnJEOG1VbUJoODBsUHFGMDJzbi81dkwyeThVelBPWkFFT010dmRpTUh1YU9xOFZ2WXgrdFlLTHhTMmtvTXJ4ejVrQXA3L0pHRXVma2hWZU0xakZoNVp2aWpqVTZHNVgvcHByRmNCY3JpbVRBRll1bzFrRm1SN2ZyWnlEZTB6RG1YVE9JY2ZkNTNuSG5kMk5ORmhwSG5VeFg1ZFBzclBTd1lVWFd6VUhkKzlYRlNhRFZMaVl5NkVOQWJiWWhvT0Q3T0xESytjS1pkNGV0SU4xUHI4cWk4WGtEa3VBTGZhNHBEem9LVFV1eVUxMEtVeENuaUo3cXNjSHZ5Ky9DNDkycnIzRDVVS0NLbGpoc1loZkZTQzBZa0lhaUEwUk44OCs5ZDNBcTNIUFhmMytNb0N2eEdLVGVmNkp2akZ1NDlHanJWcGNmU3liKzNUVVI1UTFZR1dlbDFqaDFkVnlqV2VkVjQzamhQQ0pITDc3eEgzbEp4dExGTUJWQUNsdXdaY2FLYXNwQ0VjYVlUS29jbkZwTFlmdmZ3dnQvcTN2Skgyd0RDaWQ5NnVTOXlUMmdCbkFKZWFDakp2THI4b1ZzcWtWTHR4YW82MzlMbWpPb3hWcWpaa0ZVQWdDSjAwWmFhdkNxaHlvUk1OSDgvVGw4NnVDRTVIemdTcnhFUG9tQUVoenI3U2k3dFV6NWZMMXJlSmc2L2xxLyt6RmtXNVVZbE1hYlZ5QkJmeXFRTmJueWREYWM5UEFLYWhTdG96aTdDNG1ZdWhoQzgrKzcwK3YzdmVtWDk0OTljb1BEZHlHWG5ZVkNTZDNGK2I4cWdpUjg3dlVkRGt4Nm9ZUmg3VEUxMXVONWk5dnJwejR3aXM3MTVKMUx6VEVMQk9nQ2NrRHRHQVNaUFNyVTdpaGRyRmYrNVJPUGg5cFpVcjVJK0h2ZnMrTVZ0SFYyOWhYNDRndXZsOWMvb2JmMXJ4YXJKY0hZSFdySmdwV21QWU53alNNMDlrcE9sdk9Zd0tqQWNKUzVJd3JHMTV5eURVV1Q0bjM5MWVialVhMEUvQUQxTTh6ZjlpVm0zdzVVQ1h6a1dyZXcydW5DMFFmRkozUHI4cnRpbktneXBnQURYRmpaNk1SZHRTKytGSXQ3dk5NL2FxQ2hBcjhYWkFGWWd3QVMwZExoU2xyQUZYeEcxbU9oNzJrWHhXTWFjVFB0SmcySU5lVmE4Ky84OTMzNEludDV2b0tBTXVZUEludmJLSy9iZTg4bkhUbUdtMGFYbytmQktwTVo1clVyNis2VTc4em1IQ2NFSjV5cjRXOXQzZXllRi9uaEZMSWdDb0UvT0lYQlFSTVFGTGsramd4dEpHczEvYjM4TjFmaWIxLzhvMEVWdUZjdVJ5b0FsNVN2eW9YVjJpRjh6c3JkTi9PYXRhL2ltVWVVZlBGbGF4MVVRMVV1YnBJSHE1c2tvS2paMEVUTmxKWlVKWGtsb0FsMTZkQU1nU2p1bm5lWE9OTEtVMHNRN0p4VkE5elp5RzRybG0rY3Jib1hOOHNCcWN2ai9iUGZuYU1ZdVJrSEpOaVdMaXlzRitWMnlrRWE0UUZWUVFZYTRJUmt1RmJpSjR2QThDbDMveUNMaXJGcDEvOW53YUwrRldSV0ZjTXFLTUlWREU1VFJoWnJSY0QxclQ0bWVYbThnZFBMQisvL3ViQkxTL3Y1d0ZWYmxFd2FlVEhvZXQvRFBNR3kyUGpMWHk0Y1JIeitGVWh5OU90VDZuQ3h0d3JKcng2Y0FJZjZGNU5lTjJaL0kxL2V3RG1CRmo5Zmh0QVl3YmpXUmxQamwrcjNQY0JKNmVmWlFKMHoybm5NNEExdllTNDRldmRNNWxuMnNHaVRPWjNweXpVb1ZKRWRrRE1Zd0owUEdKUXhhQWdWYno4NUtxazQxc2J5cDkvQmN6dFZ4VW1yVzFGQzZxc1dzQkxrOGIyZWhsMmVleUEyVngrVldhQkNFTFdIKzdIemk4S0tDdUY1cWhwNXYxdCtsWFpGMEJkbE5nbU9rZFM1c2JXcDk4RmZCN3V1YXZmWHdQdzMrTE9KM00rN3ZTb2d3ZVBUNGxSSDlPa0k5cmZ6UUJWTG93QlBLQmIyTEliRlRtSDVzdHBNazNJQVFEd24xdGQ5YzlXejVSS1pPUFdRWVVZVk1sZklNeTFlVUVWMlgzUDduZC9reHI4eEZlYUVSWGVvazBBVnVCWmo3c3p2eXFQRUMzdDJiMHUrdHNucUpHWUFsbnlrV0ZKQStUQ2M0MGU1bEFjRnA3aVowK2QrbFVCRVdpcGxXS1NaaWt0VzE1ejVXWEVMTDhxbTRhemNSR1lpa3kyZGp5eFYrMlFMU2ZwQXN2UG55ODcxMDRYQjJjdmpnKzNMbys0MEhJRGUxdCtWYjRKWS9tc3BWdEhBR1QrT0J4WFRuNyt3Mi9yUWl0OTVqVWZPR0EvM3NIc3FvQ01YNVdUeVFaYlFURkhvRXJNd2VDdnBVMGRGWU0vc3RaWlBUR3NqaC9lTzlySFBINVY4YTliOVJ6dzBXNmpMLzZidUE2MzhHQzFoazhYTjJvOFhKM0NzMjh3bnd0RjRiR1Bsa3Q3YXJ5TWpYR0pHK1ZJcEw5VDJTenZtL05vc1p3R3kybXZwakdjbGVIaytKV3FuZVcvQ0tneWwzd0JNOUN2Y1R1aDhpTTg0UjkzVkZTV3BLTUUvOHZ0Wml2WkNXUkJWV3d1REx5Q1BLSklmanFlZzJ0YmJvT3pzRitWRzhUdTlIZG1NcnN2cjlJR2FOU0FPbHhXc0cvUjVQMnE3TThFVUJXMGE0Z2NRR0ZKMnNQbFVwNnlpbEFQbDg5VXZ5bzdid1NvY25XR2tSZ01ZR2wvNzUzdi9vcnZ3NzE1L1JrQTRVUGpkejZaNDdpMzdkMWZpNC9YS2pHMmE2QXF4SnRtVDlNeldsQjRvdXBPS1VYdUx1VThQWnlCSzJXRHZuM2pmTWtVZ3lvZ2dDSDRJdHA3anNNaVU2SWNZb0tQZXlZR2R2L3hPOVhnSjc2Qy9MY0VJeUNVQVZYaVhpelNlVkJsNWt5VVZtZ3lhbkduRGpxNGNHdWQ1R2RyV09hUmhpVnhQQ3ZNNVJ2eGljTk1pQXdMQXNuSEFibjR1RXN6UU1xbnlBTXBlZStuK2NJbVFMbEhUUUJXQUU4eENIUFNCbDZJU1RNdWdLcWczbWNmYUhTdW5DMEc1NTRiSG0wK1B3NWpJUFI3MlB5NjhWQTNBVHEvS25HVWp0dTBTc2Y2R3FpeU10c2NLZzNtRjMvbnpWMVVpcys4OWpmMlhMR24rbFd4OGF0eW9Bb2dhWEVKb01vMmhoTHd4OUg5eHNudStzcW9PdG84SEIzWlBwQ0NmTG9Kc1A0cEhRbTBvckxpckY3RE5iV0RYVG9XNGZJdjlIZHFBa3g1aFk5SkJ3QklZTHpxY0EyLzFwTnYvQzBpZitlaDcyS0dGc3NCTFBjRzRiUk1aaFZpY254UHQ4R2svY1NZMTY4S1NEczR6MytabTFFYTJUR3hnTTkxWEJwYlN5TU9HQVV3M2E5S2NuTHFXeFkxOXBnRmdjZmhsYlBOYU1ma0ppQjUzYzVrRTZDOUNiNEJib0piUVVDTWN0QXJqU1BuNG41VjNnUW9kL0lHeHhrcXUydGJPdXJFQjVoR3ZHYjdWZG02bW5JWTZlR2tnUyt6MnJqNFM4QXJjYzlkL2Y0bWdDL0IzWnU0Y1ZoLzJNWDU0UWJpTVo3U1oxWTFNYUpqd2VkaWJkc0NlTExxb2hFd1E2WmM2ZE8wMG1RNUhKUEN0NTI4VU80V0phWHp3V0VSZVRuRmo2WHpSYTJ0M1FrZkNKcmQ3L3RyZFBDVFgwSGVtZDJES2x1NERPQVNjMEhHTGVSWEZRRXVNRmFPVzNqd3hnYjFqc05iZ1U0QVpKb3Fxa1F1UE5zeEpKKzQxcUJaVUdVTFdBZFZnUWZIdEVuYUtjTXYzVC83eHJzTlVPWFR1eklGd09UM3htTGo2TFJWanNZT2Z5OUw3TWJOVHcwbkI0dFJnM3JQUGR6cVhEbmIyTC93OUhDMGRuUHNRSlVWdFZsUU5jbXZ5cFUvYUw3c2VrQnVRK240ZWhucjQ1akFWejc2aG1WbzRyT2Y5LzVkMXhYeitGVlowV2tLeEJ5QktyWmRKY0dYYlhyV0lQN2x6WlZUWDNwNSsxSjNYRlZpRFozc1Z5WFh6SlErWGsrcmtKYUJSOGRiK0hEak9hc1FtZXhYWlo3ckg0QU9nelk5dTh0K0Q3RmF3bjNESmk0MWowV2NwTHRUZWQxQXY5L0F4WXNqVExpa0Jpdm5IelVydy9uaU85WkV1SWhmVmR4aGsvTmlNSm9vQlIzWDRpZW5yeTg1YVNpQnIxai9LeUFhbEhZd3g1eUU5dHpMRzVVQlZmTForRitaU1N0MjFVYk5HMWZIbXdERkJBYWc3YTRISHBnRkhveGlzS3lndE5zQkxPUlhSY1JPRXg1QVZmenFNaE1EemVPMnNndlc0bjVWd2dSb3dzamYrNVZWVlZWcitZVy9nM3Z6K2lxWXVYUzNKbTRjOXRhOUN4UEdjV1pWaThadWZZUzdFQW1sN3RNdG5OV3RHbVg5Q1ZOb09Ia1dseW5qOTZ5ZmEzeTYwVmFLcDRPcUVNZitYc1pGWVZMcmxjVHYvZUJmcG9NZisycmxqbUY0T2Z5cWZKd3RlME1yUEh6OUZKMDg2SWFtb1NsTlBEZW9jbldSUEVUamVRcE9HdG5UL1AvS3I4cFdLVzlpaEpGZGxHamc1S1l1QlhiRnNFMnJuM3hONjNqemVUVzQvNWtobDJNdFpTcGc1VG9COC9oVkFSWTRVWkNka1F6MW9JcnNKcG1kVE9lclR6M1pnUzcwK1NkL2RXY1J2eXFHTVFGU0RJNmMxY1dES29iallkNGlQQ3FJZnZIMHlxay9jV243aFFKY2liU3dhMGo0N0UwSWpUVk1GTVVKTTZKcEoyaGlMSEdKaDZvMWZLcTRMbmdMNEdUemtITE0xNFVtQTdJZ09EUWVPMXJEcGVhTFlvQXRMbituMHk4Qm1BbXd3a2VZRjh0b3Z2aU9iaWQwY2J5WnJSS3RUcXFNVEJIQ1dsd2dCb2gxR3RrUjA4UGpPQWF1dGhyK0RVSWdtcnRzK2ovV3lDVzdjejhaUUhBYmx1aHpDSWZYemZjSHAvcFZBWEozQkQ5QkRZbVB0K002cEFGUURKWlYwRjY1U1QzYnI4cUJQSUFEcURLRmRrS05pWUQyVWFkUWNMTjdjYjhxR2VhSGg5alJBUUNkZU9HcHIvdS8vdUpsM0d0WHY3OE80QjJZL2tIbjI1bTQ1bnI0YUJXbjdhR2lubm9HcUhKaDZZekpBYTRXQ0o4YmZTTTBMbG5NUFEzbkRKMjlZcVR3bnBXVHhTOTNWcFhiYkZDZDhvNUJsZVN4OTZOZlEzdi84bXVVT2NlSUEzR2lzY3FDcXNseElkeU0wUUNzcUo3UHhzRXlIcm0yU1dWVjFMb3MxMVM1OEZ5ankxMmNEQXRQOGJPbmxxREs1NUhqeVhGY2VwK1dMYSs1WWo5d2NxQW4xYVRkUmI4cW01YWpnZVhIRlFkUVZ0Tmt1bmtTeXRTNmZycHM3SzRWZ3djK2VUUTZjV1BzWldJd0FXcHZMc1IwdjZvQXFrejVMT0F5enVoV3B0cXZHR2hualhBdnRWeC8ralVkTUhUL3lWL2RXY1N2eWxWY2dMSDBhQWN0ZkNHMSs5MXBGbzBQYml5dnZPbjYvazBFOEJKTWdJNTNER3lrZkttaUR2WWd5eDRGUWF6QnhOalNhN2lxZHJGRFJ3allJTzlYRlg5TTJsM3VtNFg1ZzBvN3VvR0hqOXA0cGoySXlqT3YvSjBkMWtLL3IzRHhZb3cvN1BYeUFLdzJ0NUF1UUlFaTcxZVY4cW9ESTNmUGFOUytsUmJTeE9nM3BLbVhKTTBIQVBGdXFkU2hVbFlESGVMZHhwR01XSjFzQW9SN0tVKzg1U0hxeWxWSng5dnJCUkh6Vkw4cXZ6TUN5ek5iSm9FcUN2R3NCbDNsQkk0SFZTU0VBSkQxcTNKblY1RXJreHY3WWRmSUlPYjJjYWNwUUplYjBaRmZsUTJ2KzFYRmd0VUxQamh3YWdWWGMrM2k5K0xldlA0b2pCdlI3VXpPMlhGdjJiOEEwK3ZKS2lib2pEQXhkN21SbmM0dUdmYmFxb2VXZnpjeHgzbFNqdlhTQTBpQkZRQjh1TlZWUDd5MlZhbzZsUVJORWFoeVZaS2dDakpNemxMRXdHenYzVjlGZXovNGwxVjQrNHNENDNpUmx2RjVFNkRUWUxtRjAyY280aERuMDJDRkI2NmRvczNkbFNoOGpxYWFRTXVoSVNDNklGSC94Y0FxQ0NRZjU4b2V4eWNpTDhsZGdyODhrSkwzZmk2LzNINVZWc3hIZmxVcytpYzRuWEtxeVl6emQwQXJ5Q0dvVVJQZFQ3MnFQZHk0TWpxNjhQUXhseU1OWVFLTS9LcWtiTTc0VmNuUDlYaFFaVkFQazFHMEJWY1JQNmFaUWN3M25ubFZCMXJ4L2EvL2xXMmI0MXgrVmJCcnJCSmFKdVVORFFGVStiMjBhUWI5cVY2NzJ6OFk3cDQ5SERydzR3YUwwMks1RUJlWGdpcGJGbUlReDcrR1JJT1k4ZEQ0QkQ3Y3VDVFNBUEtEMDZsTEVVRUNyVmhqbHRPQVBYeThnbWZiQnhNK29YTzdzbG5lTHdFNFFPWjZlUUJXUzFzVG9RMlp4NjhLVVlxVUxvUVRqRVNiZEFRRVo5TElVSXFlWU1XN2t4RFlLUXVWQUt1YVg5VXNFeURndmlrRlo0TzNDd2JoOFBxbU1oTlFlMUJsWitSVXZ5b2dURHpYREFKVStRbWpSZzFTNDRaOTE5ZW1tOU92U2dxMEJGUlpNaU1JMmtmdHdncDNGczNzTldGdzVYZkhRTml3akRBVC9XVGppSUgyL3MxditGZC85bC9qWHJ2NmZRWGdpeENQcjBVbjUrUzR4dzgzc0Y3MXNpK0RtRUVVajJXSVo0cEMwN1RtOXl5M2NGNjNrNXpUTkVoeXFIT2RpQ0NBbTZyRWQ1MjhyOEdDVW9JcVY5UjA3YzYrVFNob0pnQXozbi92bjFLNzMvOC9xdmgwZGxNNHI1RVNHb29zcUxKMFdWRGw0c0FKcmZsZEczVHc4TlZOYW8zTFNCRE1iS29hcmNnWG9ndm1BVlcyWWVxZ0t2QzRLNkFxNU0wMXZ2T0FxakR2YTRESjc0MWpvREhScnlxWUFJT3lOdkl2cFNRL0tmKzg3SEwzWW55SU9qZHZicGFOdmRYaTZNS25Ea2ZyVjBmT0JMaW9YeFV4dkMrWGxYbk8zR2l0RjVZdlV2bExmUFAzSDJ1RFZlL0M2Mzl4MnpXMkFqUmpzbDlWV0x2WUF4UGZWZlpvQldYU2ErdFRyRzBiOGdkT2RqZSs3Tkt0eXczTkdxZ0JHNWRlYUxEOCtwa0hWVXphcjY5T2k3V01KazdyRHE2b2ZUR0FwbjJ6TUFaVnZ1UEVud1JhVFZaNC9MQ0RqeTN0QXhGOTduZlJPTUM4VVRqQXhZdTFhZTBBVmh1em1keGVmTGRxUXZrZGZpemdKL0hLQUpRYWY5ZWhTOXlJYVBOcEorZHBoaDc3U1JkRU9nUGd2YUpVVkQ5Sk5nK3FLT0tRaGx1WlIxQXcyaHNDWTNEdFRFbkUvcXZsd2Z0WGV4N0krRlg1ZkNXb01wb3VCcXhtMldpdkNqTkJGL09yY3UwaEhUV2Rsa3J1SnN0eGs1UXVyQXVBU1c4NTV2MnFwREFMZVVtQjZ3U1VNNFd5NmwzL1hkeWIxK3NCYk9EdW1nZk5QUUY0NDhHRktNNnRIQ21vQ3NJeXBvM1R4cE8vQU9IenFsNDJSY3kxWGpvQTAwQ1ZUUHU5NjJlYis2cndPR2RoRTZESVl3SXc4eHdPZnZyTGFQdDd2OTZBcXhSVXVkKzc0RmZsTldHaUVvcUJDOWRQMHVudE5UZmRaemRWRG9DNU1pSHBsa2lEeGRHem9QbXZmbFdtSGx6UHg4b1cxN2RTRG9Gcm9DcmtLOHgrQUdoY292UHB6MWthM1R4WkhsMTRlb0RtTVUvMXE2SndIcFgwcTNJYlowTWIvTFhzbzVHek50Q09VMjMyNUl6dDV4NWV1bHdlamU1NzdmdDNYY0dzNW1xaVg1V2xjNW91Q2I1ZzF6ZVh4dkhUQk9iRFF0RnZuZXl1dlBYSzNuVUJhQmoxTTZ6c3Uvc1dORTBFVldBdzZRREdBREFxOUtzMVhDbDJaQWNqQlZNSVpaZDFpc0JVV2k3M2ZIN1l4ZFB0ZmZzSm5XbnlkMUY1N1g1YkFJNlFYS1dJbkpmeFl2SG1EQ3g1V0ZnK2ZSMFlBWFd6b3BUT2JFdGVJQVZBOGpkZEl1cEFxd2FxZ29RRjlrdm5YZ1NiTlhzSjdYQ0RIMFlCcnNYeVZiUGZYam10anp0azlQRDZWdUg5bjl3RU5VVXp2Q2h2QWtSUU4vc0pxK3drZFhVbE1OUmh0d0N4WHRTdnl1VXZCUTZDQTd1NzU4YW8wUWpoaS9sVklRSmNIUHFWckVDeFpHWDMyay9oM3J5K0dMNXlnUGhGSm15eCtmUEVZQXVyVlFjT2FMcnczSXlKMTVqME9ScUwvdmxSM1VHYlZUSWYwdmxSVDUxREJXWmcxZEwrV21lMStNMmxubExSdEowTXF0eHpiVzFHRnBpeGpELzQrVDlHdC83eE54VmVJNVdDS251ZmlUTzNZZEVOd0NvRHFneXQ0MkdlZThjdFBITGxOTFdIemRCa2xIWkdwdUNTZ3RLbVpvaCtEMDJiYXFza3FKSU5VdVBKY1Z4Nm55dGJIV1J4d1VDaENVd1JJZEtjeHFTZDBPUzRMaHpsK3dmaFZ4WGF4NWM1MHVhN3ZNaWlFZHZYVG1ZQkJHNXNiNVRseHordmUvVElSdzkwZDNkc2VlYjlxZ3pQbWwrVndBd2NRRlVZZEdiajdjY2h3enJBZzVpdlAvdDRkNmwzYTdqeDBPOGRFSHVyaXJiRnovcFYyYUh0UVpWTnBDMGdzK2Rta1RNZmFnWllnZkdaVG5QNS9ISnp2Mzh3ZEJvZ04rVFNzN0RpTTdFQUM3WWdRSlZQVzBWcG1sQTRYM1Z4c2RqRExMK3FPcGdTNWtTZklpNVR5WXhYRHpyNDhQSytMLy9ka2RmdXQ0Risvd2dYTDBKZUpmcjlFb2crNnpxTDRXTHhIZTBPTUszSDUwR1ZwQTEwbEVuSFlMUzVRTW8vNVJ2cnd4bkNCQmgyVmpKTjJKYnRGNHFFdlpvQnE3MEs4c0dFdVdkeTY0M1JVUmxBNXJOeDU1ZUE3ZS94emdrRmNOYXZDbWJpMjRrbzNoNUpRQlRzcXlPZTF0cnpBZjhHb2VkdE5oZmUvT2lGUm13Q05HWEpnU29JZ1VsZ2JveGF4TmFYYTFHL0tpRjRIWDB3UzdwakdockR3NVgvK05YM0hzRHE5MDhEZUFLNThicjR4STNqQ3lhODd1QisvNXdiMlhIYU9Dd1BnY0wvSmdpUFZwMXNiSlp6UmdWajF4NHhGNk8wZTZyQVB6dHh1dlRnU3M1QS8zdG5vTXI5SHY3R1craldQL3liaFRmYkJUQjAxL3lxeE9kU0F2Z2k1ck8zMXFsLy9TUlJrQ2YxSnN4cXNEaFVBcUlMSXVEaVZzT1lLZ2dIVWZZNFBoRjVTZTRTL0luN2tnbExyTkRVaEpJVkdrelVZT0pTRTBvbWFyQktTamU1VGd4Z1RKckhTdE5JYVl5VXhsaHBIcWtLSTZWeFdJNTRiSTdPa0xMQ3lVNFBsSGlLWDFWQXZ6VVRZRHpvSE5BSzhUYVJpRGQ4V0dvbC9WNDYzaFQ2WnpWdTBOSW5YcnM4dlBEMFlIenErU0d3dUYrVktMOGRqTnFzRVE3VVdWREZWcmFUbDV1c0wzLzB6YXZ0N3M2d2QrclNFU2p5cTNJdlVUbWM2djJxSEtoeXh3c1o4VTZzYkdXVk9FdkxmczZ0SWdBZjJsaGUzVHdhSDdUSHVqTGRJclJVa1YrVjFWYTVkZGJNV2plOHBZOVdzRUtaWDQyemVnV1hpaDFvYTNZTVpzakF3Nld0aHdFNmMwNlgxSUNkR1hYUXJmYXhYOXlwdk02RkVjeGg3ZEViaFNXQ2VYQmVSb3ZGdDdWN2ZUMG4vT05HaytHSnlXMUN2dG9ETENub0tYcUNsNHpSN0hUNXlPMVV3cC9CQjRYWFlFMDBBVWFnS2pFQkFsWmJKY3RGQVppTkQ1ZkpPYk1ENmNRTGk1QWlEZmE3RUE2Z3lnRWhzTm54K0lSRzNhd09seFdNN1Qvd0prZHZKMnNRTmh3RWx4VG1UZ3RGY0tmTnd3cUJ4cmlocklvT1dNU3Z5b1ZKMEFaTGIyZ1lCS2plOWFmK1Fyd3B1RmV1TDdLL2k1b0haOU05T1RpRFpSME96ODFwYmxOZXMwQ1Z2QjdUeTJnZzFsNmxxZk9vSU9aZkw3Mi8rK2ZycDV0N3FoQSt2UjQwdWZuanc4SlFjNzloUVowRXFrd2NZM3l4VHplKzYxdU5Uc0F0MkRsUVpabmRqbCtWcjVvWjIrYmxFd0FQWHRtaXpaMDFjb3R3cmduanNMaWl2b0huQVZXMlllcWdLdkJZQkZTVlRPam9Ba3VWUWtjcld0SUZtbHJseWtTMWVpSHBja3JEekZXeW9xSlNhRldleHBXS0FkRFlBcTNEY29TamNzU0R4b2dycGNGeitsVjViam5RNU9XWXUvZjk2amFEb1Rua21IQWFmaEwzSVgza3BPN0dXZXU1UjVlS3diSWEzZi8wd0dxaWpNeWUwNjhLQnRnRnl5ajVieHF5d1JJZW1Ga3RtTjFBTS9EY0IvL3cyaU9mL3pOWDI5M3RrUjhDMXEvS2dTeGJYZU5YNWRZdmJVeUFESEpuZWprd0NDWm9yeml3YTkreFV1cTMxcnVybjM5MTk5cGNmbFZPRFduV3ZBQjhVbEFsdFZFbEF3OVVYVHhUYkl0aEZ2NWk3VlZJQjg4dmdDbllkZ2lYNGZHcXd3NStzN3Nud25LL2k4YTUreWJtQUZqekxncnp4YmZZQUt5Nk9PWWFiWDRoeVMwZ1FYVm9USVJ4K2MwUVlqL3Bna2hud1NubG0rVi9VQ2p2ZzBXQnM5ZS9PaDVaVUNYNENobms1Q2NUTTZxakphVklSNkREVmwrK1FXaE1nSGJ5d1UrNEFLcWNtcHc4RFlPcUJ0R29hYzdBOG5KdHRsOVZBRmlSeHN5WENjSjNvQncxM1J1S2pwL2xuZkdyY2dGWlVPVUVpSGxta3k4YXl6ZitBKzYxcTk5dkFQZ0N6SjQzaTRjMW1QRGF3ZjBJd2pMRWM1SXVaMjJLYVVXOG5ROHRFQjdTbldRV0NKbzB6RDdYTnp2MTh0aTczMXJxRnIvYVdTM2dpMit3d1N4UTVaNVRYRUtTamdPZEhuUnc3WC8rVHNXSFM3QmozR3MvZkhVOHFMS1o1a0JWUkN1YmdqMHQrWTBKVUZZRlh2SENXVm9aZENqbkJGN3ZsRkNtcUlFakRSWkh6NEltbUFCbmdTcGY3cmdzQktPZFdxa0tyRlFsZFNxRkJpdkp5WlNBT0FtcjFXSktuVkk2VHVvbnljeHRvUW5kVVpPNm95WmdjeCtyQ29lTkVlKzFqbm0vZWFRcmMwQ3lUZTk0eWo1ejg4VDFsNHRrMmM5K2JGalZqdmo4RFNJYWVJQWwraDRJOGprRzZHeGxNSmZYenpUVlVZZEdEMzkwbjV2RElLUG45S3V5ODhQbDdXUXl1dzJ1dFdKb0svZTl1NGdlTi9DWi8vU0ZKeDU5Mjg5Y0tackgyZzBKRW41VnlncGpCV2hqWktpREtndkd3dHVHcHJiT2ZLZ1ZBODh2TjlyUDlscnRCM2VQRCtieXE3SThrdUdqa1pyMjNQRVBHb3pOcW92UHFoME1hU3hrVk42dnl2RXpmVEhabkNnOXNaMk9BQUFnQUVsRVFWU0IyWHJWUkl1QlkxcDBZenhQSEtIZkwzRHhvdFBVdlV3QUs5Y2dMajRGVlZLUVR3SlZNbld6eGo4MHNBUlZYdFRVSkZQb2VNY3pnQ2MrTEpROVdEd1IraXhNZ0xZekhhaXl5ZjJyczc0MC90ZXdxbzdiWUsyWVNMdFUwLzJxL0U3SVRneGJXS2Vac2lESkh6cGFISFlMR0kzVFFuNVZRVU5tMmlDQUt0ZGVKbTgxYmloaUNsKzhoZ0JPa1JZTEFVQUY0ZWo2eE8zVVhEUGErb0doeGxYUjJmMlh1UGV1TjhOOEptSGFKSjEwUDMyaXZ2R2dqN1p1aWpsUTV6VzN0c29MTzl2dkJEeGU5YURDUytzSlhjd3hub3YxVXRUdk1GQ0szN1YrcGt5MVZUV0ZDbUpRWlV2Qk10N1RjVXhuYUlsdi9QMXZMVWFYem9IRVloZ3RqR0hSamVKaVIvYlFOUEhpeVJHb2N2emF3eVplY2ZrKzFSNDJSV0VuZ3lyT2hJVW5sNWVJTjg4Y056cENBMUt1bTZPMC9yNnRGVmFxQXF0VlNaM2ttNGVCS3BTcFhvZko1Yy9UaGpLd0RJNXpxd0ZGMmVrbEsvU0dMZW9PV3dTc3FNUEdrUGRiUjNxL2RZempjcGhxdjIyNm1xYkpQTWd4WVlMeWZsVlNLMmFmWjRHcVNNWlpHVmtjOUFyMTFKTzkwVU1mMitmdXppaUFLaElXQW0wSFlkMnZ5b2o0SUE5alVBVTJCMHJiRGJhUTFhTkJWMzNtZys4NDhmQ2JmdUVxbEFhbStGVUJjQllXQjdFcjJXVUNtR243dld0dHY3ekd4SXpmUGJHOHVqVVlIU3lQV2MvMHE4cHBxOEo2YVA2MERYUG1QUVdOQjZvdVBsSGU4TzBkWkUvZTV5dndqZFpibjRjTFUyYnR3aU5IVFh4czZWRFFJTG1mTHFPbnh4V3VUWUdYQTJBMUV4TmhtR2xpd1lic0pKbSt2b0Nsd0tpSkFtNTM3azJBbkdtTURLaXFkMHhjRWdBRHBaVGJBWkQwcTNMekM4SUVpQUNxSW0wWElyeGhKd1l3R25RTHZ3aVIweklGNEdNRlFjMnZ5b1hic1NNbkpzSko3d3dhTllrRU9QT1RkcEpmRlNpVUl4VXlWZ1BCQ0tiRjVyaXBJT2c5bjBnREdXbTNRbHY3SXh0ME9FOEdWdS90NnRvK3VQSjFQL0tYM0pzbDk5STE2V2lHU2ZmelRWVEZ3T09IOTJYcEZ3VlZwaXVDclEwQU9xeHdRWGNpdXBTcjVGOHZJU2NVdGJMOGk3V3Q1bzJ5Sk9VMFZySmttQjlVMldFUXI4VW1qb21CN2Yveno2dkREN3lKMHJPdTV2YXJJZ0dxT05DRkEza2xQL084TXVqZ2tjdjNxZEtCbFJxd1lzZ0NjeWJNaE1nd1gxYjJjYkl4eFBNOEpzRGxxc0NLTG1oMVhLS2w1Y2xqazh1VUgxajFPdVdHeWdSK25NUk9CbFZKWFlSY0FnQzB4dzFxanh2RnlZTWVqNG94RGxwSGVxOTlxQWZOSTZmZFNRQm0zSDlZMEs5cWdnbVMvWFFuTDZNVEFHYkNhTnlnNXROUGRNZjlwdy8wNXZQMi9DZ2RUSUJlWGlQclYrWGlQSDltWjhGZ1lpLzNHYkRtTy9OMUd4emMzQ3cvKzlHM3JQWmY4LzZiMC95cWlHRk1nUEIrV3FCZ1BuVEF6R205MkNpR3FiSyt1M3BFekw5MXNydjZoMS9jdTJwYk5aenFianAyc2duUXhYT1Nqdnl6V2UvWDlSSzZYR0NmeGpQOXFtekQrNEhsL3N6QlRTNG5IZjJlR1RYd3NhV1g2dURSQXYwK25MTjdpZkFHNGJTRXN4aFBqbTl3QUZpeThTZW55NEdxREowWmZXaGFFNkZzNUJsK1ZVbUhTQ3BKZ3pFSVEwV0VTU1pBaHBod2dkYzBVQVY0NTBFZUgzUkxFQ2QrVlphSEczc1p2eW9EYWt6bTFuK0xnNm9aL3BNT05HcVM0UytGaEMrWWY2NlpBSVYyeVlNNnJ3NTNhY0hsc05sRThKa0s3VGZKQkVpd1owK3dBRlVXU0FablZyZGoxS3ExL3huY2ExZS9md0hBbzRqbkRNVDk3VXhLOC92NDBTbTBkZE9IelEycWdMREpDSjFjNC9HNDdpSjZKN2JHblpQbmVqNDhPZllqN1k1NlgyK3RVQ0k4Z0tZQWxpYUNLaUFvSTJUTlJJa0pqTUVIM2t6Yi8rclBLdGl0OWQzeXEwcTFWVkp6Y1dwbmxSNTQ4U3hKSzBqVUlCRUk0ZmxBbGExUUhWUUZIdk9BcW9JSjY2TUdOc1lOdWwxUUZZZHhVcCs1K0xGOGNrS3hGaGFGWndaWURmZXpReUFvZFlIVnc0NWFQZXlvWVRubW5jNiszbDA2cUNwVnNVd0xKejhGeUVKUW84YmFMZzk4YkxaQjYybmtuZUhyTllySmh0WEpYR2F3ZXlPU2ljQ05pNDkwcW1FYit2d3pCM2JKRUg1VmZqNElFNkNUaFphVzNNYlV2NDNvNVdQUVh0bTAxb2QzNTlLRDdldWQ3YVZURDMxc0x6VUJSbjVWcHFpZUIxdHRGZHliZzh4Z0ltM1NFak94VnVHUVJMN1JMcHRQcjdTWEh0MDUya2YwR1J6a1FaWHJUcWV0WW1oN2NKTzJucUNCM3ZHNFVQWHdrZks2V0t0VFU2RE1rNU04QTVpU1FNdVZvNlVWN2o4dThWeHJHUEdLZjNOaDg4cDByOFY2NlRWWURUYkhLRkNHWmg0VFlCUm1RWlVQSWFESkplckhRR1RTMXMreWd1c2dkeGVyTzNtdlVaUVdEd0EweGE4cXlCUHp5MjdTK1RCV3NtUjJZSThPdXlSTmdCNlFUL0dyc2p0dm01LzEzV0xTL2lBN3dJTWdOV29FcC9Td0MyT2JoNjlMNmxjRlozNlVtaWMvbVFHM0MyeU1tOHFhQit0K1ZSNmsxZjJxWEp0WTdSYzg0RElhTGdlQXVXanZmUVQzM3ZXRnVQMkpOejN1bFlmbkVKdTdZNXJhZXBSb2JyTXJ1TDN2Y1luenVoT1ZvTDdaaVdmUXBMczRCUUR3TVNsOC84YVpwc1VydGpSdTZNV2d5b2Y1V2dRNkVjK3VocExQOExQbjZkby8rcFlpQWtBNVVPVVQ4MXgrVmZhNUJyNklnUE5YdCtqMGpZMEUzb1NLUm8wU2dRNk9LeFZvT0orRzY2REtsenZjdTY1cmE0V1Q0d2F0ajB2NHR4aWpuRGdwVC8ycWRmNEVZRFdCSDJjb292cDRna1ZBRlhtWm0yMWJCcU5SRlhSeWY3WFkyRjlSZTBzRHZkUFpyNDZiUnpwcEt4YjhwZVpLYk9RUVFKWExHMnlQV3JETEFzVUhQVnRqQVhQZzU5d3pnZ3hValBMcXViWUdkSFgrVXdmQjRnQUJxaGpJK0ZVQi9tM0VzT2swUmRNdXJiTGxKdU4yWVdVNjlJdlBQTkZyTGU4ZXJXMDlkMlNicXdJbSsxVUZFNkE5QkJYUTFoNml5UjdHS0J3TksyTzlJZjc0MnRMS21jSG9vRGVxREdCeUdnSDNKLzJxVWxCRjloZVFiLzU1c3hvQWpSWGR4SVl1Y0ZNTi9ackFibXdnRDZwaU1PWDRKOC9FVU13NFAycmd1ZGF4YTIrUjkrM0w3M0FwQ0lCVi80ek5mSm5ORjkvZ01ta01HVDhIcUJKMFlmYWE1NElKcFR2RWxISnBzMzVWVVJta3FWTE9aZ2J2bDRvb09MaUQzVkltNnBOcXF4QUdXUmpVY3VDSk5OV2dBNmxob3BwZlZkaUpCVkRsVk1kd2FtZDM0SjdKTThRRFZZT3dvRitWTndFNjA2UXR0MUNKQThyc3VJcXFvVUJjQmVFVU5GOU9sZTJheTlRRjdONDRsQ3AyOG1aRW53NGdjTkU0K0EzY1MxZS92d1RnRDJIeWhMdjlpYm81V3NMbWFLMUdXMXVQL0dwa1Y0b3BvRXFHdktycStVV09rM2hPMHFWcHM2dGlIUFpqSjA0MXJwUk55cHg1NVZOSmJkVXNVR1dldzdRbEdLZjJxOS94N1FVZnRpTkE1YlZZSEo0QnpPMVg1ZmtnU1F2R0F5K2NwWlBiSndMc29Fd3pwS0FxcWxpb1RMMHJVNTZaT1A4YzJtdTFLbkJ5MUtUdUhINVZDWmZNYzZCTjZkTDZzQXlPYzZzQnlWcW5KNEsvcnFrQ1IyMGg2eStWc1RFL0pnQzlveVhWTzFwU3c4YUlkenA3NDczT2ZzWG1KSDhPUEJLWGh3aElPenA1TDh5RkFwQ0xyMTI0dzUvWkxqUFpsNGZVOWROdEFyanFmM0xmeS9xY1g1VjdjOUJ3RCtZN2F3SmtzNG0yb0NvNHFwTTdYSlNZclJVUWx6LzI1aFB0enM2TFM3M3RrYTM2Vkw4cWdDcGpmVFJhSzdqR01LWHhmbFhPZDZzQW93TDRJeWVXdW0rOXN1OE9JSFZwZ2duUWhTRUJWUTcyQkkwWEVIeTBnckxrL3FxTEcwcnloeStiQzh1WkFsMDdPakRsZmdGQVdZdlFTbFZnclNKc0Y5clR5N1NMeXU4MHJOOG5YTHpJMGtTWUVzNWlORjk4T2NQSjNmelA4TEhhcXZpOHFwZ3V2RUVZODVKb0Z6NDBwWkdodVhMd2ZpRU9HYVg1L0tvY2ZaaXhhUnBMeTR6UllaY1VhZTJYa0huOHFyeXExTHphQ3lTZ3lvTXVNSTFLVTU0Ri9LcWtDZEJOWnA4ZjRGVGp4bG15SWpiSG50akdtTWV2eW1zWVdEc1ZlTWhQdTd3QlZZMk9IOTcvZjNGdlhXOUQzYVFPY1QvUHBNelR2M1p3MWo5elN1OVdBdzVqTjNDcTgrWGtlWjFMbk9GMlJKdTd5NFhIc1drNEE4QW5tMHZxNTNvbkd1TE1LNTlLZ2lvN0RPSzEyTVJGSmtDWkRqRGJRV2ppYS8vd1c4clI1WE53cGtGUDcwQVZDVkJsNTR1ZlA3WmdRQVpVMlh1VFZzTytibzRMTDU2aGs5dHI0bHZ1b3RwSkpiSW1RTCtLK3VjMFB1NitDYURLM1crTUd0Z2FOa20rQVRpcFRHbTMxVHA1S3FqSzh1TWtkaktvU3VvU0JrTnRTQVVCbXBaVWdxbzZQMitpazd3YjQ1Sk83cDRvMXc1NnhYWnZlN3kzdkY5NTdiakl5dzlFTjQzRDVqV3NNOUg0aWsyQWRSQW1OZjFPMXRueUVXdTZzZFVxd0pydi84U3VYZFltK2xVUmdsOFZtTFQ5V0xrRFUxNDJLeHZtemlDRStlZzBFekZyclhENVkyOVpmZWlOdjNCVmtYWkhORXowcXdLWXJRbVF3UVFpYUxQeUdnREhiQnppMmN3TURhTUZ3OVYybzNtdFhSYW5qc2JIdGlPQ24xVnFBcFFBTEFWVmlPS0Q1cW5ESlU3ckpxNm9Rd0RUL2FyaW9XdzFXdkVwOWhIZ0twangwRkdKRHk4Zmk3UzNLOU56Y1FTQVN4Z3RWbzVnRm9QNTRzdmFRYUM1UlVSSVBBbXFSTHFjNDhNU3l3TlM2NmU1eHpsTkIxVlVMK05Cb1pTZCszUDdWWG1RNVdTUXJRMmJWMlFCbU5kbEFXQjh1RVJZMEsrS0FUak5sUytxMXc2RnlhNklOVlVOQW1rOW4xK1ZtN3dDaEZtdGtoUThMbDlWbGZiOG41eGZsU3RZemEvS0NxOGdLRURhQ1V0TER3WXpVK3ZneGIveGQvOWFkS2JJUFhEOUVkejV4S3VITlpqd3dQRnB1VjZZeTBOMU56OWNxam9QVHA1bCtDdXJsVnJzdEx1a0ZCUHpzQ1BxQjA2ZWJnR29HU3FERm10K1VNWDJOOVdBM1hyM255MEdIM3dEUWVrQXFpekI0bjVWZ2M0ZlVPbDVtZkQraTJmbzFLMTFpclJMODRBcVc2RTZxQW84Wm9FcUZzbVlHS3ZqRW1lSHJjaS9LbGVtZXJjbFhYYmJvRXBRektHcHF1VlJBMVljN0Y0eVpnYW9JaVRMUUVEeVVoYWkxQVdkM0ZsdnJCNzBpbHNyMjZPRHpuNFZ5VHVUMW1zVTUvV3JjcTRpWkpjcHVha1VmS3lRRkE3c0JORE56UmFndS9yQ0ozZmg1UHMwdnlxQXpWaTNKa0FpQWFoaVVBWEFuYzNtMHg3dXJ4Ylhubm4xOHVtSGYzY2I4RzhUVHZTckltSnQ0SjR4QVNxd1dQTlFtWlVEbXN4SnFEN3U5MWFYdW04LzNEdkVKTCtxdWdrd2dDaE80alRZcDFXVzdueGx2bEVvZWVYOHF0STNDMVB0bFR2alhwb3lUNDRMbEt3eHJrM2kyNVhwOGRUcTkxRUMvanVCYWFKWlRHZkhONWpzcE5FaU5rbmpScXNMb1ppK3ZtQUVKNHNXblA5VjNnUVk3L1p6Z0l1alp4ZHJFZlorVVFnVG9adDBmc09WOWF1eU5ZbzduZG1ES2x0TUpnYkd4MHZrdFRwK0Z6WERyOG8xR1pqSmI5WDlKUE1nazRoQjQ1S2dLblp0VFBBNjRiQlRTL3lxbk1Dd29NajJqZE9tZVJDb0Zhc1N4R2Jpa1plWEhQeXFrUFdyQ2tCUDhyZHQ1WGFhaWxtMUJwL0J2WFQxKzY4QUlOL3d1OTJKVnc5NzllR1dmUmtFQVZTbGNDWERvN1pDWmZodmNoT251RDAxUmJSU3pzZ2pTZmZyM1pYeXVVYUxYRWtscUlwS2o2Q284SllWMUVHVnhVcEJFb0J4OU1sWDBLMzMvSGVLU0NOb3BYeEdjSXNpTUIrb011SHBNM3RlNTE4OFE2ZHVibEM4MEl1R1NrR1RvWWxOZ0xMYlVsRGx5eDN1V1NheHo4dFZnYlBERmkxYlU2RG5QemVvaXVsVDJnbjhPRU1SMWNjVExBS3FhbjVWYWRsa3UvbTBFYWdLdkFTd1N2ZmQ1T3JBS0t1U1R0MDYyVnc5Nk9sYks3ZEdSMHNIWTdaNUxlWlg1ZVZTS0w1eW0xUjNjS2tFVmVRM2xDVFRiMisyaXVmUTFmYy90ZU9CMFNTL0twUEVhSXhJdzN6c2xkbHFpYzNSQ3RhNUhkYTB4NEJXWkNxa3dIempzNDkyVms1OWRtOTU1ZWF4VmNwcXA0SEwrVldadHc3QmhTbWFCMVVnc1B6V29US25kMmtDOUU2cktDNHROOHY3RG9aSHFQdFZPWTJXVzFPRDlzcjViZVZBbFdsOUF5eGJESnl2V3JoWUhNS0RwMlI5elprQzNYb0VzZllVektoc3ZTdlNLQUE4Y2x6Z3FmWllEaTl4Zi9zeTNkNVBBMWk1c01YaUd4TVBHUVVtK1ZXUldGeGlyWlY3aThETk5rYlRmMHN0cjYzS2hkZnlqZ1lBSk4xaG9aUzNlbG5xV1g1VlhyUEZEQkN4T0JGQkxwa2FBS3FqSlhPS2UrU1BOTU92eXBrQUFiYjIrd2hVZ1IyNGFoTE1EZ2ZlQkRpSFg1VmQ4YlQvMkhUcVYyWG1PUmVWY3NLRjUvQ3JBcHgyeW9lN3Z2UXFlVFliTldnbVppcVByK0RldW5MYUsyVENGbzk3N1BDY0hVRzJYYWFBcXZ4ZC9Ddi92N0phblpwVzV1REM1NkVCVUlId2s2c25td0VZdVc0Tmx3UlY1am5zaFJ5ZC9Zd0h4Mmt0M2FqRXRmL3RuUVVZZ05KMzdsY2xUSUFKK0dJaTROeVYwN1I1NDJSaUZnd1RWelpMRFZSNUdoWkFJaFBubitONzk5VFNDbWVHVFZvYk53UUhuZ3FzT0gyYXFxMEs5V0VaSE9kV0E1S2VOZ2UyUkgxaW5xSXRJbTJoNEJEem13MnFjdjBodFlaUldSaU5jWU0yYjI0Mmo1dEg1YTBUMTQrSGplTktBdkpGL0tyY0pwWHNLR1ovdElLUWM5REIxY0xVbWVGazhQWkdxK0RIdXZ6QXgzY1ltT3hYWlRXd1FoT21nZkRHb0FkVjVxUE1BQVd6b1huUmppb0djUG1wTjY0ODh2cjNYVkZLVzdCalRZQ21UcEZmbFcxN2N4Q29CVlZPVzBYc1FaVlpPd2hNekpwQitoT3I3ZVZ6QjhOOU85M21Nd0dTQlYrbXM5MmhwZHF2RTh4V2ZjZ2FtN3FGaTRYVlltWEFWTTRVbUlJcCtSczI5Y0NaWVlHbjJpTXgxS2JKNzF4WVBlN2lSUi8yMGdLc2tnbVIvNVhWVmszenE4cUJLdE5aOVlxWnNQcWhac2o4dXNhUGVlUTFhL1p1WUE0WjFhNVVISGpJUlNNMkFZWkQzV0NWVDRaT2ZzSGNYdVBqSlVXa3ZhT2lGZklNVFBHcnNzbVZBVlpXYmdrL0EyYytIRFpMdDN1cSsxVTV3VmYzcXlLd0diak9OOENyd0sycGtZMG1pM1JoL0FzVzhhc2k5b1J3UU11cDJzRWF4a2xBZzVoVk1Yb0I5OHJWNzY4QWVCM21tVnlMVHRSend5NU9WTDBvYmxFVElJblJMcSt6dW9WMWJ0YlN4bFNUOCtEcE5ML1VXeldPN1F1WUFOM2xqRjBVcElGblRoelczMXMvK1ZYRjZOSjVJdVhtQWdkUTVZZ2RMNkdGY25FVFFaV2xJd3FabnJteVJWdlhUNmxKaTcrb1hNWUVHSjVubVFCOUNvb2JXQkhqOUhHYlRvMGFacldQOHE5M1c2MTdwb0txbU1ZK2NSSTdHVlFsZFluREl6cDIrZFNHN0F4dFZZMVhCS3JTOG5NR1ZBbCt3blJuNDdnMWF0TFd0VFB0dmU3MmFIZjExckVtOTFVWHQ1WVlHVHJMcndyRTJpMDNRVU1sekg0eUhlRGtyM1gwWnNiZWVrdGRmS3pIOTMvOEZqbFppT2wrVllDemdyREQ5ZGJDNGZ5ckRLaXlZMTNiZFlWSFI4dnF4V2RlMnozMzZHL2ZNbEtkMldxeVpGTlhjR0dKQ1pBMEtnZXEzTGxhQk5hay9kcFREVXFsbnUyMVdnL3RIQSt5b0VwcW5weTJ5Z3h2WTA3VURpQzV6K3o0WDFPcUpoUk82Z0xYMVdpbVgxVUtxbVNZN3h1aFlWdlN3T2tSNGNWRzNjVW9YTFBEQktpUzEwc0xzQW9uRWNWR2I1WmYxVFJReFNLdGZNN3JxV0lUWVB5YkxraHlua1lOVFNIUHVmeXFKS2dLQTlXOXpCZjQ2dU1Xb0JVcnNIRTVyUGxWV1JPZ21Pd3FOUUZLODVvVnlXNnhwWEdEWUhaWFhyTVZUSUI1dnlyVFp0b01RSk92am5ad0FFTnBKakFyWGRnaklCeVFncmpQKzFWWmdlZytHY3NBYTJ0bkRlVzBwKzFTY1h3Sjk4NzErUWkraW90TnZGbjBUeHllc3lGMU9rNmVaYmljRy9IVURyUGdFZDJyamZSWmVlUjVwZVhBRUlSL3M3YlJWQ0p5SGhPZ2pXZjRaM1pobm9lak8vNzlCK25tdi8yVEJieHBFSGZrVitWQmxmM240cGlCTTljMjZjeTFMYlVZcUhKNTFqdGhtZ2t3OVNNQ2dFNVZvSC9VTm41V0ZNSnpVcnZXSFRTTmpxUHlja1RxeEhDY3loTWs3UkRsVVNzZmMxeU91SzNtTVFFNnZuRUJrLzd3dThNNlB5bGtiWmlUUXdGSUFlZ2RySlpMeDB2cTVzYlY0MkhqYUl4Ri9hcjgzRXRNZ0ZFNi8yd1oyL3lkdk50WmI5Q0xGenAwNXZkM1liQ0FscUFLUU0ydmlxMEpFTmFkd3JxVHNOTm13WnlwS00yVEdnRGZldUhDMHNySlM3c3JKNjRjUzFERnBybTFzbW92TjR4VitFNmgvRjZoTnVzZUE4R2ZxbEptK3VEVHZkYlNoZDNoZnNIczQweHRNTUVFNk9OampSWWorRXN4QlY1bmRCTlhpNk9aZmxWQUFyVDhHREw1aklsUk12dGZBSGo0Q0hpeHNZamNEbkVUZ0pXN1htS0E1WmQ3WUY2L3FrbjhKMm1pSk9nS2ZPVHNUMDJBS1YvSms1TVlEV2Z2cnBrWDgzNVZFdjJIczBlTThQSHFWUWFQcTFLUkJVQjV2eXJ3VkJPZ25iWFNSNHNFMktGeEV3U3RQYWh5K1UveHEzS2dDZ0FFc0RJYUs1ZWYxUjRZRTZHdTRFeUhrWkFSd00veFVlRXdQYnREWTdZQXp2TGwwT2JNaFJyZlM1OTRmaU9tVGJKRko2VzdiK3NDL2VNdHlMRlhXNkVtOE1nRHNoQzJ3ZzFzY0N1aW1wUkhqbVlHM2Mrdm5tamNMRXIzbmZPcG9FcnVsaU5RWlcvZEdoeXQ4K01DVjcvLzYwdG9CVkwrVzUwbVhRWlVtWEFBNGhOalVxTWxRWlZMNStKUDNUeEpwNitlVmt4Sk04LzBxMG9hWlFxb1NqVXovaGFNcldFTG04T1d3WVVUdEZDMUxwcEt4eUpqVDhNSlJRMG94bUdab1pHQ3FqOEF2NnEwTEJsUUJhK05zb3AwZzRxaTl1ZXlLdW5VMWJQdGc5NzJjSGYxeHBGQkZrNWJ0WUJmbGROS2tiY1VBT0xzUCtFMkljTEFJQTI2ZHE3RDdmMWpXbi94MEwrNU44T3ZLb0FxNVQ3OHJEMFFzKzRtL2tnSFZ3V0N2dktwejEzdGZkNHZ2b0JpekpUNlZiRlpxeGp1aEhmV3psekpJRzB0Y2U2VE9rWmpaczYzMHJZLzlWQXBQTDNhYm4zTzlxSDdrTExSWk9YOHFwemZDaE5Ec1RaQXlWdE5OTndialFaK2FSVE1XSVpDaDRFamIxbzBORmxUb08vLyt1a0ZKVXVMRjJOSWpMV0tzS3daQjhLcmVwcmNuZ0dxNUZVaXlNTThzMW1aVFk0M1h4aE4zKzdMbVFCZHZOTzd5dWM0ai9RNWZEZ3k5YXRLK2RkTmdKSmZXS0JJNUdzd2NzMEVPTTJ2U2dVNXhWYkFzcVdUeitiRG02U2RGSjdQcjhyTzJCUlUyVVdMcldiS1REeXRyTGJKdFduNERFTUFSQlljV2I4cWlzSTAyN2RMbktZTGlyMEprSlV1R040a0tFeUpHUk9nODZ1eWxkVWdZL2QzdkUzYnNiYmFLNEJZbDYzQlozRXZYUDMrQ1FCOTFNZjR0UEUvWDl3VGg2ZFIyQTFPYlpXb2pjMUpmTjI0amNNZjBzczFubkdLOUtyVHBEbmE4RU9sNkdkWDF4dGhyTE1YSXE0WTAveXEzTm9IdTlqNnRHRXU0ZVpQZjdrNi9zd0RCbHpCQTM0UG1HcWdhb3BmVlExVU9UN0U2QjBzMDdrWHpvVXpoRjhpdjZwY1hGc1gzRDlzcXlVdG5kakR4ZW5UQkZCbHdrTGpzUXdXUDBsbm9EWU1LQmRXcXpGSGJSRnBrQVJYQWRRWTgvaFZ5VHJLdnFpM3JlVWZKdzNneGxBSTA2OUg5VEVvWndCWTNsOHQyMGRMbmUyTks0ZkQxcEUyYVoyN2hFdkRQTld2U21pVnJLd08xZ0pyNm5JWWtSeG9NOStmMVhUNW9SNjFCc2ZVMng0VDVEbFVCb2dvYXdVSUprQURxdHltMStRQkVIa3JnSGFnU2tIRG51T3VSMGRML01Lbm4ramU5OGlIYjgzMHF5TFNTcHMyVkd3MFYwelFTb08xZ2dGb2RuMVdnTmFBVmdBdWRwdk5CL2FPdVQzVzd1QlJEV2NLVFAycXBBblExTUQ1aURsZmJLTzlJbUpvTXVuUFZ3VStXWnJUMTZmNVZWR0NDZHp2aUJoTk5xQ3F4WXhqT3lDR3BQSGdNZUdqUzdrakg4ejlBcUJLWHFrR0t5L0E1NCtQN3d0Mnp6SytiZ0tNelIwcHIvcXpDNUUrV0lFdUI3UWsxd1R3Z1pQOG8zVEVyQ2Y1VmRsSnpKU3JQME9IYnhpYU1Qbk5RakFLY25iNTJBVG9GcTI2WHhVTXFBSUR5bXVLM0FSMldpbnJ4MlYyUW5hSDRjQU93UU1xMHhUQkJPamVIZ3dhS1BPYU1MTlE0YnJKN3llM3hqeCtWVWI0K0owYnJCYkxDUXlmemlTc1NGWGp2L3BEZi8wYTdvM3J0WmcrL3FlRlRZOTc5T2hjYlp5Ni81UDhxdUp4bXh2aFJuTjhuKzVFb2VtTXlJZmxjNHpEK1dkVzFwc0h5bnhEU3E3WDgvcFZ5VFJ1elZNK2pqRzZmQi9kZU85WEZqRmdZcDlnRWI4cVN0TGFCUW9BMEJpWHVQL2lBNGJrSmZLclNrR1ZJOXNjTm1ucnVLMWtGeVpjemROVVVCWFQyQ2RPWXVjQ1ZiVThZbkRJTHA5MHFNelNWdFY0VFFSVi9wNG50clhmMmZxOFFuVjlXa1R0SElFcSsrd0V1Y3UzcUVxMWZ1M3MwdjdxemVQOWxSdkhHUk9ncTBlb1V1cFhaYytyZ3JNMVdybElGcGl4MndnSHYxVXJyOEc0K0lwVmV1UjNycUZ4WEpIUWRobHRGYndET0UwQVZYWjkwT0dGS1lDQnlpcmRyQ005OU82MSsxcTc2ODgzVnRaZkdEaFFsZldyc21ZK1ltTUMxQWFRYVNhanVTSUJxc0RnZ2t6YWlzQ2ZYRzIzbnJnMTJFUDluS29xQWxVQXZBbVFoTG13c0tZL2dnRlc1dG53V05jRkNsdm5hWDVWUURBRlNsRGx4d3pDbXRYUmpJRmluQm9CYW9rajlIQ2JvRXBlTHpIQThrdkFkUE5nUFgzOTJZWEVKa0F0Nkd2Z1NLU3BJMU5wVG96VCtiY0p5Wjc3TWNtdlNpVitWVmIxQ3FldEFzVG5kY0p1M241WTA4ek0ydEVLay95cTRPV0htVkJtdDJUZjlyUGFLNy9iSWszUUZlQnM4ckZmRmVDQWxDMlpVeTFiQVJSMlVSQUFpcG5NakhJQ1JJTjBCYjhqYy9JMzQxZGwweHNoNDNaaHdhRlQwQnJlYXJ5UGUrZktBYXg1NThia3VBZVAxOUNybGpISjU3QzIwc0tOMmR3SWo4ZDFYeStqaEVJNnN1dTB1ZWNjbmIvZlZRVzliMld0QVppMXo2Mk5zYmJLeVRMNDlUUFpoRWpBSmNjOFNCTmUrT2RmVjZJcVFNcE9id2VxeE1TY3g2OHFwckg1Mlh2RnhCYys4MkJSakF2akVKMkFrQnFvRW1sbGhWMnluRitWNUFXTE53b1E3ai9zVUhkY3BqbG04cTlmTE9KRkdOY29Kb0dxQkR6V09nVUpzd2hvdWZaUHVDYWdTbXFySE4rVVoxUmVwOTdKOEF1Z3lvZDVOYWp6cS9MQ09mQ0xteVR3Y0JvcGx3L2JaWUNKZ083dWlWWmoxS0Nka3k4T21Lb2c5MnhkNjM1VmxvV1RkeDQwc2RkcVdRMnE5NnVTMml5M0NTVmRnRC96K0twNjZIZXZVVEd5R242dnpaTGZrZzNuVmRseUtOTGFXQnJNaStrZ0JqUnBwYXhjVmU3TlFtWUM2eGMvL1VTMzE3dCtRSTFSUlRQOHFydzUwSjA2UmRiaDNZSXFkMjRXTVNvN0pxcm5PNDNHZzdzRjkzU2w0ZnlxbkFuUVhEYk1PYmdMVUNYQkZGdXRGVnZORmpHakpNYVpxc0FsTmJUdE45bXZxaUdjNGQwNjMyYkdrUjBvUnphZmdRcW13d3ZIakdkYmR3Vll1ZXRPVElTVHdzTjk0VTJFOFFJQi95VFQ1L01MQzA4dVhzUFplbVZja0JPY2hLUW13TUFuY1BCZ2tHRFZxQjVVU1JPZyt3eU15Y2VCS2t2SDRvTzNIRUNWNWVITWRjVFYzSDVWa0tES2poa3lhbDFyYnRQZXpHOG5FeE03RGRGY2ZsV2s0VFJkTGc5TEszWng3dFZpc0laaVo3Tm5KZ3VXekk0SmxxOXJhK05yUm1DR0JxenZHVnNWc2hNa1RuZ1I2WHZqZ05GK3Z3bmdNZFRIK2JSeFB5MHN4TDN5OEJ6U2NWL1gzdFpYK1VtZ1NvWmQwTjBzcjl4ZHlqMWZGcmg1K0grdmJiU09sYUpGVElEdWNtdWdBVndjOFhkeHQzNytTOVhScHg0aDUwdDF1MzVWempRb1FaWHduY0Y5bCs1WFM0ZExxZmFrM2loVFFGV3FtWWthUzRBcU5wc1BORFhoZ1VGWHVRTkRhdzA4UVZ2RlNieWc0WVFpb3ZHZHVBaW9NcWFjQk9ESnNvbE9EUHp1Q2IrcWhKY0hWVUdMU1NrZEMxa0ZnTGwxMUNuWHI5NjN2TDF4ZWI5cURObC80VUw0azBvQVpkc2grRlZaRlQ2NVRTM0RXUlBnTlRqZTk5UWR5NkFadzZiaWk2OVlvUWMrZG9NeWZsVzJtYVdXU2h1eklTcDI2NElLY1g0RGEvMnh5TWhyMWxYSlZ5NDkzajUzNFhkMklmeUxuUWtRd3E4SzdGL2UwclpKSzE5bXRzNzRUSnFKV1FGYXNWa0lubDVydDU2OE90aDFIUVhwVitVQVU4RWFtdUExVlM3T3FNVk51Mm13L1ZhTFNhdkJPTDlSWVpVQUFDQUFTVVJCVkZzcFhGYXh0aXJuVitWTWdEbFF0YUladTk3ZnlvVDk4STVVQXQyMWExRU4xcVQ3Zkx3NVoxMkxTYitZQ1RDbitlSWtqS00wa2w5WW9HSlFsZU9WUytmeTExbS9LdmFmSHZDeVNOWEw0Y3VnQkZBQ2pMWkxPWkJETWFnQ3h5WkFjbjVWSmlFTEZiWURMZ0FjMExFbVM4VVZTTHR2WDgzbFYrVTFXZVMwU1FDc3laSGQyeTFXQUpQU0ZjaDlvSjJDQ1ZBWlFVVVp2eW9ydVMwdGc0SEtuL1ZDWUxJZkhBV3gvUERuSCtUMU9PWjdlM0RlT1dGK2UxVUQ1NGFiZnV6VzZkeTRyWWZMY1IzRldlSVQzTVFxTnhQYU5HMTYxZWVHdXd1bVN0d29TdnFWM21xREVoTmdEbFM1WFZzT1ZHWGlHQUJHVjA3VDlmZjhtWktVR1NZVC9LcWszNHQ5OWdzei9PWURQbTFZVUMydmpXdWJ0SFpydzMySklHbE8xNVNaaGQvZVI4MVgxMXl4N0JKSDNhbEtYQmdzcThJN0J5V05odnJGU0Jvb0loV2ROVWxiSmVxU0szUE1rME0ra1FaSmNCVkF6UzdDUHR6emtxQXFxcVBubHpVQldqNXgwditQdlhlUHRpVzV5OE8rWDFYM2ZwN0hQZmZlbWZ1WW1Uc2FpVUVETnNpR21CaU1uVGlFeU1ZcmdjakdvQ2Q2QUFzWkljUkxKUFpLbkRpSlk2OWtHVkF3c0lSNVNDTUpBMEgyQXBQNHNWWk1BQXRoRUNpQUpDUUVza2FhR2MzY3VjL3oybnQzMWUvTEgxWFZYZDI3OXpuN3pzeWRoM1Rxcm50MmQ3MTM3KzZxcjMvZlY3L3FVSURyNktwU0JUbW9JdEo0eDdvTTQzZU9sdEhJMzRVOGhTdmt6T1c3TjI2YytjemVZcnhYZ2Jlb3E0b1VZT1NlR1ZkVkU0M3NReVg1R1F3dnN5SDlZS3ZFb3krY3lsMGZ2dzZpcGF0QzNGNm5SUUZHVUdXQ1dEelFmUEhGdGVrREtOQTRqNFh4OWViakY0ZDNudnM0eXZHZVAwNVhKWWgwb1laNXlvQmV3c1NqUnFBa2FWUW9RcDhzYTA4TUMzdHRVSmlkaFZ2RVh5TlNnWEZjMS9vaGJTakFDTzVhb01vQzhHbU9sbUFsRzVBNHJjQlY0d0NzMWxVbG80eUpjMXNPcW02YTJ3cXE4aEM5Ung4NUthdzZQajdkMU05Z04zMzVQTVUwSEdrT1Yvb3BSdFoxZHlsQWR2TGxhY25jaWFWeUlUNm1DK05Fd2l5OVgxZVZ0ZEsxVmtsY2tZRldYSjBXUGZLbXVoSTNYOU45VVpqZWdLcndBSWxHNjJnRWFPbGhEKzFGaWtSRk5LTURJOERMZFZXWjFRaFFTdlIvSmZXQVVKdW5OU3pIcjgzTzRXRVJTbnB6UTRjQ1JLTXpZSGc0RXFoaVo0VkxwREVqR0F0ZzhqbGl3UUplZ3VYNy9haG5ZYjNuNUNXSEZ4c0xSL2FaUUZYM3p1M2NZKzE2c3hsUUFMelFiMlQ1dTMvejBKL2FQY3JPZjJIbnpNaUoxUE5nWmp3NlZsZlZCVlZOV3RQYTVYZTlwdUJpRURCNGk5NWJYMWVWSnNIYTZOMnhZbTNzYjhqNVIrNDI0V0hNTHNvUm9HcGRYVlVEVXZLZmhqaTlHTWhkczRsSVdpNXpKS2hDSzA5VGNTdDFOYWc2eGxxVm5XZjliWmM1emxxMVZGY1hWQzFicTNwQlZjekxWazg3b0twQjVYVWNlMzZyVkFkYmZZOExhekpRQWtRNk1JNWxnUjV1dDgyQXpZWGJWODVQRDdhZk9Eall1blpZajJlU2RGWDExalpBbjY0cWpaZFN1N3BaMWxWRnlqRmpDc0JyZDQ0eDNqMlUwNS9abHhXNnFwb0NGR2hjaVE0d3ZLeENHRjdtdzNmeHd2U1NBUTlSQ28wS2hJOTkrb0hScGMvNzdVT0dqWjhwN05kVnhSZDJIMTE2YTJScU5HQWZlQnY2clFCZ1NXcWtHRCt4TlRBN1R6aC9wSzVLQUdnRVh6YTk1SU0xcU5KSVBTWmc1a1ZSZ0RoSHdUWG9zYm9xb0tFQW4wRlFsWWNDd1V5WTlLbDlFOFNxNCtQVHV4cXBkcDdtdVpMV09aZnlkQ2VnRUJMSDIxZzd1dGFxcHZ3eUJjaFcrN1c4THl1cFJOUmdvYUVBZ2FOMFZlRTgrTGFTZW16SXRGcXB2cEIzSlFXNFVsY1YyNCtlM21zM0VjMnFsNXFXQ3dMMDRJTWhwL3U2dXFybXpTM3VoeVhOdmxnTmNOUGtxNlh1cDlDTHFNbEJsZFIxdEUzYXlDakFaQVVMd0pNYTMvNVVKSG9sRnFvWWRYaTJ3NlZMQXVDTHNIeS9IM1gvSHhYWHBOMWJ1MlpvN3VuOHFlbm1YMld0YXNxRytBS0NpenJKNTl2MkROdGJaNTdTamF2NzltZzVrUGROdDhxY3FaRk8vc3dnVk4vN0tSN29BVlZBTXFSaTl2SDdaZTkzdjlTSTBRWlV4VDhKVkpFNFVsZFZXNnM2b0NxbW9YUWw3djRQTDB4elNMdHo4WmhvdnNPNnVxbytVSldPTDh4R2NzZHNMS2xmN1F0YzE1YlhtVlc4bEtNRm9Kb0wzSk92MCs5V1pkSnpnM1JBbFM4WDZpWTM5em5lMjVYQndRME1EejVqaHZzUG1jSGhoNHJCM3Z1MTBJK25zdEU2Q1FBd3pweDJmdlFWdXBqOGFaMVA3K05pZkFIVjVCVG5rMjJ6djdWcHEyR1pXWnBTK3pWbzZ0ZFZJYmRBMWVkcFBFNzNTK3dNRzNCVGY2ZG1uQXUvVlYwVWpUVTBqVk4xdklDYzNqd3p0TDdBM3VuUDdLRzJQZ0UxY0FwajdiS3VLbGl2NGd0eWNLMFEza1RyOFMvMW5jaTJ5d0dFZlB5ZURiTnhiYzhNRDhMOGxvT3FycTZLMGFXQ01NVUhUUllTcUFvL0owUWo4RklGeUlQclorM0I3bzZaYkY1YnBOdkJva1VCMW1Yak4vRUdnQVpBcHFUUWdqUUJoS213MFd1SndsOFpXM05valk3Rit5TjFWWkNrOEFxZkJSVmVBc2dxeUJwVWVTRUdERzVQVHlrd01zUkM5RWhkVmM2QVBjUEFLb1VpZGlJZjg0NmFMRzR0M1l0SG4zVXBqR0o5bGkyZ0M0Q1cyMndtcHZTdlRRSG03U3lYYTlyUExyaDA4eEdvZWVoNkdlc3h1cXE4YkEycTRtQ2g5YUNCdUVRMkFERGZnS3FJZVNUWFZRVkhubkVzanc5TnJZL1MyRzRDaUJGSVJVKzhvZ3FqV3V1cUlHenFxQi9zK3ByWFZxWHM0VVZhY1JqM1JRemZtK2tOekFPVW8zUlZ6QzFrVVFmUUFsVkE4M1lWcUU2Tlc3MC9GeXhZTHdDd2hmYTlBNkIxVCtHWXRPVzRIVC9FcHAraVBjY3RsMXNYVk9WL1grQTNvdSs1YnVnK0cwMnNvUHVrNVlDdlR2dFhXNmRHNlg3dnMxYkZTYlp2YmcvQXY5TnV0R3JWbU9IeXo3KzhiTFpuUXV1UjdOVlZ4UVp5Q3JCTkpYYlBpYnMvOFNKalhkRzFvTVRMZ05aNTZ3czBuWTRIckhWVmJPS3pQS0dQbC9ZM1pEczQvRjM2U2ZLZnJXUFI0bEtPUG12VnJZQ3FTT3N2V2F0aUhiNm90SnBlUCtEV2xjL1lqU2QrcDlpNC9LN3ZldmNyZmhrNGhTY1JIZ1B3a1ZXSmIzdk5nMy9HSFp4NmpUODQvV1hjTzNYSjdKODZiZHl3aUhJZGRxNC9XOTlzVFYxVnJLUGxrVDJuQURNcldRNnVNa3RJSGtlT0RqWUhBazcyemo2eWg2NnVDbEtQazNITVk3amZrN05sMUJ0Tkw0MnJ6UXNyQXpFQkZmRUF4ZXVqTDl3eTkvN0I0K3ZvcWdKMkV6V01JdmcwL2dxOVVDQkNqd0F5TmVJN0QwQXZmL3FCMFgwUHZHK1BDSzZIQkttTlNBRkdmYk93b1FCTk5FWWEwSXRHdlZZRVZ5SU1BbmtSV29JUGJRenNpMi9NNXZGaFg2MnJTcUJLRUsxV0JNcmFjSkxjN1lmU2dnQzA3bEhpUTBhZkRWM1ZyWVFFc0V3V2Q5UWtjV3ZwdVFXcnlYRzhycXFkbGt4LzZTeWxwZjl0QjZMTlhrZDVXMDJPR2xnSnN4YWFzczNrUlREZVpIbkwyWG1QcmlxTmZTMVFsVjV3VGYyRXg0VkxvaHJmdE5mVFZjVUhNVmhyYTY0L1RVcnBvWVVobGFLZTRlMG5QdmhyNktxUzI0WDBQUnRkVlJnd2dsNGdEQXBHRlVaOW5KNHlDckN0cTRxWG9OWmtTYVB2Q2hvdFFHRzBzYm9CQ3ZIUHZnVUwrR0xjR3BoYTd4bTVmM1oyWlZyTERFSXV6YXhvNWVvK0o4Qzl1dG1lUVR0LzAxRU9xdktVRlMzTWpNWDdOemFMbWg3UGVsa3pPS25xRG1ab1k0K1FJMUdHS1g3L0Q3N1lIUHpoRjRwRWo0YjlGR0E5bVdZcllGbGJ0MUxvZ3Fvd3NRR25MNTh6NDROSnM4ZGdqK1VxUCs4Y054TjRacTFpeDFxVmprV0lTL3Nic3VYS0xyblkrb21aUjJjZjlRVmRMdFZxcTYvUDdUclp0TlBwYXpYYXI5elpoejlkblAzRVAxMjgvK3YrKy8vbXcxc2EzTDNkM3ZEbWQ3NzZnd0ErbU1mOTRDdCsvbHVxNnhkZmcrdm5IakFIbTlNMllMMGxYUldRV2F1V1FWVTg3NEtxMmhLVkg2ZDZGWUJ3ZUxoUjRzcUY4ZjRkait6RytJd0ZJSkRycXVLaW5nUytHdm9RUUJwWE0xMVZaQlFBaEZWNkZDb09wd1d2WGh6YnM1KyttVjVXVXoxOXVpb2gxWWhTUXgyQW9WclVleFZTUU05b2ZRc3Y5c3JGM3Fic1hqMWZiTzE4NXJBR1ZRS2xnc0V6RzF5Y254UUVMS2tnV3A3YVJlaVN1TjBBVklvYW9TcEVINThVY3Y5TnVBaDdBc0RxMDFVbFVKV3NWVTRVQTRaVmdXTVNsU2djaUJKRWhXQzFPcVBFS2ZXNC9zenJxbTRsSklvd1hzL2VTU0kvdnJWMEwxcmZ1RUQzelhzMXFBcWhBVWZOMk5HdVAvelk0WWFPNHkrNmdDakU5MUtBOVdmN2piMXVSeEtDWDFOWHhScElOT09heWI4LzRxcU1lSmEydmdrUDBQRzZLdFRMYzltQU8wbldkTlliYkVhYTBCUHE2MG1yb1FCWDY2cnFONnBRYjlSenFpRHc1TUhwb3pMMFVWMERxbGJycXBLMUtsbkNnb2s2dm9rRTAzbWdUU1hrQlJoWFdUN3I0Y25TZzBjL0YzY3Z6aUsvbC9zdHRhaG5jbW5sYVgreXprcmNxU05zc095dHQzdlVmOTZUUDl6ajc1dHVsbk14QXQ2aXJncHhEb3lnS25VMW0rY0pBSmQvNFJ1SzJpVkRhclpqcVVyM1dnMnFtdTcxaWR5WndCaEFET1lqdWVPUnUwd09uSjZxcm1yNW1QWEozUWRUczFVTmxtMU12UlJnZHZGWGdhcGpyRlhaZWRiZmRoa0lNTis0ZnNnN0h2cFllZllUUC9EZDcvN0dCNEd6Q0RMRFp6ZTg1VDFmLytNQWZod0EzdmFhZDN4bGRlUGlXL3kxdS82ODJkdlp3ZE9vcStvSFcwaHlpd3hVTVFFdkFxazljRGliRHVTSjh4dDdaeDY5ZnFTdUN0R0NGUUJXekJmcUVrUjJBVWp1SFh3RWRYRU1EUUFGSVBqRXhRazJyOXlVMGI2WGhrWmNvYXNpazU2S1FqVmhDdkZSMTBxQWFrVTFiVE1qZ0tNaExqL3llWU90N2NkMktXenBxa1NoTkVCT0FTS0JLb1duSlVWRnU2QXFnanB2UUtpQlBqb2RtTHQyRnhXQ2laSXJkVlU1cUFyTDd0cHVIRVlNMmdFRkFmR1lFcmpYSzY0YlB0ZEFWUjRTd0RwcWNzQ1RUbGNFaW5BVlZiZGNmaFU5MkpSSmFla2hZYk9NRkt0QVZRcnQ3WEs2ZFhZbkx5S3NkL0RBbXJvcTFDMjJhTXVhWlk1dk5jMGJmTE5ac2duTFhkSFUxYXVycXMzUUVDTHRoQjVCVmJoK2pYazRpTnpETEtpTnJrcVAwRlVsYi9YVWFKVUtxeGtsV1pnUXJIcEN3cWdUMUJOZjBoVXM2YW9RSnVOZzRRb29rWVJxV0NFVDk3d0tZTkpIcTVjU1V2elVKZUIxejlabU9jRjcrN0liaGFjS3RJWTBPT3Qya04vSDdkbDZHVlQxMjVxeVNTTG11Uy9iZDNCVnZuYjl5M1dHZm5UYnhhOXNiUTI3Rk9EeG9DbzNualJZb21WUUFYRHp0LzVqTS92a0MycTNERDNnaVgyZ0txYlZvQ3A5MThiSzBWQ0xGeDU2Z1RHcGgydFNnR3VCcXZ6THhqSjM3MC9OcWNXd3NTZjFncXFtanRiRnlDLzZyVkNBY1R4WStqRUZVT001di9PaFJ3ZDMvOEhmKzk3My9NMGZCeTRnN1B6MDNBeHZmdWMzL1RxQVh3ZUF0NzNxM1MrYlgzbkJXM0gxN2dmRVc5c0JXMDlLVjFXREtqU2dxZ1pYQ1ZReGdMUldlaHluQjdOcHNYbmx3dWJCMlUvZm9GSGxrYnFxQ0tyaTJBaUNDSWFXREZTbHNUaXRFdFJZTm95MS90RVhidG43ZnU4eEdxRUoyOWF1MUZYVmM0ZkFDVWd4U29tc1E3SmlSUzJMaHloRWpkZkZpTmV1M0ZPY09mdlFRVmRYWlRJSzBCQ3FobW9vVkVzVkZRMmlkbEVMcWc5YjZ0Q0FxaEJhaGFxQWp3MEx1ZXRnN2lJRkdGa0tDWUEwMTFXbExYVU1nZ3NIZ0toQWpLRFIzWUppQnVKZXJ6aUlEOEJMRHhVYkIrM3g3VGtXRWtYNDVBRFVjZWxlVXQycmRWVTVCZGdQeEZKS1RoV21QQWxjMVdDblNjNTRncTdWckFGVXpVZ2xuYmp3akRFQ0hRTEg2NnI2UUZVMFptZXJFU1BvWUxSTUlWbDJXSU9xMWJxcTBGcHlyWkNXeFVvME5kVmdKM3dkRjk4U21ONWlXdngvNXF3dWNmeGs4NkRIN2tiTFV3M2NOT29rU09NV01Db2hqdEhLdDZ5ckVrUmRGYWtJK2pHTkluMEM0Z21sR0NoWlc3SThBTTcvOHR0M2dHKzlobWNuSEdXOTZvdGJMKzFGczlNUlh5YzBrWEowUWRWeStlN3NtVDhySTFxYzAwbWRlalFGMkpQV2VsWmE0ZU9qa1gxNE1EREI0M09UVXpxZ3FwN1hsakZEWDF5d2ZLckI1WC8rMTB1WXpKTkxUUUdHaG83VFZkV2dLZ0tmT2oxZWg1MG43alRqL1ExcDlyVHEvRlFacURwT1Y5VjBvZzJxMHZIRnc0MElycGo5dE1zZjdZc0J0QzY3ZFBKbDE2VVZGMm45Sld0VnJMY2FIVGgvOGFPL096NzM0ZGU4OVIzZi9MSGdjZVQ1RmQ3OHJsZStGOEI3ZitTYmYreU93NnVYL29GZXVmZXI1WEJ6T3cyN1QwVlhGWC9uK3NVeUROTDFlU1BKeU1kdkNkczJsZk94blY2NWEyUC9qazlmVCtDbEhsZDdkVlVhNWg1VHN4UDFkalpwbFNCcng2SkJWeFZBbTZqTVIwWXYzejIyZDN6cVprMEJIcUdyUXFRQVU3OG8wYldDYUpxek5OS0pvTUFCME91UFh5cDNkaDZtTmQ2dDFGVWg2S3FVVUJ0ZWpEMHRLRXJWQU13MGdhckNVNk1PUytmVzhFWmhkVHM0SGcxV0t3ZkZBS3hWV1FKR1gxWnRVTFdqeEZ3VVF3SURlQXdJdktSS0ZHVm5wSHB1aHR0dHdlb0NvR2FJbHl5dUdUdmE1ZnVwa1h5YVNNQ3JkcTJRcGFhanRxNnFyNy9TQVlCMW5lS2phWFFKVlBWUmdMRjExaTlCelZpYVZpS2l5Y2Y0a0FDQWhnMDlhekY1ZW50S0Qzbm1yeXFCS3VRci9kZ0FzUlJYTHFyd3RyQytyc29FSDFZYVp5Y1BDWG92RlhoamxMWElVYWdzcW9Vc2FCRkI0cEt1S29ub282NnEwWGN4Z2pqNGlEVTlBRytFcEZFRnhRTWtDdXdBZUxZQjFyclB3RHBwd0wyTE81Wm4rUGpKbmpMc3lkY3RTeEQzNmtaclI4TzgzSElkNmE3c3o5V0orYmViMjRPVjFxcDYvbHJXVlFGdEVCYndRRHZmamQvNGkzYngyQVdSR2xTbFNvL1dWVVVxQllrQ2xCV0FxNndHY3ZiaGU0TDhZWmtDWkt1ajZkSWRTd0UySUtZNUppNGNUT1gwZkNnWjZtVCt3YnErSnJsMTBhVXZydnR6TnUweks5T1VCeGJUbTNQYzk0R2YrWjczZnMwYmdLOUErUC84RG4vcm4zemJaUUJ2QUlBZitJYjNmbi8xMk9lL1VRNm4yNWxwOUVucHFtcnJlUTJxa25XcnR0WXlXM2hCWkxLTVlqRzBrNnZucGdkbkg3bUJkWFJWaHRFbklRSUZXRE1TMlV0dGxFOFlSSWtJcVNKS2YvWDgyR3hjM2VWMGQxSHJxa0w2a3E0cXB3QkZsRXFqWVp5SHQ4SHBsUXVMcDZCaUZJYjByRXAvL2JGN3pkbnpmMUlCZ0FnZEFKZ2pLRUFDa01CUW9RQlZYSmpMckFRTG13aGRxYVNENkdPVGt0dUhXaTNwcWd3QUU2blZrb3E1MFJhb0dzSmpTT0RMRjIxUXRjSFdZL0pjRHVzQXJGc0RWZm14RjE4RG5CRDZkRlh0enk0Rm1KZmpVcHdIeEdleHVhaTlDN2E2azFmTDRvUWNxTVh6K0pBdFVZQ21VemFuQU9zOENaQTE0M093UXNVeVJUbjNVbTl6RU1DSWtlWUJEbVdXZEZVdEs1VVJEYnFxWnZmMDVDT2F0cHhWVGpTdDRteFJnRjFkVlRCZVJhMVoxR1lwNkUwY2tLTG4rU1JhVndFVnhXSUI0OHV1cmtweVhWVm9OeTVWaHE5NTkvaTJsVUFYZ3lWTEJmQmhnMnBWMG16aDJRaVhMZzBCM0EvMDNEUHQ0MXNEV2dMaWZIVUdYV3ZWS2xBbFI5VFZ0UVRmcFJ0WkRKZit0bzZXS2NBNlJ5ZjNuckh5dTlOcDJiVlc5VktBT1ZZSm55MVFCUVRMYkRMc3NDcncrTC80dWlMbytpS295cnAzbks2cUFWWTF3QW9WU1BQdWR1NlRMekJHVFYxSDg5MFNTT2tEVXZreHM1TUdUS1V2S2ZINHpzT3huSm1QRGZPOHlDNUUzeVUraGdKY0NhcnkzSmtCMUExblR1Lzc0UC85dmIvNG4zMGQ4RFg0YkEzZjliTXYrNGNBL3VFUGZQMC8vMS9kNC9lL0FvdlJ0QVpWQUhBcnVxck1rbFVEckRSVzFucXFmRXl1WDJvQlFNdjV0QnpkUEQyY2J6K3h0NjZ1cXJGU2hiRTB6aU5lNnJTb3EwcStlc0xxUVhXUDNiY3h1dS8zRDBUVXcwVGh1bEVhc043alQ2S3VDb0N2UVJVVUt2QVdHblJVUm1FQ2k2ZFFveUxxUmNqZHF4Zk1xYk9mOXFWZCtENVFGUXdOYlFyUVVNTjJPVFpZck1UU1U0WGk0UXREZFJRdExQWDZvRUJWTExRazI3cXFNdEtGaVFJRWlSMHFEc0RuTTZqS3crMEZXSXJrcTJwNVVsZ0ZlUExTUUp2dXFJRldOaHJudXFvMkNiSzZqVGE4MDFaNmsxOEh5a3JpQW9CVkZDQXlYVlZxTTQyUEpvQXExRmF3NXBORlVkRVk3NmdXNitxcTR1VklmZlNTMDRTaEgwa29yeXdXd1VLMlNsY1Z4ZXFCYWd5NktrWUxYYlJjMVZxdzlKQm40STZ3MVJ5aVE0bWUyWS9UVlNHYXRPdCtCMHJSQjQwWGZPeTNSL0p0UnRuQXN4TWVRTnFEWUIzZ3RDN1F1bWV4aFRLSzBQdXBjblR1LytWN3Q2K2RLUXRzY3BEbFdKcUhqd0JWM1ZqR2ZnQUVmMzF6Y3hnY2kvYUJxcWFOVlJRZ0VPbnVWQzdEQlZmLzM2OHEzTFVkQ1Z1S05CMVlwYXRLajE1T0FVcTBFaVREZFFBOEJBaHVYN25UVEc1dW0zcUNyVHVhZzVPZVkyUmZOcFpaeXBmRmJWWkQzSEU0alQzS2ZvRDhZdFQxWmhldDNlS3l0U3BTZ095VXlVRVZBR2hSYVhYdmh6NHd2dmlSbDc3cEo5NXdBNThqNGJ0Ky91disyM2UvOW4vNUh4N2JlOG4vN2kvZjk3VndnMkY4ZDFsZlZ4VXB3RnErSWJXL3FzN0t2NGIrYTNSZndmbzAyajAxNHVCd1hrMXVIc0FFT1VXZnJvcW9YNUpyZjFXRTBFQUpFN2VTaVl5REpPYWhwZ0FCVkVQNkt4Y0c1UjBQN1M3cHF1S0xieGkzUllWVUdxb2hQV2xvUldtb1lXc3pOVW1tb1lqYnFSbVFLdUp2WEw1a3o1MzdvemtGdEtEdjZxcUtqQUlVeStnTEMrb3BhZ0UxUHJxa3NIQlFZS3hLUzNxRjhNcUc5ZWNQMVIrcHErcFNnTTlUVUpXSGRUUllUeDVncFZXRVRWbzd2UUV0Nk1tVFJweCtYUlZBZUxnNmZSbFU1ZlUxNVlnRXROcnVIVUx3ZFM0QlJrNHJBUVpwOUpUUTQrU09vRmRYaFFaZ2RVRlZzQ0RGQWdLeUhCd3Vxdm1rQU5iVFZTR0NremliQkI0OWM5ZUFkQXloR2N3cUZicTFkVlZHS2Rwb3dhSzFUV0VZUFAyR3JkWWRnR0NOS2lzQnRLSVJDc0pEbW5SVndSTTNQS0FhQndNUGdHS29KRFNDTGkvaUkrQ0NDbFRqSU9RbFdDWkhlSGJDbjBiL2ZZUmo0bzVPdTI5K3gxSjhGd3F0QjZyYTlWN1FTZXNaNllLcWZsalZUeDFtN1JMQXIyMXREU0tHT1JaVXhibW9IZGZGTS9GVDUwTSs4YS8rV3BHc1ZMMFVvS0FHTXJVZnJBeHdkYTFWa2sycTFwVnk1dE9YTElLSXNqRVk5bEI3ZFZpaHE4cnoxZTkxTWYvUVc3bDdiNlBaSWV0SWE5WDZvS3A5Y1p2K2RNSGg3T0lmZjNKeTZiZi82bHZlOGZxUGZqWlFnYmNhWHZuVGYyY080RHQrK05VLytROW0xMTcwMDdoKzdvdUl4c0lFWUcxZFZXT3Rxc2ZLUlBNMVkzekRJaWlFWUFSTG8rdDNUclZjSEhKMFVDVWcxZFZWU2Fhck1tR0ZvUXFVVVJzVkZ3RkZ2NGhoWTVyZ2V3cElaYjFldjNPSW5VZXVvM0MrcTZ0QzBsVkZDbENDMndnSzRDWE1MV3BBMWNCNnVBQ3FsSVdvRWxRTCt2MGJaNmtYL3JnU3FoS0FKWDJmcnFvZzZDaStKRmxaOGFXU3hzRnJDWllWcVFQUUt2eWdWSFVxT3Btclhwc1dlbjdmdWJWMFZaOEZ3Q3FGMjJ2QldvaEQxKzlWUHpYU042RTB5NHBTV3BjMm1ja2ltMXk2OWE3UVZXVTlhZkwxOW1uaXRZb0FpV1lOWFZWT0FTTGMrUFZuQWxWSVhuWUpESVlIbFZ1TVpGMWRWVjFuRWtrU2lHODdsREFEMFVCSk5ZcHlvU0xxNGh0WG91a2FDbERnVGVpc21reGNLUUdRcVFFb1lmZFBIeWNmWCt2RGhBcFR6VVZZb1JtTXRLdXJFb0MwdnRGVklXaTV3RUFGZ2xRSXZCRWxhWndZRGVKSmdLU1o0SmtPd1h2N0Y2QU5zSjRlb0hVeHVtZFlCamE5QU9mSXV2STZ6bkhTS3JrMEcyZDUrMEZWYjNzZm1rektLMFZoc2wwTEFJUzV2d0ZMRFFXWUE2aFVZemN1VVluWDMvOFhyTi9mRURITm83dXVyaW9IVmJVbEloNm50RE9QM0cyczJ1emhiSDhCWk9YRHlkR2dxaTZXZ1RBTHdUMjcyMGJpekwxOGlkdHROU0JxQ1dqVjdiTlRaaFd3Y29PWnd3UHZlOXRiZi82Ly9MN2dydTF6Tzd6cHdkYy9ET0NyZi9BVlAvY3QxV1AzZngrcjRRUUFHc3MrSXRBK1dsZUZoaFlFa280MGdpcVIrQUlaZnIra3EyS2tpWFZ5N2R6bTRSMmZla0tMaFpkUU52b1ZWQVdsWHRpVGRGVkJDQlplWkkxUXFUVXc4eFJsMm9jdzZyWENTekxoOU9yRm9iM3prOWVQMDFVRmRnOEs4V2tGZVNWR1lieFJtMEJWS09SdG9EYzlLZGk5ZWllMmR6N2pMYUZHQXdWWUpBb3cwMVdWREJSZ1NXcnBBcWdhVkVGL05YVDBJMVd0QU4xVzFXb1R1dTI4WWtqOWJOQlYzVW9vRUt3U3R3ZGdIWnJHd2dTMEtaRFZ1aXEwWHhVN0FDb0hURE9ab3d2UStuUlZUWS95UGkvWDJ5NnJZNmNWbUh3Nk5ZNUNFNGpxNnFweUNqRFZsU3hSTlNESzlnRXNCb2VWRUhaZFhaVTAvcUU2dWlvQTZTR0JJSER6U2w4c0tyaENFcWhpQkU1QTFGVkpCR1pKVnlWTW15NHJKZEM3VVFZUXpkZVpycXBZZUpGNnBTTGk1NUt1eWtDVlJqUjZwUTlBUzhRWlVhaUlNOEs0YWFreStOWUNUYWhyRzg5OHVCZEEyc3R2UGVDME9xNUpPKzFHMk5DTkkvT3ZvZ0RiZWZKbmlDaGhjSnJqQmtuMGdLcSt2OUxLMnd1MmZuVnphOUNSSE9FNFhWV09BeklRVnZjdHhWMzdkLzlKWERtNG5xNnFjYjJBbWdKTVh0MGJ5MVlvVTg1SHNubmxEc05XR2JUTDF5Y1ptT3JvcXJLeTlYZk4wKzdlM1RZRHRlMkx2cjZ1Q25FeXorS09CbFh4TCtkM2ZPcngwZWU5L3krKythZGYrOGM0Q2Ezd2x2Zjh6Ui8veDkvMFQzNWhkdVBTMi9YYXhUK1hnNnBHVjhYc1psdldWYUZGQWNZTjZzT2dtZm15Q3Bhb09HWUNZWGtTUjFmUGI4M3VmT2h5V0t3VFhrZ0ZKSXdHNnErbHE5SzArQ2VNNnlZeEVjcDZUS3dCbDFBaWRlaHZuQ25LVTQrU3c5bmlPRjJWSWJ3UFl6OUY2TlVidFVZYlVFV2pFS1VWOVRDcTRvM09ycDNGbWMxSEs3RnhDNTRpNktvc29JYjBTVmZWb2dCRk9IVDBhc0RTcUo4NHFucmhOcHhYTDd5dm1Ic3NoRGd0eEo5Yk5BYU56MUpRbFljQ3dBTHJUU1pQTHQxTEJjc2l4cTZocXdKcVVFVGtRQ3VCbjZhTlExVG9XcUJZMTltZGRJNEhWYW1OTUFIcHhPa2lzMVFGQUhTRXJxcXVTeEtOR0hnMVF5WitybG1SS05EQllMWVE0YUNQQXBSa3BjcDBWVWdEaGxBbGRDTG9sWnFCQkFrb2thS21tTS9WMnlLWnhpWFRWUVhldjM2STQzV3RUZFRCcWhTcFBDQ3RzSW02S29Ld2xjTDZSYngyUHI3aEtZa2xYWldrZnNZSFhVQ3Z3WVN0REZZMld0RFR4S1hHVUNkcVJ6OTFDZks2aDVaQXcrME1ENkFOcm9EbGUvcldnZGFMNXNsNmRTdWdxc25SUEM5dEs5UjVIUy9WZ3A1ODNkaWx1YjdkNWpWYm1BOVB4cVZrb0FnSXEyT0IxYnFxOUptQnFsQXVTOS8vNC92TjdORzdKRTRzNFNsWlIxZVYyb3VXckJTZnVXZ2dCRGoxU0w1cU1QdGF0NkNyWWcrb1NpWTVBWEhuL29hWkxnYXlSRHUyVzF4SkFSNm5xK3FDS2tIWUc5RGYvKzkvN3EzLzdLV3ZDcmZwU2VnTDMvNk9iNzRLNEcvODBDdC81dFdMeDE3OHQrSHRFRkdFbWdFc1pNZEx1cXJBN2pVVVlMaEpFN0NLcTk2aXhhaVdXeGpTK0FLRDYzZE9xOU9QWEZ0TFZ4WDlWU0ZTZVkydUNvMnV5a1M5RktrU1YxbFhUOXd6SE43OTBZUGpkRlcwOUZhRkJnRjhXWUdIVVRXa0JtRGthVUVQOGJRYVFGYmxCbHJOTm53NTJYTXRYVlZ3NllDeEtrdWhPaFV0REwwS09KbXJEa3YxdWhCdWpBT291ckF6OXpnUW9zUm5OUVY0WExqOUFNdkpBcGJ0emFTUDBsVjE2Mm1EcWp3Zk1aY0ZnbWZZaUdlTzBGVzE2KzJ1TnV6MmdRQTQ5cnBJRkdHdXE2b3RXYkd1bkFKa0VCa0NTRnZXMUhsYmJSbEN5OEdoTTlGblNlcFhTMWNWTGsrdHEwcmdpa0hYeEM2b2lpNFhhSUtaVERHWUwyUStUdFJKUzFjbFh0dXRjd0FBSUFCSlJFRlU3TkZWR1FWSWhSRWk2cXBpdlQ1T2d0RzNWZFJWR1QrUGpodUNyZ3J3Y1ZWWXI2NHF6dEErREFCS0pMMlZvVUlsZWl1bUY5Q1JvdlAvNHUxbmdHOTlBczljdUJ2OTl5RjY0dFlIV3NGNysycGZjTjM4YlZEVmZVbG9ZcEx2cTI2dVBwRFdqZS8ySTB2NXRhMnRJU0V3L2JxcU92Y3FDaEROczlIRk1yejY2LzlwSWFLM3JLc0tFZTIwQktvUUw5ZmdjSUtOcTJkTWxyOERxdkxqMU5HMnJpclZWWDlSYVN4eUJMbTVHTXFaMlZSNjZiL1l4MWJjS2wxVnVpQkhnS29FNEJhVDNWbjVoZi9QeTc3clhhLzgxemdKYTRYdmZQZkxIL3poMS8vRUJ3OC84OERiTVp1Y3JlbSttZ1pFQTdnQ2dHcnBxbW9LVUJwUUZSMG94M2tnYWJSWVcvb2hZRG1iRkp4TkN6ZmUzVi9TVlNGWnBKZ29RQThneURxQ1JTem9xZ1NCWm1Ud29VVVZGMWNwcWxoUEhtNklIRXlBeWU3aU9GMFZZRHdzVlVpRjhSRFNGZUtWaGxvcTRvdXc5NlZScldCMUlGNXY3SjkxRjhhNzFaS3VxbXAwVlJ2cU9SdUszNjZVRzBQblhXWDB3cndpaHZTZjY2QXFEN2NmWUZXeXdCRERlSGE4cnFwcnBXcC9MdE45RGdzVUtGcHhSL25leWorYnNUQUhmblV0MDBvZEFMK2txd3A3RklhWDBRNEZtRUJWTE1Pd2RVR29XUm9MbGhKZ09UeGNRQmoyZThJYXVpcEROVkFFazdFbTBCVjBWUVJVNkkwb1NGRUxKWXY1M0J1MUszVlYyUWFpTlFVWWRvbVBtMDB6cmY0RGdnWEtDMEJZVDFBOGkvbWhWQ01iTm9pT0p1cGdjbmUyUjFjbHRRTThlQXE4Q1dBckRDeUZVM3JyREZSaHZSclNHK2dwQU04RmdQWGtnZGFRQnFmZFRnOUlhdWZ2Z3FDKy9NMXNIRkRCSFp5c3FMZS9mRGUrSDVEaEF4dlRnYVN0M05BMnNEd1pVSlUrL2Y2RzNQejlQMnZEeXNGWTFxQUZuSHAxVlVSbXJXSUNvTW1LRmVvWFlPZmhTK1U2dXFvRWJMcTZxdVg4SVQzbExkWGd3dDZXWFFKV1Q0T3VxZ0ZWYU5HSmk5T1BYcDE4M3EvKzJXOS81eHNleGttNHBmQ21uM3pENy8ralY3L25xN2g3NXFkMDcreEwwTkpWRVNMUXJxNHF1Rm1veDhiSXVJU3hNVEx4UVVPVkpCd0J0TlVyb3dHeXZIbDJ3dEhCcm9wekxWMFZlblJWb2F3UzR1TXo0RXdYVkJuQ2dJSEdZN0IwVmRjdURrYlRQN3hKQkxuSEtsMVZBbFhHZW9vYURVWW5WV1BWSzRURzBoZFVUMUUvZ0NxaG52T3hOM05ieWRpdDFsVk5vT2VjMDNON1RuRmV3eXJBdi9TNW9hdTZsZkJNV0xBQ2piZXVycXEvTDkxSnB3RmFDMW1nWUZwV2Y2eXVLcXUxYmNWcWwxRVFtRHF0dDhwWlYxY0YxRFFpMCs0ZnBtbkx4MEZVRFlCeWNMZ3cwR2JYOEpvQ1hLMnJJb0xKTjRBcUJsMVZOSUhic0IxRG9CZEZLYlphaU5HQk1OZFZLUVhSK1Z4WFZ4VW1rZ2grR0MxV29xRStJZzRnUHJSdktNT0RRL0hGRU9FVlBlaXFJTTRtbHd5aTJ0SlZTYUlBNmF4UkphRUNxWXh4d1pwVmVEV2lIaFFuVnRVWWZlWjhZVjI2dElXZ3Yyb3Z5dWovWERlT2VOSHNEZ2lrTnkzOTdiNWt0Tk1iNUpISG45VXhDalFpSU1uekhnTzIrb0JWelBQb1lHQ3ZCbkY3dTNYazRLcWhBRnNZWWprdXd5REUxZmYvaFFMZVFFeGMyUldCMHpJRjJBVlZRSnowR3V0U1doMFd3M0IvVThZM2RpVGx5enZTMVZYMVVZQTVxTXIzc3BNSXhnamczUDZtTlpUOFMzVXY0cFBTVlVXZzE2cVhBS3E3UHZxSDdtUC8wUmQvKy92dXorL0prM0FMNGJzZmZNVUJnRy80d1c5NDc5K3RydDM5TW9FSW9XMWRWYkRtRThIbGVxMnJRclAvWDcxMVRWcGhHQzMxeVEwUkdjb3BBRFVVSFZ3L081bWZlZlRLT3JvcUNIM2N0TmticUJjS0VjWjdoYUdIaW9yUUE2b21ES29lOHdtNWYwcnM5TnJDaUNvTnZLWDZQbDBWVEtRQVJSV2lhaXk5aU5mQ0dEVlFKOVpyWWJ3RGdCRXFMVXpsWjdNdFBWVmVxZGJTVmIya2FzKzdKOENxRGpuQWV2cEFWWDVjU1JWZlM5ZlRWVFdmN1FsR2V2SVJ4RUxtbUVRL1FFMzk3WHFXZ1JtenRHWGdGZ0dSSlZFcW5UZGl3a0FZS0VCd3RhNnFEMVFCWWN3TUF6dVFRTnRnY0RodnpNdHI2cW9ROXhtRU1JZ2I0Y1BjRVAycGFLUUpTWnB5dmxDeWl0Y3YwMVg1SlYxVnZDdyswb2NLaWI2eHBCWnNFaEExNHNObW51TEpjcjRIMEN6cHFvdzZ3L2lkNG5ZTWdMcG9GbGNST2tDQzBONDRGMW5VS3BuTnhkQVpxQ05rZ0djdTNBUDAzb3ZvaVZzZmFGM0s2TUVVbDJiOURvUUNlbUs2d0NwOW50ZEpxNy9MMEtuZG4zNVF0VlR2NzA4bVJiMW9JL1VBYlZBRnRIVlY2ZnNFTEJTUVVVS1V0WnNIQ3E3OTVsY1dNRXlXcDJpRkFodUF4VjVRbGFWRllDWUptTlZ3WitmaGU0cG1QOFBZcVZ2UVZhVnZRbUVFVlUxWkVXSnpQcExOK1VpZVRsMFZsK3BLWm0rbHZ1aTNmdW43ZnZFL2Z4bE93dE1TM3ZLekwvc2ZmK2lWLy9RVDFSTXYrRTdVa3BJMkJWanJxaEJCVlhLdEVIMzdSYzQ4N1l3UlJlNUllN3FtTVRWb29LcVJMUTQyQ3I5eGZmOG9YVlZjdWUwUWFVTWpxcVQ0dUFncFdkRThoSEczQ3pvTEJTamVYVDFmbHROck4yR3BodFFDcWw2b2hYaWxVSk91Q2xBdERMMkQ0VUM4QXF3S1U5R3pkTFpZY0lSS2grVkNLMS9vZURqelloZCs3SVFvV0cwZVVHdGQxZVpNc1RCNlFnR3VId29BRlc0bndGcElueEM5cjcxMjNETG95Zk0zUUttcSs5OEdUOXJxVjI3SmFvT3FCUHphWXZlNnpiSFhhbGVzVFZUSWNicXFVRlYwclJBYUQzUWl3azduY1RKU0lUZ1lIV3JTWUMzcnFqUlpzc2dJZGhUaFlSWTFYaVJoTG9tN3BvZVZMQ0lLRW80QVREazdGS01UaVU3dFJPS3FreDVkVmRSdkJUbzBpQ25idWlyU0d3SERmbGppamZHVXdjRkNqQTdScDZ1eVZLUGlHUUJWcmFzeVFvWDRzQm1wVlFXa0V1TlVWSnlVenNPTGg2VVhwU3VNTXovNmxuZmJOLzdnSzNNZDNlMEtkK0ZvNjFWZjNQSFB3WjNWR1N5REtyU08wSTFiQWFyU3l3bEIzTWxwejNPRTNoYU9BVlg1M3c5UHhvTU1QSzFQQVRMZDd4TG5INkdwdXd2c2ZmUUx6ZUxxR1NOcGlYejZtbDFkbFRRRGRaY0NSRHFYQnFRSmlOR05IVFBjcloySzNyS3VLb0dxL0pKSXlFZUFzRFE0dDdkbG0vME1BNmhhUlFFZUNhcVFsVXNYTGpVc0JFWEpCLzdkajMzUEwveTFOK01rUEszaE85LzlqZS84b1ZmOXpHeHg1ZDd2RHY1ek83cXFaSjBLZEo5UHVpckVqZXZaYUs4YVo2SnhCWGJVbHlxaEdxeitxdVhlemdTanZWMlVjM2UwcmtvSkZSZW5JaGVjUHRPTHdCbFJxZ2l0MEZOVURlQkE4VERxNlFicTkzWk11Zlg0TElHcU1zeDd2ckJPcmRJblhaVzNkQVAxdEo1T2hwV09VS2tmVlN6Vit3U3FOaDNKNmN5ZEs2L3BobkZlS1R3M2QxcnJxcjdVbllDcVd3eTMzNEsxcUgxVnJacWMrdHdvOUUxMC9SYXdVTCt2QVZJeldhU2pOa0JMRkdCVGd5N2x5OERZMEd1MWIwMGllVm9VWUordXFnV3FDSnJ3VUNGNk9ZOFBkTWhYMm9XSzhRdW9TUEw0aXlWZEZWcTZLb1JsdndGVUNXa1F4T29BWERRaHFDQUtKeWMzdkFNcklOQ0laUEM1c2twWEZXem5hRndya0F3clYwQksxQWJRT0dQQ3RqWXNGaERqWm9FdVhkWlZoVHBOVFFFYTBzZVZNRTZzODZMaWFLQUc2bENJaWhjSFEyK0lTcXhYQzNWbjNTYzNBVnpIN1E5MzRjbURxZjYwSFRkQ3lVSHIzdXZtWHhkVTViazNXV0lTdmNMMzFkc1ByRmFDcWhTL2I0MThjamdzVEtTK2dTTXdCTG80b1FGVklZMTFtd2JBbGZmL3hWS1MzdVVXZEZWTm84bm5VTG9jREZZekliWWZ2bVFEVUxsMVhWVnVTWW9nck1FN3NmMDdkemV0VFUvMHJlcXFBbW5aU3dIV0ZkVEFVS2t2ZnQ5UG5vQ3IyeGUrODEwdi83bTN2ZW85aDR0cmQ3OFZOTEpLVnlWb0hIMENET3lFa05GZlZRZFVwVldDQ2FScFdEbE5zTHg1ZGxLZGVmaXlFWVZTdkluYmwvWHBxcUlreEFGQ0d6UmJEcUpxclhnQ29Td0Q1U2RBWll5bjdwNUd1ZlZJMWFlcmtzTHJRTldMOFRvMDNsa3ZOTk5LUy9XK0xHY1VOWDVqY09qTjlNQ1BLdEhKNkladWpKMC9kejNUVmIxMDBaNjdUMERWTFlWbndJSmxrZ1dybTdjN09TeURxbVc2cnltYnlzMHhYd0pKVGYxdFVOWFVzQXltSk90SGFnSEEySE1Pb0pBMWRWVTFxQUlRcVRiRU1WYmpabVVCak1UMkI0UERxcHFQYlFPcWVLU3VDaW9hK0hrU2hGS1M0enFqVmlJQWkwN3NiRkhSREdaelZBT3BkVlhSUFVQd3BFNndvNnV5NGxsYnNrUzhnVkpGdksxWEVLb0sxRU1RK2phWTcwczF0RmlocXdLY0dsR3ZhcDJ4WG8zQ2F3QlJEa2E5RUY0c25RaTlLWnd6d1V1OGxxYnl4aXljTmRVWXp3ekF1b2luQXFiNjBpNVVtMWgxWHdQb0FWWHRQTkxLM2VTOW9GT3NBNnJ5cDJ1NW5tNVpmbWc4R2NSZU5SZ2lwcThHVlhsYUE2b2FUQWhXMTNaazk2TmZXS1J0Y2RiVlZlVVVZTzBMUzdLMmhCanViY25nWU1Nd3oxdURxUVpVc1FaeGJPbXFwSzQ3ZEw1TEwyN01SN0kxSHd1N1A5V3Q2S29rTys2QXFyb1dJZm5pMzNqUDk3ejNhNzROSitHMmhqZS82eFcvOUxaWHYzdGVYYnZyKzBsalZ1bXFVT3VxcUpLa0hDWXNCSXIzVzlDVVJxRjdLaE4wVmNFQ0ptNkE0bkRENnVUbW9aSGdGN0N0cXlJTjRLUGpad3JnQ0tVUjlSVGpoWWlXSzZveGRJSktFUUFaRGRYTFl1aDFQdkhseHMxRlYxZGxqWGN3UVZjMUxCZGFtVUlIc25ERlpLYVQwYjRiVmFLVE1vQXFOY0lMMjlHMXdvbXU2bWtMeHdHc3B3cTZnTG5rOVhkQkZiQkttSDUwWEZOK0pnczBGR1FEalZicnJ2cmkyaDdlZzVOTmdNR0NsVFJUcXlqQVhGZFZnNnJZNTdEeUY1UzBBM2s5NWdaaHZDM25DejhmbGNIZml1aHh1cXJnUElpaExvRVBxL1VBSStxRFJsT0NrRDNXWVFZSCsrcUxZYTJyQXNrQXNucDFWUUE4Q0JyakNab2dVQ2M5akNZaEprWGdKTkNWWGdhSEZGY00rM1JWUWVBdVhveFhLNnhNVVNtZGRkWjZiMFNkS0R3S3JYSlFSWGhmUUR5TXI0YW04aWdkZnVvUzhMcUhjUHRDRUxoUHNYeGZQeldnZGRadG9mZWVYNE1DYkpkcHc2UnpPdTNVMkQxYXJyZmIxeDZ3OWVIcFpORHkzSDZjcmdxSlptc293cnlOaUpsNDlkOS9aWEJhYXJTWEFseWxxMm83R0syZFJjWlRFRUpzUEg2K2FLeGI4YXV1MGxWbElDaStYTFJCRlJEN0VLb3hBTzdjMnk3YUlPcG9VTFZLVjRYWTM5WWxrdGdCSVhqL2IvN0NkNy8zcjc0V0orRVpDVzkrOEpYLyttMnZlWkRWdGJ1L0Y2aDU3U1ZkVmJodHFKU3dzQWhSRXhXZFFNY2RLb0t1S2xDQXRZOUJselJieGNIMmNERzVjY09LUzZzRk0xMlZrZ2ExcmlxODNJb1BsS0pYSytwVm9EWTRQZlVXWGlIR1FieTNBdTloeU4yekxEYXV6YnE2S2hrdEtJdWlUUUZ1QkFwd1VuaW5SbmhoZXFLcnVwMmh3RU1QZVZ5NjVORjY2WHphQUJheGErZFkxbEYxTFZyOWNkSUJRdTFwSklDdU9RTEE2cU1BdXlzSW0vU2FBcXovTm1WU1h3Z0FrN0Fmb2E2Z0FMWGVpQ3pxcFZxZ0twWUp2dW9rNmF1WTFjWFJlSGUyT05nMFVPUE5FYm9xSU9pcWtxZjBDSGJDZmxaeHcrVUE4b2l3N0JjRTRNMW8vNEFIVzZaZlZ3VWFVWi9ycWdLb0NocXRzT0tReVcrV2g2RWFSZGdmUzZnRzNyT1lxOFVHeERvUGhYWjFWYlQwaHVwUitLaXJxaHdGVHRSNGErZGFEbWJlZWFzRDQ2b0FxaGJlakNvZHk3d3FSN3RhR2k1MlgvK0RCbmpMN1Z4SnRhNzFxaTl1ZGRxTzM4eG00M1ZCVlgrZWRENkF4UlpIUGZDcVc2YS9iLzFnaXlxQ1B4cVB5bWJlYjBEVEtsMVZ3ZzRtcTZ0aDRScFIrZlhmKzVLeXJZVnFVNEFpeWZVSWtXdXlhbEFWRzB1Z0twUUJqQ3N3dW5iRzV1TDJkWFZWS1M5aW13bFUxVCtUa0tjT05tM2hUUVBjNmkrWWdTcEJjRXl5U2xkVkE3alVWbDI2dnBEK2hSLzRsOS83ejE3NmNweUVaelM4K1oydi9qZHZlOVhQbks5dTN2bnlkWFJWYWZVMjRzYjJESHJUNkhKQkNZb0xvdktvcTZJNGdSSnFYSG13WGJpTks3c2k2bzFRWVFFQlhGZFhGUUVlQktoczBGWDVnaVFFemxybmpSZFY2OVZTSFF2MWhSZXZlMXVWQWF1UkxIelNWVTNOb2M1ODZiY0hON1NscXpMQ21nSlVJYjdVNWNhSkUxRDFOSWNpZmk0QTVDdTJuajZBZGNQTzQraTB2cTRLNk5KMlRYdzRhdW82bEFyUk9wTzFlcVN1S2dOVkNhaWx2dVF3alJCdzVIVVJLYjFWdXFyZ1R3WDFDa0ZWUktxUFFodUdYeG93Z3EyZ3EwcEFiVEs5UHR1OWNtRVFhVDhsb3IrcWpxNEtBR3NLa0lFQ05BZ3VoMDAwU3hQUmtTam9EY0lxdzJLOGUramwzSEJ0WFZYQW1qNitrWG1LcUEyN2Yzb3JualFtOHYrT0Fxb1o3aTVNc1dsQWNWSmt1aXJDbzFCdmxHMWRsZkd1TUpYQ3Fscm9nb1h6VTdOd3hmVFFXNjl1dW5IVmw0WUxNenpnenZSbU5aenU2Z00zMzJkdk04REs5VmRQSDlEYThodEFib1paVWY0NFVKVi9udGZKa2licjFrQlZiL3pIeDZOeUxrWk05cHdlcDZ0S2RlV2dxczRYNjU5OTVxS3BydTlJM0N0dHBhN0twTWU3QzZva29wZXdnVGlRRm9FSU1ibDhya2hJS2JsV1dGZFhoWm9XUkF0VUpRQmxhYkN6djVFTDI5TUZXOVpWclVVQk5uM1A2NnN1Zk9KUDN2cUxYL1ZmNFNROEsrSE43M3I1Z3ovMGpmL25lVC9iL29yamRGV011aXFKTG1jaTRGY0l3MHJwTUliN2FNR0tiaEhvRGVoeHNHbnR4bFV2b291Z3RaTGtWZDJKZ0VGYUVYUlZJTHhCMkY3SEdqcVNLZ2Jla2s1S3A2TEdRYUJXVVJYd0tpT241dVpwUDd6d1JGWHJxallPL0U1R0FSNnBxd0pPZ05WdENnbGd6UUdVV2Z6VEI3QU9qSVBDd1dTS2t1TjBWZTNKcDUwblR5Y1VjL0dJdEZiV3ZpNTlOdEFLTlFYWUJsVU5JRXZwSWpwMkRCYXNMZ1dJMWJxcVBsQVZYVFFvQllFQ1JLQWF4eHZYWmtKTW9uQTlDTTJQMEZXWkpOQWxQQVUwVUUxN0Y1cGdtUUxEVXNQQTk0LzN4UnJ2dXJxcXNESXhlWEZYTDBGOFNRc3FUWGd6SStnSzQwZ2FHa0Vsb2pRU0gzeFI5VFRPRGcvVmlqTXFWaTNVMDRnejRTMnVFa0d2cnNwWTd3cG5xZ1NxeHB2N2lzV2tHbTVkMVIzZWRPTjdIbk1BVU54LzZPNzZVeC9JZi9mYkZTNWcrWjUrYWtEcmxCK2hySVhvRGFESnJWWEhnNnJsUERzNlhNcTNKZ1c0T3Evd1E1UEpvTVlweUt4WUdhaGFSUUVDMHFMa2FzMDJnQnQvK0VWRjBMYkUwS3VyQ21nbDI0Y3dnaXBtSHR2Wm9neEZ3TWtUNXkweWE5VzZ1cXJRU0hZSnM2V1NLWDVuZjhPYTJJZFUwYTNxcW1vS3NLNDcrMG1FZEp0WGI1WVhQL3dsd0pmZ0pEeDdZZXQ5ZitOL3Uvbmw3LzM3dnBxODZEaGRGWUs3QmgrRjZXU2crVUthSWkwZ1VpUHdHcGtDQXBXQUxQYTN4VzlmbVNkZGxURHBxalM0dDRHb29Yb1I4UkR2eGNDTGVHOElEN1UrdEN1VnNZNERxWFJRTEh6bEJqcTBsWlBGMUozWnZqWXI1dUpQZEZYUG5aQUExZ3hCZzVMQzB3ZXdBR0JoNWhqcG9CVjNsSzVxV2F6ZW5SaWFkQ0k0TXkzaWRqeU50YXE5T2pIVFZhR3huS1hVVUtiaEpqUzJvcHNMdjRDaU9rcFgxYVVBS2ZCRzI2Q3FCbWdLMEVDVGFINHl2dUdNOVk0YVh2SEZRRzNZQ0RRQkgzUjFWU0wwRWpWYmdhb2pnOGtzZXAwM1ZBdFBwV2hoWjNURjRsQmRLYm11S2xCKy9ib3FFeTFtUmpTc2FJRXFqUGRDMGxpdm9IRmlQQXV5TXRhVG93TzExY2pVdWlyVDZLb0dacVlLdUZ4WHhkSzVqZEhNajRkekozYnV6ZzZ1ZURjeGJyTDVCRWZqUFgvdXBSL3N2bUVSZXdKczNMYnhJRkdFVHc1TTljVmRXSVRObmRmVlZVbFBIVGxNU2hUV0pvZDF2ZTF3Rk5qSzRwSjVDQTBVQXZqUnlYaGdtR2k4Mk9RUnVxbzJxR0tPTzFpREhJSjdIL3VDSWdkVnZSUmd2UFF0Q2pCNjFKYllDVUcwUGtXeCt2REdqaWtXUTZISlFSY2JRTE5DVjFVYkZET3JWc3VDQmFCUUk5c0gwN2dKUTRZWXMwdFlGKzRGVlFuRU5SY3kxWjl5NjJCV2plLy8xYi95cG5lOC9nQW40VmtOcjNzSStLRlhIdjVQQnVidnN4cWNUc0wybzNSVllsUUo4VWE4TXF6d1U0cHhNSnJZaE1xSUFnR0lCUXB3dGtFenZlNU1NVnNvakZyeGphNEt4b210MUtnNE5ZQ2xPcXFwaXNLcjE3S3k1VndIVXFrYVE2dnFobVhsWUx6Yk1qZVZRKzkyQmpmODVNYjI0dFNkbjlCenhkeUhaVm5DRTEzVnN4dHlnUFgwZ3FyOGVDNHpqS0tGYkIxZFZkOGswYWZSU2lCcWdUa0twRGY3b3lsQUlFMVBuWFRwcFJVM25Qb0I2WnpVVXR4ZVhWV3lWa1ZKeGtwUUJRbmI1OFN4MkZPSTRYanZjSDY0VVlRSmpzR3JldlNMRlZlYnNFVUJCaUVrYTFxUkNRUkJvY0VLWlVRSkdHL0V3dzRQOXFHYmcrTjBWY1o0Q3VrVVZpMVV4VHFGaHhwTEFxakVlZ1pkbFZlclZCYk9Hdzh2MDJ1UUcrZHNycXVpQ0MxMFlZY0xWM2gxWFYyVkdSNXdhenhmVERhZjRIUjhSYysrOUNPK2N3K0YvN2NQVklWdzZkSW1Hb0g3T3FDcUwyNDU3YXpiek82bDVieXJyVkJ0VUlVc1ZRQnN0dlJYZmFBcXhSd0J3RnBDSWo0MkxJdnJoVFZBZ3gyTzAxVkZISk1janJhK3Y0bjRwZHJieE1HamQwZmZWeDFRRllGSFYxZUZqQUpNY2JVaHFGNWxLSmhjdmxEVXc4VXQ2S29hYTFZYlZFbjZNZ0JPNzI4WlNRZ3pmYXRiMUZYVmxxOW1sVUJ6eVkxcThlSmZlK3ViM3ZINkQrQWtQQ2ZDZDc3N2xZYy8rdnEzLzZQWjdvVy9MV0c3MmVRdnNLMnJVdkVTTEZaT0dyOS80ZVhVdXVSYXdTUEcwZEJKb0EwQnlxTGMzeEsvY3pBdjZDbml2Vmk2UmxkRng5Sjc2OFVYb2s2TitwSmVpNkZUcStyR2R1WVhLTngwY09CWlFEZnR6QTBKWjhxRm5qN3dmdXFuN3B4V211bXFnRENHbm9DcVp5azhNd0JyWnViWTl0TU0xT1RwYWFEdlc4NStWRnhUdHBJRnlISWxxTXBoVlIrb2F0ZWIwNFFFZ2EyRm4xMFpGdVU2dWlxRTg3cXV0QmVoU2E1UEJaNUU3UmZMZ2h5UHI4K3JneW1RSE5ybHVpckQxRTdRVlZtRmdKN1Jza1NZU0JNcUpUaWdja1k4U090TjhMR2lacmh2ZERaRkVISlNDZVA3ZEZVU05nM1ZndDRiUTFMRm1TS0sxVVZvU2M5U2ZVRlZHdkdGZUllQ1doUUxyN1B0VVNuT0oxM1YwTFBSVlcwdDY2cW00eXM2djN1aUhRcXcrVzF2TjdCcVFwL0EvYWtEclIyL3RSUy9paHBjVlJkYmFjUW1oMmpzdEVjQXFHNmNMUGRENmpOOGVESWVJR2dMNjNJUnh5eGJxeG9jMHJKdU5ZYWNaZy9EbXgvOVUyVXRYTS9BemxHNnF0UXBrUnA0MWRRY0VMQ0txUVlZM3RneFNMcXJOWFZWWFlvdXo1ZXNWYVZhMlR5YzJLZWlxMm8wWVhsN0VaZ0I0TDIvOTIvZThwNXYrQkdjaE9kVWVPTlBmdXVuZnZnMUQvNlNtMjE5RFVBWGhPd2RYWlZwZEZVS1VURktJYXF3ZzQxNFdPOUZFeWlqbWpDdUtvRGdXTFFhYU9GTHgrS3dPbEpYTlhBNmtvVzN0dkxXMEJlVmNUSmMrSW5PL2FqYzg2T1M3dlRoM00rR1d6cWswK0xQNy91N3Z1dzNUeWpBNTFoNFpnRFdvV2xXRXJZbkJ5NlY2d2RWL1pOd1NsdWdRdHhlQmwxZFZRNnNBcy9RTDRaUHI3Nk5XRDdRakFST3pmM2g5WUcxQkdEQW9IM3FVSUJKVjVYNmx5akFNSEZSTllpRlNZaGFrSXhPU2luZ1pITGpjUGZxaFdLbHJpck1kcld1aWpBc3hKTkNUWHRZMmVENUhVYWtDaE9pQnJNMWhPVm85OURmdk1ORTY1c3JURVhTMEJwMUlxcEx1cXJDcVNYVmkvVUZ2S29ZYncwVm9ETVViNHozVmtWaFBRZG00WTFaZU5sNHZOTEZXTWZEdWV2cXFzNE9ydmpCdWFzVjBLdXJZdjMvbVFOVmVVajZxL1dBMDdyZ2FOTTNGT0U2K2J0Lys1Nk5IZWI2cTd6RVVhQ3FQMS9XcjQ4RzcrMEI1Q0FEVld5YWoxaWpjZFdBRnY3SXlqWnQzUHo0RnhRU3Roc0IwSUNtbzNSVk5ZUFo4b25WV0xvRTRPVHloU0EzQ0p0R3AvTEg2cW9DVmRtK05CTDdrZEozYnU0VThmTDFncW9XQlppK2RBYmEycGk0NlZQMExrKy9lZlhHMlE5KzFkZmlKRHdudzV2ZStlci82Lzk0NWM5K0huMXhEd1ErRUFmaVJKUUNjVzFkVmZKWEpTNndFVjZGWWFzdkVlOUZOREFENGoxb25Gam5BWEdZVFR5MjlnNlRyb3ErY0xaWWFGZFhCZVBjWkRqelptSGM5TlExTFZsVUFERFJZVFhrdms0dlhOWFAvL3BmUHFFQW44TWhGN25mUG9CMVlISnY4YzJJdWtwWDFhUXRUOEpOelkwMWFrOE9jUmFUVHVsK2E1WDJncXB1M3hxckY4Q2R1WnQ5WW1zd3FrSFZFUlJnQkYrMTFTck1QS0kyYmdndEdqNU5vaG9WT3A3Y2hJRERvM1JWWW53Q2FtcmhheHJSaUFjZ0xncFF3c29VQllJV0FONUFsSk9iY3lOYUFFbFhCYllwd0dWZGxWYUZMNnp6UnRSYnBZZjF6cW9vU3MrUk9WUlA4YVdodDhPNUx5dDZPWFdWZzV1YmxNMURQL1pWbGV1cW5sVUs4UGh3SGxpNjE5QTV2aldnZGNvUGx3VHVmV0JLV3ZmWjZzOWtjZHFLK3FzVVY0ZCtYVldyN0RLRUl4QWM4and5R0VSNmVyV3VLbXNwV3FnYVVKWGlVMEVCUUZkdy96KzhxR2dBVEVNQnJ0SlY1UlJnMUdxeEZzQ0R0WDVyZU9XT0lvS3J0WFZWaVFJa0VDMW83WFFBc0RReW5VMU1IcmNFcW83UVZhVzg0U0FlTTFLWVF0Q29EdS83N1c5NTNhKy8rRm0vNlUvQzZsRFl2UWNyM2ZvT0VSWmswRlZCcURUZW1UQUZlRWJYQ3NGVmd5YUxscmZHSzBGbnhDdGdLbU1yTHhSSDYyaW9GUXYxdGhwVXJJcVpqR2J1T0YwVkQ3ZmRZTExMYlJnMzNMaXAwOEVUZXU2dmZ6Q05wU2VnNmprZTFnVllUdzEwN1pzWkdndFBubWUxcnFwdmNrcWdxV3NCMjVVREVLZFhncXEyVld5SkFvejE1Q3NOUXhzbWZKNWV1RG1DZGFrQlZRVGlkalpNbjNGTTlYR0txQ2xBUm1pWDlGdVN0dHdKVHF3NEh0OTB4dm9Sdk1VcVhaVkp1aW9HWFJVZ0xnS3k0QVFWcW1IYkJTRU5mQ0ZVVDFGalBJMVVmbDdPRHFVYVNFdFhSVlJTck5CVmxYTnZCQjdPdXFLY2Mxak1WR0ZaaUsvc2NPNG5GYjBaZVoxaTdvcnhJVXZheXR0OXlYVlZrUUxzL3A3UEJWQ1ZoNjRGNjZrRHJmUFZKdEk5bEtjbFVKWGlXak56ejczZVBkL1NJeXhZYlYxVkMxVGw3WFFBM1djR0E2dlN3Z1c5dXFwTTByVGtsZ0hJYU1OWS84MVAzRitxS3lCR2dWVzZxa1FCNXFBcWdSOUJEYXFRSG1zaGk4T3BzWXRoVHZHdDFGV2xUcVk0aWR4OGFqZExKMEJzN20vYVJzTlZYNzZsdXZwMFZiWEZMQWRWcVV4Q3BIZDk1RmZmL09BcmZ3a240VGtkM3ZqT04xejdrZGYrMUwvUXhmU3Y5T3FxaE02RVhTc0l5aUtCS2d0U3hEdGo0S0Npc000Ym9tSlpPYVBpTE5RcDRVcnhuaWg5V1Z4YkRPSGNVYnFxNG81SC9YVHdoTzdmYzBwZitHVy8waDVMbjF2ajZFbm9DUUZnUGZTUXc2VkxEb0RGN1FCWU4reWlQbDVYVjlVRlZlMzA5dFJ4d3h3aVVZUjlGR0R1cmlFSFZjem93SlEvZ3FxY2JweDZkVVBQcWpKaWtIUlZhSFJWMHFPcnFpbkFBS3pxK2hPb01nUVY4SVlnRFRFYTdzMW5oNXQySFYyVkFhbVVRTzBGN3ArVUJLcWdSZGhYaTFiVUdmRVVnTVBwbFgyL2UzYlkxVlVWOEtxbHVDVmRsWGhQSXhpVWg3NFFYOUdxVGlyMXhmVFFGeFg4ZE91NmNyYmxCcU01dHdxNjRmU2FidTE4bUFkblQvbm5nSzVxdlhEcDBnYUN3TDNQUjl1dHZuQTBuMmNqd09wTFd3ZFVyVnBSdUlITWd0VVZCTFZBVlJ1Z2RVQlZIU3ZBdzhOQm1VQVZNdkRVYnFIUlZabGM5eDNyYWdPdGNMajdSdzhVVWx1azR0YzZRbGVWVVlKTVhHT0tyOXNTWXBnY2krYUFwZ1k1WFZvdkU5RW5TMWtEeE9xOFNTaS9kVGlOZnE5NmRGWGhndlNEcWhRWFY3ekExSEcxZnorZDNyaDU1MHQrOVd1QnY0eVQ4TndQZit1blgvYzcvL2cxNzd3ZmZuQWhidW5WNktvRTlkNS9VSGd4WG8xSVJhb1hBMi9JaWxaVmdBb0czbmhURmZBZXc0VWJtNW5DK01xU2JnQi9VRTRQZGJJd2Jqb05GR0JYVjlVQlZTZldxdWZFR1VYS0FBQWdBRWxFUVZSWktMTGpPWUF4YmdmQTJyVVZWQndNVFIxM25LNEtTRytKUkpwQWx0c0k1WndvWnVZUUl3NVhVSUJMdXFxc25wRGUvaTVMZE9KbTVlZlhCa1hacTZzS0ZHRDZSZ0ZBb1FGaE5HbjFIOEFBcW9JRmkvV0tSQjJPOTJadU5oa21YWlVZcWtDMVYxZEZZZG85WFNqQjIyOEVWWVh4UHV3WEtCVHJhYW5lVzZPajdjdlZiUGMwMUlqTGRWVkcxQXV0NjlOVkdWcUY4VzR5bXJrUnZRNDNkNzNseUp2QlFzL0tnY3E1bTB2K3FuYnk2L3BjQkZYdHNNcDZoWjY0OVlIV0tkL3NRYmdNYnBiTE5JQytmZi9uNVRZNWdJR3NwQUM3NVZhQnFqd28rTWh3VUppc1Q4ZnBxb0Rhb1c2cjdzU0NwUjF2Ym43aTgwc0pJdllWdXFwRy8xUy9nRWoyTGhYMFVpa2RDY0FNYnB5MlNKdEdOL25hdXFvK0NyQ2oxVXFnS3JVM21ZK005VGF6ZmpYbDI4TUY2cmFUcmlxaHpEcFBDM2dGWUZiZSt6dmYvMDMvODk5ZDRDUThiNElkN2Y5YlB6UC9OUWdWZzM1ZFZlRzhVQnlLeXNOWkY0R1lFNG96UmVWTHFYeFpMTHp6aFMrTnEyQzBHay8ybmFtazJweGNyNFpGdFVBQlRQeTAydGk2ek9HcGZYK2lxL3JzQ1YyQU5jTHRBRmdFY1NnelREbkdxZzJaVXo3SjRvNWRXU2hOWGZzeXc0QzJFWVhVMXFvY3BDRTdEaHQzNXNBTHlFRVYwTGlVOE5zTGYzaHRVSmhlWFpXUG41bXVLbVFKVnJWSUt3YXJWZngraHF3dFdSVG9kSFJqZmlCM21IVjFWY1lvVlkwM3hrT0VMb0V1TVo1d290WTZDdWdnUUFGZjJZM3JtRmtuQlVTVHJvb0NYNEFlNVp3amM2ZzBWRXR4U1ZkbE4vZjh4SG1QallXT0YzUm41VUFQemNCUE5xOC8xM1ZWNjRZN2NiVDFxaS91K1B0L3kyLzBncVQ4czQ4Q2JKMUxBeUlveENtT1dubjdLTUF1ZGQ2TzY4dUR6d3pLSXJad1N4UWcwTEJrZVQ1RDRPQ3hpOWJ0YjRvRUlMU1dyaXBXbFBZbGJDeGZVcmRGNDBxeEJ4c0cwWEhwT3JxcTJsclZzcVRsbEdWSTI5emZ0RTlLVjlXMDB3SlZXUjNrNlVjZWVzdTd2L0VkT0FuUHEvQnRiMy9qNHovNnVwLzRROUhpRWtFbllmWDR3bloxVmFWNlMxWmkxTk95R3BpRjkwYlVxcnF5Y0JXTXE2YkZnZWZBdXcwejk4WVZpL0daaC8zcHdid2FUdmU2dWlyZytUZU9ub1FWb1F1d2NzRHoxRUJWTisrQk9jUkVCMHZsVittcWx0dEtvMS91cHlvRnhiNGM0alRHdlJSZ2o2NHFUbERObTBMVGZrNHJNZ0d0VTNNL2swalJyS09yeWlsQVRVQUtvQ1dWQ0M2QVRRSm9oQjlOYmhLVXdvUTlBNE91S2xHQWZib3FodTFzTERRRFZUNkFxZ0lRd2xIQWdsNVpxTGNLanJZdXE5OC9MYXQwVldWRmI4YVpyZ3Ftd2dDWXVxS2FiQWRkVlhuM2JwOXJoZlNtaGVkWjJNYVRCMVA5YWR0K2lKTHBQajhhUkIxWGY3NDc4YlltQjZQdG10b3ZEbjF0cldxWEN1RHlvQ2lFUjFLQUswRlZzbGJsVkNFRjJQL1VDNnlJMXMvbmNicXFCS3BhdEtBZ0EyUGh1THgrdWtCbjFkOXh1cXBZVHcyNm1BT3U4R3l6OEZiR2k1RlpTUUVlb2F2S1BiM2tvQ3J6VXMvQnhZOThOL0NsT0FuUHZ6QXNEMzlyVVkzUFdBR2g4TEFhZEZYV2V3TldqYTdLZVIycUwyVGhCL0NWRm5RRExDbzdYbkJFdDlDaGMxTXpjNmZkVFRkKzBlUHVSRmYxdVJGdUo4QnF4KzNaR2M2NnpYaDJ2SzRxQjEyVVpTdURRRnQxM1pBRDNJTlQ2T3Fxd2tpZVU0Q0tOTG8zT2ZPNmtyOHF6ZnJKMHdzM042UWlVb0RTVUVEOXVpcHBLTUFFcW9LdUhHcEphaFN2UjFjTk9oN3RWc2E2TXRBaTYrbXFDanB2clNkb1ZBcW5oYWgzTUZyQ1VVczZHM2JOOGFWMVhrVzRzZlg0ZkcrMlBSeVVoMzdBeXZrQ3ZxdXJzaHg1STVFQzNISnVhK2ZSNTVldTZ0YkNzcStxOXZHdHAxMm9FajNZdlorUEtwdnU4OVV2RmxzZEI2T3JRTlVxY1h2NzJRWUlQallzU3lleXRxNnFDNnFFcmJoRUhlTHc4WXMybGxtaHF3ckFwYUVBbVNwTmJUSFBtNHphZ1I3VVc5SlZoYzlvYktyQkZwb3lBbTRjYkJkTG9DcGR0cFc2cXZxU0pVdFdpLzVrQkZjOCs2bVBmdWM3WC9VdmNSS2VsK0gxYjMvVHdZOS82NDk4UkZ4eFQwdFhSVlFGdEtXck1sWmQ0YVFxcGdkcUtxa21HMWQ4S1daeFIzblpMNFlETjVSOUxmL016Uk5kMWVkUXlBSFdJVzRud0xwV0hPTGVlZHNsd2xHNnFqNVExUVptYmVSLzNjd2lVQXJua2xtZ3d1ZXltNGFtem1YYXNnRndBS0NUU3YzQWM3RXdJa2FQMWxXRlQvcDRUZ3JVS2tscHJGYUdjRUhBSVQ3b3VNRE55YlhaL3VHMnlYVlZBRkFZZFdKVXhiZDFWUVc5V2dXOTlhNkVvMWVyZzZMeVJwd2FGdDdZU2dmaVBJMWdZaGNxTzd1cTF5N1NscFVmV2xmMTZxcTJuL2U2cWxzSlNZeU9ucysrdU9QVFRydjJGam5MY0djVnFPcW10Y0hVQnB1ZENscmwwZjR4dExlZHpzd2Z6aDhlRG13RVVtdnBxb0RvcFQwRFZVREVIa3hsd05ubDh6WnVsTHVXcmlveWhzenl0aWxDQWtKaHNidHRFKzJJMkJnNmdDelhWU1Z3Si9XcXY3UzRPRm1hd3FyRmpjT3B6UzFjNitpcXNqcVlISjJtaXhhSEtkS29qczU5OUkzQWwrTWtQSC9EM3VIOUg5dWFmT3lVVUNDaTdpaGQxZVIwQUZWbTY0Q2JnMnF4c1hXWncyTGYzL1gxdjNIaVhmMXpNRHh6QU91Sklqa2I3WnNrK25WVjRlK3l0YXNkRitJOUZETTV4SmpGU2xDRmVCWkNMaVRNNjJTckRCc3QxMGJsNTllR2hZWFVmcXkwVDFjVkp5QU4vckNFUmhzcU1NNENua0phQlVKV3FvSDQ2ZFpWSEJ5Y0tuTmRWWnNDN09pcUNnZFcxZytNODBhY0ZsQTFaYVdvckM5R0J4eGhRWVhob0ZpNFlqalR3VXpVblB0VVZkelk1SnE2cW5TOVBwdEFWUWlYTGdFTndGcjMvajQrYmF6REZualAwN3E2cXVYeWJWQVZndFlDOS80WGsxWGdyUXVxMnVrRUh4ME9TZ2tibWRkcHEzUlZXVndOcW9pazNXcnlxaXRsZnUyMGtmUVlINk9yU3BZb1FhSUY2MGVWRGJVb0xHL3VGS0ttQm1LSW9DbzEzYWVyQXBIVGtrd1hUN0krRGQzQVdMVUMzSnF1S2w4ZHlUYjRpbldRY3VjblAvZ2Q3M2p0YitFa1BLL0RkejM0MWY1ZDMvNy9mZExEM2xuSXdoZUNoU25uYnFnSEx0ZFZEVGV2NmRudHh4Y251cXFUa0VJRHNCNTZhQkZkTmFRZE01NWVnTFZ2WEd0VDV0WWtzRUpYdFpSdmFSSnF4eC9JREdOTzZ2T3VycW9CUzBzVVlNeVZuK2Q1Q1VDM0t6KzdOaXlHa1FvOFZsY0ZBQkYwQmEwVzArcEMwcEtxSW1vSktrUUY0T2IwQ1hmRlhvSWxlM1ZWTFFxd2lCUmd1ZkJsNFR3cTY0dkJqQ003cDlvMnFDcTNEblRIM25DWUFLZXQrS3VIbjIrM1N1ZUc0ejNkMm5tVTVkbmRQZ293SEgvMkRnaFRoSHY5dUplS1d3TmFJeTJQeU5mV1ZhMENWZEtKVHdMMzl2UFJSeE1lRGFvNjhaOFpsb1cwcFVVcmRWV0pBc3pyQ0U0WEc2QUZBTFBIem9kcm1sWUhIcU9yU3ZxbVpHV0tCcUJ3SERsSWtDeXZueWthT3ZCNFhWWEl4OHlpVklNd3hrMmhJYUljelVhV0dkQ3I2Nm1IcGo1UWxjeHVTNjd1YStzY2hSeWUrWlAvRHZoTE9BblAvM0RPLy9FVFY4Y1hKd082V2xjbG13ZCs1TFE2MFZXZGhGV2g2SndmQXRFait0TUJxcnJITTNPSURUOE9NV3ZvcXBxMEhPZzBjYzJrRWNvZHlBRjJNR3pGZFhWVnFSMnB5d0tOTHFzcEU4VHdtb3ZodHlvL00wU1JRQlhRcGdDN3VpcERVbUhVZ0NUQkltamoxUUxCSXp0QkVqUkNEd3JLWXNITjRjMzVZakdTUGwwVlJQMUFSQ0hxUjFGWGxTakE0V2ltWTg1OVZSamQ0cjR2dHc1MDdLaWowemQxT3ZaZUsrRWRDMGQvOFZOK1orVGR3WmxHVnhVcHdNOFdYZFc2SVJlNEh3K2MxZ1ZhdzQ0SDk2TXRWZUc4dWJlWFFGRG9xVGIwb0dibFFzaGpsc0dVOU1RRFZBR3VsR1VSdDFvNlZsZUZoQjh5M2l3ZHhTMmdLQ0FPSDdzNGtPaVpQUU5Ob2UwZVhWVnR6ZXI2d1FLRGk0Y0l3dXorcGhYUm8zVlZ5eGF5Qk1LV1FWMnNZenliR05TQy9QcG5hUUdtMXNVVjFoUmdZN3FMTkdIODNoUVNXMWNlK1k1M3ZQYlhjQkkrSzhKWC85aVBMbjc1ZS8vT2xmSEdFMld1cTlyWXVreTh5TGtYZnRtdnRPZWtFd3J3SktBZllJM2o4ZE1Qc1BiTkRCczZiTVVkcGF0aXEzeUs2NXVvd3VkMW1lR3VGUlJnQWxETm1kYjFKVUY5RzFSMWhmSFltZnU1Z09QYWUzdUhBbHpTVlVGYW9JcVdOQnFBcFkxN0doWWFRWmFxYWlFNm1WNVRuWjh2K25SVlJPR05DYm9xV0dKZ25aYmxuRUx4eFhDbTArR2grLy9iZTVjWXlaWXRUZXRmWm52N0l5THlkUjUxN3ExYm5TcDBLYWx1TlVndDNSRWp4S2ltVEJqMUJCQUlDVkNEMUdva0prZ2dJUkFJaVNsU0N4VmkwaEtURnNNZW9KNGhCczFyMGtLaUtGWDJmVlNkWjJaa1J2aGptNjJmZ1pudGJYdjdkdmZJekRqMzVNbFkvMVZlZDkvdjhPT1B6OWYvMjdKMW9LNlcxL3BvR1RWRTBjLzNnV2cxb2dYd3l4QTlnR2Y0ODQ4NVYzVlgzYjg5Q0JBTExtWi9QRXhmcndXcTZwVGdzZU12MGZTQWRYaXM4YjVUcUpxRExnQi92V2liL0FicGMxWDFkdE5jVlZvbFBWUkpWYjBScHVxT0VMajkraWRlcEc4a2VqcFgxZHQ5MGxlcmhuTWw0QklRVUErM1d3a3FDRHVhcXhMMmxhcHF0Q0h5RVBzK1l5VkMrTmlnRGEwN2JNOHc1S3FHUDVZVm5BR2NnNnA4TGdqWWZQS1gvOEJHRG41Y2VubjV4YXUvOGVndmxsZVB2NkpaZ0thN2FBcFk1eVo5ZmovQXV2WTdmQkdPd2RSaHJtcjRVamkwQzhmNGxkYS9jbHNBY1FSTnAzSlZ0VjJJL3ZHNCszdDFySFZRWFFidTk5N0pORmNsZ0twQVBmT0hiODVWNWJ4V0NieW43RlVFNlVDZisyYzVUZjJ5dkRKY1B2b3UzRngvcmd2UjRIM0hwbXZpdVZ5VmY3cUpuN3FYTVY2Q1Z6dU5uKzhEc2RUMC9Ya0I0QmRoM0xqdVk4MVZ2WjNLQ01LM2ZiMGZYK2VBYWc3Q3NueFNBZ0Z3dkFscHZiU0d0Z1lZQWY4Y2tFM1BjL2hlR2FBT09YL0ZPbGRWVzRDQzhURjZ0NjA2VjZsNGNUZ090bDk5NFp3b2VZZGNWVzhCRGtEVGo4VExWaUlCb0xtOWFnUWduQTUvUXcxTktMbXFmTzB5VkxqWW53TUQ5R1hnVzI5WDdWMXpWVkp5VmZrNisvTFpZQy8yeDhWaXQ1Ry85UmYvSlV3ZmxmNzJmL3AzRkcvK2cxMjF5S0RLZEZLL1c4RDZydGtDdXpyN1ZOYlZYdzV6eThmQjkzVHYwRTRNVUd4bGl4V2JXUXR3bXF1YVdJQVZnQTJBbHI1Q3lxZStQdHVIN1ZlcnRqM0lWUkZzK3NtWWgxeVZVNnA2NkJTcWZHNzM0QW1OQW0yVURFN2lSWHZMdHQxRUo2SjN6VlgxRnVCNkYrR0ZKNkFxUGJZUEJPQ3dndlgrb1BVb1R2dGZEWEF6elZYTjNjNURFN0hJV2JFNzVLcXFaZVB0Umx0S3lWL3BORmNsT014VlpiQXFvTlVmczFTYlhHWU43VnJaWHovekVOS1ZTem1ScXhwZ0pkbUpOVlNWODRvUS92WlNSdTBZS3ZnNXpGV1I5WVVQbFM1RjJhNzhMYXRkbWRpNWVyS2tnc2hKcnFxdWNPVnJ5YmRsV2RyY2ZmS3IvL1UvL0kvL2JnZlR4NmowT1dxZm9hWTc2QzZBOVg1UVZTLzc2MmFQWEsxQitVZy9sNnNxUUFUTWp3YWM1clkyc3NXU2x6aHZBY2IrckRLcFdoVVlLK2NITkNkVDlJdHQySHk1V3VCVXJnb0FYQjd0SndBWGthcE1NSlZzUVRKQVlzTTBwMkJMYW9Ub0FsUUYrUFRpMis1bTk4d3RWMXU5bEszdXZJOVAvV3YxbDlzNGw2dnFMY0NmUjRPcXUydVl6aWJwL1VHckJxemh0WDBLbnVybDlicnhkYlgwR1ArZ3VNdnhKby96RDRWY203cjJqZXY1NFV5dVNpYm5sR0c3QVlZSWJyLyt3b01wUEo1dTUrWVhCQ2RRbFdDdW4zT3dIdzNZUDNmdTlzcERJZ0U1bHF2cW9hdFlnQU1vVlZtdWRLRUpnaUJjN0ZicDdackJhWlRQQW1Zc3dBSGNTdVd0dW80ZXRwWlBmdlZmd1BSeHlqNUhUVytoTVdDOWVCSHgvSG1YbDk4L1lLa1FOMjZES3kzVGZwUXZveWxrRGZ2TlFkVjhiaXV0ZVNNN1BNRnlCRlhsdUhNVzRCalFjaGVoQkZOcFBZZnFsZ00vMjRXNFVHMmpCeHdrenVXcVNyWEtSYW8yb294Z3l3cXFrS0FLQWpTZUFRQ1dRU09FV0ZEVVg3NFNwMjFvbGx1OVdHN0NwMmR5VlpQbmZQaG5Id2FuVkU4TGRScWNqcThiTDd2VUZzaWpVOU9TNDlzZnExYWhYNXUrN0QwRUh1NWczYWxqamFGcVdGTDltTG4xVGlTWFljN2xxbGdlajgrVnVFUUV5SjNnYjcvOGFlcC9kWWRjVlExVnJsckhORHRDQlZJQ3Q3bDAyVm84bTZ0Q0JoMnBMYnNNUjRORkNMVDdWVHF0YUptekZNVUNMRERWRTFXcGdnM0hINVlQdVN3U3BLemZmUHZ2L3cvL3h2OE9rOG4wNERXdFlBR3BpbldKN3dPd0FPSzEzK0pLYXl0bCtHS1p5MVhOUXhYN3JhZkxybVdMbitGcWxLc3FrRFpuQWM1QkZmSnlDTkUzVEV6N09JVSs2ZUx1TzljSWNENVgxVEJCRngyMEpTTUVhSldSRHZTQkVaNW9BNmdpYkpSUlBma2szS3A3OGgwL2RhL0d1YXBIVWJFL2FRRWFWTjFkYzREMWZxQjFvUXRVbWFhRDIzTlFWYmFwRzVTdTJlSlVCckc4QjFqdE0zMS85R2cwSkxkdnZQY0ptczducWh4VE5TZmhUdnIvZmovbTVxRUVObDkvVVJxQkFpZHlWWkl2ckZpQVREMnlDQ0ZjUGo2UXQ2T0QyNjJrV0gvbmNsV1RrWWdjUUsxY1FGclc3cGVOcEJHQjg3a3FjTEFpKy84ZTFmTEthZ1FTVkFvQS8vakwvd01tazhtRWVjRGFJVVdqdngvQStyYlo0cWZkMWVSTG85dzdWYUVpRG85ZnZrajZEMUM4ZER1a29IdnNqMVcyNlhOWm90V0hydmJiRktoU3BNcFhmeXZEeUVJQlA5dUV6WGNydi9Ba1NXR3JaRzBCam5KVmtOaVNqQlFWVC9VaFExWmtCVlhnVll3TVh2UWlxcW9IbjYrL1BjeFZtUVY0bnpxY0YvTnRZR3J1ZHEwTFRQT0NwNkdxYkRGWWNOTVJnQ3Q2REQ4eTVzOWRmaUJVRm1CL25ycnZWdDVTQWU2Y2lLQWZxTkVmYTVxclFvRXFTckhGODIrTjhkOHBBblp2SHN0UWFUcWVxd0lBbDJZcEtGQlZZS1lISXNuMzVjMlRSakRrcXVoNks0OXp1YW9lNE9vSm04czFRWko5Q2JBTmpjdWpITytVcXpxQUtxblg5WUNuemVVMy93QW1rOG1FNHhXc3VXeEtmZjhjVkIzZjlxL2FMZjVrTS9TaG11K3lmZ2hGWmZuVVRxeUh1bXMrMms1MldPV0dwbU9RSy8yd3NsV1lxMWFDM2dMTXpVYkx0NGoydHdBZ2lBRHgrVGJvWDhhRlY0TGVVWW1KQlRqSlZjRU5GcUFYMFZWVWhoWjZvVkY3cUNMNHhJZW9LdnhjVCthcUJyQTBxSG8zUFgvdUFJejdWU1c5SDJpdE5GbnJkOGxWemNGVWZWdXViUVYvQUdsVEMzQXcrWVl2L2VLbEhRS2V2bW04QjZGU25mOVlya29xcUVMaW0zRUlQci8vQkdEWVhEZ1I1WWxjVmY4ODFGbXF2c0lsN0ljSkZqQnptMHRIMTg4L3lQS256T1dxS2x2d0FJRFNOZlcySmR2OVVpaXF3L1lGb09aelZSak9QMEFWKy8zU3RiUzdtNy96UC83dC94a21rOG1FZWNBcVUrWVV2UXRnSFY5LzR5TDJzc3REejRFNUMxQm12b3lHWXczVnBYcFpmYXlYOGdZLzRSWE81YXBRNEVsNkN4QUNoZWVrYWtVaUNzcDUyMGIxc2xQWmVuRUZxdWpBWWdGT2MxVStwR01WQ3hBdDQrTU1WYzhrYUJEUkVWVDlNb3puclRLb3VtL2R2ejBJQUV2T1dZVEQvZU9aclByeHVBSzJwQi92ZXp4WE5aeEh4c3ZHbGpqZWVPK0F3UUtVWWdGaXNBQkxyZ29acXNyeENsU045czNNRWJkckVWRk5iNk5zOHgzSlZhRlVxSVREZTcyM0R3ZGdjcHRMWDhEck1GYzFBcldSQllqU0pxSUhPREpQMzZOT25YajFwWUtWbjZjQjNpQ1RYTldvWlVPdW51VnRxdlBSWFgzOVQyRXltVXhaaDREMTRrV1hwOHp4ZWNuOUFoWUF2UEZiZkJKS3gvakQ1cUxuUmhiV3kzU20ydmFWMitBbnVzNFpxdkxsZEppckdxekFERk9wYjlVQlZLVkRFdzZseFlRKzY4TCtOMjNyQzFUNWlNajJlSzVxdGFPR0M5SEhJYkpyb1dzZjlkT2JxSmFyK2tGMENyRGVIYlNXdlVVNEJ6anAzbndUMEttdE9Qei9zcTlnamQ4Zk03bXFHWUNySzdabEM3NXVuTGhjd2VwelZka0NUTnV6dHdxQmNhVUtHQ3pGd2hnRXFOMVNORFo5cmdwVkplZ2dWMVZaZ0hudXpra1Zxczlyd2UxV3ZhMTNMbGRWVzREOU5WVDVxUUpDYldoOVg0MFNzandKazF4Vnpvc04xMVorK0hISWxlWEpxL09rN0Jjdi96Rk1KcE1wYTY2Q0JhUXExbVcrZi8rQTljcnY4RWxZOWIrc3grdkxGMG4vQVhya2kyaDhMaFhDNVEvZDcxeEFKM3MwR1orbUZtQ2RxeHBaZ0t4elcraWhLbUlZZ1pqR2M4WFBkeUgrZXIxbzZselZnb29vVGhkUURWNTBtcXQ2NW1KVUVmN0JlaGV4RitJcExGZjF3MmlKdzhyUis0UFdvcG9tNTFTdUt1bndoOEVCSUFteG9LODZ3K2RqbjRHcXNueG9oeklDdlRmZXk4bGNWV1Vibm9BcVpBaWpJN0MvdVhKT05BOHNJUVpvd2dpcVVFQ29EcnlMVlAyc05QMkZrdXhKU1ZrcFBaNnJRdFc1dmJjUzgvTXhRQldHV3piZFVsSlhsV3BiR2E0WFBjQXhQWitsVWpXQnFoS0lMekRYTGwvK0x6Q1pUS2FzWTRDMXhmYzVKK0dYelE3LzNHNzQwamlYcXhvMFZKNm15OHErQmJTdVpZdG5YSlFFN2NnQ3JLR0tpQkNpdGdEUjlGQ1YxanNBc1EvR0V4NjZndUp4aU53MUdISlZIbnFGWlBrOTFYaVhYTlZ3M2VXZlFkWHZRbldiRU9EMGEvaHU2eHlBSm5kY1A1ZXJxdmVkZzZvNnJMNUFzZ2hUbVdWK240a0ZPSHYrQ3JadXZYTW8xaDVPNTZxQWdVK0FmaGtkOC9icE9yUzd2ZkpWb1Axa3JxcC9tMHZPYWVVL1RRQ1Y3RTJXakpYRXRsU2xaZ0FvWDVPd1hsY3lZT2tZMWZMUzJxSHRGaTcvR0N0VzMzRE04dmRuZ0V2SFlYNSswclpTSFF2Rk12VGQ5dC85czMvNy80YkpaREpsblFLc3UzelJ2TnY2cjlvT1FRSThTMytmODdtcThURXphRlZWSzhjeGFIM2xiL0ZKU0IzZEZZcm1kSzRLRGNmOXNFci9yQUppeTF6ZENsQjRBa0gwYVF6NlVqM21jbFc2QUQrOWlZckxiQUUrRmVMbllWcUJNNmo2WWJURTZTYWpjOHRPdjZhSEpxTmwrYkVmQWNlaHFpeVJhdjhXZVJTaERDQlZqakdHcXJKMERGVXpzSFhqdlhQVk5aM0tWUlVMTVBjSjdhK2JKVmVWbDRYVWJWM3ZrcXNDQmd0UWNvVUlROWFKTGo4RmpHMXlNZVY0cmlvenAvYkZ3Z3hIMGtNcGg2cFdYdTVqSTZsYVhmMDVSM0pWL1hGR0RVd0xLRXIvV0ZadmZnT1R5V1NxZEF5dzlrZ2Z3TU5IOTMwQ0ZrSGN1QjBleDZFaGFQMmxOSmVybW9PcXNzOTBtWUQ0MHUzd1J3aHd0UlhJa1FXQ1NhNnF0dytMclJpaFdJQTlWRVVoUEFoQTBaS2ZhTkRyeHZOb3J1cTRCV2hROWNPcVdJVEEzVi9McDlkZHhXUVAzaVZYTlgxTkY2anF4L0ZWSWZXVzQ0bWVEMmM0dUJOVTFWWGhXKzlTNHJEYWR5NVgxWWZjaDJ2dnI4T3hyM3Fwa0FpYlM3Z2NjRCtYcXdKRmh4WU8wM1dBQ0JRZzNMNzFnRkprQ2xYbGVzWVdvR1RveVZXeEhxcFFSZzhTQ2xFNGRVaTVLWjdOVlhFNHI5WUIvVEZva1g3NSt2K0Z5V1F5VlpvSHJCY3ZpT2ZQZHpqL1JZUjNYdjl0czhQajJGWXd4WU50eCtCMGJMdjBUMERFNm90SlFieVJMWjVwQ3V2SGF2bGdBWTV5VlNPb0tsOCtQbjBob0trQXJVMlF0QXJLTDl5ZTRYeXVhcmhPQTZzUFFYTXpGYndmYUtYbXVWUHJ0NEw1Y252UXJ5cEQxdENOczkralFlcmtqcXFubTh3ZGN3Slo0L05PZmxTQUcrOUUwanlFQlc3U0dGdU1jMVdZUUpWTW9Bb2lkRGtXRlc3WE1wZXI2aWQzenVBaXVhZFZ5VmoxZ3lMN3h6MHNxWVNGZzFNdEZhZ0Vmdk81S3FEc3J5T282cHVKZ3ZtemhIRHFpTDdKNkJpcVJya3FJYVd2R282QnFyY1dtVzdkNHViL2dzbGtNbFU2VnNFQ1VzUFJ1V2FNeCs2LzNmcmZ0RHY4NGU0Q2I1T3JtaTREYWp0bEFLK1lROEZmdXkyZTZzVkJydXJRQWlSOC8wWFVXNEI1SEtXaXpaVXVCeUtBdUdDcVVEWEFzOHQ5dXYvemFLMFZmandhVHowenZwMWJkbjVkdzZIYWV4YXFSSWZGQnkwVmhxcldtb3NlL0kvbHF1cHp6VUJSdjd4dlZ3SnVuUFA5aU1FQ0Z6ak1WZVZMN0VHdHhKNTZlekgzLzZTQVlYc2hFT1hSWEJXR1hGVnBVRmVnaXVtMnRoWXBRcmpRU001d0hjOVZvVlN1TUl4K2xCNzAwaTBGWlptTEhzemdkelpYVlZ1SG81NWIwQ0VjbjQrNzJObjBPQ2FUYWFSemdIVlpQWDUvcUtydmY5c0U3R1dQQlVzN2lQTzVxaWxVZVk2clZ2MDU4djYvY1h2OEVSWUhVSFhNQXB4Q1ZTZkVJbC9YaW1uL3ZSQlBOVUhWb2dlcit2d0dWUisraHV6Zm9QY0ZyV0ZHQUFBbmMxVTlUTW13YjcxZGdTZmZJOVE4VkUwdHdCTlFWVzVUSDE0UmNKeWhLczlIM1hDMHR3cFpqVERNNThqYnBHbWhDSWJ0V3B6MFU4Wk1jbFZwOG1pVWZsUjkyWXI5YUVGa3FBTDdnTHhLdDBDeUNESEtWYVVHcVlNRm1LQ3EvSG5zcTNBRmZ2SjVWVUI0WFpUNUV0bHZleVJYVmY2R0FialFiNWV2UmZPVHBRNmRXWVFtazJta2M0RDE3Z0IxbC9YWGZvZlB3aW92TzEyMXFyOUFvaHphaFJFY3Z0djZxcGppamV4d1JUOExWZXZDWXdjV1lMSmtIdWtBVlo5a3FMcWc1YXArL0pvQzFuMkJGb2RxRlk3bnF0TC9ENEgxc3F4K3pQeERvTHh1eitTcVVGV2FxaXM3V0xmM3prR2diMk1CMWlNTWM3NnFHbUdZNkNqdTFzbldPNU9yd2xCMVVzeEFWYTRtcGVjaXRDSk84M1lZNTZwRWhtelVHSlNHOTM5cVJaZXVYRWlJMGtmdktLcDN5VlZOb1Fva1JLQk03U0pTWlUwSWlPNyt2VC83dDc2RnlXUXlWVG9PV0M5ZUtKNC83NnB0N2grd3ZtcjMrQ3dzWmkzQUFsV3pGYW82QkY5SzkzbFpFS0twY2xzdjNSNlA0dUxBQWl4UUZhRm9pVmtMY0F4VlpnRitQRG9HV084SFduMi9LaG5ucXNiYkRpSDF2RmNGVU9QWFY3R3ZqK2VxaG0xcm5NSm82eEZFSWYxMDZWL0xCeFpnbGF1cUxjQzBuY0FOcmFocWE1RWFXaGtBSy8vV21jbFZEZnNtT0VtakJFc1ZTOHAyQkVnSkxRU01BMVFsb0J2bHF2cU1sMmhmcWFyNllJMUM3a0k2T2hISlBiQnk1U3dIM292MWlBUmU2S0dxSHlDVG5vU1lqcFgySjBqWDdxNWhlbmU5RWRobnFPbGoxS2tLRnBDcVdOOWZSL2QvdHVqd3g1dnlZWCszWEZYYVBTMHJIZGlSSHczSHp2WWVpYjl5ZS94QmRIZktWUUVZV1lBR1ZSK3JIRTYzYVhoYjBDcjNkVFpYZGN3Q0xGREYwVEU0T2w3WjVwd0ZXQytmdm5mS21uUU1rV0ZHaEQ1WE5UUVpuVUpWbnZnNXJ3U0FFcEJQbDVBaFM2Z0tkY1UrTzVhcktuWWdNbVNsQ3lxQVZWbUZvSW82d09tUXF3Sm1jMVVvVmF3QmtQcVdEOFVpbERSTmxycm9GY0o0TmxlRmZGeVgvL3NWNk92aFRtTEpiSW52dm9QcDdmUW1mM0JmMGVESzlOSHFMb0MxenZmdkI2cnErM3NoM3ZnOUx0V2Z0UURMaDJFVW9wbDhjZFZWcXpxUElpQytkVVFuQVplVUF3dHdMbGYxRk5OY1ZUbVBRZFhIbzdtUU8yYVd2ZTNybXppWHF5cmJUckpQaDhmcDcwOW1GNmgrU0hDeVpxN2YxcUdONkpEQmFqWlhKVU91cWpvR3BMSXFlNmlxejlSWGp2b0ErUUJMZGE1cUFsV1Q3YlNIbHFGcUZOTmJ1YnluRDNOVncvdWRmWjZyaHlwaHFpeTZ2RDBGY0txNFE2NnFXZ2FrcXBZTzRmbGM5WUpFTkh1ekIrOGlneXJUQTlNNXdOcmpibDg2Nzc3K3BkL2pVcGM5Vk5YQjlibGNWV2tJT2dkVmV5R1dNN210YTluakV6ZzRqS0ZxUGxkVnJqSDlxclVQZ285UmJ6dUs4Tno2QWtWNk5sZFZiejgrWHBYYjZyR2xWRkNubGlENjdlOEdWV203aEFSMHBCN05WWEhJVmVYd2VLbGs5ZXZLa1FWUW9tOU1TaEdObUVEVnlBTE1Rd0ZkWHcwcXoxbXViSTF6VmVsNG9tbXU2Uk81cWo2TTMwTVY4dmFWamRqbnFqUm1hRHVUcThyUFZscW1lVzRoNUI5cGl0eFVsV0IwdmpQQU9xWTN3NjhLK3l3MVBUU2RCcXpVRDJzUG9NeXhodXIyMlAyM1cvOVhiWWVmZFMzZUpsZVY5aHlIaE91cTFUWURtc3U1anQvNERuOFNHdXlGZUtSRW02b3VBYU1BQUNBQVNVUkJWQUhMTE1DSHFya0d1dS96K2k2dnZmRThnSE81cXZHK2M5VW5ZSGc5YXdWWnFMYXZYNnYxc1dhaENtWDJndnkzU3c0d25jdFZGY2dxZ2ZicTd4bnNRMUFKZ1FpamdES1hxeHFhaXViSEtLTU5FOGlVYWhZQkxYMC8wMk5xQXByVHVTb3AvYXFLbFpmaFNGeGxBd0thKzNKRklKYU0xZEZjbFFDeFpNY2cxUHgwcUJSWVk1bzZLK1hPdFA1eFpqS29NcGtBbks5Z0FhbUtOZGVZOGRqOXQxdi8xMjFFUUVTVEY5OGxWMVdXQ1lqZEpMZFZvQW9BYmwzYS83Y3V2ZEdWd0I4YlZKbDZ3SG9iZ0RxM3JJYWNVN21xWWQzd282QkdwN294YUlHczhUbUdJNCtyVmVQdGdXbVQwVElwRHFCM3lsWFYrMVo5c2VvY0ZRQTRrZzVVRmNyWlhGVnZJMlpZZ3ZSUTVWSUFyTGZxSUl3aTZzcmZKbjBWYXB5cktzMCtjL1VwMWVKU0ozWWRKb0x1cmIwSXg0aURYQlV5VlBVd3FDZ1ZyS0dWUkw4UHl1aEdRQ0hTNGFITG9NcGtPdEJkQVd1Tjd3dXdBT0NiWm8rZmRPVmF6dWVxcGxBRkFOdHNNVGFqTDZHMDdCODlJZjdiYThYWUdySmMxY1BXRkh4dzR2NWRRSXRWbFdnTzNnWUxjRndSd21TLzhucWZPK1loVkIwZTQzQ0tIdWtyV1FURnU4SGFPNW1ycWkxQXBOM25SeDhDeWdSUGNqWlhsUTdkVzNGQzBRR3Ewam55L096S2xJZlMyVnhWMzYrcUFxOThEbGJ0SWdZdzB2VGNDS01JUTZsTVliQUZxM0M3eEFKazdDR3RoN2hVVVNzWkxTRWg4ZUZXc0F5c1RLYWp1Z3RnQmFTZ2JYa24zUTlVMWZlL2JEdjhwSE52bGFzQ0JxaDZyTVIxN3V4ejdRYXI1ZSsvR3U2bkQ0TDBnV29mQkE5ZEVlY3JXRyszVHZKcmE3eDhMbGMxaHYrNTR3NTVvNWozT0ptcm12d3Q0eEdHSXZWZS9YN3VEcmtxb0xjQTA0akFIclNRN2J6aHZFNm9oTXJaWEJYS2VZYVJlekxrcXZvMkR3SW9Vd1hMeithcXFuNVZxUUlsSmZDdXVVMlc5cU1EQyt3SjFEbU5FSTJZNUtvRVZBcjZYRlUxL3lFRnpBQ1pBRXVHdkpZaURSaDRXQlVzZ3lxVDZVNDZEMWd2WGlEbnNCWjV5ZjBEMXE4V2lqL1p4T29YZmxwM0tsZVZsTDZJMWhWZzFWQlY2NnEzTlV5bW9UVkkwbjJCMWdCVnczbUc5WWQyM25BN2IvZjFnREFEVmZYeEordWtQc3Fvc3BYZlBmMDhoUFZ4RDNKVllBNi9jd3hWQkVYeVdmSTFTNElTT1p1ckVnd1dJSWErVm4wVktWV3FLS0lVVVFVWXp1V3FJRkNYbnFhY3F3SXc1S28wdVlaVUFTTEFEcUx0WEs1S0JoalRHcXB5ZFM3bnJqU0J0Rk9DVkVBVURnRWZ1d3lxVEthMzFsMHFXQURRSVFYZGdlOERzQWppcFE5NEV0MmRjMVZKNmY1L2ZqTVBWU2JUdkZJR1o5RDdnbGE2UDdheXE3clFKQXMxaFNxTTFrNnJVWWVBTlQ3R3VGcFZielB1QXQ4ZnQvVEJtbzRDckxmSkhkeDdxRXFuQVdVQ2dzTFNTNHZxcE93eUhHK2FxeElBeFFKTW9EWkFWVHBlcVFvQklnd1VsVHBYVmFwSVpaKzZFb2FxdFVLMkNCVTVWNVZHTGlyaFlvUm9ONXVyS3QzbGgxR0N4ZnBNejBIZjNpSEJtZ2pKQklJZkoyQVpWSmxNNzZXN0FsYkEyM3pSdk12NkY4dUFmL0cyZWF0YzFZc1g5cTQzdll1S1JRamMvZlY2YmwwT1hFK2dhZ3hUUlllOXJNWlFOUnlESSt0eEhxbzQycSt1b3Vub0RNVyttMVNyeW5HbnVTcGdzQStkRE1jU2xrcFpsWjBTeG1RUm5zNVZwZWNoOStES3ZtUFZyNHFsSWxWR0hZcW8zaUZYeFg2MG8xREpPaDlGcGtLYXhMeHZoRENjeTFVeFZic29naWpRQWw4cXcvUTZrV21lUkNYZEVoK0xhcWdDREt4TXB2ZlEzUUFydFdzSVNGM2Q3dytxNm1WLzFSSy9rSWh0WG42WFhKWEo5RzZhamlTdGIrKzZiTHFPS0UxQjU3YXJXemlNOXlsTDY2cHR1UzF3ZFM1WE5SeHIrcml1ckJXb0l1TmRjbFY5dFNwVnJucW95cTBXK3VkUldFQ05rdHNYakhOVlplUWdvSlNxWDFXU3lyaEJhSmxHaHlyYVFTakpBa3hWc3JsY1ZjckRTNm82U1o0TUdxVUNCWFhwNHFOelN2cXdGYWZOdVZ4VnNRQ2xaT3N5NEtWc0Z5S2dNVmZyb2xCKy9JQmwxU3FUNmQ1MTF3b1drS3BZNXpwZzQ1M1hFOERMUnZGWmw1YmZKVmRsTXIyYjVpcXk3d3RhUEZoMlBGYzFIR3RzRXc2VnIyRjVocmJqdWFwWnFLclgxeFV0bEF6V1hYSlZJRFJsc0ZncVJNaEFrdi9DdnFkV2F1QUo1T01lelZXbFBZZjJDZWlENUxrN08wckFYRjJ6N3lockR4bkRHQ1NkZjhoVmdlSVVQWUFSNmpJdzliY2doVlMyKzA1RXUzTzVLaW5RSmFVblZwNWVoNGpJSVhoQ0lxQkt1cmY1SFAxd1pGQmxNbjJ2ZWx2QSt2NGFqZ0xBYjl1SXovS0FITXRWbWI0L1RVUHV3T25YN1YzV0RWbXA4N21xdnF0NVhqSU5xNmZqRWRxRDFYamV3Y1BLMVRHb1M0LzdmWk03VjFvcm5NNVYxVkRWYjVmWFYzTVZxaEJvMjIzSDJIZ2N5MVdWWnFDcEFzUThnSzkwZTA4TlJmUGZtVm85VU5uc09ncWJzN21xVWoxTXgrMG5hczUybmtxcHdEbXF1RTRndXNwV0lTR2l5QmJnS0ZjRlJCYXJFb3dRUkFFSnowam1VWWFDS0tLRTlQblVEMThHVlNiVDcweDNCNndYTHhUUG44OEZnNC9kZnhmQUF2NjNWL2F1TjMzZm1yWnB1Qy9RR3V5OE9hZzYzSDRNV24zRnFhOFBSZFFoZDliYm9JRFhnUVVJSFVOVmRUMjZpaG9kRVNtQXF6SmFzN21xeWdMTVVEVUU1Tk5JeEhJMk5zdE4xMjB2Y1N4WFZjRVJaR3dYSmtoTExSM0tpTU1FWkl2OVRod1hBaVdaZTFOVnVhcDhESFhwU1lwNUNwNzAvS1NXRHVvU3VLazRCWUhBWmc4UmRvQnExUWZySUZlRjFKaytneFlKSURBL2RpNHlyMWRBZ2tQRS8vUnYvaWZMZisyLy84OTIrQkJsdVNxVDZRZlIyNWEydTJxZmQ0R3ErVzB0ckc3NjNlcFltNGIzQWEzcHREWkRaYXJPVmRXVnBYcWJIcW9xV05yTEhnTUVUYTkzWENrYlE5VncvQ0VYVmtDS1M5VnU1NXpycmNGMFVwM21xakJVclhxb1NuOUdnaXZtYWhVaDJpNDIreTM2cnV0SGMxVk1tU3dDWmVPK2tXalZPd3Zxb0lUZjdRaGQ1U2x1eXJaVnJnclJPU1hVcVJORjFjdEtJVXdqR0hQVFVBQlJuQUxOWGlHeFE2bWFqWE5WSllQVlc0Q0VxcFJLVmFwa3BRcGF1czdnVWsrdCtLMy95U01BSHhaZ1diWEtaUHBCOWJhQUZaR0M3c0Q3VnEwTXFrdy9uTTYxYVhoNzBOcTZEclY5ZHl4WGxaUWZ5K0hJd2hxYU5ySUh4NEEwN0R0NnpNbXkyRCtXL3JhL3JuWFFmZGZLWW13Qjl2UDVEYm1xTVZ3TjJheFNtY3A5T2gycDdXSzdGK0dpWE0vUlhGVWZlQjhxVFZKYUg2UVNtUUtJcEVDVzJ5NW51MDducWx6TW93TlRXd2hoZ2pBQVVWd0VTQlZJR2luWWRJVFRJRHlTcTBvVnJ5aWlDaEVWTXNJcEJZeE00QmhGRURROUR3cG9TQ01YL2FjQXZzWVBMWU1xayttRDBkc0JWaHBOcUJoUGxndWMvaElhN2h0VW1UNE1GUmdDem9IVDhYWGpaVGR1QnlDT2FrcUgyNCtyVmNjbmgwN3JJNGlBQUE5M0tsZFZIWHRzU1k3MzZiZGZCOTFmdDk0ZnkxWDFsUzJpYXExUXRpM056MWx2cisxcXMwOVQwQXdXNEZ5dWF2aTdTWUVVQ090elZRTFNRVlBKcXRudW9qQ2N5MVc1bE8xaWdpUWx4S1VLV0JwVm1FY0I1bHdWUk9IQ0Z1bzR6bFgxZWFvb0xsV3JjalV0cEltc0VkbFh2VFE0QjZiV0ZBZ09qSTd5R1lEL0J6K0V6QUkwbVQ1SXZjdm9GOFY0TkNGdytzdkh3TXIwb1dtUCs3VUhpZGV1SFBOTXJtcFVUUnFnYWd4TEEyaDFzb1BuOGxTdWFuSTlPanJHREdpdEl2ZENMRS9scXZJYmZPZzV4VU1Ja3lvWnRtZzNuVXRWSGc3VktrVzJIc3QxcGthaGtpQks2Zm81LzFKdUMvMlVOWTVFWE93NzUyTEFZTFhPNXFvZ1FBcW9sMzVWTVZXclVxVXRabnN4cHR3VUtEN2NBazJEYWE0S3VYSUZDVTRpU1JmeXBNNlJUb05QODFpbnlhSlZJa1NqRTBZSGphcnVDcjlMR1ZTWlRCKzgzaFd3emxld0RLcE1INjVPQWRhN2dkYU4zNmN2WFFwTzVhcWtPczVRc1NySEdSNFhJT3F3d3lxL1Q0L2txaWJITDNrc1FLdU83dFcyRjBHRE1FM3ZjalJYbGVZRmhHZ1BiQXFBcm9JcUdXQXVMcGEzRHNJd3lsVVJLbFd1S25keGlLVmplc2xOOWJrcUFDcUlUaFNnaTAyemcwSURYTTYzdWQ3R0hPZXFVcitxMUs0aE5ScWxTM01SUmpqdG03VVdhMUhiN2NiclpYdVlxOUpScmdvU1MvdUpLSUtRQVM4NHAwcUJndEk1cU1MRklKUTFmaGN5QzlCayt0SG83UUVyMllUVEw0WmhuY24wNFd1b05nMTZQOUFpaUlBOUdtbE81cW9Pb1dyWXJnQlVQWnZCWHJyVWlYelVCbUllcW9aalR2OE50aUtBZGRRZGdNdHp1YXB5WGYySVB4MURWYmwyQjZCZGJQWU9HdlAxeithcUJBUWNtRHFqUTBIUlBKVk9oaDlSbnpKVXBGTUtHYVhwZG9pTkNGS0g5alRDVDVOVlNCa3FWVlcvS3Vtdmo5R0JwS3R5VlhDVXhlWld1dVhGdVZ5VkF5SzhScENkU0dsQ0twMUlwRGhHSVZOMnl5RUF5ai83ZC82YjliLyszLzNkRGU1YkJsVW0wNDlTNzlvZ2J3Z0lHMVNaZm53YUF1bEo5d05hbmR1aExZUGpNTFlBNTQ4N3JsYk5CZGozU05tdTJ1NUR2OVc0TjlaZ0JRNy9QN1lWQ1FEcnFKM0xMUTVPNWFvS1ZFRkFwM2tad0Z5KzFySWRDQ3dXbXd3M3AzTlZ2UVU0ZEU1bjdnS2ZKb2dtSXh6cEZBbWFtdjBXS3MxQnJvcXBNV2pKVldVYk1vZlZ3Vnk1aWhraXRXK3RRQ1VXbStodUh6V0FkS1VTTnBlcnl0UHpSSEhhcGRBN1k3SW9OWUlTcEFrUmRKMXJPa1YwWGFlUExnRGNEMkNaQldneS9lajFyb0JGdkhoeHJ4ZGlNdjBPZFF5dzNnKzBkckxEQlZZanlEbG5BUjdPTXppR3FKMTBHRnVDZ3dVNGpFNGMrbS9OaGR2cjh5U0xzQU1aQktkelZZNEpvbGpzdzVMTkl0UVZ3Qk5BQk9yYlBSc1hRdFJHVCtXcWlnVW96QlV0Z1lwb21ZcEhSUlFrUWdJenhHWnh1NDNkWW5rMFYrV29PVHVXTzhram9NcFZrYVUvbGtRSEplRUNsaHRTc0lDTElVOXFIZW1ZUjVZeTlMa3F1dWlnQ29uQml5cUJUbnlJb2hMb29RNGF4TWZnb0lFZVliRzRmZ1RnRzd5ckRLcE1wbzlLN3daWUJsZW1IN2RTSDZSQjl3TmFlOW1qemp1ZGg2cjZHR003c1lEU0RsdWtOTlVVbU9hT3JaTnR4dFB1NU9VWG5lNmxta1RhVllCV1c0QUNJRFh5SEtDcTJJcTVsWU82dkk4QzJyVGJQZmNYN2xpdXFyWUE0YWhRU2YycW1FYnJzUWN1VWpSTnRLeXJteHU1ZmVKU2dhNjBWdEJjZFVLMkdLRUFveFBWVkxITFZhemNIaUpQR0IwRWpJQkNSS08wMjQxb28wZ1RHYVpjVmVxYzMrZXFQQUpGTkloamNJcW9EdEVSQVcwSVRoazhHQ2dJWGpTZzNhbURXK0JkWkJhZ3lmUlI2c2M1aDViSjlENUtzeEpNSnk4SDNnNjBEcGZ0M1E2WWdSdGduS3VheTE3TjVhb0lZQ2RkRDIybkxNQzZhbFdha3g3Wi9pSkdGU0JNYzFYRkFzUlFxYUlySXdpTG5TZ3A2TTRFV3pHMWtSSTZrTTFpdHcvZDJqc2V5VlhWRmlCVDEzV21LcGhDU0Y4bVQ0WUNrdUNyV2IzZXFPZ3kvMlhKQWdRR0M3RGtxcUFxVHRXQnFwQTBLcEFTbEtJcHdLOFJRbldDQ0VkRnU3dVd2V3ZtY2xYaU5DMXpRVUhYT1dpUUprWlBDWENNanVoRTJMbmxUbHZYUmVmMndma1ltdUM2Zi9oZi8wZnR2L3IzL3F2dXpDdlFvTXBrZWdBeXdESTlWSFU0UDNuNTI0SFdObmRlVDB1TzU2cks0eHFxaHVPTTcrOWtCL1lacktPNXFvT3FWUWFqZm51ZzlOMmlVMkNoN0RvUk44MVZ1WFNzbURZZldpdGtxNUFnSXBFYWo2Wk82YUJMMVNvdVZ6ZmIzYzJUSlp6Q3BlYWRRNjVLeUw1ZkZWTy9Lb3BUbjA2ZmUyUkptYk13MHFXR29lN2ltaEJlMUZDVkFXK2Nxd0tDU3dPY08rZVVvRVI0alo2Z2cwWVZGeDBaODlRNjZoYmI2RUs3UEo2cjJpdWk2OFIzQ3FBakpUUk5GejFpYUJmYkdLTFhoUXNkMnQxK3Zkd0ZIelZjUHYwMk5qdngrYlYxS0xNQVRhWUhKUU1zMDBQVkhoaE4wdnYrb0xWeCs1RlZkeXhYQlF4TlJ0RmowSFFxbmJSK2syM0hNN21xMmdLc3psZmFRdWgwMzJYVWZXaDhlelJYbGNITHBldUtMUFpndWt5dDE2c2tPM0Y5OGVyMnpUYy9hUUNvdUp5clFzcFZGUXRRZ09pa1FKVU91U290VStnd2lpUFRDRU5FTkFHKzNXeTFXN3BUdVNySjhBVWZZOHBWaVRJRjNwVkFhRnhISVlQU3E0ZXFMRzcyZm5PQnVWd1ZtaGc5TkhXUmQ5cDVGd085c25WZDlOQTlYT3dldGJlUml4Q2VMSzhEOWhmZCt2TmZ4V2VYMTkxNitYTDhLak9vTXBrZXJBeXdUQTlWT3dBWCtmN2JXWUhIMXQyNlVzRTZuYXVxTGNDMGZBeGJ3K2hEb012OTNLWHZQWGNNcW9acVZZR3E0U2djcnhOZEIzWTNIbkl1VjVVS1Rza0NaSm82Um11bzByUTlSWUgxMVhkYkFkZWpYQlZUcnFxMkFGUEZpTmxjUkJTaDByRmtwdXBjbFRxbyt2WE5EVUs3U3UwVVdLQnRuS3VDcHNBN0VFU2dGQTNlUlpLT0FuU09VR21pdWhqVithamk5OEc5K2dUcTVEQlhoWnlyV25YYXVpNjI3THJZTXF6UWRXN1Y2VnAyM1hxNUMrSjM0Um12dy9ybmZ4MHUxOS9vN2c4dTlHZC84NStvUVpYSlpBSU1zRXdQVjF1OGY5VnF2TzdHRFNQK1R1V3FobjJuSS82bUZhb01XYkxIZ2cwR2pEck1ZUUc5QlRpQnFyUlZTcG1YbytwRnB6dFp3cC9MVlFHcGRZRlRnTGtqT3dWd1JFejlRS0ZDS0IxNGVmR3ljNkpobXF0aW1ieTVzZ0RobEtJcEh3VXdPa2p1ZlZYbHFxZ3FvbXlYcjdmNjVyR1VYSlU0RUdtN0RHc3BWeVdLS01MVWNCVG9SSlJPb2dvWm5TTkJkTkpFZ3E1clhLZGNiZFIzQy9hNUtraHdxMjJjNXFxYXEwMzBVY1BsMWJleGRkeC90dmdtaGdzWExoNTl6ZWFQTnVGbmYvT2ZUQWNlR0ZTWlRDWURMTk9EMVFidkExTnp0Njk5YW1CNkxsYzFCMVhUYkZhNm41WjEyR0VCaHprTHNGUzE1cUFxVjZ2eTBVZTI0ck11Ym40TkxNL2xxdks4aEdWS25hRzVhS2wyYVo0WVdxSE9CUzdXTjV1d1hYdWtudkNhUnhTT2MxV3AyM29VZ1BRSnF2SjUxVXRNQVhtU0tnZ2VDcXh1Z25QcVM2NUtDRHBKdVNvdlZFMzdxM2dOSWxxZ1RiMm9raEpjazhQcVRVZDJUZlErUkFEQnJXKzJqdUs5aTZGdGp1ZXFXc2U5Vzk3eThYcTN2M2owTlZmck4vR0xQLzAvRHl1VkFBMnNUQ1pUa1FHVzZhRnFoekg4QU84TFdrR0lLQjBjVTNqK1dLNktPQVpmUUExTDVkOWU5bGh6Y1pDckt2dG9WY0dxb2FydWsxWDJ5VlcwVC9aaFErTEs1V3JWc1Z4VkRWVkFQMTloR1ZtWXdDeTFTMUFTV0s5ZWJWOXZWNHVVcThKOHJzb1JhZDVDb1llcXk2VXFueUFyZWlnSkh4dW5Da3AwbDlkMEVsZkhjbFdRbkt2eVFSMFpJMTFvZktlaUV1aUVub3hzUW15b1FWd1g0V05vSkVaZWZTdE5kSTJIN3YxeUY5WlJnN3ZZeFRXNzRMWFpsMXpWOHZLMVhxNi8wYy8rOUovR3lYK3Y5TStneW1ReXpjZ0F5L1JRVlN6Q3UwRFYzTEw1ZFh2WlljVVZUdVdxRGtQdzg3MnRrUGZaWW9lbnVNQjhyaXIva3pKcThMREs1VVlWTGdXQnA5c1FHbVdNTHNHVlUwQ1QzY2M2VjlWYmdMbWJPd1NSQ2E0VVFNcFZhVjRQY0gxNXZiMTUrWHZ1WEs0cXpVMll1cmlMVUIyaFRpSWcwam1RQ2szYk9WVVJ4SzdkM1dwWThHU3VTdGc1Q3NVeGVES3kxZWdqb3djRGlkaUFFY3ZBaGR2SEJic1FXOFIyMjhDMVlKMnIrbXp4VFZ4ODhXMDN5bFZOLy9zWVZKbE1wak15d0RJOVZFMHJXUGNEV3AxMFdLTTlzQUNudVNxT3pqMC82ckRjdm5HM29EN0dRYTRLQkdWY3hVSlZ6Um95VytPcUdFRW40S011YnE0WHZrWEpWU21pSkYrd3oxWFZGaUFxcUZJS2N4ZjBWUFhTdFAzNjh1WEdpYllFWm5OVkhza0M5S0NxdU9na0FwQ1FLMXlwV1NoVXZaQVVSRWRHSjFTL2VuTXJ0MCs4aU9yUlhCV0NxcmpZK2hoSmlZM0VBUGpnbHgxWGJwT2FoM3FON2Q2SDVtb1RtdzV4OVh0L1NiKy9DRE81cXVsL0g0TXFrOG4wVmpMQU1qMVU3WkVDNlVQaWFYdzd0K3o4dWs3MklGWjUyZkZjMVNtb3FyY2ppSmV5UVptUDhFU3VDb01GT0V3QVBZVHROUUZaQVRQbzR5NXVYN2UrL0QzYTk1ZktnWGZIUEdrejhxVE11U2xwdGdSWklFeHlpd2NsNHNYNkduQmNwZldpZ05JSnRjOVZBYUZKL2FwQzFhOUtSWVZlVkZVUUc2RkdRaHRSaW1NUXA3cTYra2EzbTZ0MW5hc1NsU0J0MERwWDVSMmpjekUyRXVPeTJhcTJubzNFemk5M2NlbEQxM1NJbDUrODFCYXV3d0s0ZEUxMzhjV3ZMVmRsTXBudVhRWllwb2VwRnkrQTU4KzNBRmE0enh6V1Z1cHU3c2R6VmVuUkdLcU8yWWx2Wkljb2UzaDRuTWhWNVFhazR6R0dyc3BxbFR4VkJyT251M2o3Nndzc0RuSlYyUUowWk1wZGFaNEVPazN3bkpZSkluTHdQVSsxQTBjb1hlUnErV1liZG11bkxvRlpzZ2hWQWFmT01SYW9jZ280WVNTb2tpWWtqSTBvSFRVaU5TRlZjWkVJb3ZMazIzM3o3VTlGMUEyNXFsWVBjMVZPc0hEN1dLQ3E3Umo5MVM1ZWhCaVhMWU5iN1BWeHc3QzhmR201S3BQSjlMM0tBTXYwa0xVRHNNUjk1ckMrYTI3eCs5MG5PSmVyR284Q0hFTlZ2NjhNVmF4YjJlS0theFM3YWlaWFZhRlZ2WDZZTnFlMEc4MGc5bXdYdGs0UlR1YXFTalZMb2FtL0ZJaGNUWFBwYU1raUJKVVFPZ1hYcTlmYk4vdFZlNWlyb3FiNUFsVUZpQVdxdkNnSm9STUdEMVZwSWwxUTlUNVN3T0FkR0IwQzE5Zm85by9RVU5VcHVtTzVxalgzd2EyaVhtSVg4R1N2NnozRFo4czNLbzlEZVB6c3Q3ejk3R21zTEVDREtwUEo5TDNJQU12MGtIWC9PYXl2bWcycWlaVDdkWWY5c09ZeldvSWhWMVgyRlNodVpZTXJ0djIrTTdtcXFRVUlZTEFSaCtPWFVZRjh1b3VkQS9jS3dhbGNWVzhCSWsxVG94bThwSXdFSkVGQVBWT29mYlcrZGpmWG4vRllycW9ScXFxTHprV0lNQWhVQldsS25RSlZhQUFJdWhhQlVid3VYSWk4K2k3Z3U3Vkg5S0ZaYmJtVW5mcTJpd3h0WEtoMkpWZDFlWmtzd00va2pXN0MwM2p4Wkp5cmVvYjh6QmhVbVV5bTcxRUdXS2FIckMwR0VBTHVBN1MrYS9ZSXNrZERQd05UaHhOQTkxYWdqTmROTzdaZnl3Mit3Q1YwZEU3MnR1QWNWQUcxblRpR3V6UTZFSS8yY2YrNjliN09WUUhKQWl5NXFocXFDTkNUV3JxK2V5V2pJSG9DZ0VRSXViNTRIZUFWUjNOVnd1QWNXU3hBVDQyRWk4NUhDaEZjRThqT3g4YUhDTkhZZXFwem5UNSsraHZkM2p4ZVRuTlZxM2FqeStYck9PU3FGbDNwVi9XSGYvcVBMVmRsTXBsK0VCbGdtUjZ5NXBxTlltYloyNEhXeHQzaUt0YlQ4TXkzYWFDY3JuTFYrNzl5TzJoVUZLZ2FqcGJ1SDBMVk1DbDBnYkRCbGl3UXhrZWQzcjVaK0JWMHlGVUJrMXpWQktyU3lFS2gwOVE3eXlQWmh5cFVyOERWK3BVdS9LNVZMbGh5VlJCVkR4ZnJYQlZheG9aUkc2Y3hnTm9pVUZ1R2xpR0tVNFVQY1NFaDBndVdzdGZGZWgvazBYZFJidFk2eWxYSlhwOWQ3bUxUN09Malo3L2xzMy81ejhQa3Y0bFpnQ2FUNlhjdUF5elRROWJjZERudm44TjY3VGU0aXF1enVhcGh5cnE2dFVJNXpyaFI2UnZaUWJHSGc4TTBWMVVmQTRoSG9ZbzltUFVnOTdRTCs5K3liU1hObXF6SGNsVU8wQUpWNlZJWlVxN0twUkdHQkJ0UUJSTHB5YXZMbDdldnJ6OXIrbHlWaThRMFZ3V0VWZ0sxWVZob3BGY0c1enR0R0FPV2V5d1ExTG05T2lmeGl0dllQcjdWSjV1LzJGMnZmMS9PNUtySzgyRlFaVEtaZmpBWllKa2VzblpJZ2UzVWVUM3AvVUhycGQvZ3AzaUtjN21xOU9od3JzTDVrWVhNT2F6VlFhNXFQUDlobWRSNWFrdHFaUTh5UDhiVFhieDF4RUl4NUtvQW9MUnNLTGtxSUhkMVQzOUxudG9tVzRBUTlVakw4Nzd4OHZIWGNmUDYyVktvSjNOVkVJMHJIeUxVeCtaaXh4WDI5RzJuUW9sWGZoUDk1VFl1ZG9pWEY2KzRialE4ZnJyaC8vZXJ2NEdUdVNyQTVnSTBtVXcvdUF5d1RBOVhxVlhEQnNDNld2citvUFZsdThVdk5ubzJWelcyQXNzeGhuL1RNUHlOYkhISkpqOCtiTTlRUmc0U1E3V3FWTHVTWXE2cUpTQVQ4UEUrMHBFaGhjd0hDMUJkdXBYVWhGUkJpWFNrVTlDbmZsYnFnUVJYVEJOQ0U2Q1BJQjM0ZVBWZDk4cDNBbEFiMFVpdlduSlZUb0k2eitoY3B3c0pjZVYzVk8rNGFQYWhXVzcxY3JrSjYwQmRMYS8xY2gyakxvV2ZQOTFGN0lWb092N2lYL21IbHFzeW1Vd2Z2QXl3VEE5ZHBSY1djRjg1ckplK1MwRjNqSVB1eHlhQVBoZUdMNDlmeXhhL2gvVlJDMUFycUpLOFYrbURsYWFLSG1leU1sUmRCZDNlZU9mclhKVmp5VlZCUFFHQ0tZY0ZpZXB5TTFLQ1RoaTlKcWp5a2FxTnFJK2tGK3I2NGhYRDVrSzBZVmhJcDNCTmRHMnlBT2xEeWxWbHFGcHNSZjJUVGZ6VXZZeVg2eGkxRTM2K0QwU3JFUzJBbjhkKzlPUG9uMEdWeVdUNlFHV0FaWHJvMmdCNGt1L2ZYK0I5NDdaNHBPdVR1YXEwZE5wR29UWUh4OEgxYTNjTHhDZlZORGl6dWFyZUF2UVl3dS8xaE5CRXRpeEpRUGpwTm14dUxoZnJvN21xYlAzMUZpQVlDbFM1a0RKWlRoRWJrcUhjZW9tUEw3OE4zKzJYc3ZJaE5vd0JGeDBXQ05xMk81SXVsRnpWTS84cXhNL0JxNTNHRVZUOU10UlFWWjRIZ3lxVHlmU2prQUdXNmFIclZORDkzVUhydGQvZ1NoZG5jMVdjN0RzL0dqQnQ5MW9DSXJvcTZENmJxOEtrWXp1bUl3c0J3Rk16YXVudmJUdDljYmwwcDNKVnRRWG9RVldDUGs4Q0RVRm9sRlNJdHFSR2lDNUFYYXhleHUzeVdUT1hxNm90d0U5dm9zSnJ4QVdPUXhWZ3VTcVR5ZlNqa2dHVzZhRnIybXdVZUZ1WW10ditwZC9ocDkzWXpwckxWYVhiTVV3bFRVY1dwaTAyc3NWbDMzQjBtTlM1eWxYMS94dXN5V1FOdW1JU0NrRXFSQWhIZmRJcExvSzIyMFp3S2xmbEk5V2wwWVpzQUkyQWVsQWRFVW13YVJoVndTVlYyMGhxUXo1ZHY5ekJLUTl5VlYyVnEzb0s0QmVobnJMR2NsVW1rK2xITHdNczA4UFdpeGNCejU4SHBKR0V3SDJCMXBmdEZuK3lqYk1RVlQ5T0dzUFUzSWpDY25zalcxd3gxYXRxQzNBSXM0K2hxc0JVRFZWQzdmZkkyYXluTVd5L2JGcC9NbGVWb2FwWWdLMlNMaUt5QlJ0bGhCQUxpalplb3dwNHNWTjFUNzdUeDNHamxxc3ltVXdQVFFaWUpsUEtZZFdOUWV2YnVXWG5RZXVWRCtpa1EwTjNNbGQxYUFXZXRoTnZaUU5pa2ZlY0hFTVV3cUZDQlFEQ3dTNU1NSldoU3JLZEtCRUNmTDd0YnI5WitoVkYyRVJTQ2M3bHFsb2xpd1hvbFJFTHdvZDBMRWVHQzBRR0wzb1JWYnZIMEM5Mk4vRnp0VnlWeVdSNmVETEFNcGxTRHF1MGFyaS9ITmF0MitKeFhKL01WWjFxMDFDQUtPMlo5djNTYmZDSDhSR211U3BpeUZVaEwwT3VWcWtRRFErZ0tsZXlpQ2o0ZEJ2WVhDTFNNelVaOVlnK1VxZTVLcStNVGF0b0E2Z2liSlJ4aGFpaFRWQ2xCSi80RUQvZFJzV3pxUEJDeTFXWlRLYUhLQU1za3lsVnNKN2kzV0ZxZnQwYnQ4ZFZYSnpOVlIxcjAxQ2dxZ2F0clpSK1dQNW9ya3FvZ0F3V29GU0IrQXFxK3VNMlZJbmdzMzNZZnJOdXhJUHFOUFhNYWp3REFDeUR4amF5aHlyMXlRSmNMVFFXcUZJVmZ2NVpsYXN5QzlCa01qMWdHV0NaVE1OSXd2ZXRXbzNYdld4MitHbTN6bytPNTZwUUxhdGhDaGl5VXZYamwrNFdGL0ZpZ0NyTVdJRFFVZFZLRUFHbTY4aFFoWWd5UjJLRUE1N0VHSy9wbTVLcjhvRVJQbG1BaXpacW9PaFZqTnczTGw3dG9qNjZpQnFpNk1nQ05LZ3ltVXdtQUFaWUpoUHc0a1hFOCtjN0FHMWVjajg1ckMrYkhYN1JOL2M4bnF1YXN3TDd0ZzFDT0xLL0JZQ3YzUzErRnBjRFZCMnhBSWtJSWZveks0aW05TUZLVUpYQUMwQ0VmdFlGL2phMjg3a3FFWDJxVWJzTDZPZTYxMDgxS3BhYTlyVmNsY2xrTWgzSUFNdGtTdG9pdlIvZXZpWERzWFhYUGlKS2dHT1o2M0FlcHFaUWhid1VBQnpIalVwVmlGY2dPdGxqU1RtVnF4b3NRS1JxVlp2dHhHSWJBb1NISWtEaGdJYmtJNDNjSkhTV0h3QUFCSE5KUkVGVXEzQXVWNlVxL0lOMXRnRC9wVkJQVjBOWXJzcGtNcGxHTXNBeW1aSzJBQzd4TGkwWlRxMjdkbHM4amF1VHVhcHg1ZWV3YWxYZkFxa2E5cDNiNEtkeENZSENNMW1DazF4VnRnQ1RLVmczSXZXNWFoV2c4RXlqRDFja0l2VFRYY1ROUWppYnF6SUwwR1F5bWU0c0F5eVRLV25hY1BSK2NsaGZ0VnQ4RXR1enVhbzVLN0FHbURMbm9DY1JoZmphYmZHVDZDQUVZajVXd3pqTlZkVVdJQlpnRDFWQkZKY0pxdEFTY0RtSHRkNXJrSmFXcXpLWlRLYjNrd0dXeVpUVUFaaHJPUHArb1BWaXNjTS92NzJBVk12bVlHck9DaXd3QlFCUmRIVDdsZXdRc0lSQWVndFFjcVdxUEs2aGFwMmh5aU5CVjRLcXRQMks2WFl2ZE05VVA5L3ZpVi8yRnFEbHFrd21rK2tkWklCbE1nSEFpeGZJUWZjVjdqT0h0WEdLVzcvSFpXeHhLbGRWZ0dzT3F1cGw0QUE4MTI2SHo5VDN1YXJTaWdGSUV6MFQ3QzFBUU5FeTViQUFJb0M0b0dJdnhDZWFibi9aVFhOVlZxMHltVXltZDVRQmxzazBhQTlnaWZ2T1lYM2pkMWlyTzV1cnFvRm1CRm9nd0tGL1ZzaWpCcjkyVzN5cXk5bGMxZFFDYkJGSFVQWDdNZDFlMEN4QWs4bGsraDVrZ0dVeURkb0J1TUs3dEdRNHRlN0Zjb2ZuKzBXMWJqNVhCVlJXNEFTcWt0TDlKbGZBZnUwamZoRWF4Tk81cXRvQ3hOTmNyVEtvTXBsTXB1OVZCbGdtMDZBOWdBamt4TlI5Z2RaTEg3RnpIVnE2azdrcVh3WFdCN0FhVjYwNklSWk1zTFFrOFZwMmVFU1BZZ0hPNUtwT1dJQ1dxektaVEtidlNRWllKbFBSa01PcWJVTGdYYXBXMDl0dm1qMSswaTFPNXFvMHQxRTRCVlhBWUNjS2lKZHVqeTlDNnQ5bHVTcVR5V1Q2WUdTQVpUS050UWV3d0gzbnNIN2JkdmpaM3AvTlZaVmJBR2lyTUh5QnFoV0piVDdHVmhUL3pDditWcGRxYms4MVdxN0taREtaUGd3WllKbE1ZKzB4Yms5d1A2RDFWMjNBVGdJYXVwTzVxakpIWWJFQWQzSUlWUUR3V0lsclI3d1NZTTNVWE9MbnNXNnRZRkJsTXBsTVA2QU1zRXltV21sZXdnNkF6MHZ1QjdRSTROb0hmQm9hbk10VjdTWldvQ01CWVE5VkFIRHQwakgrL2l2RkcxRWt4Q3BRcFFaVkpwUEo5TVBLQU10a09sU0hBVmlLM2grMHZtdzdQSWt5Z3FxeXJzNVZBY1NGRXJjWnBtNHpUTlZRTmRaUXVUS3dNcGxNcGc5Q0JsZ20wNkU2M0QySGRYZlFlckdJK09OdDdMdTZDNDViZ0FXcVVObUpoMkNWbEtES3lNcGtNcGsrSUJsZ21VeUhDdmcrY2xoQmdCc1hzRlE1bWF0S09sYXRNcGxNSnRPUFFFTGFEMStUNlVEUG42OHgvQUM1UDlENkZ6YUMzOSs3M2dJMHFES1pUS2FQVWxiQk1wbm1GWkNDN3ZlYncvcnpKZkRUN2pCWDlZK2VFQzllMks4ZGs4bGsra2hrZ0dVeXpTdmcrOGhoYlJ5d2NRRVh1VTJWVmF0TUpwUHBvNVJaaENiVE1UMS92c0x4YVhQbWx0ME50S3hTWlRLWlRCKzlySUpsTWgxWHdMdmxzQXlxVENhVDZZSExBTXRrT3E2STk4MWhHVmlaVENiVGc1UlpoQ2JUS1QxLzNsYVA3Z1phQmxVbWs4bjA0R1VWTEpQcHRDSlNWM2ZBTEVDVHlXUXkzVkVHV0NiVGFTbU9CZDBOcWt3bWs4bDBSR1lSbWt6bjlQejVlRjVDQXl1VHlXUXluWkZWc0V5bTgxSzhlUEZEWDRQSlpES1pma1N5Q3BiSlpES1pUQ2JUUGV2L0IzcTlwdGZzc1c0K0FBQUFBRWxGVGtTdVFtQ0NcIixcclxuXHRcdFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndCREFBZ0dCZ2NHQlFnSEJ3Y0pDUWdLREJRTkRBc0xEQmtTRXc4VUhSb2ZIaDBhSEJ3Z0pDNG5JQ0lzSXh3Y0tEY3BMREF4TkRRMEh5YzVQVGd5UEM0ek5ETC8yd0JEQVFrSkNRd0xEQmdORFJneUlSd2hNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpML3dBQVJDQUs4QWcwREFTSUFBaEVCQXhFQi84UUFId0FBQVFVQkFRRUJBUUVBQUFBQUFBQUFBQUVDQXdRRkJnY0lDUW9MLzhRQXRSQUFBZ0VEQXdJRUF3VUZCQVFBQUFGOUFRSURBQVFSQlJJaE1VRUdFMUZoQnlKeEZES0JrYUVJSTBLeHdSVlMwZkFrTTJKeWdna0tGaGNZR1JvbEppY29LU28wTlRZM09EazZRMFJGUmtkSVNVcFRWRlZXVjFoWldtTmtaV1puYUdscWMzUjFkbmQ0ZVhxRGhJV0doNGlKaXBLVGxKV1dsNWlabXFLanBLV21wNmlwcXJLenRMVzJ0N2k1dXNMRHhNWEd4OGpKeXRMVDFOWFcxOWpaMnVIaTQrVGw1dWZvNmVyeDh2UDA5ZmIzK1BuNi84UUFId0VBQXdFQkFRRUJBUUVCQVFBQUFBQUFBQUVDQXdRRkJnY0lDUW9MLzhRQXRSRUFBZ0VDQkFRREJBY0ZCQVFBQVFKM0FBRUNBeEVFQlNFeEJoSkJVUWRoY1JNaU1vRUlGRUtSb2JIQkNTTXpVdkFWWW5MUkNoWWtOT0VsOFJjWUdSb21KeWdwS2pVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmdvT0VoWWFIaUltS2twT1VsWmFYbUptYW9xT2twYWFucUttcXNyTzB0YmEzdUxtNndzUEV4Y2JIeU1uSzB0UFUxZGJYMk5uYTR1UGs1ZWJuNk9ucTh2UDA5ZmIzK1BuNi85b0FEQU1CQUFJUkF4RUFQd0NuNGg4SldQalg5b2ZVdEgxQ2E0aGdhMVdUZGJsUTJWaVhIVUVZL0N1by93Q0djUEN2L1FVMW4vdjVGLzhBRVZWc1ArVHBkUS82OGY4QTJrbGUyMEFlT2Y4QURPSGhYL29LYXovMzhpLytJby80Wnc4Sy93RFFVMW4vQUwrUmYvRVY3SFJRQjQ1L3d6aDRWLzZDbXMvOS9Jdi9BSWlqL2huRHdyLzBGTlovNytSZi9FVjdIUlFCNDUvd3poNFYvd0NncHJQL0FIOGkvd0RpSzgvOGUvQlM4OE5TdmVhUWwxZmFRcUFzKzRQTEdjY2xsQ2pqM0FPTzlmVWRGQUh4NzRTMFB3UHFNcTJ2aU85MVN3bFk0UzZoa2pNSjltQlFsZnJ5UHBYcmtYN08zaEc0aVNXSFdOV2tqY0JsZEpZaUdCN2doT2Ezdkdud2cwZnhJWkwzVGRtbWFrM0phTmYzVXAvMjFIUSs0NSt0ZVYyV3NlTmZoSnFnc3JxSnZzYk5rVzhwTDI4bzlZMkgzVDlQeEZBenVmOEFobkR3ci8wRk5aLzcrUmYvQUJGSC9ET0hoWC9vS2F6L0FOL0l2L2lLN1B3ZDhSOUM4WXhyRmJ5L1p0UUF5OW5PUUg5eXA2TVBwK0lGZGhRSThjLzRadzhLL3dEUVUxbi9BTCtSZi9FVWY4TTRlRmYrZ3ByUC9meUwvd0NJcjJPaWdEeHovaG5Ed3IvMEZOWi83K1JmL0VVZjhNNGVGZjhBb0thei93Qi9JdjhBNGl2WTZLQVBIUDhBaG5Ed3IvMEZOWi83K1JmL0FCRkgvRE9IaFgvb0thei9BTi9Jdi9pSzlqb29BOGMvNFp3OEsvOEFRVTFuL3Y1Ri93REVVZjhBRE9IaFgvb0thei8zOGkvK0lyMk9pZ0R4ei9obkR3ci9BTkJUV2Y4QXY1Ri84UlIvd3poNFYvNkNtcy85L0l2L0FJaXZZNktBUEJmRTM3UE9tV1hoKzd1dER2TlN1TCtGZDZRek9oRWdIM2dNS0RuSFQzcmd2aHo0SjhNK0s5WGwwbldMM1VMVzdkZDFxWVhRTEpqN3lFTXArYnVQb2ZTdnJldm5uNHVlRDUvQy9pQ0x4Um8rNkcydUpnN0dMajdQY1p6a2VnYnI5Y2p2UUIwZi9ET0hoWC9vS2F6L0FOL0l2L2lLUCtHY1BDdi9BRUZOWi83K1JmOEF4RmQxNEE4WVErTS9EVVY2TnFYa1g3cTdpSDhFZ0hVZXg2ai9BT3RYVTBBZU9mOEFET0hoWC9vS2F6LzM4aS8rSW8vNFp3OEsvd0RRVTFqL0FMK1JmL0VWN0hSUUI4Z2VLL0FtbmVGUEh4MGU2bnUyMHp6SW5FdVY4d3d0akp6akdSODNidFhyWS9aeDhLTUFScXVzRUhvUkpGLzhSVVB4L3dCREQybWw2NUduTWJOYVRFZjNXK1pmMUREOGE3ejRaYTUvYjNnRFRMaDMzVHd4L1pwdjk1UGwvVVlQNDBBY1Yvd3poNFYvNkNtcy93RGZ5TC80aWovaG5Ed3Ivd0JCVFdmKy9rWC9BTVJYc2RHYUFQbGY0cGZERFIvQTUwc2FmZDMwMzJzUzcvdERJY2JkdU1ZVWYzalhaK0h2Z0Q0YTFmdzVwbW96YWxxeXkzVnJITTZvOGUwRmxCT01wMDVwL3dDME45N3cvd0RTNC84QWFkZXFlQ2YrUkYwSC9zSHdmK2dDZ0R6ci9obkR3ci8wRk5aLzcrUmYvRVVmOE00ZUZmOEFvS2F6L3dCL0l2OEE0aXZZNktBUG5ENGgvQjd3eDRNOExQcU1Hb2FwTGR2S2tNQ1N5UjdTeDVPUUVCNFVHb2ZodjhGOUw4WGVIWk5WMVM4djRBMDdSd0xBeURLcndTY3FlK1IrRmFueDQxbDczeEhwMmhRZk45a2k4MWxIZVNUaFIrUUgvZlZlMCtGZEdYdzk0VzAzU2xBemJRS2prZDM2c2Y4QXZvbWdEelQvQUladzhLLzlCVFdmKy9rWC93QVJSL3d6aDRWLzZDbXMvd0RmeUwvNGl2WTZLQVBIUCtHY1BDdi9BRUZOWi83K1JmOEF4RlFYbjdQZmc2d3M1cnU2MW5Wb3JlRkRKSkkwa1dGVURKUDNLOXFyd2o0MWVOMnU3b2VFdE1jc2lNcHZUSHlYZitHSVk2NDRKSHJnZHFBUE1QRDNnaTM4VytNMTB2Ui90YTJMU2xqSk1WTHh3QThzeEFBemp0anFRSzlqL3dDR2NQQ3YvUVUxbi92NUYvOEFFVjFYd3Y4QUJDK0QvRG9lNVFmMnJlQVNYTGQwL3V4ajJHZWZjbXU1b0E4Yy93Q0djUEN2L1FVMW4vdjVGLzhBRVVmOE00ZUZmK2dwclA4QTM4aS8rSXIyT2lnRHh6L2huRHdyL3dCQlRXZisva1gvQU1SUi93QU00ZUZmK2dwclAvZnlMLzRpdlk2S0FQSFArR2NQQ3Y4QTBGTlovd0Mva1gveEZIL0RPSGhYL29LYXovMzhpLzhBaUs5am9vQThjLzRadzhLLzlCVFdmKy9rWC94RkgvRE9IaFgvQUtDbXMvOEFmeUwvQU9JcjJPaWdEeHovQUladzhLLzlCVFdmKy9rWC93QVJSL3d6aDRWLzZDbXMvd0RmeUwvNGl2WTZLQVBIUCtHY1BDdi9BRUZOWi83K1JmOEF4RkgvQUF6aDRWLzZDbXMvOS9Jdi9pSzlnbGxqZ2llV2FSWTQwQlpuYzRDajFKUFN2SVBHdnh2dExFU1dYaGhVdTdnWkRYc2cvZEovdWorTSsvVDYwQVkzaUg0TWZEM3d0WUc3MWJ4QnEwQ0hPeFBNaUx5SDBWUW1TYThqazBDMDFiV3haK0c3VFVwVWtPSVlwV1dTWi9jN1ZBSDhoNjE2TDRlK0hYaW40aFgvQVBiR3UzVTl2YXk4bTZ1Um1XUmZTTkQwSHZ3UFFHdmRmRFBoRFJmQ1ZsOW4wcTBXTm1IN3lkdm1sbC8zbTcvVHA3VURQSS9EbjdPdGpQbzhjbmlHOXZiZlVHSkxSV2txRlZYc0NTaCtiMXdjVnJmOE00ZUZmK2dwclA4QTM4aS8rSXIyT2lnUjQ1L3d6aDRWL3dDZ3ByUC9BSDhpL3dEaUtQOEFobkR3ci8wRk5aLzcrUmYvQUJGZXgwVUFlT2Y4TTRlRmYrZ3ByUDhBMzhpLytJby80Wnc4Sy84QVFVMW4vdjVGL3dERVY3SFJRQjQyZjJjZkNvQlA5cWF4L3dCL0l2OEE0aXJ2d04wMjBIdzRSeENtOTd5YmUrT1d3UUJuOEFLOVdiN3ArbGVhZkE3L0FKSnJGLzErWEgvb2RBSFBXSC9KMHVvZjllUC9BTFNTdmJhOFNzUCtUcGRRL3dDdkgvMmtsZTIwQUZGRkZBQlJSUlFBVVVVVUFGVk5TMHV4MWl4a3N0UnRZcm0ya0h6Unlya0gzOWo3OWF0MFVBZUNlTWZnbmVhZEkybytFNVpKNDBPLzdJejRtakk3eHQvRjlEZys1cUx3aDhaOVMwV1lhWjRyaG11WW96c00rekZ4RWZSMU9OMzZINjE5QVZ5bmkvNGU2RjR4aExYc0hrM29YRWQ1Q0FKRjlBZjd3OWorbEF6ZDBuV05PMXl3UysweThpdXJaK2p4dG5COUQzQjlqelY2dm1UVXZEZmpQNFVhbTJvMk03dFo1d2J1M0JhSngyRXFIcCtQNEd2VGZCZnhrMG5YL0xzdFlDYVpxSndBek4rNWxQOEFzc2Z1bjJQNW1nUjZkUlFDQ01paWdBb29vb0FLS0tLQUNpaWlnQXFqckdrMmV1YVRjNlpmeGVaYlhDRkhYdjhBVWVoQjVCOVJWNmlnRDVpMHE5MUw0US9FYVcydk4wbG9TRW53T0o0Q2Zsa1VlbzYvVU1LK21MYTVodkxXSzV0cFZsZ2xRUEc2bklaU01naXVIK0tmZ2NlTHZEL24ya1lPcTJRTDIrQnpJdjhBRkgrUGIzQTlhNHI0SitPREZKL3dpV3BTRUFrdFlzL0cwOGxvdjVrZmlQU2daN2xSVmEvMUN6MHV5bHZMNjVpdDdhSVplV1ZncWdmV3ZGUEYzeHptbGQ3THdwQnRVbmI5dG5UTE1mOEFZVCtyZmxRSTlHK0pjZW0zWGdUVkxUVUx5M3RmTWhMUU5PNFhNaS9NdU05VGtEcDYxNGI4UGZpVzNnZlQ5UnRuc0h2RnVIV1dKQklFQ1BqRFpPRHdSdDZEdFYvU1BoZDR4OGEzUTFQWGJtVzBTVG56NzRsNW1IK3luWWZYSDByMURRdmczNFQwaFZlNXRYMUs0SFY3dHNybjJRWVg4ODBEUE1yajQwZU5OWm1NV2sydHZBVHdGdGJacDMvTTUvbFVmL0Y0ZFpPZitKNnF0L3UyNC84QVphK2k3V3l0YkdFUTJsdkZCRU9pUklGQS9BVlBpZ0Q1bHUvaG44U2RYMk5mMjA5eVV6cyswMzZQdHoxeGxqaXA0L0IzeFkwcUpGdHY3VFNPTlFxSkJxQ2tLQjBBRyt2cE9pZ0xuemIvQU1KTjhXdkQ0M1hTNnNZeDFOelppVmZ6Mi8xclMwcjQrNnRidUk5WDBpMXVRT0dhM1l4T1B3T1IvS3ZvREZaR3IrRjlDMTVDdXFhVmFYV2Y0cEl4dUgwWWNqODZBUG5MUWRUdFBGUHhnaDFqV0xtRzB0WmJ3M1Ara09GVUJSKzdUSjR6d28vQTE5Ukk2eUlyb3daV0dRd09RUlhrUGlINEM2WmRLMHVnMzB0bEwyaHVNeXhIMno5NGZyWEJpYngvOEtMb0svbXBZN3NCVy9mV2tuMFA4Si83NU5BSDA1Ulhubmd2NHVhTjRvYU96dk1hYnFiY0NLVnN4eW4vQUdIOWZZNFAxcnVyKy90dE0wK2UrdkpsaHRvRU1ra2pkRlVkYUJITGZFbnhySDROOE50TEV5blVybk1Wb2g1K2JITGtlaTlmcmdkNjgwK0RQZ3FUVjlUYnhacXF0SkRESVRiZVp5WlpzL05JZlhCei93QUMrbGM4VHFYeGgrSS9IbVJXbjVpMnRsUC9BS0VjL2l4OUJYMHJwK24yMmxhZGIyRmxFc1Z0Ym9JNDBYb0FLQmxtaWlpZ1FVVVVVQUZGRkZBQlJSUlFBVVVWUjFYV05QME93ZSsxTzhpdGJaT3Nralk1OUI2bjJITkFGNnVROFkvRWJRdkIwWmp1WnZ0TitSbExPQWd2N0Z1eWozUDRBMTVmNHY4QWpScU9zVEhUUENrTTF0RklkZ3VObVo1U2V5S003ZjFQMHAvZy93Q0NsOXFjaTZsNHJsa2dqYzd6YUsrWnBENnlOL0Q5T1Q3aWdaejk5clhqVDR0YW9iRzFoYjdHclpOdENTc0VRN0dSajFQMS9BVjZuNEwrRCtrZUhESGU2cHMxUFVsNURPdjdxSS83S25xZmMvaGl1OTB6U3JEUnJHT3kwMjBpdGJhUDdzY1M0SDE5ejdtcmxBZ29vb29BS0tLS0FDaWlpZ0Fvb29vQVJ2dW42VjVwOERmK1NheGY5Zmx4L3dDaFY2VzMzVDlLODArQnYvSk5ZdjhBcjh1UC9RcUFPZnNQK1RwZFEvNjhmL2FTVjdaWGlWaC95ZExxSC9Yai93QzBrcjIyZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUd5UnBMRzBjaUs2TU1NckRJSTlDSzhrOGEvQkt4MUx6TDN3Mlk3RzZPV2EwYi9VeUgyL3VIOVBZVjY3UlFCODFhRDQ5OFdmRGZVQm8rdFdzMDFySHdiUzZPR1JmV0orZVB6WDZWN3I0WDhhYUo0dnRQTzB1NkRTS015MjhueXl4L1ZmVDNHUjcxYjEvdzNwUGlhd05ucTFuSGNSZndrOE5HZlZXSElQMHJ3bnhSOEovRUhoQzcvdGZ3MWMzRjNid25lcnduYmN3RDNBKzhQY2ZpS0JuMFhSWGlQZ3Y0NGc3TEh4V20wL2RGL0VuSC9iUkIwK28vSVY3UmFYZHZmV3NkemFUeHp3U0Rja2tiQmxZZW9Jb0VUVVVVVUFGRkZGQUJSUlJRQVY4Ny9HYnd4SDRkOFNXM2lEVEoxdDJ2WkM3Um8ySGptWG56RkhvZXA5RDlhOW04WitMN0h3Wm9UNmhkbmZLM3lXOXVEaHBuOUI2QWRTZXcvQ3ZCZkQvQUlmMTc0dWVLcDlTMUs0ZExSR0F1TGdENVkxNmlLSUh2ajh1cDVQSU5FU3llTXZpOXJNY0xQdmdnMjdqZ3BiMi9IM2lPN0hyM1BwZ1Y3WjRNK0dXaCtFSTBuV01YbXBBZk5lVEtNZy83QTZJUHB6NzEwdWk2SnAvaC9TNHRPMHkyU0MyaUhDcjFKN2tudVQzSnJRb0VGRkZGQUJSUlJRQVVVVVVBRkZGRkFCVWR4YnczVUR3WEVTU3d5RGE4Y2lobFllaEI2MUpSUUI0cjQ1K0NVVWl5YWg0VUFqa0h6TnA3dDhyZjljeWZ1bjJQSHBpdk1kVzhaZUpyanc5L3dBSXZxdHpNWWJhYkxyTXBFM3k5STNKNUlCNXdlZW5QU3ZyaXVEK0lmdzFzdkdWcTExYmhMYldZMS9kejQ0bEE2SS9xUFE5UjlPS0Jrbnd1OEkyM2hmd3BESXJ4VFh0OHF6M0U4YmJnY2o1VlU5MUFQNGtrMTNGZk9IZ0R4MXFIdy8xdVR3OTRnU1dQVGhLVWtqZmxyUi83dzlVUFVnZlVlLzBiSElrMFNTeHVyeHVBeXNweUdCNkVHZ1E2aWlpZ0Fvb29vQUtLS0tBQ2duRllIaWp4bm9uaEcwOC9WTHNMSXd6SGJ4L05MSi91ci9VNEh2WGhXdmVQL0ZmeEgxQTZQb3RyUEJheThDMHRUbDNYMWxmamo4bCt0QUhvL2pUNHlhVDRmOEFNc3RJQ2FucUs1VWxXL2N4SC9hWWZlUHNQekZlWTZkNGU4Wi9GalUxMUM5bmNXZWNDNm5CV0dNZHhFZzYvaCtKcnZmQlh3UnN0TzhxOThTc2w3ZERCVzBUL1V4LzczOTgva1BZMTY1SEdrVWF4eG9xSW93cXFNQUQwQW9HY3I0UStIbWhlRG9RMW5CNTk4Umg3eVlBeUgxQTdLUFlmam11c29vb0VGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFqZmRQMHJ6VDRIZjhrMWkvNi9Mai93QkNyMHR2dW42VjVwOERmK1NheGY4QVg1Y2YraFVBYzlZZjhuUzZoLzE0L3dEdEpLOXRyeEt3L3dDVHBkUS82OGYvQUdrbGUyMEFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBSEJlTlBoVm9uaXp6THFGUnArcUhuN1RDdkVoL3dDbWk5Ryt2Qjk2OGZEK052aEJxbTBnaXprZm9jeVd0eDlQN3JmazMxcjZkcUM4c3JYVUxTUzF2TGVLNHQ1UnRlT1ZReXNQY0dnRGpQQmZ4UzBUeGFFdG5mN0JxWkhOck13K2MvN0RkRytuQjlxN3F2RHZHbndQWkM5LzRUZnA4eHNKWDVIL0FGemMvd0FqK2RaSGhYNHVhNzRVdXY3SjhUMjl4ZHdRblkzbWpiY3dmbjk0ZlhuM29HZlJGRlplaGVJdEs4U1dDM3VrM3NkekNmdmJUaGtQb3lubFQ3R3RTZ1FWVzFIVUxiU3RPdUwrOGxXSzJ0NHpKSTdkbEZXYThLK09maTU1cnFId3BaTVNxYlpyc0oxWmo5eVAvd0JteDZsYUFPV2tmVi9qRjhRZHFiNGJVWjJnOHJhVzRQWDNZL3FUNkN2bzdSZEdzZkQrazIrbWFkQ0lyYUJkcWp1ZlVrOXlUeVRYTi9EUHdZbmhEd3hHa3lEKzByckV0MjNjSHNuMFVjZlhKcnRLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdEenI0cC9EMVBGZWxuVWRQaUExbTFUS1k0ODlCejVaOS83cDllTzljbDhGdkhieFRMNFMxU1FnYy9ZWGs0S2tkWWorcEg0ajByM0t2bno0eStFbjBEWG9QRkdsN29ZYnFVR1V4OGVUY0RrTVBUZGpQMUI5YUJuMEhSWE0rQS9GS2VML0NscnFYeWk1QThxNVFmd3lyMS9BOEVleHJwcUJCUlJYRGVNL2lsb2ZoRVBiSy8yN1V3T0xXRmg4aC8yMjZMOU9UN1VBZG5kWGR2WTIwbHpkVHh3UVJqYzhrakJWVWVwSjZWNHg0MCtPS3I1bGo0VVFNMzNUZnlweC8yelU5ZnFmeU5jZTh2amI0djZyc1VFMmNiOUJsTFczK3AvaWI4MitsZXYrQy9oVG9uaFR5N3VkUnFHcUx6OW9tWDVZei9zTDBIMU9UUU04eThML0NueEI0eHZQN1g4UzNGeGFXOHgzczg1M1hNdzlnZnVqM1A0Q3ZkZEE4TmFSNFlzQlo2VFp4MjhmOFREbDVENnN4NUordGExRkFnb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQVJ2dW42VjVwOERmK1NheGY5Zmx4L3dDaFY2VzMzVDlLODArQnYvSk5ZdjhBcjh1UC9RcUFPZXNQK1RwZFEvNjhmL2FTVjdiWGlWaC95ZExxSC9Yai93QzBrcjIyZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDdWQ4VmVDTkQ4WVd2bDZuYWp6MUdJcm1QNVpZL28zY2V4eUs2S2lnRDVwMXp3UDR1K0dlb25WOUl1cHBiUlArWHkySEtyNlNwengrYS9TdTg4RmZHelQ5VTh1eThSQ093dXpoVnVWLzFFaDkvd0M0ZnJ4NzE2eVFHQkJHUWVvcnkveHI4R05MMXp6TDNSQ21tNmdjc1l3djdpVSs2ajdwOXgrVkF6MExWdFh0dEkwTzcxYVoxTnZid05NU0Q5NEFaQUgxNEg0MTgrL0MzU0ovR254Rm4xelVoNWlXcm04bUo1RFNzZmtYOE9UL0FNQkZjM3JFM2k3d3RwdHo0VDFWN21DeW1LdDVFbnpJd1ZzZ3h0L2R6MUE0OVJYdVB3WDBRYVY0Qmd1bVVDZlVYYTVZNDUyL2RRZmtNL2pRQjZKUlJSUUlLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ3NueExvVUhpVHc3ZmFSY1kyWE1SVldQOERkVmI4Q0FhMXFLQVBuYjRONnpQNGM4YzNYaHkrekd0NFdoWkNlRnVJODQvTUJoK1ZlN2E1NGgwcnc1cDdYdXJYa2R0Q09CdVBMbjBVRGxqN0N2QXZpOXA4M2hyNGt3YTFZbnltdWdsNUd3SDNaa09HL2twL0dvTkU4RmVMdmlkcUkxZlZybVdLemtQOEF4K1hJNnJucEVuSEg1RDYwREwvaXI0dTY1NHB1djdKOEwyOXhhUVRIWXBpRzY1bittUHVqNmMrOWEzZ3o0SHZJVXY4QXhZNUFKM0N3aWZrLzlkSEg4aCtkZW4rRlBBK2grRDdYeTlOdFI1N0RFbDFMODBzbjFQWWV3d0s2T2dDdlpXTnJwMXBIYVdWdkZiMjhRMnBGRW9WVkhzQlZpaWlnUVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUNOOTAvU3ZOUGdkL3lUV0wvQUsvTGovMEt2UzIrNmZwWG1ud08vd0NTYXhmOWZseC82RlFCejFoL3lkTHFIL1hqL3dDMGtyMjJ2RXJEL2s2WFVQOEFyeC85cEpYdHRBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUWVsQUh6cjhkTHg5UThjMldtUmtueUxWRkMvN2NqSC9CYStnTk5zazA3UzdTeGpBQ1c4S1JMajBVQWYwcjU0OFQvOFRiOW9GSVc1WCswYmFINkJRbWY1R3ZwR2dZVVVVVUNDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BOGsrUHVtaWZ3eHAycEFmTmEzZmxrLzdMcWY2cUs2TDRRNmlkUStHMm1iamw3YmZiRWsvd0J4aUIrbUtQaS9iQzQrR1dyRTlZdkxsSDRTTFhQL0FBQ3VDL2hEVWJjbi9WWHhJLzRFaW4raG9HZXMwVVVVQ0NpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUViN3ArbGVhZkE3L2ttc1gvWDVjZjhBb1ZlbHQ5MC9Tdk5QZ2QveVRXTC9BSy9Mai8wS2dEekx4WDR1bjhKL0gvV05WdDdhR2Q0b2xoQ1N1VkJCaFRuSXJYLzRhRTFiL29EYWQvMy9BSHJRdDdXM3V2Mm9kUmp1SUlwWXpaWkt5SUdCUGxKemcxN0YvWVdrZjlBdXgvOEFBZFA4S0FQRGYrR2hOVy82QTJuZjkvM28vd0NHaE5XLzZBMm5mOS8zcjNMK3d0SS82QmRqL3dDQTZmNFVmMkZwSC9RTHNmOEF3SFQvQUFvR2VHLzhOQ2F0L3dCQWJUdisvd0M5SC9EUW1yZjlBYlR2Ky83MTdsL1lXa2Y5QXV4LzhCMC93by9zTFNQK2dYWS8rQTZmNFVBZUcvOEFEUW1yZjlBYlR2OEF2KzlIL0RRbXJmOEFRRzA3L3Y4QXZYdVg5aGFSL3dCQXV4LzhCMC93by9zTFNQOEFvRjJQL2dPbitGQUhodjhBdzBKcTMvUUcwNy92KzlIL0FBMEpxMy9RRzA3L0FML3ZYdVg5aGFSLzBDN0gvd0FCMC93by9zTFNQK2dYWS84QWdPbitGQUhodi9EUW1yZjlBYlR2Ky83MGY4TkNhdC8wQnRPLzcvdlh1WDloYVIvMEM3SC9BTUIwL3dBS1A3QzBqL29GMlA4QTREcC9oUUI0Yi93MEpxMy9BRUJ0Ty83L0FMMGY4TkNhdC8wQnRPLzcvdlh1WDloYVIvMEM3SC93SFQvQ2ord3RJLzZCZGovNERwL2hRQjRiL3dBTkNhdC8wQnRPL3dDLzcwZjhOQ2F0L3dCQWJUdisvd0M5ZTVmMkZwSC9BRUM3SC93SFQvQ2ord3RJL3dDZ1hZLytBNmY0VUFlRy93RERRbXJmOUFiVHYrLzcwZjhBRFFtcmY5QWJUdjhBdis5ZTVmMkZwSC9RTHNmL0FBSFQvQ2ord3RJLzZCZGovd0NBNmY0VUFlRy84TkNhdC8wQnRPLzcvdlIvdzBKcTMvUUcwNy92KzllNWYyRnBIL1FMc2Y4QXdIVC9BQW8vc0xTUCtnWFkvd0RnT24rRkFIaHYvRFFtcmY4QVFHMDcvdjhBdlIvdzBIcTMvUUcwNy92KzllNWYyRnBIL1FMc2YvQWRQOEtQN0Mwai9vRjJQL2dPbitGQUh6TjRhMWg5ZitNV21hdk5Ha1QzZW9ySXlJY3FwSUl3RFgxVDJyNXI4VlJSNkQ4ZUlwSW8waWhXK3RabFZRRlVCZ21lQjc1cjZVb0JoUlJSUUlLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdEa1BpbGovaFdldlovd0NmZi8yWmE4RDhFL0VtODhDMmwzYld0amJYSXVaUklUTkl5bFNCampGZTMvR0s2RnQ4TXRUVW5tZG9vaCtNaS8wQnJuUGdibzFuYytEcnk2dTdPQ1pwTDVncGxpVmlBcUtPTWoxelFNNXovaG9UVnY4QW9EYWQvd0IvM28vNGFFMWIvb0RhZC8zL0FIcjNMK3d0SS82QmRqLzREcC9oUi9ZV2tmOEFRTHNmL0FkUDhLQVBEZjhBaG9UVnYrZ05wMy9mOTZQK0doTlcvd0NnTnAzL0FIL2V2Y3Y3QzBqL0FLQmRqLzREcC9oUi9ZV2tmOUF1eC84QUFkUDhLQVBEZitHaE5XLzZBMm5mOS8zby93Q0doTlcvNkEybmY5LzNyM0wrd3RJLzZCZGovd0NBNmY0VWYyRnBIL1FMc2Y4QXdIVC9BQW9BOE4vNGFFMWIvb0RhZC8zL0FIby80YUUxYi9vRGFkLzMvZXZjdjdDMGovb0YyUDhBNERwL2hSL1lXa2Y5QXV4LzhCMC93b0E4Ti80YUUxYi9BS0EybmY4QWY5NlArR2hOVy82QTJuZjkvd0I2OXkvc0xTUCtnWFkvK0E2ZjRVZjJGcEgvQUVDN0gvd0hUL0NnRHczL0FJYUUxYi9vRGFkLzMvZWovaG9UVnY4QW9EYWQvd0IvM3IzTCt3dEkvd0NnWFkvK0E2ZjRVZjJGcEgvUUxzZi9BQUhUL0NnRHczL2hvVFZ2K2dOcDMvZjk2UDhBaG9UVnYrZ05wMy9mOTY5eS9zTFNQK2dYWS84QWdPbitGSDloYVIvMEM3SC9BTUIwL3dBS0FQRGYrR2hOVy82QTJuZjkvd0I2UCtHaE5XLzZBMm5mOS8zcjNMK3d0SS82QmRqL0FPQTZmNFVmMkZwSC9RTHNmL0FkUDhLQVBEZitHaE5XL3dDZ05wMy9BSC9lai9ob1RWditnTnAzL2Y4QWV2Y3Y3QzBqL29GMlAvZ09uK0ZIOWhhUi93QkF1eC84QjAvd29BOE4vd0NHaE5XLzZBMm5mOS8zby80YUUxYi9BS0EybmY4QWY5Njl5L3NMU1A4QW9GMlAvZ09uK0ZIOWhhUi8wQzdIL3dBQjAvd29BOE5QN1FlckVmOEFJRzA3L3Y4QXZYYWZBcHQvd3hnYjF1NXovd0NQVjNwMExTTUgvaVYyUC9nT24rRmNIOERlUGhyRC93QmZrLzhBNkZRSTUrdy81T2wxRC9yeC93RGFTVjdiWGlkaC93QW5TNmgvMTQvKzBrcjJ5Z0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb3JMMXJ4RnBIaDIxKzA2dHFFRnBIMjh4dm1iL0FIVkhKL0FVQWVHL0htd2V6OFg2ZnFjUUkrMFd1QTMrM0d4L295MTd4b3VvSnEyaVdPb1JrRmJtM1NZWS93QnBRYStkL2lqOFJ0TzhhUjJ0bnA5aEtrVnBLWFM2bWJhelpHQ0FuWUhnOG5QQTRyMHI0SWE2TlM4RWYyYzc1bjAyVXhZNytXM3pJZjFZZmhRTTlNb29vb0VGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFCNDk4ZjhBVXhGb1dsYVdHR2JpNU16RC9aUmNmemI5SzYzNFVhYWRNK0cra0l5a1NUb2JoaC92c1dINllyeFA0eDY2dXMrUHJtQkhCZzA5QmFMenh1NnYrcHgvd0d2VGZCM3hqOE9YdHJiYWRmb2RIbWlqV0pQTmJkQ1FBQU1QMi80RUI5YUJucWRGTWltam5pV1dHUlpJM0dWZERrRWV4SFduMENDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FFYjdwK2xlYWZBMy9rbXNYL1g1Y2YraFY2VzMzVDlLODArQnY4QXlUV0wvcjh1UC9RcUFPZXNQK1RwZFEvNjhmOEEya2xlMjE0bFlmOEFKMHVvZjllUC90Sks5dG9BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaXVaOFRlUDhBdzc0VVVycU44cHVjWkZyRDg4cC80Q09uMU9LQU9tckQ4UStNTkM4TFFlWnEyb1JRdVJsWVI4MGovUkJ5ZjVWNGxyM3hqOFMrSkxuK3p2RGRwSllyS2RxQ0ZmTnVYL0VEQy9nUHhxWHc5OEZOZDF1ZjdkNGx2R3Nsa081MUxlYmNTZlVra0wrSko5cUJrbmlUNDQ2dHFjaHN2RE5rYlJYTzFacEY4eWQvOTFSa0Q5VFZMUmZoTDRzOFczZjlwZUlycVd5U1RscEx0akpjT1BaYy9MK0pIMHIyenczNEk4UCtGWWdOTDArTkpzWWE0aytlVnZxeDUvQVlGZERRQnhlamZDendyb3VuVFcwZGdMaVdlSm9wYm00K2VRaGhnNDdMK0FGZU9lQmRSbitIWHhRbDByVVdLUVNTR3l1R2JnWUp6SEo5T1Fmb3hyNlhyeGo0NStEamNXc1hpaXpqeThDaUs5Q2pySC9DL3dDQk9EN0VlbEFIczlGZWVmQ1h4cVBGSGh3V1YzTG5WTEJRa3U0OHlwMFYvd0NoOXg3MTZIUUlLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ3NIeG40amk4SytGYjNWWElNa2FiWUVQOGNwNFVmbno5QWEzcStjZmlsNG9uOGIrTDdidzlvMlo3YTJtOG1JSWVKNXp3VytnNkEvN3hvQXMvQlh3eC9iMnZYK3Y2bkV0eEJBR2pIbXFHV1dhVGxpUWV1RkovNzZGZGw0bytCK2lhcHZuMFNRNlZjbm55d0M4REgvQUhlcS9nY2UxZHY0UjhPUWVGUERObnBNQkRHSmN5eUFmNnlROHMzNG45TVZ1VUFmTWJXL3hCK0ZVNWVNelIySWJsay9mV3IvQUZIOFAvanByMEx3djhkTkoxRFpCcjl1ZE5uUEhucGw0U2Y1citPUjcxNnc2TElqSTZobFlZSUl5Q0s4NzhVZkJydzVydStld1U2VmVOenZ0MS9kc2ZlUHArV0tCbmYybDViWDlzbHphWEVVOERqS3lST0dWdm9SVTlmTXQzNFo4ZmZESzVlOHNKSi9zZ09XbnN5WklXSC9BRTBqUFQ4UitOZG40WCtQRnJQc3QvRWxuOW5jOGZhN1VGb3o3c25VZmhtZ1I3UFJWUFROVzAvV2JOYnZUYnlHNnQyNlNST0dIMDlqN0dybEFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQWpmZFAwcnpUNEcvOEFKTll2K3Z5NC93RFFxOUxiN3ArbGVhZkEzL2ttc1gvWDVjZitoVUFjOVlmOG5TNmgvd0JlUC90Sks5dHJ4S3cvNU9sMUQvcngvd0RhU1Y3YlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlNFaFFTVGdEcWE0SHhSOFhmRFhoMHZCQk1kVHZWNDhtMVlGVlArMC9RZmhrKzFBSGYxeHZpajRuZUd2QzIrR2U3KzFYcS84dXRyaDNCLzJqMFg4VFhqVi80MzhkL0VhN2ZUOUtobmp0Mk9HdHJBRlFCLzAwa1A5U0I3VjFIaGY0REtObHg0bXZkM2Y3SmFOZ2ZSbjYva0I5YUJuTzZ2OFVQR1hqVzhPbTZEYnkya2NuQWdzUVhtWWY3VW5iOE1EM3JYOE0vQW0rdTNGMTRudmZzNnNkelcxdXdlVnY4QWVjOEQ4TS9XdmF0STBQUzlCc3hhYVZZd1drSS9oaVhHZmNucVQ3bXRDZ0RIMEh3dG92aG0yOGpTTlBodGdSOHpnWmQvOTVqeWEyS0tLQkJSUlJRQVZIY1c4VjFieTI4OGF5UXlxVWRHR1F5a1lJTlNVVUFmTW5pTFI5VitFbmpxRFVOTkxHeVppMXE3L2Rrai9paGYzQTQvSTE5QStGdkUrbitMTkRoMVBUMytWdmxraUorYUorNnQ3ajlSelhuM3h4OFQ2ZGJhQ3ZoNHd4WE4vZEZaZm01K3pLRHcvc3g1QTlzMTVUNGMxdnhEOE85UXN0VlcxbWp0TCtNU2VUS0NJN3FMUGIwSTZnOVJrZGp5RFByR2lzUHd0NHMwcnhkcFMzMm1UYnNZRXNMY1BDMzkxaC9Yb2UxYmxBZ29vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpdkxmaVY4VnJmdzZrMmthTElrK3JrYlpKUjh5V3YxOVg5dTNmMElCQjhYdmlNdWpXa3ZoN1NaditKbE9tTGlWRC93QWU4WkhUUFp5UHlIUHBVSHdaOEFOcGxzdmliVklTdDNPbUxPSnhneFJuK01qc1dIVDBIMXJ4dFk5UzBmVXRNMTNWOU9rdUlybVQ3V2d2QVN0MEEzelpKNjU5L1VIcFgxbG9HdDJQaUxSYmJWTlBrMzI4NjVBN3FlNmtkaUR3YUJtbFJSUlFJS0tLS0FER2E0YnhSOEtQRFhpVXZPTGYrejcxdWZ0Rm9BdVQ2c3YzVy9uNzEzTkZBSHpWcVh3OThjZkQrOGJVZEdubW5oWGszT25rN3NmN2NmVWovdm9WMFBoajQ4U3hsYmJ4Tlpid1BsTjNhTGdqL2VqL0FNUHlyM1N1UzhUL0FBMzhOK0t0MHQ1WkNHOEkvd0NQdTJ3a240OW0vRUdnWnRhTDRoMG54RmFDNTBtL2d1NCsvbHQ4eSt6TDFVL1VWcDE4NDYxOEp2RnZoRzcvQUxTOFAzTXQ2a2ZLeTJaTWR3ZzkwL2kvQW42Vm9lRy9qbHFtblNDejhUV1J1MVE3V21pWHk1ay8za09BVC8zeWFBUGZxS3cvRDNpL1F2RkZ2NXVrNmhGT3dHV2l6dGtUNm9lUi9LdHlnUVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQ045MC9Tdk5QZ2QveVRXTC9yOHVQL1E2OUxiN3ArbGVhZkE3L2ttc1gvWDVjZjhBb1ZBSFBXQi80eW0xRC9yeC93RGFTVjdiWGlWaC93QW5TNmgvMTQvKzBrcjIyZ0Fvb29vQUtLS0tBQ2lpaWdBb3FHNnU3ZXh0bnVicWVPQ0NNWmVTUmdxcVBjbXZMZkZIeHowalR0OEdnd0hVN2djZWMyVWdVL1hxMzRZSHZRQjZyTExIREcwa3Jxa2FqTE14d0FQVW12Ti9GSHhwOFA2THZ0OUx6cTEyTWo5eTJJVlB1L2YvQUlEbXZMaEg4UWZpdFB1UG5TV0picWYzTm9uMC92SC9BTDZOZWorRi9nZG91bWJMalhKVHFseU9mS3dVZ1UvN3ZWdnhPUGFnWjV6UHJYeEErS1Z3OXZhSk0xa1Rob2JiOTFib1A5dHo5NzhTZnBYYytGL2dSWVdteTQ4UjNSdlpCejlsdHlVaUhzVys4MzZWNjdiMjBGcEFrRnRESERDZ3dzY2FoVlVld0ZTMENLdGhwdGxwVm9scFlXc050YnA5Mk9GQXFqOEJWcWlpZ0Fvb29vQUtLS0tBQ2lpaWdBcm52R2ZpeXo4SGVIcHRTdWNQTDl5M2d6ekxJZWcrbmNuc0sycjI5dHRPc3ByeTdtU0czZ1F5U1NPY0JWSFUxODA2cmY2dDhZUEg4VnJaaDQ3UlNWZ1ZoOHR2Q0Q4MGplNTRQMXdLQUxYZ0h3cmUvRWp4ZGM2N3JoYWF4amw4eTVkdUJPL2FJZjdJR00rZ3dPOWUrNjc0YjByeEhvN2FYcVZxc2xzUjhtMzVUR1IwWkQvQ1JVbWc2SFplSE5GdHRMMCtQWmJ3TGdaNnNlN0U5eVR5YTBxQVBtYlh2Q1BpajRWNndOWDBxNWxleVU0UzhpWEkyNSs1TXZUOCtEMndhOUw4Ri9HVFNOZVdPejFreDZacUp3QVdiOXpLZjlsajkwK3pmbWE5TWtqU2FObzVFVjBZWVpXR1FSNkVWNU40dytCK25ha1pMenc3SW1uM0p5VGJPQ1lIUHQzVDhNajJvR2V0QWhnQ0RrSG9SUzE4eHdhNzQvOEFoZGNwYVhheXJhNXdrRjErOWdjRCs0d1BINEVmU3ZRdEMrUEdpM2FySHJWbGNhZkx4bVNNZWRIOWVQbUg1R2dWajFxaXNUUy9GL2gzV2dEcDJzMlZ3VC9Bc29EZjk4bkIvU3R2TkFCUlJSUUFVVkhOY1EyOFprbmxTSkIxWjJDZ2ZpYTVQVi9paDRQMFlNSnRaaG5sWC9sbGE1bVkvd0RmUEEvRTBBZGhWSFZkWjA3UTdGNzNVN3lHMXQxNnZLMk0rdzdrK3c1cnhUeEQ4ZTd1WVBENGYwMWJkVHdMaTcrWnZxRUhBL0Vtc1BTL0FYamY0aVhrZXBheFBORGJQeUxxK0p6dFAvUE9Qamo4aFFNMVBHbnhrMURYSkRwUGhXS2UzaGxieS90QVUrZk5uc2lqbGMvOTlmU3RYNGUvQnN4dkZxL2l1SU0rZDhXbms1QVBYTXZxZjluODg5Szcvd0FJZkR2UXZCMFllMGc4KytJdzk1T0FaRDdEc285aCtPYTYyZ0RudkdQaEt5OFgrSFpkTXVBcVNBYjdlWURtR1FEZ2oyN0VkeFhobmdMeFRmZkRieGRjNkhyaXRGWXlTK1hkSWVSQy9hVmY5a2pHZlVZUGF2cFN2TS9pMzhQL0FQaEpkTC90YlRZUWRXczBPVlVjM0VZNUsvN3c1SS9FZDZCSHBTT3NpSzZNR1Zoa01Ea0VVNnZGZmd4OFFQTlNQd3Bxc3Y3eEIvb0Vqbjd5anJFZmNkdmJJN0N2YXFBQ2lpaWdBb29vb0FLS0tLQUN1ZDhTZUIvRC9pdU0vd0JxYWVqVFl3dHpIOGtxL1JoMStoeUs2S2lnRDU2OFFmQlhYOUNuKzMrR3J4cjFZenVSVmJ5cmlQNkVIRGZnUWZhbWFCOFpmRW5oMjUvcy93QVNXajN5eG5hNGxYeXJtUDY1R0cvRWZqWDBSV05yL2hYUlBFMXQ1T3I2ZkRjWUdGa0l3NmY3ckRrVURLZmhyeDc0ZDhWb28wMi9UN1NSbHJXYjVKVi80Q2V2MUdSWFMxNEo0bStCVi9aT2J2d3hlbTVWVHVXM25ZSkt2KzY0d0Nmcmo2MWxhUDhBRkx4ajRMdkJwdXYyMDEzR25CZ3ZnVW1VZjdMOXg5Yy9XZ0Q2UW9yanZDL3hOOE5lS2RrTnZlZlpyMXYrWFc2d2prLzdKNk4rQnJzYUJCUlJSUUFVVVVVQUZGRkZBQ045MC9Tdk5QZ2Qvd0FrMWkvNi9Mai9BTkRyMHR2dW42VjVwOERmK1NheGY5Zmx4LzZGUUJ6MWgveWRMcUgvQUY0Lyswa3IyMnZFckQvazZYVVArdkgvQU5wSlh0dEFCUlJSUUFVVm02enIraytIN1EzV3JYOEZwRjJNallMZXlqcVQ5SzhmOFVmSGxtMzIvaG15MjU0RjNkci9BT2d4L3dDSi9DZ0QyZlVkVXNOSXMzdTlSdTRiVzNUckpNNFVmcjFQdFhrdmlqNDhXZHVIdC9EZHA5cWNjZmE3a0ZJeDdoZnZOK09LNC9UdkFQam40aFhpNmpyRTAwTUxjaTUxQWtISCt4SDZmZ29yMXJ3djhKZkRYaHN4enZiL0FObzN5OCtmZGdNRlAreW4zUitwOTZCbmtGdDRkOGYvQUJRdVV1NzE1amFFNVdlN1Bsd0tQOWhCMS9BZmpYcVhoZjRNZUhkRDJYR29nNnRlTHp1blhFU24yajZmOTlacjBnQURwUlFJYWthUklxUnFGUlJnS293QVBhblVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJYbVh4YytJSC9BQWplbWYyUHBzMk5WdkUrWjFQTnZFZUMzc3g1QS9FOXFBT0wrTHZqbVh4QnFnOEthS3pUV3NVb1NZeGNtNG16Z0lQVUEvbWZwWHB2dzM4RFJlRE5CQ3pLajZwYzRlNmxIT0QyUUgwWDlUazF4ZndYOEFmWjRrOFZhcEQrK2tYL0FFQ0p4OTFUMWtQdWUzdHozcjJpZ1lVVVVVQ0NpaW11eW9oWmlBb0dTVDJGQUh6djhidFFsMWZ4M1o2TGJrc2JXRkkxVWY4QVBXVWcvd0F0bGVpWHZ3VzhKMzFqREdJSnJTNWppVkdudFpOdTlnTWJpcHlDVDE2VjVoNE5WdkdueHJPcHV1NkVYVWw4ZStFVGlNZm5zcjZWb0dlQzZuK3o3Zkl4YlROYnQ1aDJXNmhLRWZpdVIrZ3JISHd3K0pXbGNXTXNoVWRQc3VwRlIrUklyNlNvb0ZjK1dOYjFENGtlRlBJVFY5VjFlMDgvZDVXNjgzN3R1TTR3eDlSV2phNkg4VjlkczRibUs1MWVXMm5RU1J1K29oQXlrWkIrL211ay9hRysvd0NIL3BjZit5VjZwNEovNUVYUWYrd2ZCLzZBS0JuaDBYd1c4YmFwSnUxRzZ0WTg5V3VidHBqK2dQOEFPdXAwbjluK3hqMnRxK3RUeitzVnJHSWwvd0MramsveXIyYWlnVnp3bjRzZkQzUnZEZmhHeXZkRXNoQVlMa0pPKzRzMGl1TUFzVDZFRDg2N3o0UTZ2L2EzdzYwOE0yNld6TFdqNVBQeUg1Zi9BQjByVzU0MTBmOEF0N3dacTJtZ1plVzNZeC83Ni9NdjZnVjVMK3ovQUt4czFEVnRIYzRFMGEzVVlQcXZ5c1B5Sy9sUU05NG9vb29FRkZGRkFIZ0h4ZjhBQXN1aDZrUEZlaXEwVnZKS0h1QkZ3YmViUEVneDBCUDVOOWE5SStHbmpxUHhub1FGd3lMcXRxQWwxR09OM3BJQjZIOURrZWxkamVXbHZmMmMxcGR3cE5ieklVa2pjWkRLZUNEWHpUcldtYXI4SWZIME41WWxudEdKZTJaejhzMEpQelJQN2pwK1JvR2ZUbEZaZmg3WHJMeExvbHRxdW55Ym9KMXpnL2VSdTZ0NkVIaXRTZ1FVVVVVQUZGRkZBQlJSUlFBVVVVVUFGWjJyNkZwZXYyWnRkVnNJTHVFOUZsVEpYM0I2Zys0clJvb0E4UDhBRkh3RysvY2VHYjMzK3lYYmYrZ3lmNGo4YTVuVC9IUGpyNGRYYTZmcTBNMHNDOEMydndTQ1ArbWNnL29TUGF2cGFxdW9hYlk2cmFQYWFoYVEzVnUvM281a0RLZnpvR2NYNFgrTG5ocnhHWTRKcHpwdDYzSGtYUkFWai9zdjBQNkgycnZRUVJrSElOZU8rS1BnUlkzUWU0OE9YWnRKRHo5bHVDWGlQc0crOHY0NXJoN2ZYZkgvQU1MYmxiVzdTWmJNSEN3M1E4MjNmL2NjZFB3SStsQUgwM1JYbXZoZjQwK0h0YTJXK3A1MG03UEg3NXN4TWZaKzMvQWdLOUlqa1NhTlpJM1YwWVpWbE9RUjdHZ1E2aWlpZ0JHKzZmcFhtbndPL3dDU2F4ZjlmbHgvNkZYcGJmZFAwcnpUNEcvOGsxaS82L0xqL3dCQ29BNTZ3LzVPbDFEL0FLOGYvYVNWN2JYejdxZmlMVC9DL3dDMGJxdXFhazdyYnBaaGNSb1dabU1TWUFIcjlhaTEvd0NNL2lMeEJjZjJmNGJzM3NsbE8xUExYemJsL3BnWVg4QWZyUUI3YjRnOFc2SDRZdC9OMWZVSXJja1pXTE82Ui84QWRVY212SFBFdnh6MUsvYzJmaG15TnFybmFzOHlpU1ovOTFCa0Q5VFZidy84Ri9FT3YzSDIvd0FTM2oyS3lIYzRrYnpibC9yazRYOFNmcFhzWGhyd0o0ZThLUmorekxCQmNZdzF6TDg4cmY4QUFqMCtnd0tCbmltamZDbnhmNHh2UDdTOFFYTXRta25MVFhwTWs3RDJUdCtPUHBYc0hoZjRhK0cvQ3V5VzFzeGNYcS84dmR6ODhtZmJzdjRBVjE5RkFnb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb3F2ZTN0dHAxalBlM2t5dzI4Q0dTU1J6Z0tvNm1nREY4YWVMYlR3ZDRlbTFLNHc4eCtTM2d6ekxJZWcrbmNuc0JYaDN3L3dEQ3Q3OFIvRnR6cnV1RnByR09iekxsMjRFOG5VUkQvWkF4bjBHQjNxcnFsOXEzeGcrSUVWdGFCNDdSU1ZnVmh4YndBL05Jdy92SGo4Y0N2b3pRdEVzdkR1alcybDZmRnN0NEYyajFZOTJKN2tuazBETkJGVkVDSW9WVkdBQU1BQ2xvb29FRkZGRkFCWEtmRW5XZjdEOEFhdGRLMjJWNFRCRi92UDhBS1B5eVQrRmRYWGl2N1FHc2hMVFNkRlZ2OVk3WFVvOWxHMWYxTGZsUUEzOW43UnRsdHEyc3N2MzJXMGlQc28zTitwWDhxOXNya3ZocG8zOWlmRC9TYlowMnpTUmZhSmY5NlQ1djVFRDhLNjJnQW9vb29BOE4vYUcrL3dDSC9wY2YrMDY5VThFLzhpTG9QL1lQZy84QVFCWGxmN1EzMy9EL0FOTGovd0JwMTZwNEovNUVYUWYrd2ZCLzZBS0JtOVJSUlFJRDByNXBzdjhBaWh2anI1WCtydGhmbVBucDVNM1Q4QnVINVY5TFY4Ly9BQjgwZzJ1djZack1JMi9hWVRDekQrL0djcWZ5Yi94MmdhUG9DaXNqd3RxNDEzd3JwbXFBNU56Ym83ZjcyTU1QekJyWG9FRkZGRkFCV0I0dzhLMmZpL3c5UHBsMk5ybjU0SmdPWXBCMFlmeUk3Z210K2lnRDVxOEQrSnIvQU9HWGpHNTBYVzFhT3lrbEVkMmg1RVRmd3lyNmpHTStxL1N2cE5IU1dOWFJsWkdBS3NweUNEM0Jyemo0cytBUCtFbzByKzA5T2l6cTltaHdxOVo0eHlVK282ajhSM3JtL2d4NC93QWhQQ21xeTRaYy9ZSkhQSkhlSSs0N2ZpT3dvR2UyMFVVVUNDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLaXViVzN2TGQ3ZTVoam1oY1llT1JReXNQY0dwYUtBUEtmRkh3TzBiVXQ4K2hUSFM3ZzgrVVFYZ1kvVHF2NEhIdFhuT1BpRDhLcCtQT2pzUTNiOTlhUDhBL0UvK09tdnB5bXlScExHMGNpSzZNTU1yRElJOUNLQVBLdkMveHkwZlV0bHZyc0oweTRQSG5BbDRHUDE2citQSHZYcU5yZDI5N2JwY1dzOGM4TGpLU1J1R1ZoN0VWNTU0bytDL2g3Vzk5eHBvT2szWnljd0xtSmo3cDIvNERpdkxybncvNC84QWhmY3ZkV1R6aXpCeTAxb1RMQXcvMjBQVDhSK05BejZaYjdwK2xlYWZBMy9rbXNYL0FGK1hIL29WWTNoajQ3MmQwcVcvaU8wK3lTRVkrMVd3THhIM0svZVg4TTFzZkF3aHZocENRY2czaytQKytxQkhuK3JlRkxmeFYrMGZxbW1YczhzVnU4U3pzWWNiaUJDbkdTT0s5ejhQK0U5RDhNVy9rNlRwOFZ1U01OTGpNai83ekhrMTVaWWY4blM2aC8xNC93RHRKSzl0b0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBcjU5K0xuam1YeEZxeStGZEZMVFdzVXdTWXhjbTVtemdJUFVBL21mcFhhZkYzNGdmOEk1cG45amFiTmpWYnhQbWRUemJ4SGd0N01lUVB4UFlWamZCZjRmL1pvVThVNnBEKytrWC9RWW5IM0VQL0xRKzU3ZTNQZWdaMmZ3MzhEUmVDOUJDektqNnBjNGU3bEhPRDJRSCs2djZuSnJ0S0tLQkJSUlJRQVVVVVVBRmZOWGpSajQwK05RMDJNbG9SY3hXSTc0Vk9aRCtlLzhxK2lOWTFHUFNOR3ZkUm1JRWRyQTh4ejMyZ25GZUJmQkRUcE5XOGRYbXRYSUxHMWhlUXNmK2VzcHgvTGZRTStpRVZVUlZVQUtCZ0FkaFRxS0tCQlJSUlFCNGIrME45L3cvd0RTNC84QWFkZXFlQ2YrUkYwSC9zSHdmK2dDdksvMmh2ditIL3BjZiswNjlVOEUvd0RJaTZEL0FOZytELzBBVURONmlpaWdRVjU5OFp0SC90VDRlM1U2cm1Xd2tXNlgxd0Rodi9IV0ovQ3ZRYXJhaFpSYWpwMXpZempNVnhFMFQvUmdRZjUwQWVaZkFmV1B0bmhLNjB0Mnk5aGNIYU05RWsrWWYrUGJxOVdyNXgrRHQ1TDRlK0pWeG90eWRwdUVrdFhCL3dDZWtaSkg4bS9Pdm82Z0Fvb29vQUtLS0tBQ3ZBdmpENEVrMGkvL0FPRXMwWkdqZ2trRFhRaTRNRXVlSkJqb0Nldm9lZTllKzFEZFdzRjdheTJ0ekVzc0V5RkpJM0dReWtZSU5BSEdmREx4M0g0eTBQeTdsbFhWclFCYmxPbThkcEFQUTkvUS9oWGMxOHgrSU5KMVQ0UitQSUwvQUU0czFtekY3VjMrN0xIL0FCUlA3anArUnI2SDhPZUlMTHhQb2R0cXRnKzZHWmVWSithTmgxVnZjR2dEVm9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLUWdFWUk0cGFLQU9DOFUvQ1h3MTRqOHllT0E2YmV0aytmYUFLR1ArMG5RL29mZXN6NEdSTC9BTUt5dDFibmJkemovd0FlcjA5dnVuNlY1cDhEditTYXhmOEFYNWNmK2gwQWM5WWY4blM2aC8xNC93RHRKSzl0cnhLdy93Q1RwZFEvNjhmL0FHa2xlMjBBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJYTytOUEZ0cDRPOFBUYWpjWWVZL0pid1p3WlpEMEgwN2s5aFcxZlh0dHB0alBlM2t5dzIwQ0dTU1J6d3FqcWErYXRUdmRXK01IaitLMnRRMFZxdVZnVmg4dHZBRDgwamY3UjQrcHdLQUxYdy84QUNsNzhSdkZsenJ1dUZwckdPYnpMbDI0RThuVVJqL1pBeG4wR0IzcjZTVlZSUXFnQlFNQUFZQUZaK2hhSlplSGRHdHRMMCtMeTdlQk5vOVdQZGllNUo1TmFOQUJSUlJRQVVVVVVBRkZGRkFIbTN4dTFqK3p2QVRXYU5pWFVKMGd4MzJENW0vOEFRUVB4cUw0RzZSOWc4RHZmdXVKTlF1R2tCLzJGK1JmNU1meHJoL2pycWI2ajR4c05HdHlXTnBBUGxIL1BXVThEOGd2NTE3cm9PbHg2TG9HbjZaR0FGdGJkSXVPNUF3VCtKeWFCbWpSUlJRSUtLS0tBUERmMmh2ditIL3BjZiswNjlVOEUvd0RJaTZEL0FOZytELzBBVjVYKzBOOS93LzhBUzQvOXAxNnA0Si81RVhRZit3ZkIvd0NnQ2dadlVVVVVDQ2lpaWdENXMrSkVNbmhENHZwckVLN1Zra2kxQk1kK2NPUHhLbi92cXZvK0NaTGlDT2FKZzBjaWgxSTdnaklyeUg0L2FQNTJqYVpyQ0tDYmFZd1NIL1pjWkgvankvclhXL0NqV0RyUHc3MDEzYmRMYXFiV1ErNmNEL3gzYlFNN1dpaWlnUVVVVVVBRkZGRkFHRjR0OEwyWGk3dy9QcGQ0TnBZYm9aZ010RklPakQrbzdqSXJ3WHdYNGsxRDRYZU03blI5YVZrc25rRWQyblVJZjRabDlSajgxOXhYMHZYblB4WDhBRHhWcEg5bzZmRm5XTE5Uc0E2eng5VEdmZnVQZmp2UUI2SkhJazBTU3hPcnh1b1pXVTVEQTlDRFRxOE8rREhqOG95ZUU5VmxJNUlzSkpEZ2oxaU9meHgrSTlLOXhvQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FFYjdwK2xlYWZBNy9BSkpyRi8xK1hIL29WZWx0OTAvU3ZOUGdkL3lUV0wvcjh1UC9BRU9nRG5yRC9rNlhVUDhBcngvOXBKWHR0ZUpXSC9KMHVvZjllUDhBN1NTdmJhQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpdk1QaTc4UVA4QWhIZE1PaTZiTUJxdDRuenVwNXQ0anh1OW1QSUg0bjBvQTR2NHQrT0p2RWVycjRWMFF0TmF4VEJKZks1TnpQbkFRZW9VL21mcFhxSHc0OER3K0M5QUNTcXI2bmM0ZTdsSE9EMlFIKzZ2Nm5KcmkvZ3g4UDhBN0xDbmluVklmMzhxL3dDZ3hPUHVJZjhBbG9SNm50N2M5Njlub0dGRkZGQWdvb29vQUtLS0tBQ2tKQUJKT0FPcE5MWEwvRVhXZjdDOEJhdmVLMjJVd21HTC9mZjVSL1BQNFVBZUkrRndmRzN4diszT044SDJ1UzhPZVFJNC91RDlFcjZXcnhEOW43UmdJOVcxcDE2bExTSSt3K1p2NXIrVmUzMEF3b29vb0FLS0tLQVBEZjJodnY4QWgvNlhIL3RPdlZQQlAvSWk2RC8yRDRQL0FFQVY1WCswTjkvdy93RFM0LzhBYWRlcWVDZitSRjBIL3NId2YrZ0NnWnZVVVVVQ0NpaWlnRG5mSG1qZjI5NEgxYlQxWGRLOXVYaTQvalg1bC9VVjVaK3o5ck8yNDFiUlhiaDFTN2lCUGNmSzM4MHIzVTlLK2FkSi93Q0tGK09mMmR2a3RoZXRCejA4cWI3djVibC9LZ1o5TFVVVVVDQ2lpaWdBb29vb0FLS0tLQVBCZmpINERmVGJ3K0xOSFJraGR3MTRzZkJpa3p4S01kQVRqUG9jSHZYZmZDL3g0bmpIUlBJdTNVYXZacUZ1RjZlWU9na0E5Ky9vZnFLN2U1dDRidTJsdHJpTlpZWlZLU0l3eUdVakJCcjVwOFM2THFmd2w4ZFcrbzZZekd5Wmk5bzdkSFQrS0YvWEE0K21EMW9HZlRkRlpIaHJ4RlplS2RDdDlWc0d6RktQbVFuNW8zSDNsYjNCL3dBZTlhOUFnb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0JHKzZmcFhtbndOLzVKckYvd0JmbHgvNkZYcGJmZFAwcnpUNEhmOEFKTll2K3Z5NC93RFFxQU9lc1A4QWs2WFVQK3ZIL3dCcEpYdHRlSldIL0owdW9mOEFYai83U1N2YmFBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLcjMxOWJhYll6M3Q1TWtOdEFoa2trYzhLbzZtZ0RGOGErTGJUd2I0ZWwxRzR3OHgrUzJnenpMSWVnK25jbnNCWGgvdys4S1h2eEY4VjNHdmE0V21zWTV2TXVYYmdUeWRSR1A4QVpBeG4wR0IzcXBxVjdxM3hnK0lFZHZhcTBWcXVWaFZoOHR0QUQ4enQvdEg5VGdkcStqTkQwV3k4UGFOYmFYcDhYbDI4Q2JWOVdQZGllNUo1TkF6UVZRaWhWQUFBd0FPMUxSUlFJS0tLS0FDaWlpZ0Fvb29vQUs4WC9hQTFueTdEU2RHVi93RFd5TmRTai9aVWJWL1ZqK1ZlMFY4MWVPSGJ4cDhhQnBjYkZvbHVJckJlK0ZVNWtQNWwvd0FxQVI3TjhNZEcvc1Q0ZmFWQXliWnBvL3RNdis5SjgzNkFnZmhYWDAyTkZpaldOQUFxZ0JRT3dGT29BS0tLS0FDaWlpZ0R3MzlvYjcvaC93Q2x4LzdUcjFUd1QveUl1Zy85ZytEL0FOQUZlVi90RGZmOFAvUzQvd0RhZGVxZUNmOEFrUmRCL3dDd2ZCLzZBS0JtOVJSUlFJS0tLS0FDdm4zNDlhUzFwNGswM1dZUnQrMVFlV3pEL25wR2NnL2t3L0t2b0t2UFBqUnBIOXAvRDI0dUVYTXRoS2x5dnJ0SHl0K2pFL2hRQjEzaG5WbDEzd3pwdXFJYy9hYmRKRzlteDh3L0E1clZyeXY0RWF4OXM4SDNHbU8yWkxDNE8wRTlJMytZZnJ1cjFTZ0Fvb29vQUtLS0tBQ2lpaWdBckU4VitHYkx4Ym9FK2wzb3dIRzZLVUQ1b3BCOTFoOVAxR1JXM1JRQjh6K0VQRU9vL0N6eHRjNlZyQ010azdpTzdRWklIOTJaUFVZNTl4N2l2cFdHV09lRkpvblY0NUZESTZuSVlIa0VIMHJ6L3dDS3ZnRWVMZEgrM1dNWS90aXpVbUxIL0xaT3BqUDh4Ny9XdVA4QWd6NCthM2xUd2xxMGhBTEVXTHljRlc3eEhQNmZpUFNnWjduUlJSUUlLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0JHKzZmcFhtbndPLzVKckYvMStYSC9BS0ZYcGJmZFAwcnpUNEcvOGsxaS93Q3Z5NC85Q29BNTZ3LzVPbDFEL3J4LzlwSlh0dGVKV0gvSjB1b2Y5ZVAvQUxTU3ZiYUFDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLK2ZQaTM0NG04U2F1bmhYUkMwMXJGTUVsOHJrM00rY0JCNmdIOHo5SzdQNHZmRUQvQUlSN1RUb21telkxUzhUNTNVODI4UjcrekhrRDA1UHBXVDhHUGgvOWtnVHhUcWtQNytWZjlCaWNmNnREL3dBdENQVTl2Ym52UU03UDRjZUI0ZkJlZ0JKUWo2bmM0ZTdsSFBQWkFmN3EvcWNtdXpvb29FRkZGRkFCUlJSUUFVVVVVQUZGRkZBRkxWOVJqMG5ScjNVWlNQTHRZSG1iUCt5Q2E4QytDZW5TYXo0OXZOYXVjc2JXSjVXWTgvdlpTUi9MZlhvWHh0MWorenZBVDJhTmlYVUprZ3gzMkQ1bS9SUVB4cUQ0R2FPYkR3VEpxRHJpVFViaHBBZlZFK1JmMURIOGFCbnA5RkZGQWdvb29vQUtLS0tBUERmMmh2ditIL3BjZiswNjlVOEUvd0RJaTZEL0FOZytELzBBVjVYKzBOOS93LzhBUzQvOXAxNnA0Si81RVhRZit3ZkIvd0NnQ2dadlVVVVVDQ2lpaWdBcXRxTmxGcVdtM1ZqTU14WEVUUlA5R0JCL25WbWlnRDV4K0RWN0pvSHhIdWRGdVR0TnlrbHN3Si81YXhra2Z5Yjg2K2pxK2EvaU5FL2hENHdwcThLN1VlV0xVRngzNXc0L0VxMzUxOUl3eXBQQ2swVEJvM1VNckR1Q01pZ2JIMFVVVUNDaWlpZ0Fvb29vQUtLS0tBQ3ZDUGpMNENheHVXOFc2UWpKR3pocjFJK0RHK2VKUmpwazR6NkhCN212ZDZqbmdpdXJlU0NlTlpJcEZLT2pESVpTTUVFZWxBSENmQzN4NnZpL1Jmc3Q0NEdyMmFnVGpwNXE5QklQcjBQb2ZxSzcrdm1YeFRvV3BmQ2p4emI2bHBMTjlqWnpKYU8yU0N2OFVMK3ZISHVNSHFLK2d2Qy9pU3k4VjZEYjZyWXQ4a2d3OFpQelJPUHZLZmNmNEh2UUJzVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFDTjkwL1N2TlBnZC95VFdML3I4dVAvUXE5TGI3cCtsZWFmQTMva21zWC9YNWNmOEFvVkFIUFdIL0FDZExxSC9Yai83U1N2YmE4U3NQK1RwZFEvNjhmL2FTVjdiUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGYzU0MjhYV25nM3c5THFNKzE1MitTMmd6ekxJZWcrZzZrK2xiZC9mVzJtV0U5N2VUTERiUUlaSkpHUENxT3RmTldvM21yZkdINGdSd1dvYUsxWEt3cXcrVzJnQitaMi8yang5VGdkcUFMbnc4OEozbnhFOFYzR3Y2Nldtc1k1dk11SGJnWEVuVVJqL1pBeG4wR0IzcjZRVlFpaFZBQ2dZQUhhcUdoNkxaZUh0SHR0TDArTHk3YTNUYW83c2U3RTl5VHlUV2hRQVVVVVVBRkZGRkFCUlJSUUFVVWhJQXpXUHFQaXp3OXBJUDIvV3JDQWpxcnpydS9MT2FBTm1pdlA3NzR6K0M3UElqdjVyc2p0Ylc3bjlTQVAxcm5MejlvSFRVeUxMUXJ5YjBNMHFSajlOMUFITy9IWFZKTlI4WDJHaXdFc2JTRWZLTzhzcEdCK1FYODY5MDBEUzAwVHcvcCttUmdiYlczU0xqdVFPVCtlYStUcjd4VmNYL2pkL0V6UXd0Y202RnlrRWhMb051TnFub1NCZ2VuU3V4LzRXaDhTZFVKK3d4T005clhUUzM2a05RTStrYzBWODNlZjhZdFQ2RFhsQjlJMWdIOGhSL3doSHhZMUVabmwxSEIvd0NlK3FZL1RmUUI5SHM2cU1zUUI2bmlvWHY3U1A3OTFBdjFrQS9yWHp1bndhOGRYWnpjWEZxdWV2blh6dC9JR3JDZkFIeEhKekxxV2xMK01qZit5MEFlOFByMmtSL2YxV3hYL2V1RUg5YWlQaWZRQjExelRSOWJ1UDhBeHJ4SlAyZTlXUDM5WjA0ZlNCelV3L1o2disrdldZK2xxMy94VkFDZkhqVmRPMU50Qyt3WDlyZCtXSjkva1RMSnR6c3huQjQ2R3ZUUEJ2aVBRNGZCZWlReTZ6cDBjc2RqQ3JvMTBnWlNFR1FSbmcxNXgvd3ozZGpwNGh0Ly9BUnYvaXFhMzdQVjcyOFFXcCt0bzMveFZBSHM0OFI2RzMzZFowNC9TNlQvQUJxWk5ZMHlUN21vV2pmN3M2bit0ZUhOK3ozcVA4T3VXSit0c3cvclVMZnMrNjBQdWF2cGgrc1RqK2hvQTkrVzd0Mys3UEVmbzROUzVCcjUxZjREZUtZdjlWcUdsdDlKWkYvOWxxRS9DTDRnV2h6Ynp4RS85TWRSWmY1NG9BK2thTTE4My84QUNIL0Z2VC85VExxbUIvengxTU4rbStrKzAvR0xUdW8xNWdQV0paaC9JMEFkZDhmdEhFMmphWnJDS04xdE1iZVEvd0N5NHlQL0FCNWYxcnIvQUlVNngvYlB3NzB4M2JkTGJLYldRKzZIQS84QUhkcHJ4RFgvQUJoNDkxSFJwOUoxNjN1SHRaY2J2TzAwb3dJSUlJWUtNSElxRHdUOFN0UjhDMjkxYVFXbHZjd3p5aVVwTzdJVmJHRGpIcngyN1VBZlZWRmVLV243UWNEQUM4OFBUTDZ0QmNxMzZFRCtkYjlsOGMvQ1Z6Z1hBdjdROS9NdDl3SDRxVFFJOU1vcmxySDRrZUR0UllMQjRoc2d4L2htZnlqL0FPUFlyb3JhOHRieVB6TFc0aW5UKzlFNFlmbUtBSjZLS0tBQ2lpaWdBb29vb0F4dkZQaHV5OFY2QmNhVmZMOGtnekhJQjgwVGo3cmozSDZqSXI1LzhLYTlxWHdwOGNYR21hc3JmWTNjUjNjYTVJSy93eko2OGMrNHlPb3I2WnJ6L3dDS2ZnSmZGMmkvYTdKQU5ZczFKaEkvNWJMMU1aL21QUS9VMEFkNUJQRmN3Unp3eUxKRklvZEhVNURBOGdnK2xTVjRUOEd2SHJXZHd2aExWNUdWR1lyWlBKd1kzenpFYzlNbk9QUTVIcFh1MUFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBamZkUDByelQ0SGY4azFpLzYvTGovd0JEcjB0dnVuNlY1ZDhFNVRGOE5ZTUl6WnZMajdvLzJxQU1Tdy81T2wxRC9yeC85cEpYdHRlSjJIL0owdW9mOWVQL0FMU1N2YktBQ2lpaWdBb29vb0FLS0tLQUNpaXZML2k5OFFQK0VlMDA2SnBzMk5VdTArZDFQTnZFZS9zeDZEOFQ2VUFjWDhXdkc4M2lYV0U4SzZJV210WXBna25sY201bnpnS1BVS2Z6UDByMUw0YytCNGZCZWdDT1FJK3AzT0h1NVJ6ejJRSCs2djZuSnJqUGd4OFAvc2NDZUtOVWh4Y1NyL29NVGovVm9mOEFsb1I2a2RQYjYxN0xRTUtLS3JYMm8yV21XNXVMNjdndFlSMWtta0NMK1pvRVdhSzgwMXY0M2VGOU4zUjJIMmpWSmgwOGhkc2YvZmJZL1FHdlB0UStOSGkvWEp6YTZKWnhXaGJoVXRvVGNUZm1Sai94MmdENkpsbGpoak1rc2lvaThsbU9BUHhya2RYK0tQZy9SeXlTNnpEUEt2OEF5enRRWmovNDd4K3RlT1JmRHY0aStNSkZuMVo1MGpiK1BVN2s4ZlNNWkkvSVYxMmtmcy8yTVlWdFkxaWVjOTRyVkJHdjVuSi9sUU1acTM3UU5xbTVkSTBTYVgwa3U1UkdQKytWeWYxRmN2TDhWUGlENGtrTVdrd21NTjBYVDdNeUgvdm83djZWN0xwUHd6OElhT1ZhMzBTMmxrSC9BQzB1UVptLzhlelhVeFF4d1JpT0tOWTBIUlVHQVB3RkFIemVQQXZ4UThUa05xTDNvUnU5L2U3UVArQUFuK1ZiR25mcyszNzRiVWRjdG9QVmJhQXVmekpIOHE5N29vRmM4c3NmZ040WmdBTjNkNmpkc1BXVlkxUDRLTS9yWFNXZnd1OEZXT1BMMEMya1lmeFRscFQvQU9QRTExOUZBRkMxMFBTYkVZdE5Nc29CL3dCTW9FWCtRcThBQU1EZ1V0RkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVlxcGNhVnA5Mk1YTmphekQwa2hWdjVpcmRGQUhNWG53NjhIM3hKbjhPNmZrOVRIRjVaL3dESGNWejk3OEVQQjEwU1lZYnkwSjZlVGNrZ2ZnMmE5SG9vQThXdnYyZkxWZ1RZK0lKMDlGdUxkWEg1cVJYTjNQd1E4WDZhNWswMjhzNXlPaGhuYUJ6K1kvclgwYlJRRno1c1AvQzNmREhYKzJqRW4wdWtIL29YRldiUDQ2ZUtkT2NSYXBZV1Z5UjFEeHRBL3dEaCtsZlJWVmJ6VExEVVUyWHRsYjNLZjNab2xjZnFLQm5sdW1mSDNSSjhMcVdsMzFteC9pajJ6TC9RL3BYYWFWOFJQQ1dzbFZ0TmN0UE1icEhNM2xOOU1OaXM3VS9oRDRNMVBjMzlsL1pIUDhWcElZLzArNytsY1ZxMzdQc2JBdHBHdU1QU0s4aEREL3ZwY2Z5b0E5c1YxZFF5c0dVOGdnNUJwMWZOYitBdmlWNFFZeTZXMTAwUy93QVduWFc0SC90bWNIOURVOWw4Wi9HV2h6L1p0YXRJYmtyd1V1b0RCTCtZeC9LZ0xIMGJSWGx1ai9IWHc1ZWxVMUszdTlOa1BWbVh6WS96WG45SzlCMHJYOUkxeUVTNlhxVnJkcmpKOG1VTVI5UjFINDBDUEhQak40Q2EybWJ4YnBNWlZTd044a2ZHeHUwb3g3OWZmQjlhN0w0VitQbDhXNk45aXZwQi9iRm1vRXVmK1d5ZEJJUDVIMyt0ZC9ORkhjUXZETWl5UlNLVmRHR1F3UEJCSHBYelQ0dThQNmo4Sy9HMXZxdWtNd3NuY3lXam5KQUg4VUwrdkg1akI2aWdaOU0wVmkrRmZFMWw0czBDMzFXeU9GY2JaSXlmbWlrSDNsUDAvVVlOYlZBZ29vb29BS0tLS0FDaWlpZ0JHKzZmcFhtUHdRR2ZockQvQU5mbHgvNkhYcHpmZFAwcnpENEpGeDhOWU5nQi93Qk11TTUvMzZBTU93LzVPbDFEL3J4LzlwSlh0bGVKV0gvSjB1b2Y5ZVAvQUxTU3ZiYUFDaWlpZ0Fvb29vQUtLS3JYOS9iYVpZVDMxNU1zTnRBaGtra1k4S29vQXhQRzNpNjA4RytIcGRRbjJ5VHQ4bHRBVHpMSjJIMEhVbjByeEw0ZWVFcno0aCtLcmpYOWRMVFdNYzNtWEROd0xpWHFJeC9zZ1l6NkRBNzFtYTNxOTc4VWZHMitTZExMVFlzaEhuWUtscGJnOHV4UEc0L3FTQjJydXJ2NHQrRy9CK2p3Nko0UnNUZkpiSnNXYVRLUlo3c1Q5NXlUa2s4WjlhQm50SHlSSjJWRkgwQUZjVDRpK0xIaFh3OFhpTjc5dXVsNDhpenhJUWZkdnVqODY4Y054OFJmaWhJVlQ3VEpZc2VRbjdpMVg2bitML3g0MTIvaDM0Q1dWdUVsOFFhZzkwNDVOdmE1ampIc1crOGZ3eFFCeldyL0FCcDhVYTdjL1kvRDlrdGx2NFZZVU04N2ZwZ2ZnUHhxdlkvQ3J4eDR0dUJlNjVPMXNHNU11b1NtU1g4RUdjZmlSWHYraitIOUkwQzM4alN0UHQ3U1BHRDVTQUZ2cWVwL0UxcFVBZVk2SDhEdkRPbkJYMUo3alZKaDFFcmVYSC8zeXY4QVVtdlF0TzBuVHRJdHhCcDFsYjJrUUdOc01ZUWZwMXE1UlFJS0tLS0FDaWlzZlZQRmVnYUtEL2FXc1dWc3c2bzh3M2Y5OGpuOUtBTmlpdk5kVCtPUGhLeUpXME41ZnNPaGhoMnFmeGZGY2pxUDdRZDJTUnAyaFFSRHMxMWNGaitTZ2Z6b0E5NG9yNXRQeEwrSk92c1YwMktaVmJ0WTZlV3gvd0FDSWIrZEgvQ09mRnZYZ2Z0RGF1RVBVWEY2SVYvNzVERCtWQTdIMFpQZVcxc3BhZTRpaUE2bVJ3dVB6ckh1L0czaGV5LzQrUEVHbUlSMiswcVQraHJ4R0Q0RitLNzA3NzIrMCtJbnI1a3p5dC82RC9XdG0wL1o2a3dEZGVJa1gxRUZwL1V0L1NnRHY1L2l6NEh0d2M2OUZJZlNLS1IvNUxXWk44Y1BCc1pPMmErbC93QnkxUDhBWEZaTnY4QU5FWEgyaldOUmw5ZG9SUDZHdE9INEdlRDQvdmpVWmY4QWZ1c2YrZ2dVQVZaZmozNFlVL3U3SFZaUCsyU0QrYlZXZjQvNklQdWFOcWJmVXhqL0FObXJvSS9nMzRJajY2Vkkvd0R2M1VwLzltcTBud244RG9QK1JmaFArOUxJZi9acUFPUFA3UVdtZnc2QmZINnlvS1FmdEJhZG5udy9lLzhBZjVLN1VmQzN3U3ZUdzdaL2p1UDlhVS9DL3dBRkVZLzRSeXkvSS80MEFjYXY3UU9ray9Ob2VvRDZTUm4rdFRKOGZ2RDUrL3BXcUw5RmpQOEE3TlhVbjRWK0NHNitIYlg4R2NmK3pWQy93aThEdi96QTBYL2Rua0gvQUxOUUJpeC9IandvMzM3YlZJL3JBcC9rMVc0dmpkNE1rSTNYRjVIL0FMOXEzOU0xTko4Ri9CTDlOT25UL2R1NVA4YXB5L0F2d2hKOTF0U2kvd0IyNnovTUdnRFdoK0xmZ2ViSC9FOVJELzAwaGtYK2ExbzIvd0FRdkNGeVFJdkVlbTVQOTZjTC9QRmNUTjhBZENZbnlOVzFLTWR0Mnh2L0FHVVZuVC9zOXhIUGtlSkpSN1MyZ1A4QUpoUUI2NWI2N3BGM2o3TnFsbE5ucDVkd2pmeU5YbGRYR1ZZTVBVSE5mUDhBUCt6NXE2a20zMW5UcFBUeklYVCtXYW92OEh2SHVtdG15dUlISTZHMnYyalA2N2FBUHBDaXZtNDZYOFlOSE9FYlhHVmUwZHlKeCtXVFNmOEFDeGZpZG92RjlIY2xWNi9hOU54K29VZnpvQ3g5SlVWOCsybjdRR3RSRUxlNlBwOHhIWHlwSGlQNUhkWFIyWDdRR2tTRUMrMGErdC9VeE9rby9vYUJXUFg2SzRhdytML2dxK0FCMWY3TTUvaHVZWGovQUZ4ajlhNm13MTNTZFZBT242blozV1JuRU02c2Z5Qm9BMEtLTTBVQUZGRkZBQlZXOTAyeDFLQXczMW5CZFJIcWswWWNma2F0VVVBZWRhejhGZkNXcGhudFlKOU5tUFJyV1Q1Yy93QzQyUitXSzg5MVg0SGVKTkttTnpvZW9RM3BYbGRyRzNtSDA1eCtvcjZIb29BK2E0UGlCOFJQQk15MitycGNTUkRnUjZuQ1RuNlNEay9tYTZXNCtLbmhYeHZvVTJpK0o3SzQwM3pnTnM2RHpramNkSEJBM0FnKzN0WHRVOXZCZFF0RGNReHl4TU1Na2lobFAxQnJnZGYrRFhoVFdBOGxyYnZwbHdlZDlvY0xuM1EvTCtXS0JuanZnanhiTDhQZkZzc1QzTWQzcFVyaU81YTNmY2pyL0RLbnVBYzQ2NHlPdGZVTnZjUTNkdEhjVzhpeXd5cUhSME9ReWtaQkJyNXU4US9CUHhOcEc2WFR2SzFXM0hQN241SlFQZEQxL0FtbStFUGlocmZnT0lhSnFPbk5jV2tURWlDZmRGTkNEMUM1N1o1d1IrTkFIMHZSWEcrRy9pZjRYOFM3SW9MNFd0MjMvTHRkL3UzSjlqMGI4RFhaVUNDaWlpZ0Fvb29vQVJ2dW42VjVSOEhGWnZocmJiUVQvcGx6MC8zNjlYYjdwK2xlWi9BNy9rbXNQL1g1Y2Y4QW9kQUhQMkgvQUNkTHFIL1hqLzdTU3ZiYThTc1ArVHBkUS82OGYvYVNWN2JRQVVVVVVBRkZJektpbG1JQ2daSlBZVjVkNHgrTk9rNktaTFBSRlhVNzVjZ3lCdjNFWjkySDN2b3ZIdlFCNlZlMzFycDFwSmRYdHhGYjI4WXk4a3JoVlg2azE4OGZGajRreCtKNUUwalI1bU9rd25mTExncjlvZnQxL2hIYjFQUFlWU3RkRzhkZkZpK1c3dVpKR3N3M0U4K1k3ZVAvQUhGSDNqOUFmYzE2NzRUK0VmaDd3MFV1TGlQKzA3OWVmT3VWQlZUL0FMS2RCOVRrKzlBenhEd3Y4TS9FdmlvSkpCYW0xc1h3ZnRWMWxVSTlWWHEzNERIdlh0UGhqNE4rRzlDMlQzeUhWYnhlZDl5djd0VDdSOVB6elhvb0FIU2lnVnhxUnBFaXBHcXFpakFWUmdBZTFPb29vQUtLUm1WRkxNUUZBeVNUd0s0ZnhEOFd2Q21nRjR2dHYyKzVYanliSUNUQjkyKzZQem9BN21vYnE4dHJHQnA3dTRpZ2hYckpLNFZSK0pyNTkxZjQyZUo5YW4reWFCWXBaYnpoQkdodUp6K21CK0FOVkxYNFplUHZHRTYzZXRTeVFxM1BtYWxNV1lmU01aSS9TZ2RqMUhXdmpONFIwcmNrRjFMcU13L2h0RXl1Zjk4NFg4czE1L3EzeDYxdThjdzZOcGR0YWJ1Rk11WjVQd0F3UDBOZFpvdndIMEN6MnZxdDVkYWpJT3FnK1RIK1E1L1d2UWRKOE5hSm9VWVRTOUx0TFRIOFVVUURINnQxUDUwQWZQNDA3NHErTk9adjdWK3p2eisrayt5eFkvM2VNL2thMk5LK0FHcFRFU2Fyck50Ylo1SzIwWmxiL3ZvNEg2R3ZmYUtBdWVhNlo4RC9BQWxaYld1bHZMOXgxOCtiYXAvQk1WMTJuZUR2RGVrZ2ZZZERzSVNPakNCUzMvZlJ5YTNLS0JDS3Fxb1ZRQUIwQTdVdEZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGR0tLS0FNKzcwSFNMOEVYbWwyVndEL3dBOWJkVy9tSzV1KytGSGdxK0IzYUhGQ3gvaXQzYUlqL3ZrNC9TdTBvb0E4bHYvQUlCYUROazJHcWFoYW4wY3JLdjZnSDlhNVhVUGdGcmxzeGswM1ZiSzV4MDh4V2hiOHh1RmZRbEZBWFBtdit3dml6NFcvd0NQWTZzWWw1eGJYQXVFL3dDK2NuK1ZUMnZ4cDhaYU5KNU9yV2x0Y0VjRmJxM2FDVDh4aitWZlJ0UVhWbGEzMFhsWGR0RGNSbnFrcUJ4K1JvR2VUNlg4ZnRKbTJycXVrM2RvZTd3TUpsL0xnL29hN2JTZmlONFMxb3F0cHJscUpXLzVaem55bSttR3hWTFZmaE40TjFVc3phUWxySWY0N056RitnNC9TdUkxZjluNkpnemFScmJyNlJYa1FZZjk5TGorVkFIdGl1cnFHVmdWUElJT1FhV3ZtcC9BL3dBUy9CckdYVEd1MmlYK0xUcm5lcCtzWjUvOGRxMXAvd0FhL0Z1alQvWnRhc29Mb3FjTXM4UnQ1ZjA0L3dESGFBc2ZSZEZlWmFOOGN2REdvYlUxQkxyVEpUMU1xYjQvKytseitvRmVnYWJyR202eEFKOU52cmE3aVA4QUZCSUh4OWNkS0JGMmlpaWdBckwxbnc1by9pRzM4alZ0T3Q3dE94a1Q1bCtqZFIrQnJVb29BOFQ4Uy9BU0pnOC9oelVDaDZpMXZQbVg2Qnh5UHhCK3RjbGJlSi9pQjhNcmxMVFVFbk5xRGhZTDBHV0ZoL3NTQThmZ2Z3cjZacUc2dExhK3QzdDd1Q0tlQnhobzVVREszMUJvQzU1OTRYK00zaDNYZGx2cURIU2IxdU5zN1ppWSswblQ4OFY2TXJxNmhsWU1wR1FRY2dpdkp2RlB3TTByVUJKY2VINXpwMXdlZklmTHdOL1Zmd3lQYXZQWU5VOGUvQ2k4VzN1RWxXeTNZV0tiTXR0Si91TVB1bjZFSDJvR2ZUbEZlZStFZmk5b0hpUXgydDIzOW1hZzNIbFRzTmpuL1lmb2ZvY0d2UXM1b0VJMzNUOUs4cStEVnliZjRhV3VGWnQxNWNkQm4rT3ZWVys2ZnBYbHZ3VnR4UDhBRFdESkl4ZVhIL29WQUdMWWY4blM2aC8xNC84QXRKSzl0cnhLdy81T2wxRC9BSzhmL2FTVjdXN3JHak83QlZVWkpKd0FLQUhWelhpM3gxb25nNjEzNmpjYnJsaG1LMGl3MHNuNGRoN25Bcno3eDU4YW9yVXk2YjRXWkpwaDhyMzdETWFIL3BtUDRqN25qNjF6bmhINFVhMTR1dXY3WjhUVDNOdGJUTjVqR1VrM0Z4NzgvZEh1ZWZRVUFaK3IrTGZHUHhUMUp0TDB5M2xTelkvOGVkc2NJRjlaWDR6K09CNkN2US9CdndUMHpTUkhlZUlHVFVid1lJZ0EvY1JuNmRYUDE0OXE5RjBYUXRNOFBhZWxqcFZuRmJXNjg3VUhMSDFZOVNmYzFvMEFOUkVqUlVSUXFLTUJWR0FCNlU2aWlnQW9xbnFXcTJHajJUM21vM2NOcmJwOTZTVndvK251ZmF2SHZGZngzUlBNdGZERnJ2UFQ3YmRMaGZxcWRUL3dMSDBvQTlqMURVN0hTYlI3clVMdUcxdDA2eVRPRlg4elhsUGlYNDhhZGFiNFBEMW0xOUlPUHRNK1k0aDdnZmViOUs0blR2QTNqbjRpM2FhanEwMDBWdTNLM04rU0FCLzB6ajlQb0FQZXZWL0RQd2c4TStIOWswOEIxTzhYbnpyc0FxRC9BTEtmZEg0NVB2UU04akNmRVg0b1NaUDJtU3hZOVQrNHRWLytLLzhBSGpYY2VIdmdKcDl1RWwxKy9rdTNIUDJlMi9keGoyTGZlUDRZcjJKVkNxQW9BQUdBQjJwYUJHWm8vaDdTTkF0L0kwclRyZTBUdjVTQUZ2cWVwL0UxcDBVVUFGRkZGQUJSUlFTQlFBVVZ6MnErT3ZDK2lraS8xeXpqY2RZMWszdi9BTjhyazF4T3AvSHJ3OWJFcnA5amZYekRveFVSS2Z4Ym45S0FQVjZLK2ViL0FPUFhpQzhZeGFacGxsYkU5TTdwMy9MZ2ZwVkwrMlBpNTRrNWdHc3JHM1F3UUMyWDg4RCtkQTdIMGk4aVJxV2Rnb0hkamlzZTk4WCtITlBCKzE2N3AwUkhacmxNL2xtdkNVK0Vmai9XbjM2blBHaFBVM3Q4MGgvSWJxMkxMOW51N09EZTYvYngrb3Q3WXQrcEkvbFFCNkRkL0Yzd1JhZy84VHBabUg4TUVMdit1TWZyV1BjZkhmd3BGa1F3YW5PZjltQUtQL0htRlU3VDRBNkRHYzNlcTZsUDdJVWovb2EyYmY0SytDb01iN0s1bi82NjNULzBJb0E1NmI5b0xUVko4alFMMXgvdHpJdjhzMVFtL2FGZi9sajRiVWY5ZEx6L0FBU3ZRNGZoZDRKZ3h0OE8yaHgvejAzUC9NbXRHTHdSNFdnR0kvRHVsci8yNnAvaFFCNDdKKzBKcWVmazBTd1gvZXVYUDlCVURmdEFhNlQ4dWw2V0IvdnVmNjE3ckg0ZDBXSVlqMGl3VC9kdGtIOUtuWFN0UFVZV3h0Z1BhRmY4S0FQQWYrRi9lSXYrZ2RwWDVQOEEvRlVENC84QWlIdnB1bGYrUGovMmF2b0g3QmFmOCtzSC9mc2Y0VWgwNnlZNU5wYm42eEwvQUlVQWVDTCswRnJJKy9wT21INlN1UDYxWWovYUV2OEEvbHBvTm0zKzVkTVAvWmE5dWJSdE1mNzJuV2pmV0JUL0FFcXZKNFkwQ2IvV2FMcHpmVzFUL0NnRHlhTDlvVWY4dGZEUlArNWVmNHBWMkg5b0xTMlA3N1FiNUIvc1NvMytGZWd5K0JQQ2M0L2VlSE5MUDB0VUg4aFZHWDRXK0NadnZlSGJRZjdoWlA1R2dEbllQang0VmsvMXR0cWNQMWdWdjVOV3JhL0dQd1RjL2UxVjRELzAydHBCL0lHbzUvZ3Y0S216dDArZUgvcm5kU0QrWk5aVjE4QlBEVWd6YlgrcHdIM2tSeCtxL3dCYUFPeHRQaUI0UnZTQkI0aTA0azltbkNIL0FNZXhXM2I2alpYaTdyYTd0NWg2eHlxMzhqWGpWMSt6MmhCK3llSW45aFBhZy9xR0ZZbHg4QmZFdHFTOWxxT216RWRNTThUZnlQOEFPZ0Q2Sm9yNXQvNFJMNHNhQ00yajZtVUgvUHJmaVFmOThsdjZVZjhBQ3dQaWZvSEdvSmRsRjYvYmRQNC83NkFIODZBUHBLaXZBckQ5b0xVbzJDNmpvbHBQanFiZVpveitSM1YxZW5mSGZ3emRGVnZiYS9zV1BVdEdKRkg0cWMvcFFJOVNvcm5OTThlK0ZOWElGbHIxazduK0I1UExiOG13YTZKV1ZsREtRVlBJSTZHZ0JhS0tLQUNxZW9hVHAyclFHSFViRzN1NHlNYlo0ZzQvV3JsRkFIbXV0ZkJEd3JxSVo3RVhHbVRIcDVEN2t6L3V0bjlDSzgrMUw0TWVMZEJuTjNvZDVIZUZPVmEybE1Fdy9BbkIvd0MrcStpNktBUG02MCtLUGp6d2pjTGFhM0M5d3E4ZVZxTUpSejlIR00vWG12UXRCK09QaHZVaXNXcHh6NlZNZXBsRytML3Z0ZW40Z1Y2UGVXTnBxTnUxdmUyME54QzNXT1pBNm44RFhuZXYvQkh3enFnYVRUVE5wVTU1SGtuZkgvM3czVDhDS0Jub2RscUZucVZzdHhZM1VOekMzU1NHUU9wL0VWWnI1c3ZmaHA0ODhGWExYdWlUUzNDTHo1Mm15RlhJL3dCcU04bi9BTWVyUzBINDU2MXBrdjJUeEZwNjNnUTRlUkY4bWRmcXA0UDZVQWZRTkZjdjRiK0lQaHJ4U0ZUVDlSUmJsdjhBbDFuL0FIY28vQTlmd3pYVVVDQ29icTB0NzYya3RycUNPZUNRWWVPVlF5c1BjR3BxS0FQRy9HSHdNdExvU1hmaGlWYldYa216bVltSnZaVzZyOURrZlN1TzBUeDk0dStIR29EU05hdHA1N1dQajdKZG5ES3ZyRkp6eCtZK2xmU3RaZXUrSGRLOFMyQnN0V3NvN21IcXU0WVpENnF3NVUvU2dDaDRYOGE2SjR3c2pMcGwwRE1xNWx0cFBsbGorcStudU1pdVcrQnYvSk5Zdit2eTQvOEFRcTgrOFcvQzdYUEJOeWRjOE8zVnhjV2tCTWdsaU8yZTNIcWNmZVgxSS9FVjMzd0pKYjRZVzdFNUp1cHovd0NQVUFjcGNhdlk2RiswbHEybzZsY0piMnNOaGxuYi9ya25BSGNuc0JXTjRxOGUrSVBpVHFvMFBRclc0anNaR3dsckg5K2NEK0tROUF2ZkhRZDgxUThlNk5jK0lQanZlYWZGTEZHOXpORGJ4czRPRnpFdkp4K05lL2VEL0JPaytETk4rejJFZSs0Y0R6N3FRRHpKVDcrZzlBT0IrdEF6bHZBUHdpMC93NEl0UjFnUjMycWpES0NNeFFIL0FHUWVyZjdSL0FDdlRhS0tCQlJSWEkrTWZpTG9uZzJJcGRTL2FMOHJtT3poSUxuMExkbEh1ZndCb0E2dVdXT0NKNVpYVkkwQlptWTRDajFKN1Y1TjR3K09HbjZiNWxwNGNqVFVMa1pCdW55SUUrbmQvd0FNRDNOZWYzdXMrTmZpM3Foc3JXSnZzYXRrMjhKS1c4UTlaR1Azajlmd0Zlb2VEZmczbzJnZVhkNnR0MVRVQnlONi91WXovc3FlcDkyL0lVRFBNdE44SitOL2loZkpxV3BUeXJhRS9MZDNlVmpVZjlNb3gxL0RBOTY5aThLZkN6dzU0Vzh1ZGJmN2Rmcno5cXVRR0lQK3l2UmY1Kzlkc0FGQUFHQUtXZ1FVVVVVQUZGRkZBQlJYSmVJdmlUNFg4TWxvN3pVVW11Vi81ZHJiOTVKK09PRi9FaXZLdGMrT3V0NmpMOW04UDZmSFpoemhIa1h6cG0raWpnZmthQVBmYmk1Z3RJR251Wm80WWxHV2trWUtvK3BOY0hyZnhsOEphVHVTQzZrMUtjZndXYWJsejd1Y0wrV2E4cnR2aDk4UXZIRXkzV3J5VHh4TnlKZFRsSXdQOW1NY2o4aFhlNko4QjlDczlzbXIzbHpxTW94bEZQa3gva1BtUDUwRE9UMWI0N2EvcUVodDlGMDIzczkzQ2xnWjVmd0hBL1ExbWp3NThVZkd4M1h2OW8rUTNQOEFwazMyZVBIKzV4LzZEWDBIcFBoM1J0Q2lFZWw2WmEyZ3hqTVVRREg2bnFmeHJUb0E4TDBuOW4yWWdOcSt0cEg2eDJjT2YvSG0vd0FLN2JUUGczNE0wNEF5YWZKZk9QNHJ1WXQvNDZNTCtsZDlSUUlvMkdpNlhwYWhkUDA2MHRRT0I1TUtwL0lWZW9vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLTVVVVUFaT29lRjlCMVZTTDdSckc0ejNrdDFKL1BHYTVQVWZndjROdnNtR3puc1dQZTJuWUQ4bXlLOUNvb0E4TjFQOW54c0Z0TDE0TjZSM2tIL0FMTXAvcFhPdDRCK0pmaFFtVFMydW1qWHZwMTNrSC9nQkkvbFgwcFJRRno1d3R2aTk0NThPemZaOVp0MG5JNEtYMXNZWC9NWS9rYTdQU1BqM290enRUVnROdTdGei9IRmlaUDB3MzZHdlZycXp0cjJFdzNWdkZQRWVxU29IVS9nYTRyV1BoQjRPMVlzNjZjYkdWdjQ3Si9ML3dESGVWL1NnWnY2TjR4OFBlSU1EUzlYdGJoei93QXN3KzEvKytUZy9wVzVYZ2VzL0FMVUlDWmRGMWFHNTI4ckhkSjViajZNdVIrZ3JEL3RING4vQUEvTzI0L3RCYlZPTVRyOXBneC92YzQvTVVBZlRGRmVKNkY4ZjRuMng2OXBMSjZ6MlRiaC93QjhNYy9rVFhwMmcrTlBEdmlWUi9aZXEyODBoNndsdGtnLzRBY0dnUnZVVVVVQUZZbXZlRU5COFRSRk5XMHlDNGJHQkxqYkl2MGNjajg2MjZLQVBDZkVud0Z1SVMxeDRiMUR6Z0RsYmE3TzFoL3V5RGo4d1ByV0JZZVBmSGZ3K3Uwc05ZaG5taFhnVytvQW5JLzJKT3AvTmhYMHJWWFVOTnNkVnRIdGRRdElicTNmckhNZ1pUK0JvR2NYNFgrTG5ocnhIc2dtbU9tM3pjZVJkRUFNZjlsK2gvUSsxZDhDRDByeHZ4VDhDTEs1RDNIaHU2K3lTSG43SmNFdkVmWU4xWDhjaXVKc3ZFL2p2NFgzaVdPb1JTbTBCd3R0ZDVlSmgvMHprSFQ4RCtGQUgwMVJYQ2VFZml0NGY4VW1PMmFYK3o5UmJqN05jc0FHUCt3M1J2cHdmYXU3b0VaWGlmOEE1RlBXZit2R2YvMFdhNFQ0RGY4QUpMYlgvcjVtL3dEUXE3dnhQL3lLZXMvOWVNLy9BS0xOY0o4QnYrU1cydjhBMTh6ZitoVUFjVHFmL0p5a1gvWVFoLzhBUksxOURkcStlZFQvQU9UbEl2OEFzSVEvK2lWcjZHN1VEQ283aTRodGJlU2U0bFNLR05TenlTTUZWUU81SjZWbGVKZkZPbGVFOUxhKzFXNEVhZEk0MTVlVnY3cWp1ZjBIZXZuN1d2RXZpcjRzNjJOTDA2M2RMSU51U3pqYjVFSDkrVnVoL0hqMEdhQkhUK09malZKTXo2WjRTM0FFN0d2eXVXYnRpSlQvQU9oSDhCM3FsNE0rRGVvYTVLTlc4VnlUMjhFcDh6N09XUG56RTkzSis3bi9BTDYrbGVnK0JQaFpwZmhGWTd5NTIzMnI0eWJobCtXSStrWVBUL2VQSjl1bGQvUU1wNlpwVmpvMWhIWmFkYXhXMXRHUGxqaVhBK3Z1ZmM4MWNvb29FRkZGSXpLaWxtSUNnWkpKNEFvQVdteVNKREcwa2pxaUtNc3pIQUE5U2E4MDhXL0dqUTlETDJ1a2dhcmVqSUpqYkVLSDNmdjlGejlSWGw1azhmZkZpNktyNXNsanU2RDl6YVIvWCs4ZisralFCNm40bitOUGg3UlM5dnB1N1ZydGVQM0RZaVUrNzkvK0FnMTVoY2VLUGlEOFNyaDdUVDB1QmFrNGFHeEJpaVgvQUg1Q2VmeFA0VjZINFgrQjJqYWFFbjEyVTZwY2pueWdDa0NuNmRXL0hqMnIxQzJ0YmV5dDB0N1dDT0dGQmhZNDFDcW85Z0tCbml2aHo0Qi9kbThSNmo3bTJzdVB6Y2orUS9HdlZ0QzhKNkY0YmkyYVRwbHZiSEdESUZ6STMxYzhuODYycUtCQlJSUlFBVVVVVUFGRlllcmVNZkRtaDVHcGExWndNT3FHVU0vL0FIeU1uOUs0alZQanY0YXRDeTJGcmZYN2pvVlFSSWZ4Ym45S0FQVTZLK2U5UStQbXUzVEdMVE5Lc3JiUFF1elRQK1hBL1NxSDl1ZkZyeEx6YmpWeEczUTI5dUxkUCsrc0QrZEE3SDBpOGlScVdkZ3FqcVdPQldOZStNUERlblorMTY3cDBSSFZXdVZ6K1FPYThKaitFbmovQUZ0OStwenBIbnFiMithUS9rTjFiTmwrejNkSEJ2ZGZnajlSYjJ4YjlXSS9sUUIzMTM4WC9CTnJ3Tlk4OCtrRUR2OEFyakZZOXg4ZWZDMFdSQmE2bk9lMklWVUg4MnFDeitBWGgrUG04MVBVcmcraXNrWS85QkovV3RxMitESGdtM3h2MDZhZkgvUGE2a09meUlvQTVlYjlvT3lYUGtlSGJwL2VTNFJmNUExblQvdEMzWC9MSHc5YnIvMTB2Q2Y1TFhwc0h3MDhGMnh6SDRjc1QvMTBRdjhBK2hFMXBRK0VmRGx2L3FkQjAxUHBhcC9oUUI0ay93QzBEcmhQN3ZTdExVZTd1MzlSVVRmSHJ4Uy8zTlAwb2ZTS1EvOEFzOWUveDZUcDBQOEFxN0MxVC9kaFVmMHF3dHZDdjNZWXg5RkZBSHpvZmpqNHdiaGJUVHMrMXM1Lzltby80WGY0ekhKdGJESHZhdjhBL0ZWOUhiVkhZZmxSZ2Vnb0ErY2g4ZGZGcW5tejB3L1dCeC83TlVxL0gzeEt2MzlOMGsvOEJrSC9BTFBYME9ZMFBWRlAxRlJ0WjJ6L0FIcmVJL1ZBYUFQQVkvMmd0WkIvZWFScHJmN3Nyci9VMWVoL2FGdU9QTzhPd3QvMXp2RC9BRlN2WjVORTBxWC9BRm1tMmIvNzF1aC9wVk9Yd2Q0Wm5KTXVnYVkyZlcxVC9DZ0R6T0w5b095UCt1OE8zU2Y3bHdqZnpBclR0L2ozNFpreDU5anFrSjcvQUxwR0g2TlhVemZEUHdYT2N2NGNzUi91SVUva1JXYmNmQnZ3UlBuYnBja1AvWEs1a0g4eWFBRzJ2eG44RlhCQWZVWm9NLzhBUGEyY2Z5QnJhdFBpRjRRdlNCQjRpMDRrOW5tQ0g4bXhYSTNQd0c4THlnL1o3elU3ZHUzNzFYSDZyL1dzVzcvWjdqSUp0UEVVZzlwN1VOK29ZVUFleVcyb1dWNE0ydDNCT1BXS1ZXL2thczVyNTF1ZmdONG10Q1pMTFVOT21JNllkNG0va2Y1MVcvNFJqNHMrSHgvb3JhcVVYL24ydlJLdi9mSmIrbEFIMG5SWHphUGlYOFNkQUlYVW81aXE5UmZhZnQvOGVBV3R2VHYyZzdvRURVZEJoazlXdFp5cC93QytXQi9uUUt4N3ZSWG0ybWZHL3dBSTNwVmJwN3V3WTlmUGdMS1B4VE5kbHBmaXJRZGFDLzJickZsY2x1aXh6THUvNzU2MEFhOUZGRkFCU0VBakJIRkxSUUJ5V3ZmRFR3cDRoTFBkYVZIRE8zL0xlMS9kUDlUamcvaURYbUd2ZkFYVWJWalA0ZjFOTGtLY3JEYy91NUI5SEhCUDVWNzVSUUI4MDIvamI0aGZEK2RMWFZVdUhnVTRFV29vWFUvN3NnNS9JbXZSL0RueHY4UGFwc2gxVkpOS3VEeHVrK2VFbi9mSFQ4UUs5S3ViVzN2TGQ3ZTVnam1oY1lhT1JReWtlNE5lYmVJL2dqNGQxWGROcFRTYVRjbm5FWHp4RSs2SHArQkZBejBpMnVyZTl0MHVMV2VPZUZ4bFpJbkRLdzlpS21yNW11dkMzeEErR2x3OTNwMGs1dFZPV21zU1pJbUgrM0dSeCtJL0d1dThML0htR1RaYitKYkx5ajArMTJnTEw5V1RxUHd6OUtCSHRkRlVkTDFqVHRiczF1OU12WUx1QnY0NG5EQWV4OUQ3R3IxQUJWYS8wK3oxU3prdEw2MWh1YmVRWWFPVkF5bjhEVm1pZ0R4VHhmOEFBcUtUZmQrRnB4RTNVMk53MlZQc2pua2ZRNStvcm1OQitKSGl2d0JmRFNOZXRwN20yaTROdGQ1RXNhK3FPZW8rdVI2RVY5SlZrZUlQRE9rZUo3QTJlcldVZHhIL0FBTWVIalBxckRrR2daaGY4Smxvbmk3d1ByTStsWFlkMXNKakpidjhzc2Z5SDd5LzFHUjcxaC9BZi9rbGxwLzE4emYraFY1NzR5K0ZPdGVEMmwxVFJaNXJ2VGxWdHp4bmJOQ2hISVlEN3k0NmtmaUJYb2Z3SS81SmRhLzlmTS8vQUtGUUk0alUvd0RrNVNML0FMQ0VQL29sYTlVOGQvRVBUZkJWanRmRnpxY3E1Z3RGYmsvN1RIK0ZmMVBhdkUvSCtxVDZKOFo5UTFTMVZHdUxXZU9TTU9NcnU4bFFNL25WN3dMOFBkVCtJR3BQNGc4UVR6LzJmSkp1ZVZ6aVM3YjBYMFh0bjhCN0F5cG92aDN4UDhXL0VENmxxRnc2V2F0dGt1Mlg1SXgvenppWG9UN2R1cE9ldjBINGM4TTZWNFYwdGJEU3JZUlI5WGM4dkszOTVqM1ArUldoWldWdHAxbERaMmNFY0Z0Q29TT0tOY0tvOUFLc1VDQ2lpaWdBb3FscXVyMkdpYWZKZmFsZHhXMXRIOTZTUTRIMEhxZlljMTRWNHY4QWpKcW12WEIwcndwRlBiUVN0c1daVnpjVEgwUUQ3djhBUDZVQWVvZU1QaVZvUGc5V2htbCsxYWpqNWJPQWdzUDk0OUVIMTU5alhpMS80aThiL0ZXL2F3c1laQlo1K2ExdGlVaFFlc2pucitQNEN1ajhIZkJHNXZHWFVQRmtyeEl4My9ZNDN6SS8vWFIrMzBIUHVLOXQwM1M3SFNMS095MDYwaHRiYU1ZV09KUW9ILzEvZWdaNWw0UitDR2xhWUk3cnhCSXVwWFE1OGhRUkFoK25WL3g0OXE5VWhnaXQ0VWhnalNLSkJoVVJRcXFQUUFkS2tvb0VGRkZGQUJSV1JybmlqUmZEZHY1MnI2akJhZ2o1VlpzdTMwVWNuOEJYay9pTDQrcU44UGgzVGNqb0xtOTRINElEL01qNlVBZTNNeXFwWmlBQU1razhDdU0xMzRxZUVkQkxSeWFtdDNPdldHekhtdG4zSStVZmlhOGFYUy9pVDhTV0Vsd2J4ck56a05jTjludHdQWmVOMzRBMTJlaGZBS3loQ1NhN3FrdHd3NndXZzh0Qi93QUNPU2Z3eFFNeWRaK1B1b3pzWXRFMG1HMkRjTEpkTVpIUDBWY0Q5VFdLTFQ0cCtPZVpQN1ROcy9QN3h2c3NPUHA4dWZ5TmU5YUw0TzhQZUhsSDlsNlJhd09QK1d1emRJZnF4eWYxcmNvQThGMG45bisra3hKcStzd3daNU1kcEdYYi92cHNEOURYY2FYOEYvQjJuZ0dlMG52M0g4VjFNU1ArK1Z3SzlDb29FWjJuYURwR2txQnAybVdkcmpwNU1LcWZ6QXpXamlpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FRcUdCQkdRZW9OWWVvK0MvRFdyQWkrME93bUovaThoUTM1akJyZG9vQTgwMVA0SGVFNzNjMXA5c3NHUFR5WnQ2ajhIei9BRHJqTlUrQUdxUWt5YVZyRnRjNDVDM0VaaWIvQUw2R1IvS3ZmcUtBUG1yN0Q4VnZCZk1YOXErUW5QN3AvdFVXUHA4MlB5RmFlay9IcldyTnhEckdsMjEzdDRab2lZWlB4QnlQNVY5QlZsYXQ0YTBUWFVLYXBwVnBkNS9pbGlCWWZSdW8vT2daeVdpL0did2pxdTFMaTZsMDZZL3czYVlYUCsrTXIrZUs3dTF2TGErdDFudExpS2VGdWtrVGhsUDRpdk1OWitBK2dYbTU5S3ZMclRwRDBVbnpvL3lQUDYxd2QzOEwvSHZoQ2RydlJacEoxWG56Tk5uS09mcWh3VCt0QUgwbFJYenRwUHhyOFVhSk9MVFhySkwzWnd3bFF3VGo5TUg4UlhwM2g3NHVlRk5lS1JOZUhUN2x1UEt2UUV5ZlovdW44NkJIZDBVMUhWMURJd1pTTWdnNUJGT29BSzRueFI4TFBEWGlmZk0xcjlodlc1KzAyb0Nrbi9hWG8zNGpQdlhiVVVBZk5XcS9EL3hyOFBieHRUMGE0bm5nVGszVmpuY0Ivd0JOSStlUCsraFhVK0V2anNqK1hhK0tMWVJuN3YyMjJVbGYrQnAxSDFHZm9LOXNyaC9GM3dyOFBlS3Q5eDVQMkRVRzUrMVd5Z2JqL3RyMGI5RDcwRE91MC9VYkxWYktPOHNMcUs1dHBCbFpZbURLZnhGV3ErWTczUWZHL3dBSjc5cjYwbWY3R1c1dWJmTHdTRDBrUTlQeC9BMTZaNE0rTStrNjRZN1BXZ21tWDdZQWN0KzRrUHN4KzZmWnZ6TkFqMUNpa0JCR1FjaWxvQXl2RS84QXlLZXMvd0RYalA4QStpelhDZkFmL2tsbHAvMTh6ZjhBb1ZkMzRuLzVGUFdmK3ZHZi93QkZtdUUrQS84QXlTeTAvd0N2bWIvMEtnRHovd0FTYWZhNnQrMEc5aGV4K2JhejNzS1Nwbkc1ZktVNDQrbGZSc01VY0VLUlF4ckhHaWhVUkJnS0IwQUhZVjgrYW4veWNwRi8yRUlmL1JLMTlEZHFCaFJSU015b2haMkNxQmtrbkFBb0VMWEQrT2ZpYnBQZzJOcmNFWG1xbGNwYVJ0OXowTG4rRWUzVStuZXVMK0lQeG0yTkxwUGhTUU0vM0pkUUF5QWVtSXZVL3dDMStXZXRaM2dUNE8zZXNTTHJIaXd6UndTSHpCYU14ODJZbm5kSWVxZytuM2ozeFFNNSswMDN4ajhYOWErMVR5a1drYllNemdyYjI0L3VvdmR2cHo2a1Y3bDRPK0gyaWVEYmNHemg4NjlaY1NYa3dCa2IySDkwZXcvSE5kTGFXbHZZV3NWcmFRUndXOFM3VWpqVUtxajBBRlRVQ0NpaWlnQW9yRjhSZUs5RjhLMmYyblZyMUlBUjhrWSthU1EraXFPVC9LdkV2RWZ4aThRK0picit6UERGck5aUnluYW5sTHZ1WmZwajd2NGMrOUFIc2ZpYngzNGY4SnhuKzA3NWZ0R01yYXhmUEszL0FBRWRQcWNDdkc5ZStNdmlUeEZjL3dCbitHN1I3SkpQbFFSTDV0eS8wNHd2NEQ4YXRlRi9naHFlcHlDKzhVWGIyaVNIYzBFYmI1My9BTjVqa0wrcCtsZXphQjRWMFR3eGJlUnBHbnhXd0krWndNdS8rOHg1TkF6eERRdmd0NGoxNmY3ZjRpdkRZcklkeitZM25YRC9BRjV3UHhKK2xlcytIUGhyNFg4TTdaTFhUbG51bC81ZWJyOTVKK0dlRi9BQ3V1b29FRkZGRkFCUlJSUUFVVVpyQzFUeHA0YTBiSTFEVzdHRmgvQjVvWnYrK1JrMEFidEZlWTZsOGRQQ3RwdVd6anZyNWgwTWNPeFQrTGtIOUs1UFVQMmc3MWlScCtoVzBQb2JtY3VmeVVEK2RBSHZWRmZOdi9DenZpUnJaMjZkSElBM1FXV25sdjFJYWoreXZpL3JRUG1OcmlxM1VTWElnSDVaSDhxQjJQcEJuUkZMT3dWUjFMSEFxaFA0ZzBhMXo5bzFhd2l4L3dBOUxsRi9tYThBaitEUGpuVVczWHR4YW9UMU54ZXRJZjBCclFnL1o4MVpqbTQxclQ0Lyt1Y0R2L1BGQUhyay93QVFQQ052bnpQRW1tY2YzYmhXL2xWR1Q0cmVCNHp6NGh0ai91STdmeVd1RWcvWjdqQS9mK0pKTStrZG9CL05xdXhmcy9hU1A5YnJtb1AvQUxxSXY5RFFCMHIvQUJpOEVKMDFabS8zYmVRLzBxSS9HZndTRC95RVp6OUxXVC9Dc2xQZ0g0YUgzOVIxWnY4QXRwR1AvWkttSHdHOEpnYzNPcW4vQUxlRi93RGlLQU5EL2hkSGdyL29JVC8rQXNuK0ZPSHhtOEVuL21KU2o2MnNuK0ZaMy9DaC9DWC9BRDhhci80RUwvOEFFMHh2Z0w0VlAzYnpWVi83YklmL0FHU2dEYWorTDNnZCt1dHFuKzlCSVA4QTJXck1meFI4RXkvZDhSV1kvd0IvY3Y4QU1WeXIvQUh3OGZ1YXJxcS9Wb3ovQU95VlVrL1o5MDQvNnZYNzFmOEFlaFEvNFVBZWh3K08vQ2R4L3EvRWVsbjYzU2orWnJSaDE3U0xuSGthcll5NS91WENOL0kxNC9QK3oxeCs1OFNFL3dEWFN6SDlHck9tL1o4MWRUKzQxblRwUCt1a0xwL0xOQUh2NlNKSXU1R0RMNnFjMDZ2bkNUNEsrTnJFN3JTNXMzSTZlVGVQR2YxVVV6L2hHL2k1cEFQa1ByQlVmODhiOFNqOGkzOUtBUHBLaXZtMy9oTXZpdm9uRjJtcGJSL3o5YWNISDVoZjYxYXRQajE0anRXMlgrbTZmUGpydzhMZnpQOEFLZ1ZqNklvcnh1eC9hQjA1eW8xRFFydUVkMmdsV1Fma2R0ZFRwM3hoOEYzNEFiVkd0SFA4TjFDeWZyZ2o5YUFPN29xallhMXBlcXFHMC9VYlM2QjUvY3pLL3dESTFlb0FLS0tLQUNpaWlnQW9vb29BenRYMERTZGV0ekJxdW4yMTNIakE4Mk1FajZIcVB3cnkvd0FRL0FYVGJrUExvRjlKWlNIL0FKWVhHWllqN0EvZUg2MTdEUlFCOHlOYi9FWDRYeUZrTnpIWXFlU243KzFZZTQvaC93REhUWGRlR2ZqeHA5M3NnOFEyYldVaDQrMDIrWklqN2tmZVg5YTlnS2hnUVFDRHdRZTljRjRuK0VYaG54RHZtaGdPbTNyYytkYUFCU2Y5cFB1bjlENzBETzAwL1U3SFZyUkx2VDd1RzZ0Mys3SkM0WmZ6RldxK2FOUjhFZU9maHZlTnFPa3pUUzI2OHRjMk9TQ1ArbWtaN2ZVRWU5ZGQ0VCtPMEUzbDJ2aWUyRUxIajdiYktTaDkyVHFQcU0vUVVDUGFhS3JXR29XZXFXY2QzWVhVVnpieURLeXhPR1UvaUtzMEFOZEVsUmtrVU1qRERLd3lDUFExNVA0MCtDZW42b0pMM3c0WTdDOE9TMXMzK29rUHQvY1AwNDlxOWFvb0ErYWRBOGRlS3ZocHFYOWo2emF6UzJjWjVzN2cvTWkrc1QrbjVyOUs5NjhNK0xkSDhXNmY5cjBxNkVtM0htUXR4SkVmUmw3ZlhvZTFTK0l2REdrK0tkT05scTFvczBmSlIranhuMVZ1b05lQStKZkFmaVQ0YWFrTmIwVzdtbHNvemxidUVZZUlmM1pWNlk5L3VudmlnWjlBZUovK1JUMW4vcnhuL3dEUlpyaFBnUDhBOGtzdFArdm1iLzBLczdSZmkxWmVKL0NtcWFacXdqc3RYTmpNcWM0aXVENVorNlQwYi9aUDRaclIrQS8vQUNTeTAvNitadjhBMEtnUnhPcC84bktSZjloQ0gvMFN0ZlEzYXZublUvOEFrNVNML3NJUS93RG9sYTkyMW5XckR3L3BVMnBhbGNMQmJRakxNZXBQWUFkeWV3b0dUMzkvYWFYWXpYdDljUjI5dEN1NlNXUTRDaXZubnhyOFJ0WDhmYWlOQThPd1hDMkVyN0ZpakdKYnIzYjBYdmo4VDZDbnIvaVB4RDhXL0VzV2w2YmJ1bG1yYm9iWGRoVUEvd0NXc3A2Wi9sMEdUMTlzOEMvRC9UZkJOaGlJQzQxR1ZjWEYyeTh0L3NyL0FIVjl1L2VnREIrSG53bXMvRElpMVBWeEhkNnZ3eURySGJIL0FHZlZ2OXI4dld2VGFLS0JCUlJYTStML0FCMW8zZ3l6ODNVSnQ5eTRKaHRJc0dTVDhPdzl6eFFCMFZ4Y1EydHZKUGNTcEZER3BaNUpHQ3FvOVNUMHJ4bnhyOGNJNGZNc2ZDcXJLLzNXdjVWK1FmN2luNzMxUEhzYTQyLzFqeGo4WGRZK3hXc0xDMFJzL1pvMkt3UWpzMGpkejlmd0ZldGVDZmhOby9oYnk3eThDNmpxZzU4NlJma2lQK3dwNmZVOC9TZ1o1bDRjK0YzaWJ4dmVmMnY0aHViaTB0NXZtYWE1eTA4by93QmxUOTBmWEE5Qlh1UGhyd2RvZmhPMThuU3JKSTNJeEpPM3pTeWY3ekhuOE9udFc5UlFJS0tLS0FDaWl1WThTZkVIdzM0VzNKcU9vb2JrZjh1MEg3eVUvd0RBUjAvSEZBSFQxRGMzZHZaVzdUM1U4VUVLOHRKSzRWUitKcndYWHZqcnJPb1NtMThPNmVsb0hPRWtsWHpwbStpajVSLzQ5V1hhL0R2NGdlTjUxdTlZa21pamJrUzZuS2NnZjdNWTVINUNnZGoxSFcvalA0UzBuY2x0Y1M2bE9PTnRvbVZ6L3ZuQS9MTmVlNnI4ZGZFT295bTMwWFRiZXozSEM1Qm5sL0FjRDlEWFg2SDhDTkFzdHNtclhWenFVZzVLWjhtUDhoeWZ6cjBUU3ZEMmo2SEVJOUwweTF0RjZmdVlncFAxUFUwQWZQbi9BQWovQU1VL0dmelhuOXBlUS9QK2x6Zlo0OGY3bkgvb05idWwvcy9YYlliVmRjaGl6eVV0SVM1Lzc2Ykg4cTk0b29GYzg1MDM0SitEN0hCdUlMcS9ZZjhBUHhPUVB5WEFyck5QOEllSGRLQUZqb2xoQVIwWmJkZDM1a1pyYW9vQVFBQVlBd0IyRkxSUlFBVVVVVUFGRkZGQUJSUlJrZXRBQlJSUlFBVVVVVUFGRkdSNjBVQUZGRkZBQlZTNzB1d3Z4aThzcmE0SHBORXIvd0F4VnVpZ0RrTDc0WGVDOVEzR1hRYmFOai9GYjdvai93Q09rVnl1b2ZBUFFKOG13MUsvczJQUU1WbFVmbUFmMXIxbWlnRDU1MUQ0RGVJYkpqTnBlcDJWMFZQR2QwRW41OGo5YW9iL0FJc2VEdVQvQUd2NUNldUx1TEgvQUk5ajlLK2xhS0IzUG4vU3ZqNXE5czRpMWZTYmE2MjhNMERHRi94QnlQNVYzdWovQUJvOEk2cHRTNHVadE9sUFZidVBDNS8zMXlQenhYVzZyNFkwUFhFSzZucE5uZFovaWtpQllmUnVvL091QjFuNEVlSGIzYyttWFYzcDBoNkx1ODJQOG01L1dnRDB5enY3VFViY1QyVjFEY3ducEpDNGRUK0lxeFh6ZmVmQ2Z4ejRXdURkNkpPYmpieUpOUG5NVW40b2NaK21UVW1tL0dMeGg0ZHVSWjY3YUM4MmNNbDFFWUpoK0lIUDRnMEFmUmxGZWUrSC9qSjRWMW9wRmMzRDZaY3R4c3V4aENmWng4djU0cnY0cFk1b2xraWtWNDJHVlpUa0VleG9FUG9vb29BS0tLS0FDdUY4Vy9Dbnc5NG8zM0NRL3dCbjZnM1AybTJVRGNmOXRPamZYZys5ZDFSUUI4eDNtaWVPUGhQZnRlMmtzZ3NpM3pYRUdYdDVCNlNJZnVuNi9nYTlPOEdmR2JTZGVNZG5ySVRUTlFiQ2htYjl6S2ZaajkwK3pmbWE5TWtqU1dObzVFVjBZWVpXR1FSNkVWNUw0MStDZGhxWWx2ZkRaanNiczVMV3JmNmlRKzM5dy9wN0NnWjYyQ0NNZzB0Zk5maDN4LzRvK0hHby93Qmk2NWF6eldrUncxcGNINTQxOVluNkVlM0srbUs5ODhPZUtOSjhWYWNMM1NicFpVSERvZUhqUG95OVFmOEFJb0ViRk5kRmtSa2RReXNNRUVaQkZPb29BOE8rSlh3Z2hodDduWFBEYUxFa2FtVzRzZWlnRGt0SDZldTNwNmVsZEY4Q1ArU1hXdjhBMTh6L0FQb1ZkMTRuL3dDUlQxbi9BSzhaL3dEMFdhNFQ0RC84a3R0Zit2bWIvd0JDb0E4LzhTNmpiYVIrMERMcU40K3kydHJ1S1NSc1p3QkN2YXFXcTZyNGgrTUhpK0t5c28yanRFSk1NREg5M2J4OURKSVIxYi85UXBueEIweTQxbjR5NmhwbG9GTnhkWEVVVWU0NEdURW5VK2xlK2VDL0IxaDRNMFJiSzBBZWQ4TmMzQkdHbWYxOWdPdzdmblFNZDRPOEc2WjRNMGhiT3hUZk0rRGNYTGo1NW05VDZEMEhhdWlvb29FRkZNbGxqaGllV1YxU05BV1oyT0FvSFVrOWhYZ3Z4QitMVnpyVXphRjRVYVVXOGplVTkxRUQ1bHdUeHRqQTVDbjE2bnRnZFFEcC9pRjhZTFhRVExwZWdORmRha01ySk9mbWl0ei9BT3pON2RCMzlLNGZ3ZjhBRFBXL0hWNmRkOFJYRnhEWlROdmFXVS92N24vZHo5MWZmOGhYVmZEdjRPUldJaDFieFBFa3QxdzBOaWVVaTlDL1ptOXVnOSszc2dBQXdLQmxEUjlGMDdRTk9qc05NdEk3YTJqNklnNm4xSjZrKzU1cS9SUlFJS0tLd2ZFM2pIUlBDVnA1K3EzYW83RE1jQ2ZOTEovdXIvVThlOUFHOVhGK0xQaWY0ZDhLYjRKYmo3WGZqL2wwdGlHWUgvYVBSZng1OXE4ajEvNG5lS3ZITjZkSjhQMjF4YTI4dkFndE10UElQVm5IM1I5TUQxSnJmOEpmQWt0c3UvRk56MStiN0ZiUC93Q2h5ZjBYODZCbk82bjhSUEcvajY4YlRkRWdtdDRYNCt6MkFKZkgrM0oxQS83NUZibmhyNERYTTVXNDhTMy9BSkliNWpiV2gzT2Y5NlE4ZmtEOWE5cTB2UjlPMFN5V3oweXpodGJkZWlSSUZCOXo2bjNOWGFBTVRRZkNHZytHWWdtazZaQkEyTUdYRzZSdnE1NU5iZEZGQWdvb29vQUtLaHVidTJzb1ROZFhFVUVRNnZLNFZSK0pyaU5ZK01QZy9TZHl4MzczOG95TmxuR1hHZjhBZU9GL1dnRHZhSzhHMWI5b0M4a3lta2FMREFEd0pMdVV1ZjhBdmxjRDlUV0ovd0FKSjhWZkZ2OEF4NS8ybUltNEgyTzM4aEIvd1BBL25RT3g5SHozTUZySDVseE5IQ2cvaWtZS1B6TmMzcUh4SDhINllTTGp4QlpGaC9EREo1cC9KYzE0emIvQnJ4dHJUK2RxbHpid2x1UzE1ZE5NL3dDUXovT3VrMC85bjJCUXAxRFg1VzlVdHJjS1B6WW4rVkFHOWVmSFR3bGI3aGJycUYydzZlWGI3UWZ4WWlzRzcvYUVnVUg3SjRkbGIwYWU2Qy9vRk5kTFpmQkh3YmFrR2FDOHV5T3ZuM0pBUDRMaXQrMCtIWGcreElNSGgyd3lPOGtXOC84QWoyYUFQSDUvai9yOHVWdHRNMHlMUFRjWGtQOEFNVlYvNFcxOFE3NC82SkNvejA4alRtZitlYStoYmZTdE9zd0JiV0ZyQUIwRVVLci9BQ0ZXOEFVQWZPSC9BQWsveGV2K1k0OVl3ZjhBbm5weXFQOEEwQ200K01kMTM4UUQ4VmovQU1LK2txTUQwb0ErYnY3QStNRS9MTnJYL0FyNVIvN1BTandqOFhYNnlhcng2Nm1vL3dEWjYra01VVUJjK2J6NFErTGk4K1pxbjRhb3YveGRKL3dqdnhmaDVEYXp4L2R2MVA4QTdQWDBqUmlnTG56YVkvakhhODU4UUhIKzBzbitOTC93azN4ZTA4WmxqMWpBL3dDZXVuSzQvd0RRSytrY0Qwb29BK2JSOFhmaURZSC9BRXlHTnNkZnRHbnNuOHNWZXR2MmdkYWpJRjFwR25TNDYrWEk4WlA2bXZvTWdFWUl5UGVxTjFvZWszd0l1OU1zNTgvODlZRmIrWW9BOHBzLzJndFBmSDIzUUx1TDFNTXl5RDlkdGRIWS9HcndaZUVDUzh1YlFuL240dDJBSDRya1ZxWG53djhBQmQ3bnpQRDlxaFA4VU82SS93RGpwRmM1ZmZBand2Y0FtMHVkUnMzN2JaUklvL0JobjlhQU81MDd4WjRlMWNEN0JyVmhjRTlGU2RkMzVaeld4a1Y0SHFYN1B1b0lTMm02M2F6NDZMY3dtTS9tTS95ckdQaFQ0cGVFU1RZSFVURXYvUGpjK2NoLzRCLzlqUUI5SzBWODUyUHhxOFg2Tk9JTlpzNExvamhrdUlUYnlmbU9QL0hhN25SdmpyNGN2aXNlcDI5M3BzaDZzeStiR1B4WG45S0JXUFU2S3p0SzE3U2RjZ0UybDZqYlhhWXptR1FNUjlSMUg0MW8wQUZVZFQwZlRkWnRqYjZsWTI5M0VmNFpvdzJQcG5wK0ZYcUtBUEpmRVB3STBhOUR5NkhkeTZkTWVSRkptV0kvbjh3L00vU3ZQNWRHK0lud3hsYWUxYTRXelU1TWxzZk90MkgrMGhIeS9pQjlhK21xQ00wQWVNZUdQanphemhJUEVka2Jkang5cXRRWGpQdVU2ajhNMTYxcG1yNmZyVm10M3B0NUJkMjdkSklYREQ2SDBQc2E1VHhQOEtmRFBpWGZOOWwrd1hyYy9hTFFCY24vQUdsKzYzOC9ldkl0VThCZU52aDNlTnFlajNFMDBDOG02c2M1Mi84QVRTUG5qL3ZvVURQcFdpdkZmQ1B4MWlsOHUwOFVXNGlZOGZiYmRTVVB1NmRSOVJuNkN2WXJHL3ROU3RJN3V4dVlyaTNrR1VsaWNNcC9FVUNMRkZGRkFCUlJSUUJpK0pQQ21rZUs5UE5ucXRxc29ITWNxOFNSSDFWdTM4ajNyd0h4QjRQOFQvQ3pWbDFqU3JxVjdKV3dsNUVPZ3o5eVplbVAwUHNhK21LWkxGSFBFOFVzYXlSdUNySTR5R0I2Z2c5UlFCd0hnRDRwNmY0dVZMRzlDV1dzQWY2a241SnZlTW4vQU5CUEk5NjlDcndmNGhmQitYVDJmV3ZDaU9Za1BtU1dLRTc0c2M3b3U1QS91OVIyOUswZmh0OFgvdFRRNko0bm1DM0J3a0YrL0FrUFpaUFJ2OXJ2M3dlb005UzhULzhBSXA2ei93QmVNLzhBNkxOY0o4QnYrU1cydi9Yek4vNkZYZCtKL3dEa1U5Wi82OFovL1JacmhQZ04vd0FrdHRmK3ZtYi9BTkNvRWNUcWYvSnlrWC9ZUWgvOUVyWDBOMnI1NTFQL0FKT1VpLzdDRVA4QTZKV3ZvYnRRTUtodTd1M3NMU1c3dTVraHQ0Vkx5U1NOaFZBNmttaTZ1b0xHMGx1cnFaSVlJbEx5U09jS3FqcVNhK2N2R3ZqWFZmaVhyME9nNkZES2RQTXVJSUJ3MXd3LzVhUDZLT29CNkRrODlBUS94ejhRTlUrSU9xcDRmOFBRei8yZkkreElVR0h1ejZ0Nkwzd2ZxZmIwNzRkZkRDejhJd0pmM3dTNjFwMTVsNnJBRDFWUDZ0MVBzS3UvRC80ZVdQZ3JUdDdiTGpWWmxIMmk1eDAvMkU5Rkg2OVQ2RHRhQUNpaWlnQXByeUpGRzBrakJVVUVzekhBQTlTYXpkZjhRNlo0WjB1VFVOVnVWaGdYZ0RxenQvZFVkU2Zhdm56eEg0MThTL0ZEVmwwWFI3V2FPeWMvSlp4SGx4bjcwcmRNZTMzUjdtZ0RzZkhQeHRndERKcC9oWXBQTVBsZS9jWmpUL2NIOFI5eng5YTVqd3Y4TGZFUGpXOC90bnhIYzNGcmJURU0wcy96WEU0OWdmdWozUDRDdlF2QW53aTAzdzJJci9WdkwxRFZSOHd5TXhRSC9aQjZuL2FQNEFWNlhRTXgvRC9oZlIvQzlpTFRTYktPQkQ5OStyeUgxWmp5YTJLS0tCQlJSVUY1ZTJ1bjJyM1Y1Y1JXOEVZeThrcmhWWDZrMEFUMDEzV05HZDJDcW95U1RnQVY1SDRvK08ybVdXKzM4UFd4djVoeDlvbXlrSTl3UHZOK2c5NjRKYmY0aWZGR1RlNXVKTEZqMWMrUmFyOUIvRi80OGFBUFh2RVB4ZThLYUZ2aWl1enFOMHZIbFdZM2dIM2Y3by9NMTVucXZ4bzhWNjljZlk5QXNrc3k1d3F3Um00blA0NHdQd1g4YTZydzk4QnRMdFFrMnZYMGw5SU9UQkJtS0llMmZ2SDlLOVAwclF0SzBPM0VHbDZmYldrZnBER0Z6OVQxUDQwRFBuMjErR0hqN3hmT3R6clVza0N0ejVtcFRsbUgwUVpJK25GZHhvL3dGMFMxMnZxMm9YVis0Nm9uN2xQMHkzNjE2MVJRSzVoYVQ0TThONkhqK3p0RnM0R0hTVHl3ei84QWZUWlA2MXU0b29vQUtLTTFRdnRjMHJURkxYK3BXZHFCL3dBOXAxVCtab0F2MFZ4Rjc4Vy9CTmxrSFdVbllmdzI4VHlmcUJpc0M3K1BmaHlMSXRkUDFPNFB1aVJqOVd6K2xBSHExRmVHM1g3UWpBRVczaDBEME0xMy9RTC9BRnJLbS9hQTErVElnMHZTNC9UY3p1ZjVpZ0xIMFBSWHplM3hwOGIzSCtvdHJNZjljN0oyL3dEWmpTZjhMUitKVXZNY1RqL2Mwcy8xRkE3SDBqUlh6TGQvRlg0aTJXdzNkeTFzSHp0ODNUMFRkanJqSzg5YW5qK0pIeFFlSkprKzB2RTRCVnhwWUtzRDBJSVhtZ0xIMG5SWHpkL3d0RDRsUmY2eUp6L3Y2V2Y2QVVvK05QamUzLzE5dFpuL0FLNldUci83TUtBc2ZTRkZmUE1QN1FHdlI0RStsNlhKanJ0WjBQOEFNMXEydjdRaElBdWZEdWZVdzNlZjBLLzFvRlk5eG9yeXEwK1BmaHFYQXVySFU3WnYrdWF5RDlHeitsZEJaZkZud1ZmWUM2M0hDeC9odUkzai9tTVVBZHJSVkt5MWpUTlRVTllhaGEzUVBlQ1pYL2thdTBBRkZGRkFGVysweXgxT0h5Yit6dDdxTCs1UEdISDYxd210ZkJYd2xxZ1pyU0NiVEpqL0FCV3IvTG4vQUhHeVB5eFhvdEZBSHp2cTN3VDhUNkxQOXIwRytqdlNoeXBpYzI4NC9YSDVOVmF4K0tIanJ3ZGRMWjY1QkpjcXZIbGFqRVVreC9zeURyOWZtcjZScXJmNmJaYXBiTmJYOXBCZFFOMWptakRyK1JvR2NKNGMrTTNoald5a041SStsWFRjYkxyL0FGWlB0SU9QenhYb2NjaVRSckpHNnVqREtzcHlDUFkxNVQ0aytCV2pYNGViUTdpVFRaenlJV3pKQ2ZiQitaZndKK2xlZHRCOFFmaFZQdlV6UjJBYnFwODYwZjZqK0gveDAwQWZUbEZlVStGUGpmcEdxYkxiWFlocGwwZVBPQkxRTWZyMVg4ZVBldlU0cG81NGtsaGtXU054bFhRZ2hoNmdqclFJZlJSUlFCd25pLzRVNkI0cDh5NGpqL3MvVVc1KzAyNmdCei90cDBiNjhIM3J4MjQwL3dBYi9DUFVqY1F5TUxKbTVsank5dE43T3Y4QUNmcmcraHI2ZHFPZUNHNWdlQ2VKSlluRzEwZFF5c1BRZzlhQVBQOEF3VDhXOUg4VUdPeXZ0dW5hbzNBaWtiOTNLZjhBWVk5LzlrOC9XdlJLOFY4Y2ZCR0tVU2FoNFV4Rko5NXRQZHZrYi9ybXgrNmZZOGU0ckI4SGZGaldQQ2QzL1l2aWlHNXVMV0Z2TFl5Zy9hTGIyT2Z2RDJQUG9UMG9HZlJGRlU5TDFXeDFuVDRyL1RycU81dFpSbEpJemtIL0FBUHNhdVVDQ2lpaWdBcnlQNG5mQ2VQV0VtMXZ3L0NxYWp5MDlxb3d0ejZrZWovbzMxcjF5aWdENTI4SS9FK2EzOE9hbDRZOFF5T1FiT2FHMHVaYzdvMjJFQ0o4ODllQVQwNkd1NStBL3dEeVMyMS82K1p2L1Fxby9GejRiUmFsYTNIaVhTSTFTK2hReVhjSTRFNkFjdVA5c0Q4eDcxZStCSC9KTHJiL0FLK3Avd0QwS2dEaWRULzVPVWkvN0NFUC9vbGEraEhkWTR5N3NGVlJrc1RnQWV0ZlBlcC84bktSZjloQ0gvMFN0YVh4aStJVFhFc25oUFJwQ1Z6c3ZwWStTN2Y4OFZ4K3Y1ZXRBekcrSXZqdTg4ZDYxSDRjOFBMSkxwL21oRVdNYzNjbnIvdUR0K1o3WTlYK0hmdyt0ZkJXbDc1UWsyclhDajdSY0FkUDloUFJSK3A1OU1abndyK0hTK0Z0UEdxYWxFRHJOeW5JUFAyZEQvQVA5bzl6K0hibjBtZ1FVVVVVQUZjdDQyOGQ2WjRLMDd6YnB2T3ZKUWZzOW9oK2FRK3A5RjlUL00xVCtJUHhEc3ZCT243RkMzR3F6S2ZJdHM5UDl0L1JmMVBRZW84ZThJK0ROYStKK3V5NjVyZHpNTEJwUDMxMGVHbEkvd0NXY1k2QURwbm9QclFCQllhYjRwK01QaVZycTVsMldzUjJ2T1ZJaHRsL3VJdmR2YnFlcE5lLytGdkNPaytFTk1GbnBrR0MyRExPL01rcmVySCtuUVZwNlpwZGxvMm5RMkduMnlXOXJDdTFJMEhBL3dBVDc5NnQwQUZGRkZBQlRaSkVpamFTUmxSRkdXWmpnQWVwTmMxNHY4ZWFMNE50ZDkvUDVsMDR6RmFSRUdSL2ZIOEk5enhYaG1wZUkvR1h4WTFSdE9zWUhXeXpuN0pBU0lveDJNcjkvd0Fmd0ZBSG9makQ0MjZYcFBtV21nSW1wWGE1Qm5KeEFoK3ZWL3c0OTY4N3ROQjhkL0ZXOFc5dkpaRFo1K1c0dWN4d0lQOEFwbWc2L2dQcWE5TDhIZkJmU05FRWQzclpUVkw4WUlSaCs0alBzcCs5OVcvSVY2ZXFoRkNxQUFCZ0FkcUJubnZoYjRQZUhQRC9BSmM5M0gvYWw2dlBtWEtqWXAvMlkrbjU1TmVoS3Fvb1ZRQUFNQUR0UzBVQ0NpbXlTSkZHMGtqcWlLTXN6SEFBOXpYbjNpUDR5ZUdOREx3MmtyYXJkTHhzdE1iQWZlUThmbG1nRDBPcU9wNjFwbWpRR2JVOVF0clNQR2N6eWhNL1RQV3ZuMi8rS25qanhkZE5aNkZidmJLM0FpMCtJeVM0OTNJNCtveFV1bC9CYnhYcjA0dk5kdlk3TXVjczF4SVo1eitHY0Q4V29HZDdySHh6OE1XQlpOUGp1OVNrSFF4SjVhZjk5Tmo5QWE0VFVQam40bjFLWXc2UllXdG9XUHloVWE0bC93QVAwcjBEUnZnajRVMDRLOTZseHFjbzZtNGsycG4vQUhWeCt1YTd2VHRHMHpTSVJGcDFoYldpQVl4REVFL2xRQjg4ZjJYOFdQRjJUTi9hM2xQMTgrVVdzZVA5MzVmNVZvV1B3RDE2NVlTYWpxbGpiRTlkZ2FaL3o0SDYxOUMwVUJjOGlzdmdCb2tXRGZhdnFGeWU0akNSRCtSUDYxMEZwOEhQQk5xQnUwdDdnanZQY08zNlpBcnZhS0JIUFduZ1R3cFpBZVI0ZDB4Y2R6Ykt4L01nMXJRNlZwMXNNUVdGckYvMXpoVmY1Q3JkRkFEVlJWR0ZVQWV3eFRzVVVVQWVHL3REZmU4UC9TNC85cDE2cDRKLzVFWFFmK3dmQi82QUs4ci9BR2h2ditIL0FLWEgvdE92VlBCUC9JaTZELzJENFA4QTBBVURON0ZJeUt3d3dCSHVNMHRGQWlwTnBXbjNJeFBZMnN2L0FGMGhWdjVpc203OENlRkwwSHovQUE3cGpaN2kyVlQrWUFyb2FLQU9DdlBnMzRLdWdkdW1TVzVQZUM0ZGYwSklybnI3NEFhTkxrMk9zMzl2NkNWVWxIOGdmMXIxNmlnRDU0dnZnTDRpdEdNdW02bFkzSkhUSmFGL3o1SDYxUyt6ZkZud2Z5bjlyK1NuOXhoZHg0K256WS9TdnBTaWdkejU2MHo0NytJTEdVUTZ4cHRyZDdUODIwTkJKK1hJL1N1OTBmNDIrRk5TMnBlUGNhYktldjJtUEtmOTlMa2ZuaXUzMVRRTkkxcUl4Nm5wdHJkcWYrZTBRWWo2SHFLNEhXdmdaNFp2d3o2YkpkYVpLZWdqZnpJeC93QUJibjhpS0FQUmJIVXJIVTdjVDJGNUJkUW4rT0NRT1B6RldxK2NMLzRTZU5mQzF3YjNRN2o3VnM1RWxoS1lwZnhVa1ovQW1wZEorTW5penc3ZEN5OFFXZjIwSnd5WEVaZ25INDR3ZnhINDBBZlJWRmNSNGIrSzNoZnhHVWhGNTlodTI0K3ozbUVKUCt5MzNUK2VmYXUyQkJHUWNnMENGcHJ4cElqSTZxeU1NTXJESUk5NmRSUUI1ajR0K0MyaDYzNWx6cEJHbFhweWNScm1GejdwL0Q5Vng5RFhtTU41NDUrRWVvQ0dWV1d5ZHVJM3pKYXpmN3AvaFAwd2ZVVjlPVlh2YkcxMUcwa3RMMjNpdUxlVWJYamxVTXJEM0JvQTQvd1g4VU5FOFhoTGJkOWgxTWptMG1ZZk9mOEFZYm8zMDYrMWR4WGhmalg0SXlRRjlSOEpzekJUdk5nNy9Ndi9BRnpZL3dBaitCN1ZUOEYvR0xVZER1QnBIaXhKNTRJMjh2N1E2bno0RDZPT3JBZjk5ZldnWjlBVVZYc2IrMDFPeWl2TEc0anVMYVZkeVN4dHVWaDlhc1VDQ3VVOForQU5IOGFXbUx1UHliMUZ4RGVSQWIwOWovZVgyUDRZcnE2S0FQbUZYOFcvQnp4RnRZYnJXWnVuSnQ3dFI2ZjNXL1VlNHIzdndmNDEwbnhucHYybXdrS1RvQjU5cklSNWtSOS9VZWhIQi9TdFRXZEYwL1g5TWwwN1U3WkxpMmxIekkzWTlpRDFCSHFLK2QvRlBnN1h2aGJyc1d0YU5jeXRZaC8zTjJveVV6L3l6bEhRZzlQUSt4b0dmUzlGY1Q4UC9pTFllTmJMeW1DMjJyUkxtZTJ6MS8yMDlWL1VkL1U5dFFJS0tLS0FNcnhQL3dBaW5yUC9BRjR6L3dEb3Mxd253Ry81SmJhLzlmTTMvb1ZkMzRuL0FPUlQxbi9yeG4vOUZtdUUrQTMvQUNTMjEvNitadjhBMEtnRHl6NGozOXpwWHhmMVMrczVQTHVZSlkyamZHZHJlU296K3RkZjhHUEFKdVpGOFdhdEdXVU1UWXh5YzdtN3luUFhuT1BmSjlLd1BGZWx3YTM4ZkpkTXVpMzJlNXZZWTVOcHdTdmxLU1B4eGo4YStqNElJcmEzamdnaldPS05RaUlvd0ZVREFBb0dTVVVVVUNDdU4rSVhqNjA4RTZUa2JKOVRuQkZ0YlovOGZiMFVmcWVCN2FIalB4ZFkrRGRCazFDN0llVS9KYjI0T0dtZnNCN2R5ZXdyd2p3bjRhMWI0cmVMYmpWdFltayt3cklEZFRqalBwREg2Y2ZrT2Vwb0FtOEQrQ05UK0pHdVRhOXIwMHphZVpjelRzY05jTVA0RTlGSFFrZE9nNTZmUnRwYVc5aGFSV3RyQ2tOdkVvU09OQmhWQTZBQ2tzcksyMDZ6aHM3U0ZJYmVGQWtjYURDcUIyRlQwQUZGRlEzZDNiMkZwTGRYY3lRMjhTbDVKSkd3cWdkeWFBSmlRQmsxNC84QUVENHpRYWFaZEw4TXZIY1hZeXNsN3cwY1I3aGV6dDc5QjcxeS9qdjRuNmw0eHZmN0E4TVIzQzJNemVXUEtVK2RkbjB4MVZmYnFlK0J4WFkvRDM0UDJ1aGlMVlBFQ1IzV3BERFIyLzNvcmMveVp2Zm9PM3JRTTQzd2Y4S3RaOFlYWDl0K0pwN20zdFptOHdtVW43UmMrL1AzVjl6ejZEdlh2V2thTHAyZzZmSFlhWGFSVzFzblJJeDFQcVQxSjl6elYraWdRVVVWeFhqUDRtNkg0UFY3ZG4rMmFuajViU0ZobGY4QWZib28vWDJvQTdLV1dPQ0pwWlhWSTBHNW1ZNENqMUo3VjVkNHMrTjJqNlNYdHREakdxWFE0TXVTc0NuL0FIdXJmaHg3MTQ5NHM4ZGVJdkdCTW1vVFBIWUY5cVcwSUt3Z2puQi92TjlmMHIwdjRUL0RUUnIzdy9hK0lkWXRmdGM4N00wRU1wekVxQnNBbGU1T0NlY2pweFFNNDBKOFFmaXJQa21hU3dMZFQrNXRFLzhBaXY4QXg0MTZGNGIrQk9qMklTYlhibDlTbUhKaFRNY0kvTDVtL0VqNlY2eEhHa1VhcEdpb2lqQ3Fvd0FQWVU2Z1JVMC9UTEhTYlZiYlQ3T0MxZ1hwSERHRUg2VmJvb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdEdzM5b2I3L2gvNlhIL0FMVHIxVHdUL3dBaUxvUC9BR0Q0UC9RQlhsZjdRMzMvQUEvOUxqLzJuWHFuZ24va1JkQi83QjhIL29Bb0diMUZGRkFnb29vb0FLS0tLQUNpaWlnQW9vb29BS3p0WDBIU3RldGpiNnJwOXZkeGRoS2dKWDZIcVB3clJvb0E4WThTL0FXMG5EeitIYjQyNzlmc3QwUzhaOWcvM2grT2E0eTIxL3gvOExycExXOVNZV1lPRmd1OHl3T1A5aHdlUHdQNFY5TlZCZDJkdGYyejIxM2J4VHdPTU5IS2daVytvTkFIQitFdmkvNGY4Um1PMnZHL3N1L2JnUlhERFk1LzJYNmZnY0d2UTg1cjVZK0svaGUxOExlTVhnc0lCRFlYTUN6eFJna2hlb1lEUGJJemozcTc0ZjhBSC9pejRmWEVOanFVTXR6WU1pdWx0ZEU4eG5rTkZKenhqNmo2VURzZlRWRmM1NFU4Y2FKNHd0Zk0wMjV4T296TGF5L0xMSDlSM0h1TWl1am9FRmNiNDMrSEdrZU03ZHBKRkZycWFyaU84alg1dllPUDRsL1VkalhaVVVBZk1WbHFYaXo0UGVJVGEzTVJlMGtiYzBCWW1DNVgrOGpkbTkrbzdpdm9Ed3I0dTByeGZwWXZkTm15VndKb0g0a2hiMFlmeVBRMWExN3cvcHZpWFM1Tk8xUzJXZUIrbWVHUTltVTlpUFd2bmZYdkRuaVA0U2VJNHRUMDI0ZDdObTJ3M1FYNVhIL1BPVmVtZjU5Umc5QVo5TjBWeVhnVHg3cDNqYlRkOFdJTlFoQSswMmpOa3IvdEw2cWZYOERYVzBDQ29icTB0NzYxbHRicUZKb0pWS1NSeUxsV0I2Z2lwcUtBUG0veDU0QzFINGU2dEg0ZzhQelRMcDZTQm81Vk9YdFdQOExlcW5vQ2ZvZmYxZjRkZkVTMThhYWVZWjlrR3J3TCsvZ0I0Y2YzMDl2VWRqK0ZkcGMyME41YlNXMXhFa3NNcWxIamNaVmdlb0lyNXc4YytEZFMrR3ZpSzMxM1FwWlVzRExtM21ISmdmOEE1NXY2Z2pwbnFPRHoxQm4wcFJYS2VBdkc5cDQyMFFYTVlXSytod3QxYmcvY2IxSHFwN0g4TzFkWFFJeXZFLzhBeUtlcy93RFhqUDhBK2l6WENmQWIva2x0ci8xOHpmOEFvVmQzNG4vNUZQV2YrdkdmL3dCRm11RStBMy9KTGJYL0FLK1p2L1FxQU9KMVAvazVTTC9zSVEvK2lWcjZHN1Y4ODZuL0FNbktSZjhBWVFoLzlFclgwTjJvR0ZVOVUxTzAwYlM3alViNlVSV3R1aGVSejJBL21ld0hyVnl2bmY0citNYmp4YjRpaThMNkx1bXRZSnhIdGlPZnROeG5ISHFGNkQzeWV3b0VaTTBtcy9HUHgrRVFORGFyOTBIbGJTM0I2bjFZL3FlT2dyNk8wVFJiSHc5cEZ2cG1uUWlLMmdYYW83azkySjdrbmttc1R3QjRNdC9CZmg1TFFiWHZwc1NYY3cvamYwSCt5T2cvUHZYVjBBRkZGVjc2K3RkTXNacjI5blNDMmdRdkpJNXdGQW9BWnFXcFdlajZkUGY2aGNKYjJzQzdwSkhQQUg5VDdkNitjL0ZmaS9YUGlsNGdpMFhScmVVV0JmOEFjV29PQytQK1drcDZBRHI2TDdtbStLdkZHcy9GYnhSQnBHa1F5Q3hFbitqVzU0empyTEw2Y2ZrUGMxN2Q0RzhDNmY0SjByeVlBSnI2VUEzTjBSeklmUWVpanNQejVvR1ZQQVB3NTA3d1haaVZ0dDFxc3E0bXVpdlQvWlQwWDlUMzlLN2FpaWdRVkJlWGx0WVdrdDFkenh3VzhTN3BKSkdDcW85U1RXYjRsOFVhWDRVMHA5UTFTZlluU09OZVhsYis2bzduK1hldm56VmRiOFZmRjd4QXVuMk1ESlpvMjVMWld4RkN2OStWdTU5L3dBb0E2RHh0OFpiM1ZabTBud2tKWW9YYnkvdGFvZk9tSjR4R3ZWUWZYNzMwcVh3VjhFNTd0bDFMeFl6eG94M2l4Vi9uZlBlUnUzMEhQcVJYb1BnYjRhNlQ0TmhXZkF1OVZaY1NYYnI5MzFDRCtFZnFlNXJ0SGRZNDJkeUFxakpKN0NnWjg0ZkdCNEpmRjJuZUdkSXQ0NFlMQ0ZJbzRJVkFVU3lrSGdEdmpaWDBIbzJuUjZSb3RscHNRQVMxZ1NFWTc3UUJtdm5qd1VqZU5malNkVWRTMEszTXQrM2ZDcnhHUHoyZmxYMHJRQVVVVVVDQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FQRGYyaHZ2OEFoLzZYSC90T3ZWUEJQL0lpNkQvMkQ0UC9BRUFWNVgrME45L3cvd0RTNC84QWFkZXFlQ2YrUkYwSC9zSHdmK2dDZ1p2VVVVVUNDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQVBJdmo1by8yanc3cCtyb29MMmR4NVRrRCtDUWYvRktQenJSK0hzR2wrT2ZoWFpXR3NXc2QyTFRkYXR2KzhoWDdwVTlWTzByeUs2L3hwb3cxL3dBRzZycHVNdk5idDVmKytCdVg5UUs4aStBR3NlWHFXcTZOSWNDYU5ibU5UMlpUdFlma1YvS2dabmVMZmhWcmZnNjcvdHJ3MWNYTnphd25lclJIRnhiL0FGeDk0ZTQvRVYxSGdMNDB3MzVpMDN4UTBkdmNuQ3gzd0cyT1EvN1kvaFB2MCtsZXgxNWQ4UVBoQlplSUJMcVdockhaNm9jczhmU0s0UHYvQUhXOXh3ZS9yUUI2Z3JCbERLUVFSa0VkNld2bkR3WjhSdFo4QTZpZEI4UlFYRDJFVGJHaGtINzIxOTEvdkw3ZFBRK3YwTHAybzJlcldFTjlZWEVkeGF6THVTU001QkgrZTFBaTFWYS8wKzAxU3dtc2I2M2p1TGFaZHNrVWd5R0ZXYUtBUG1ueGg0TzFqNFgrSVlkYjBTNG0rd2VaL285eU9URVQvd0FzNVBVSHB6d3c5NjluOEErUGJMeHRwVzlRc0dvd0FDNXRjL2RQOTVmVlQrblExMDk5WTJ1cDJNMWxld0pQYlRvVWtqY1pEQTE4MitLdkRlc2ZDanhaYjZycEUwaHNtY20xblBQSGVLVDE0L01jOVJ3RFBwcWl1ZDhHZUw3SHhub1NhaGFmSk12eVhGdVRsb1g5RDZnOVFlNHJvcUJCVlRVdE50TlgwMjQwKytnV2ExblFwSkd3NElQOWZmdFZ1aWdENWkxS3gxbjRQZVBJN2kxZHBiVnNtRjI0VzVoejh5Ti90RGo2SEJyNkwwRFhMTHhIb3R0cXVueWI0SjF5QWVxbnVwSFlnOEdxSGpQd25hZU1mRDAybTNJQ1MvZnQ1c2N4U0RvMzA3RWR3YThQK0hQaWk4K0gzakM0OFA2MW1Hem1tOG00Vmp4QkwwV1FmN0o0eWZRZzlxQm52bmlmL2tVOVovNjhaLzhBMFdhNFQ0RGY4a3R0Zit2bWIvMEt1NjhUSFBoTFdELzA0ei8raXpYQy9BYi9BSkpiYS84QVh6Ti82RlFJNG5VLytUbEl2K3doRC82Sld2b2J0WHp6cWY4QXljcEYvd0JoQ0gvMFN0ZS9YMTdiNmJZVDN0M0lJN2VDTXlTT2Y0VkF5VFFNNEw0dWVOajRZOFBmWWJLWGJxbW9BcEdWUE1VZlJuK3ZZZTU5cTV2NEkrQnhEQi93bFYvRis4bEJTeFJoOTFPaGsrcDZEMno2MXhlblc5NThYUGljODF5SFN6TGVaS1ArZU5zcHdxRDNQVDZzVFgwekJERmJRUndRb3NjVWFoRVJSZ0tBTUFDZ0NTaWlpZ1ExM1NLTnBKR1ZVVUVzekhBQTlUWHpqOFF2R3Q3OFFmRUVQaC9RRmtsMDhUQklVVGczVW45OC93Q3lPY1o3Y24yMy9qTjhRR2trazhKNlRJVHlCZnl4bkpKN1FqSC9BSTkrQTlhNmo0VS9EeGZDMm1qVk5TaEg5czNTY2h2K1hlTS93RDNQYy9oMm9HYlB3LzhBQWRuNEowY0o4czJwVGdHNnVRT3AvdXI2S1AxNm11d29vb0VGY3o0MDhiYWI0TDByN1RlSHpibVRJdDdWVGhwVy9vbzdudDllS1BHM2pTdzhGNktieTZ4SmN5WlcydGdjTkszOUZIYzl2cml2Q3ZEbmh6WGZpMTRwbjFQVkxpUkxOWC8waTVBNFVkb29oMHpqOHVweVR5QU4welNmRTN4aDhVU1h0NU1ZN1NOdHNrKzArVmJwMTh1TmU1OXZ4SnI2RzhPZUdkTDhLNlVtbjZYYmlLTWN1NTVlUnY3ekh1ZjhpcldrNlRZNkhwc09uNmRicGIyc0s0UkYvbWZVbnVlOVhhQUN1UitKdXMvMko4UHRWdUZmYk5MRjluaS8zcFBsL1FFbjhLNjZ2RWYyZ2RaQWowblJVYnFYdTVSN0Q1Vi9tMzVVQVMvcy93Q2plWFphdHJMcC9yWFcxaVAreW8zTitwSDVWN1RYTGZEclJ2N0M4QmFUWnN1MlV3aWFYMTN2OHgvbmo4SzZtZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BOE4vYUcrLzRmK2x4L3dDMDY5VThFLzhBSWk2RC93QmcrRC8wQVY1WCswTjkvd0FQL1M0LzlwMTZwNEovNUVYUWYrd2ZCLzZBS0JtOVJSUlFJS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLK2FJLzhBaWhmanB0LzFkc0w3YjdlVE4wL0FiaC8zelgwdlhnZngrMGN3YXhwZXN4REgyaUpyZDJIWmtPNVQrVEg4cUJvOThvckU4SWF3TmY4QUNPbGFwbkxYRnVwZi9mQXczL2p3TmJkQWprL0hIZ0hUUEd1bjdaMUVGL0V1TGU3UmZtVDJQOTVmYjhzVjRmbzJ1K0pQaEQ0bWswKy9nWjdSMjNUVzI3OTNNdlR6SW05ZmY4RDdmVGxZSGkzd2hwbmpIUjJzZFFqdzY1YUM0VWZQQzNxUDZqb2FBTDJoNjVwL2lQU1lkUzB5NFdhMmxIQkhCVTkxWWRpTzRyUnI1aTA3VVBFUHdkOFl5V3QxR1piV1FneXhBL3U3cVBvSFFub3cvVG9hK2pkRjFxdzhRYVRCcWVtemlhMm1YS251RDNCSFlqb1JRQm9WbjYzb3RqNGcwaTQwelVZUkxiVHJoaDNCN0VIc1FlUWEwS0tBUG1BSFd2Zzc0K3dkMDFzM1hzdDNCbjlHSDZIMlBQMGxwR3JXZXVhVGJhbHA4d2x0YmhONk4vUStoQjRJOVJXSjQ3OEcyM2pUdzlKWlNiWTd1UE1sck9SL3EzeDMvd0JrOUNQOEs4YStHSGkrNjhFZUo1dkRtdDdvTEthY3hTTElmK1BhZnB1LzNUd0QrQm9HZlJ0RkZGQWdyeUg0MitDUnFHbS84Sk5ZeFp1clJOdDJxai9XUS8zdnF2OEFJbjByMTZteXhwTkU4VWlLNk9Dckt3eUNEMUJvQThmOEJlTXo0ZytHZXRhVGV5N3RRMDdUNVZCWTh5dytXUXJlNUgzVCtIcldsOEJ2K1NXMnYvWHpOLzZGWGszaWZUTHY0YmVPcnVDMHo5bG1oa0VHN3BKYnlxVktuNmNqNnFEWHJQd0g0K0Yxc1A4QXA2bS85Q29BNG5VLytUbEl2K3doRC82Sld0LzQ3ZUxQczlsYitHYmFURDNBRTkyUWVrWVB5cWZxUm4vZ1B2WE5hOWRRMlA3UTdYZHc0U0NDOGpra1k5bEVBSnFsNFFzcC9pWDhWWk5TdjBMV29sTjVPcmNnUnFjUngvOEFvSStnTkF6MXo0VGVFZjhBaEdQQ1VjMXhIdDFIVU1UejU2cXVQa1Q4Qno5U2E3MmlpZ1FWd3Z4UDhjcjRQOFA3TFYxT3EzZ0tXeTlkZzd5RWVnN2VweDcxMkdwYWphNlRwdHpxRjdLSXJhM2pNa2puc0IvV3ZtdXh0OVIrTC94SWVXNDN4MmhPNlRIL0FDNzJ5bmhCL3RIcDlTVDJvQTZUNE5lQkcxSzcvd0NFczFaR2VHTnliTlpPVExKbm1VNTY0T2NlK1QycjNxb2JTMGdzYk9HMHRZbGlnaFFSeHhxT0ZVREFBcWFnQXJHOFQrSmJEd3BvYytxYWcveUp3a2FuNXBYUFJWOXorbkpyU3ZMeTMwK3ptdTd1WkliZUZDOGtqbkFWUnlTYSthdGQxWFYvaTc0NmhzZFBWa3RGWXJiUnY5MkdMK0tWL2M4Wi9BQ2dCTkswM1hmakQ0MWx1N3lSbzdWTWVmS3YzTGFMUEVhWjdudCtKTmZTR2thVFphSHBjR25hZEFzRnJBdTFFWCtaOVNlcFBlcW5oanczWWVGTkRnMHZUMHhIR011NUh6U3VlcnQ3bi82MWJGQUJSUlJRQVY4MCtKeWZHL3h1K3dvZDl2OEFhNDdNWTVBamorK2YwZXZvWFg5VVRSUEQrb2FuSVFGdGJkNWVlNUE0SDRuQXJ3cjRGYVcrb2VMNy9XWjhzYlNFL01mK2VzcDVQNUJ2em9HZlFvQUFBQXdCMEFwYUtLQkJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFCNGIrME45L3cvOEFTNC85cDE2cDRKLzVFWFFmK3dmQi93Q2dDdksvMmh2ditIL3BjZjhBdE92VlBCUC9BQ0l1Zy84QVlQZy85QUZBemVvb29vRUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRmNGOFlkSC90YjRkM3JxdVpiSmx1MHdPY0x3My9BSTZXL0t1OXFHOHRvNzJ5bnRaaG1LYU5vM0hxR0dEL0FEb0E4cStBbXNmYXZETjlwTHRsN0s0M29NL3dTYy8raEJ2enIxdXZtNzRVWE12aGY0cVRhTGNIYUp2TnNYei9BSDBKS24veDAvOEFmVmZTTkFNS0tLS0FPZDhaZUQ5UDhaNkk5aGVEWkt1V3Q3Z0RMUXY2ajFIcU80cndmd3g0aDFqNFQrTUo5TDFXTnpaTTRGMUN2SVplMDBmcngrWTRQSTQrbXE0cjRqK0E0UEdtaS91Z2tlcTJ3TFdzeDR6Nm94L3VuOUR6NjBBZGRaM2x2cUZuRGVXa3lUVzh5QjQ1RU9ReW5vUlU5ZlBQd3A4Y3orRmRZZnd2cm02R3prbU1hZWR3YldiT0NwOUZKL0k4OXpYME5RQVY0OThhL0F3djdFK0o5UGl6YzJ5YmJ4Rkgrc2lIUi9xdmYyK2xldzAxMFdSR1IxREt3SUtzTWdqME5BSG1md2M4Ym54Qm9oMGEvbDNhbHA2QUt6SG1hSG9HOXlPaC9BOTY5T3I1azhUNlhlL0NuNGp3WCttZy9aQzVudFFUdzhaT0hpUDB6ajZGVFgwZG8rcTJ1dDZSYTZuWlB2dDdtTVNJZnIyUHVEa0gzRkFGMmlpaWdEelA0MmVHaHEvaEQrMUlZODNXbU41dVFPVEVlSEg0Y04rQnFQNEVmOGt2dHY4QXI2bi9BUFFxN3Z4Uno0VDFuL3J4bi84QVJacmhQZ04veVMyMS93Q3ZtYi8wS2dEeVA0ci9BUEpUOWIvNjZSLytpa3IyTDRLK0hQN0g4RmpVWlV4YzZvM25FbnFJeHdnL0xMZjhDcnl6eDVwYjYzOGE3elM0emhydTdnaHo2QXhway9nTW12cGkydDRyUzFodG9WQ1JSSUkwVWRsQXdCK1ZBeVdpaXNUeGI0aWc4TGVHYjNWcDhFd3ArNlFuL1dTSGhWL0UvcG1nUjVKOGNQR0RYTjNGNFVzSExMR1Zrdk5uSlp6eWtmNGRTUFVyWG9md3o4SEw0UThMUnhUSVA3UnVzVFhiZWpZNFQ2S09Qcm4xcnlqNFIrSEovRmZqRzU4U2FvVE5GYVMrY3pPTStiY3R5UDhBdm43My9mTmZSVkF3b29yaC9paDQxSGhEdzB3dG5BMU84ekZhanVuOTZUL2dJUDVrVUNQT3ZqSjQzbDFiVWg0VDBsbWtnaWtDM1hsOG1hYlBFWTlRRGo2dDlLOUcrR2ZnV1B3Ym9JTndxdHF0MkE5MDQ1MitrWVBvUDFPVDZWd0h3VThFRzd1VDRzMUpDeUl4RmtINTN2MGFVK3VPUVBmSjdWN3RRTUtLS0tCQlJSUlFCNWg4YzlZK3crQ1k5UFJzU2FoY0toSCt3bnpOK29VZmpVL3dTMGYrenZBS1hqcmlYVUpubko3N0I4cS9vdWZ4cnp6NDJhaExyUGorMDBXMnl6V3NTUXFvNS9leWtIK1JTdmY5SjArTFNkSXM5T2hBRWRyQ2tLNDlGQUg5S0JseWlpaWdRVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQWVHL3REZmY4UC9BRXVQL2FkZXFlQ2YrUkYwSC9zSHdmOEFvQXJ5djlvYjcvaC82WEgvQUxUcjFUd1Qvd0FpTG9QL0FHRDRQL1FCUU0zcUtLS0JCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQjgzZkZhMmw4TGZGV0hXcmNiZk9NVjhtUDc2RUJoLzQ3LzQ5WDBYYVhNZDdad1hVSjNSVFJySWg5UXd5UDUxNVY4ZTlIKzArR3JEVmtYTFdWeDVibkg4RW5IL0FLRUYvT3QvNFA2eC9hM3c3c1Vac3kyUmEwZko1K1g3di9qcFdnWjNsRkZGQWdvb29vQThkK05IZ0VYOXEvaWZUSWMzVUMvNmJHby8xc1kvaitxanI2ajZWb2ZCM3g0ZGYwdit3OVJtM2FsWkorN2RqelBDT0FmZGw0QjlzSDFyMUZsRHFWWUFxUmdnamcxODFlTy9EMTU4TlBITnRyR2paaXM1WlRQYUVmZFJ2NDRqN1lQL0FIeWZhZ1o5TFVWa2VHUEVOcDRvOFAybXJXWndreS9NaE9URzQ0WlQ3ZzFyMENPUStKSGhKZkYvaE9lMmlRRyt0LzM5bzMrMkI5MzZNTWo4dlN2Ti9nWjRzYTJ2TGp3cmVzVldRdE5hQitDcmo3NmZqak9QVU5YdTlmT1B4VzBLNDhIZVBMZnhCcFk4cUs3a0Z6RXlqQVNkU0N3K2g0UDRtZ1o5SFVWbCtITmN0L0VmaDZ5MWEyNGp1WWc1WCs0M1JsUDBJSXJVb0VaWGlmOEE1RlBXZit2R2YvMFdhNFQ0RGY4QUpMYlgvcjVtL3dEUXE3dnhQL3lLZXMvOWVNLy9BS0xOY0o4QnYrU1cydjhBMTh6ZitoVUFjVHFmL0p5a1gvWVFoLzhBUksxOURkcStlZFQvQU9UbEl2OEFzSVEvK2lWcjZHN1VEQ3ZuMzQyK0k1ZFk4U1d2aG14eklsb3dNaUljK1pPL0NyK0FJSDFZMTdkNGkxcUR3NzRldnRXdU1iTFdJdUYvdk4vQ3Y0bkEvR3ZDUGcvb3MvaWp4M2MrSWRSektMTmpjTzUvanVISngrWHpIOHFBUGEvQlhodUx3cDRVc3RLUUF5b3UrZHgvSEszTEg4K0I3QVYwRkZGQWlPNG5pdGJlVzRua1dPR0pDN3UzUlZBeVNmd3I1bW5rdmZpNzhUZ2taa1N6WTRYL0FLWVdxbmsvVTV6OVdIcFhmL0hMeGI5ZzBpTHc1YXlZbnZSNWx5UWZ1d2c5UCtCRWZrRFd0OEhQQ0gvQ1ArRnhxVjFGdDFEVWdKVzNEbEl2NEYvWGNmcjdVRFBRTEd5dDlOc1lMSzBpV0szZ1FSeG92UlZBd0JWaWlpZ1FVVVVVQUZOa2RZbzJrY2hVVUVzVDJBNjA2dU8rS09zLzJMOFBkVW1SOXMwOFl0b3Y5NlE3ZjVaUDRVQWVOK0E0MjhaL0dadFZtVXRFczh0KzNzbzRqSDVsUHlyNlZyeGo5bi9SaEZwdXE2eTZjelNMYlJIL0FHVUdXL1ZoK1ZlejBBd29vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQVBEZjJodnYrSC9wY2Y4QXRPdlZQQlAvQUNJdWcvOEFZUGcvOUFGZVYvdERmZjhBRC8wdVAvYWRlcWVDZitSRjBIL3NId2YrZ0NnWnZVVVVVQ0NpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdERThZYVAvYi9BSVExWFRNWmVlM1lSLzc0R1YvVUN2SHZnRHJCZzFmVk5Ga09QdEVTM0NLZXpJZHJEOGlQeXIzeXZtaHYrS0UrT21mOVhiQyt6N2VUTi9odi93REhhQm4wdlJSUlFJS0tLS0FDc0h4ajRZdHZGdmhxNjBxZkN1NDNRU2tmNnVRZmRiK2g5aWEzcUtBUG5UNFVlSmJud2Y0eHVQRFdyWmhndXB2SWRHUEVOd09BZm8zVC92azE5RjE0WDhkUENQa3pRZUtySkNBNVdHODI5bS9nZi8yWC92bXZRdmhuNHQvNFMzd2pCUE00YS90djNGME81WURoditCREIrdWFCblpWeW54RzhNRHhWNE12TEpGQnU0aDU5c2YrbWlqSUg0aksvalhWMFVDUEMvZ0w0bE1keGUrR3JoeUErYm0yRGRpT0pGL2tmd05lNlY4MGVON1NiNGUvRnBOVnMwSzI3ekMraFVjQXF4eEluNTdoL3dBQ0ZmU05uZFEzMWxCZDI3aDRabzFrallkMUl5RFFNb2VKL3dEa1U5Wi82OFovL1JacmhQZ04vd0FrdHRmK3ZtYi9BTkNydS9FLy9JcDZ6LzE0ei84QW9zMXdud0cvNUpiYS93RFh6Ti82RlFJNG5VLytUbEl2K3doRC93Q2lWcjZHN1Y4MWVMdFdnMEg0OHo2cmRLN1FXbDNGSzZ4NDNFQ0plbVNCbm4xcnRUKzBGb2U4QWFUZjdQNzIrUFA1Wm9HVmZqNTRpOHUxc1BEMFQ4eW43VmNBZjNWNFFmaWNuL2dJcnVQaGY0Yy80UnZ3TlpReXB0dXJrZmFyakk1M09PQitDN1IrRmVKMmtoK0p2eGhpbmRHRnBQT0pQTGZHVnQ0aG5hZmM0L05xK25od0tBQ29MeTdoc2JLZTd1WkJIQkJHMGtqbitGUU1rMVBYbEh4ejhTLzJkNGJoME9COFQ2aTJaY0hwQ3B5ZnpiQS9BMENQTy9EOXBQOEFGTDRxeVhsNGpHME1uMm1kVDBTQlRoSS94K1VmOTlWOU5BQlFBQUFCMkZlY2ZCand6L1luZzVkUm5qMjNlcGtUSEk1RVg4QS9MTGY4Q3IwaWdBb29vb0FLS0tLQUN2RHYyZ2Rad2RKMFZHNEc2N2xYUC9BVS93RFo2OXhyNXA4UUUrT2ZqaDlpVTc3ZjdZbHFNY2p5b3Z2bjlIL09nRWU0ZkQzUnY3QjhDYVRaTXVKZklFc3YrKy96Ti9QSDRWMDFJQUFBQU1Ec0tXZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FQRGYyaHZ2K0gvQUtYSC90T3ZWUEJQL0lpNkQvMkQ0UDhBMEFWNVgrME45L3cvOUxqL0FOcDE2cDRKL3dDUkYwSC9BTEI4SC9vQW9HYjFGRkZBZ29vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLOEYrUCtqbUxWTksxbU1ZRThiVzBqRHN5bmNwL0l0K1ZlOVZ3dnhlMGYrMS9oM2ZsRjNTMlpXN1RBL3VINXYvSFMxQUc3NE0xZ2EvNE8wclVzNWVhM1h6UDk4ZkszNmcxdTE1RjhBOVkrMCtIZFEwaDJCZXp1UE5RRS93QUVnLzhBaWczNTE2N1FBVVVVVUFGRkZGQUZIV05MdHRiMGU3MHk4VGRiM01SamNlZ1BjZTQ2L2hYeng0QTFPNStIM3hObTBiVVgyUVRTL1k3a25oYzUvZHlmVEpINE5YMHJYaG54NThNN0piTHhMYnBqZGkxdWl2cjFqYithL2xRTTl6b3Jrdmh2NG0vNFNud1ZaWGtqN3J1SWZaN24xOHhlTS9pTUg4YTYyZ1I1ZjhjZkQvOEFhWGc5TlZpVE0rbVNiMkk2K1UyRmI4anRQNEdwZmdsci93RGF2Z3IrenBXelBwa25rODlmTFB6Si9VZjhCcjBMVWJHSFU5TnVyQzRYZERjeE5FNHgyWVlQODYrWVBBM2k0ZkRueFRxSDJwR3ViWXE5dEtzTEQ1bVJ2bFlFbkhZL2dhQm4wbjRuL3dDUlQxbi9BSzhaL3dEMFdhNFQ0RGY4a3R0Zit2bWIvd0JDckUxTDQ3YUpxV2pYOWlkTXZvbnVMYVNKRzNSc0FXVWdaNUhITmJmd0g0K0Yxci8xOVRmK2hVQ01DMHRMZTkvYVIxT0s1Z2luaThsbUtTb0dHZkpqeHdhOWgvc1hTOW16K3piUGI2ZVFtUDVWNUxwSUovYVYxWDJnYi8wVkhYdEZBSG1Qamp3RlphWENmRjNocTJTeDFYU3o5cU1VQTJ4em92TEtWSEFKWFBJNjlEWGY2TnE5cHJ1ajJ1cDJNZ2t0N21NT2hIYlBZKzRQQitsWEpZa25oZUtWUTBicVZaVDBJUEJGZU4zZndRMUcxdVpSb1BpbWV6c25Zc3NEN3dWOXNvd0IrdU0wQWV6NXI1bDFpUi9pWjhZaGFSTVdzMm4rem9SMFczanp1YjhjTWY4QWdRcnA1dkF2eE84TTI4MG1rZUlEcU1ib3l2QUptTEVFWTRXVEl6NllJTlUvZ1piMk5qNHExT0hVV052cktSQ0dDMm1RcSszT1pPdmZoZU91T2FCbnZrVVNReEpGR29TTkZDcW9IQUE0QXA5RkZBZ29vb29BS0tLS0FNenhGcXFhSDRjMUhWSEl4YTI3eWpQY2djRDhUaXZEdmdScEwzL2lyVU5hbkJiN0pEdDNIdkpLZVQrUVA1MTJmeDExZzJQZ3lEVFViRDZoY0JTUFZFK1kvcnRINDFiK0N1ai9BTm0rQUlicDF4THFFclhCUGZiOTFmMFhQNDBEUFJxS0tLQkJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFlRy90RGZmOFAvQUV1UC9hZGVxZUNmK1JGMEgvc0h3ZjhBb0FyeXY5b2I3L2gvNlhIL0FMVHIxVHdUL3dBaUxvUC9BR0Q0UC9RQlFNM3FLS0tCQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFWRmMyOGQzYXpXMHk3b3BVYU54NmdqQi9uVXRGQUh6YjhMTGlUd3I4V0pkR3VHMmlVeTJENTdzcHloL0hiL0FPUFY5SlY4My9GdTFsOE5mRkdIV3JZYmZQRVY2bVA3NkVCdi9RUitkZlJObmRSMzFqYjNjSnpGUEdzcUgxVmhrZnpvR1QwVVVVQ0NpaWlnQXJKOFRhSEQ0ajhOMytrVFlDM01SVlcvdXQxVnZ3SUJyV3BHSVZTV0lBQXlTYUFQbm40SzYzTm9mak83OE8zdVl4ZWJrS04vRFBIbmo4UUdINEN2b2ZOZk1tdTIxeDRwK0t0NWUrQklaNTNTWkpmdEVZQ29rbzRMN2p3RkpHUVQxNTROZGdud3YrSU42UFB2L0dyeFR2eVZTZVo4ZmlDby9JVURPMStKZXFYVVdpMnVoNlpNSTlUMXU1V3loYk9DaUgvV1ArQzhaOTZ1ZUhmaDU0YThPV01jTnZwbHZQTXFnUGMzRVllUno2NVBUNkRpdWY4QUJmd3RtMEhYeHJ1dDZ6SnF0L0VwV0RkdXhIa1lKeXhKSnhrRHNNbXZTcUJHZkxvbWt5SVJKcGxrNHgwYTNRLzByZ3ZnYU1mRFNISC9BRCtUL3dEb1ZlbU45MC9Tdk5QZ2QveVRXSC9yOHVQL0FFT2dERjBqL2s1VFYvOEFyM2IvQU5GUjE3TlhqZWpmOG5KNnovMTdILzBWRlhzbEFCUlJSUUFWd254RjhGSFc3TmRhMGovUi9FV25ZbXRaMDRNbTNuWWZYMi9Mb1RYZDBHZ0RHOEthNm5pWHd2cCtyb3UwM0VRTHAvZGNjTXY0TURXelhGZUFveHAyb2VLZEVVWWpzOVZhV0pmN3NjeUxJQitaYXUxb0FLS0tLQUNpaW1UU3BCQzhzaENvaWxtSjdBY21nRDUyK005L0xydnhEdGRFdGp1TnRISGJxb09mM3NwQlA4MC9Ldm9IUzdDUFM5S3RMQ0VBUjIwS1FyajBVQWYwcjUyK0hzVCtNZmpHK3J5cVdqU2FYVUc5Z0RpTWZtVi9LdnBTZ1lVVVVVQ0NpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0E4Ti9hRysvd0NIL3BjZiswNjlVOEUvOGlMb1AvWVBnLzhBUUJYbGY3UTMzL0QvQU5Mai93QnAxNnA0Si81RVhRZit3ZkIvNkFLQm05UlJSUUlLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdEeWI0OWFQOXE4TFdXcW91WHNiamE1eC9CSU1mK2hCYTIvZzVySDlxL0R1empac3kyTHRhdnp6aFRsZi9IU1B5cnBmRm1qcnIvaFBWTkxJeTF4YnVxZXo0eXAvTUN2R3ZnRnE3Vyt1YW5vMHAyL2FJUk9pbnM2SEREOG1INVVEUGZxS0tLQkJSUlJRQVZ3dnhLdkwyNnROUDhLNlZJWTc3WEpqQzBnLzVaUUtNeXQrWEg0bXU2cmk3QkJxZnhhMWE2WVpYU2RQZ3RZL1o1UzBqbjY0Q2lnRGY4UGVIZE84TWFQRHB1bXdDT0dNZk0yUG1rYnV6SHVUV3JSUlFBVVVVVUFJMzNUOUs4MCtCMy9KTllmK3Z5NC85RHIwdHZ1bjZWNXA4RHYrU2F3LzlmbHgvd0NoMEFaR2kvOEFKeU90L3dEWHNmOEEwWEZYc2RlUGFHQWYyajllSjdXdkgvZkVWZXcwQUZGRkZBQlJSUlFCNUw0b2s4ZDZGNDgxVzg4TGFOOXJ0dFFodDJra2VJT3U1Rks0SHpEQi93RHJWbm40ai9FalJSNXV0ZUQvQURMWmZ2dWtEcGdmN3lsZ1B4RmUxVVVBY240TCtJV2plTllHRm16UVhzYTdwYlNiRzlSNmdqaGw5eCtPSzZ5dk12aUg0U1hUQ1BISGg2SmJiVnRNYjdST2tRd3R6RVB2NUE3N2M4OXhuUGF2UnJLNlMrc2JlN2kvMWM4YXlMOUdBSS9uUUJQWEdmRlRXZjdGK0htcHlJNVdhNVFXc1pIcS9CLzhkM0g4SzdPdkRQMmdkWnpOcE9pbzMzQTkzS1AvQUIxUC9aNkFML3dBMGJ5ZEoxVFdYVEJ1SlZ0NGovc29NbjlXL1N2Wks1dndEbzM5ZytCdEpzR1hiS3NBa2xHUDQzK1p2MVA2VjBsQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUhodjdRMzMvQUEvOUxqLzJuWHFuZ24va1JkQi83QjhIL29Bcnl2OEFhRysvNGY4QXBjZiswNjlVOEUvOGlMb1AvWVBnL3dEUUJRTTNxS0tLQkJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGZk5GMFA4QWhCUGpwNWcvZDJ3dmcvSFR5WnV2NERjZnlyNlhyd2Y5b0RSdkx2dEsxcU1ZRXlOYXlrZGl2ekwraGI4cUFSN3hSV0I0STFqKzMvQmVrNmtXekpMYnFKT2Y0MStWdjFCcmZvQUs4ejhWL0dHdzBqVUgwblJMS1RXTlNWaWpDSW55MVlkc2dFc1Izd1B4cmQrSkdwMzloNFdGcHBSSzZscWR4SFlXekE0S3RJZVcvQlFlZTFXL0IvZ3JTdkIybHgyMWxDclhKVWVmZE12N3lWdS9QWWVnNkNnRHpuL2hOUGkzZWZ2YmZ3bWtVWjZLMXF3UC9qemcxMXZ3enR0ZVpkYzFYeEhZR3p2Nys4VmpHVjJncXNhcUNCazhmajYxM3VLS0FDaWlpZ0Fvb29vQVJ2dW42VjVwOER2K1Nhdy85Zmx4L3dDaDE2VzMzVDlLODArQjMvSk5ZZjhBcjh1UC9RNkFNM1FGeiswWjRoUHBhZjhBc2tWZXZWNUg0ZVVuOW9yeElmU3pIL29NTmV1VUFGRkZGQUJSUlJRQVVVVVVBVTlWdGZ0dWtYdHJqUG53U1I0OWR5a2YxcmgvQUh4QjhQWFBoZlM5T3U5VHQ3UFViVzNTMm1ndVg4czdrQVU0SjRJT0s5RXJoUEVmd2s4TGVJN3FhOGUzbHM3dVlscEpiVjlvZGozS25Lay9oUUIzU3Nyb0dVZ3FSa0VISU5mTk9zZjhWejhjdnN5bnpMWTNxMi9ISThxTDd4K2gydCtkZHpvMTVmZkRMKzMvQUE5cUY2MTNaMjJuTnFXbVRQd2NBN1NtTzN6RmVCeHprZGE1djRDNlMxNTRsMUxXWnh1K3l3ZVdySC9ucEljay9rcC9PZ1o5QkRwUlJSUUlLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0E4Ti9hRysvNGYrbHgvd0MwNjlVOEUvOEFJaTZEL3dCZytELzBBVjVYKzBOOS93QVAvUzQvOXAxNnA0Si81RVhRZit3ZkIvNkFLQm05UlJSUUlLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBcmlQaTFvMzlzZkR2VWRxbHByUUM3andQN24zdi9IUzFkdlVWekJIYzIwdHZLQTBjcUZIQjdnakJvQThrK0FXc2ZhTkIxTFIzY0ZyV2NUUmovWWtIUC9qeW44NjladTcyMXNJRFBlWE1OdkVPc2tyaEZING12blA0Wnp5ZUV2aTVKbzA3YlZrZVhUM3ozSU9VUDRsUi93QjlWMkE4S1MvRmp4RnFPcjZycUU4V2hXZHk5cFkyOE9NdUVPR2ZuSUdUbm5HVDdZb0diK3BlSjlHOFMrUGZER2s2VGVSM3oydDFMZVR2Q2QwYUJZWFVmTjBKeXc2VjZKWE9lR1BBMmdlRVE3YVRaN0o1RjJ2UEk1ZVJoNlpQUWV3eFhSMENDaWlpZ0Fvb29vQUtLS0tBRWI3cCtsZVkvQXYvQUpKdW4vWDdQLzZFSzlPYjdwK2xlWS9Bdi9rbTYvOEFYOVAvQU9oQ2dDcDRjQlA3US9pZjJzaC9LR3ZXcThvOE0vOEFKd3Zpci9yeFgrVU5lcjBBRkZGRkFCUlJSUUFVVVVVQUZGRkZBSG1ueGY4QUJPbytLZE9zcnZSb3hMZTJoWkhpM2hUSkUyTWdFOGNGUWNIM3JndEI4QWZGTFNiTmsweWNhWkd6K2FZaGRvcGRzQWM0Qnp3QjFOZlJGRkFIbS9ncnh6ckRhMS93aXZqS3oreWF6dExXODIwQmJrRHIwNHp3ZVJ3Y0hvZUs5SXJoL2lscHdrOExmMjNBdTNVTkVsUyt0NUIxQVZnWFg2RmM4ZXdyY3NmR0hoN1VieU95dHRac0pMeDFCRUNYQ2xza1p4MTVQdFFCdVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQjRiKzBOOS93LzhBUzQvOXAxNnA0Si81RVhRZit3ZkIvd0NnQ3ZLLzJodnYrSC9wY2Y4QXRPdlZQQlAvQUNJdWcvOEFZUGcvOUFGQXplb29vb0VGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSVFpKRWhqYVNWMVNOUmxtWTRBSHFUUUFrc3NjRUx6U3VxUm9wWm1ZNENnY2ttdkZiM3hSNDcrSVdvei84QUNGSzlqb3R1NVJicG1XUHppTzVaZ2Y4QXZrRGdkYTZYeDU0czByVy9DaytqNkZyTnBjM3VvWE1OaGkzbURNb2tjS3h3TzJNODEzbWs2WGE2THBWdHB0bEVJN2EzUVJvbzlCMytwNm42MEFmTytvZkRUNGtTYTJOV2x0MHVMOHlLL3dCcWh1WXdkNHdBM2JIUWM0cjNqd2ZvUjhOZUU5TzBsbkR5d1JmdlhIUnBHSlpqL3dCOUUxdVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUNOOTAvU3ZNZmdYL3lUZGYrdjZmL0FOQ0Zlbk45MC9Tdk1mZ1gvd0FrM1gvcituLzlDRkFHREY0bzBqd3I4ZFBFOTVyRjBiZUNXM1NKR0ViUGx0c1J4aFFld05kb3Z4aDhETi96R3dQcmJ5ai9BTmxxNXEzd3o4SDY3cWsrcDZsb3NkeGVUa0dTVXl1Q3hBQUhBYkhRQ3FmL0FBcHp3RC8wTDBQL0FIK2svd0RpcUFKRitMZmdWdjhBbVlJUjlZcEIvd0N5MUlQaXQ0R2JwNGp0ZnhEaitsVi8rRk9lQWY4QW9Yb2YrLzBuL3dBVlIvd3B6d0QvQU5DOUQvMytrLzhBaXFBTGEvRkR3UzNUeEpZL2k1SDlLa1g0aytERzZlSmROL0dZQ3MvL0FJVTU0Qi82RjZML0FML1NmL0ZVZjhLYzhBLzlDOUYvMytrLytLb0ExVitJWGc5K25pWFMvd0R3SlVWS3ZqbndvLzNmRW1sZitCYWY0MWkvOEtjOEEvOEFRdlJmOS9wUC9pcVgvaFRuZ0gvb1hvZisvd0JKL3dERlVBYjYrTVBETC9kOFJhU2YrMzJQL0dwQjRvOFB0OTNYZE1QMHU0LzhhNXovQUlVNzRCLzZGMkgvQUwvU2YvRlVmOEtkOEEvOUM3RC9BTi9wUC9pcUFPbkhpSFJHKzdxK25uNlhLZjQxSXV0YVczM2RTc3o5SjAveHJsUCtGTytBZitoZGgvNy9BRW4vQU1WUi93QUtkOEEvOUM3RC93Qi9wUDhBNHFnRG9OWi9zM1d0RXZkTmsxQ0JFdTRIaExyS3BLN2hqUFd2T2JyNE5lRXY3SThxdzFlV0hVVVVHTzZlNlVqZU81VWNBWjlNRWV0ZE4vd3Azd0QvQU5DN0QvMytrLzhBaXFQK0ZPK0FmK2hkaC83L0FFbi9BTVZRQTM0ZCtMcGRUMG00MHpYSjRrMXJTcGZzMXlXa1g5NEI5MXdlK1FPdnFNOTY3TCswYkwvbjdnLzcrci9qWEgvOEtkOEEvd0RRdXcvOS9wUC9BSXFqL2hUdmdIL29YWWYrL3dCSi93REZVQWRoL2FObC93QS9jSC9mMWY4QUdqKzBiTC9uN2cvNytyL2pYSC84S2Q4QS93RFF1dy85L3BQL0FJcWovaFR2Z0gvb1hZZisvd0JKL3dERlVBZGgvYU5sL3dBL2NIL2YxZjhBR2orMGJML243Zy83K3IvalhILzhLZDhBL3dEUXV3LzkvcFAvQUlxai9oVHZnSC9vWFlmKy93Qkovd0RGVUFkaC9hTmwvd0EvY0gvZjFmOEFHaiswYkwvbjdnLzcrci9qWEgvOEtkOEEvd0RRdXcvOS9wUC9BSXFqL2hUdmdIL29YWWYrL3dCSi93REZVQWRoL2FObC93QS9jSC9mMWY4QUdqKzBiTC9uN2cvNytyL2pYSC84S2Q4QS93RFF1dy85L3BQL0FJcWovaFR2Z0gvb1hZZisvd0JKL3dERlVBZGgvYU5sL3dBL2NIL2YxZjhBR2orMExML243Zy83K3IvalhILzhLZDhBL3dEUXV3LzkvcFAvQUlxai9oVHZnSC9vWFlmKy93Qkovd0RGVUFkaC9hTmwvd0EvY0gvZjFmOEFHaiswYkwvbjdnLzcrci9qWEgvOEtkOEEvd0RRdXcvOS9wUC9BSXFqL2hUdmdIL29YWWYrL3dCSi93REZVQWRoL2FObC93QS9jSC9mMWY4QUdqKzBiTC9uN2cvNytyL2pYSC84S2Q4QS93RFF1dy85L3BQL0FJcWovaFR2Z0gvb1hZZisvd0JKL3dERlVBZGgvYU5sL3dBL2NIL2YxZjhBR2orMGJML243Zy83K3IvalhILzhLZDhBL3dEUXV3LzkvcFAvQUlxai9oVHZnSC9vWFlmKy93Qkovd0RGVUFjRiswRGNRVHRvSGxUUnlZRnhuYTRPUHVWNmg0THZyUlBBK2hLMTFBR0ZoQ0NESXZIeUQzck0vd0NGTytBZitoZGgvd0MvMG4veFZIL0NuZkFQL1F1dy93RGY2VC80cWdEc1A3UnN2K2Z1RC92NnYrTkg5bzJYL1AzQi93Qi9WL3hyai84QWhUdmdIL29YWWY4QXY5Si84VlIvd3Azd0QvMExzUDhBMytrLytLb0E3RCswYkwvbjdnLzcrci9qUi9hTmwvejl3ZjhBZjFmOGE0Ly9BSVU3NEIvNkYySC9BTC9TZi9GVWY4S2Q4QS85QzdEL0FOL3BQL2lxQU93L3RHeS81KzRQKy9xLzQwZjJqWmY4L2NIL0FIOVgvR3VQL3dDRk8rQWYraGRoL3dDLzBuL3hWSC9DbmZBUC9RdXcvd0RmNlQvNHFnRHNQN1JzditmdUQvdjZ2K05IOW8yWC9QM0Ivd0IvVi94cmovOEFoVHZnSC9vWFlmOEF2OUovOFZSL3dwM3dELzBMc1A4QTMray8rS29BN0QrMGJML243Zy83K3IvalIvYU5sL3o5d2Y4QWYxZjhhNC8vQUlVNzRCLzZGMkgvQUwvU2YvRlVmOEtkOEEvOUM3RC9BTi9wUC9pcUFPdy90R3kvNSs0UCsvcS80MGYyalpmOC9jSC9BSDlYL0d1UC93Q0ZPK0FmK2hkaC93Qy8wbi94VkgvQ25mQVAvUXV3L3dEZjZULzRxZ0RzUDdSc3YrZnVEL3Y2ditOSDlvMlgvUDNCL3dCL1YveHJqLzhBaFR2Z0gvb1hZZjhBdjlKLzhWUi93cDN3RC8wTHNQOEEzK2svK0tvQTdEKzBiTC9uN2cvNytyL2pSL2FObC96OXdmOEFmMWY4YTQvL0FJVTc0Qi82RjJIL0FML1NmL0ZVZjhLZDhBLzlDN0QvQU4vcFAvaXFBT3cvdEd5LzUrNFArL3EvNDE1aDR4dWJqNGdlTEI0TjArL0Z2cEZtcXphcmNvdytjbjdzWTlmcDB6MSs3Vy8vQU1LZDhBLzlDN0QvQU4vcFAvaXFWUGcvNERSdHkrSDRnZlVUU2Y4QXhWQUdYYmZDWHducHVyYWJxTmhlend6V1U2eWtQY0NRUzdlY0hQVG5IVDhxOUNPcFdLL2V2TGNmV1ZmOGE1US9DWHdNZXVnUkgvdHRKLzhBRlVuL0FBcUx3Si8wTDBIL0FIOWsvd0RpcUFPb2JXdExYNzJwV1krczZmNDFHZkVXaUw5N1dOUEgxdVUveHJtLytGUmVBLzhBb1hvUCsvc24vd0FWUi93cUx3SC9BTkM5Qi8zOWsvOEFpcUFPZ1BpancrdlhYZE1IMXU0LzhhaWJ4ajRaWHI0aDByL3dNai94ckUvNFZINEUvd0NoZmgvNyt5Zi9BQlZML3dBS2s4Qy85Qy9GL3dCL1pQOEE0cWdEVmJ4MTRVWHI0ajB2L3dBQ2sveHFFL0VQd2V2WHhKcHY0VGlxSC9DcGZBMy9BRUFJdisvMG4veFZML3dxWHdOLzBBWXYrLzBuL3dBVlFCYVB4SzhHTDE4UjJINFNacU0vRkR3VVArWmlzL3dMSCtsUS93RENwZkEvL1FCai93Qy8wbi94VkgvQ3BmQS8vUUJqL3dDLzBuL3hWQUR6OFZmQkEvNW1DMy9CSFA4QTdMVWJmRnJ3T3Y4QXpIVVAwZ2wvK0pwZitGUytCdjhBb0F4ZjkvcFAvaXFQK0ZTK0J2OEFvQVJmOS9wUC9pcUFJWCtNSGdnRC9rTU1mcGF5L3dEeE5aUHdLSWI0YklSME43T2YxRmJuL0NwZkEzL1FBaS83L1NmL0FCVmREb2ZoN1MvRGVtalQ5SXRGdHJVTzBnakRNM3pIcWNrazBBZi8yUT09XCIsXHJcblx0XHRcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3QkRBQWdHQmdjR0JRZ0hCd2NKQ1FnS0RCUU5EQXNMREJrU0V3OFVIUm9mSGgwYUhCd2dKQzRuSUNJc0l4d2NLRGNwTERBeE5EUTBIeWM1UFRneVBDNHpOREwvMndCREFRa0pDUXdMREJnTkRSZ3lJUndoTWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qTC93QUFSQ0FLOEFyc0RBU0lBQWhFQkF4RUIvOFFBSHdBQUFRVUJBUUVCQVFFQUFBQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkFBQWdFREF3SUVBd1VGQkFRQUFBRjlBUUlEQUFRUkJSSWhNVUVHRTFGaEJ5SnhGREtCa2FFSUkwS3h3UlZTMGZBa00ySnlnZ2tLRmhjWUdSb2xKaWNvS1NvME5UWTNPRGs2UTBSRlJrZElTVXBUVkZWV1YxaFpXbU5rWldabmFHbHFjM1IxZG5kNGVYcURoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1SGk0K1RsNXVmbzZlcng4dlAwOWZiMytQbjYvOFFBSHdFQUF3RUJBUUVCQVFFQkFRQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkVBQWdFQ0JBUURCQWNGQkFRQUFRSjNBQUVDQXhFRUJTRXhCaEpCVVFkaGNSTWlNb0VJRkVLUm9iSEJDU016VXZBVlluTFJDaFlrTk9FbDhSY1lHUm9tSnlncEtqVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0dVBrNWVibjZPbnE4dlAwOWZiMytQbjYvOW9BREFNQkFBSVJBeEVBUHdEdFBBZmdQd3BxSGdQUTd1NzhQNmZOY1MyY2J5U1BDQ3pFamtrMTBYL0N0dkJuL1F0YVovMzRGSHcyL3dDU2NlSHYrdkdQK1ZkVFFCeTMvQ3R2Qm4vUXRhWi8zNEZIL0N0dkJuL1F0YVovMzRGZFRSUUJ5My9DdHZCbi9RdGFaLzM0RkgvQ3R2Qm4vUXRhWi8zNEZkVFJRQnkzL0N0dkJuL1F0YVovMzRGSC9DdHZCbi9RdGFaLzM0RmRUUlFCeTMvQ3R2Qm4vUXRhWi8zNEZIL0N0dkJuL1F0YVovMzRGZFRSUUJ5My9DdHZCbi9RdGFaLzM0RkgvQ3R2Qm4vUXRhWi8zNEZkVFJRQnkzL0N0dkJuL1F0YVovMzRGSC9DdHZCbi9RdGFaLzM0RmRUUlFCeTMvQ3QvQm4vUXRhWi8zNEZlRmFqNGYwandoOFpsczc3VGJXYlNKcmhTSXBZOG9JcGVCZ2Y3TEg5SytucThYK1B1Z21XdzAzWG9sTzZCemF6TVA3cmNvZndZRWZpS0FPLy9BT0ZiK0RQK2hhMHovdndLUCtGYmVEUCtoYTB6L3Z3S2s4QWE3L3drZmduVE5RWjkweGlFYy84QTEwVDVXL1BHZnhycGFBT1cvd0NGYmVEUCtoYTB6L3Z3S1A4QWhXM2d6L29XdE0vNzhDdXBvb0E1Yi9oVzNnei9BS0ZyVFA4QXZ3S1ArRmJlRFA4QW9XdE0vd0MvQXJxYUtBT1cvd0NGYmVEUCtoYTB6L3Z3S1A4QWhXM2d6L29XdE0vNzhDdXBvb0E1Yi9oVzNnei9BS0ZyVFA4QXZ3S1ArRmJlRFA4QW9XdE0vd0MvQXJxYUtBT1cvd0NGYmVEUCtoYTB6L3Z3S1A4QWhXM2d6L29XdE0vNzhDdXBvb0E1Yi9oVzNnei9BS0ZyVFA4QXZ3S1ArRmJlRFA4QW9XdE0vd0MvQXJxYUtBT1cvd0NGYmVEUCtoYTB6L3Z3S1A4QWhXM2d6L29XdE0vNzhDdXBvb0E1Yi9oVzNnei9BS0ZyVFA4QXZ3S1ArRmJlRFA4QW9XdE0vd0MvQXJxYUtBT1cvd0NGYmVEUCtoYTB6L3Z3S1A4QWhXM2d6L29XdE0vNzhDdXBvb0E1Yi9oVzNnei9BS0ZyVFA4QXZ3S1ArRmJlRFA4QW9XdE0vd0MvQXJxYUtBT1cvd0NGYmVEUCtoYTB6L3Z3S1A4QWhXM2d6L29XdE0vNzhDdXBvb0E1Yi9oVzNnei9BS0ZyVFA4QXZ3S1ArRmIrRFA4QW9XdE0vd0MvQXJxYU8xQUh6VG9YaHpScmo0ODNXa3k2WmF2cDYzVnlvdDJqR3dCVUpBeDdWN2IvQU1LMjhHZjlDMXBuL2ZnVjVONGMvd0NUa0x6L0FLL0x2LzBBMTlCVUFjdC93cmJ3Wi8wTFdtZjkrQlIvd3Jid1ovMExXbWY5K0JYVTBVQWN0L3dyYndaLzBMV21mOStCUi93cmJ3Wi8wTFdtZjkrQlhVMFVBY3Qvd3Jid1ovMExXbWY5K0JSL3dyYndaLzBMV21mOStCWFUwVUFjdC93cmJ3Wi8wTFdtZjkrQlIvd3Jid1ovMExXbWY5K0JYVTBVQWN0L3dyYndaLzBMV21mOStCUi93cmJ3Wi8wTFdtZjkrQlhVMFVBY3Qvd3Jid1ovMExXbWY5K0JSL3dyYndaLzBMV21mOStCWFUwVUFjdC93cmJ3Wi8wTFdtZjkrQlIvd3Jid1ovMExXbWY5K0JYVTBVQWN0L3dyYndaLzBMV21mOStCUi93cmJ3Wi8wTFdtZjkrQlhVMFVBY3Qvd3Jid1ovMExXbWY5K0JSL3dyYndaLzBMV21mOStCWFUwVUFjdC93cmJ3Wi8wTFdtZjkrQlIvd3Jid1ovMExXbWY5K0JYVTBVQWN0L3dyYndaLzBMV21mOStCUi93cmJ3Wi8wTFdtZjkrQlhVMFVBY3Qvd3Jid1ovMExXbWY5K0JSL3dyYndaLzBMV21mOStCWFUwVUFjdC93cmJ3Wi8wTFdtZjkrQlhqWHhuMHJ3OXBlcGFabzJpNkxaVzl3Vk04elFSQU0yNzVVWGo4VGo2VjlHc3dWU3hPQU9wcjUxOFBnK1AvQUk0eWFpd01sbmJ6dGNqSXlCRkY4c1kvRTdUUUI2bG9Yd3M4SzJXZzJOdGU2RFlYRjFIQXF6U3lSQmk3NCtZNSt1YTBQK0ZiZURQK2hhMHovdndLNm1pZ0RsditGYmVEUCtoYTB6L3Z3S1ArRmJlRFAraGEwei92d0s2bWlnRGx2K0ZiZURQK2hhMHovdndLUCtGYmVEUCtoYTB6L3Z3SzZtaWdEbHYrRmJlRFAraGEwei92d0tQK0ZiZURQK2hhMHovdndLNm1pZ0RsditGYmVEUCtoYTB6L3Z3S1ArRmJlRFAraGEwei92d0s2bWlnRGx2K0ZiZURQK2hhMHovdndLUCtGYmVEUCtoYTB6L3Z3SzZtaWdEbHYrRmJlRFAraGEwei92d0tQK0ZiZURQK2hhMHovdndLNm1pZ0RsditGYmVEUCtoYTB6L3Z3S1ArRmJlRFAraGEwei92d0s2bWlnRGx2K0ZiK0RCZy93RENOYVoxL3dDZUFyNDYxbUdPSFhOUWlqUlVqUzZsVlZVY0FCeUFCWDNhZWxmQzJ1LzhqRHFmL1gzTC93Q2htZ0Q3QitHMy9KT1BEMy9YakgvS3Vwcmx2aHQveVRqdzkvMTR4L3lycWFBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDc1B4aG9pK0l2Q1dwNlVSbHA0R0VmczQ1VS9tQlc1UlFCNGQ4Qk5jZU9mVlBEMDUybi9qNmlROW1HRmtIL29KcjNHdm5QWE0vRDc0NXBxQ2paWnp6aTRPT0I1VXVSSVB3YmNmd0ZmUmFrTUFRY2c5eFFBdEZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZSVFhNTnRHWko1VWlRZnhTTUZINW1zRys4ZStFOU9KRno0ZzA5U09vV1lPZnlYTkFIUjBWNTlkL0dqd1hiRWlPL251U1ArZUZzNUIvRWdWalhIeCswQkFmSTByVXBqN2hFSC9vVkFIclZIYXZFcHYyaFkrZkk4TnlIMDh5N0Eva3BxaEwrMEZxWi8xV2dXYWovYnVIUDhsRkFXSWZEbi9KeUY1LzErWGYvb0JyNkNyNUdzdkd0N1llTzV2RmtWcmJtN2tsa2w4bHl4akJjWUk0NTcxMlAvQy9mRXYvQUVDOUovNzVrLzhBaTZCbjBSUlh6d1BqOTRrL2kwclNqOUJJUC9acWxUOW9EV3g5L1JOT2I2U1NEL0dnTEgwRlJYaE1QN1FseVA4QVgrSEltLzY1M1pIODByUmcvYUQwOWlQdEdnWGlEMWpuUnY1NG9GWTlsb3J6QzIrTzNoU1k0bmgxRzM5MmdELytnazF1V254WDhFM2dHM1hZSW1QOE02UEgvTVVBZG5SV2JaZUlORzFMYjlpMVd5dU4zUVJUcXgvSUd0TE5BQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQWNoOFRkZS80Ui93RnFWd2o3YmlaUHMwSHJ2ZjVjL2dNbjhLNUQ0QzZDTFh3L2U2MUltSkx5WHlvaVIveXpUamo2dG44aFdKOGQ5WGt2dGMwcnc1YS9NOGErYzZqdkpJZHFEOGdmenIyWHc1bzhmaC93N1lhVkZqYmF3TEdTTzV4eWZ4T2FCbXBSUlJRSUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FFUFN2aGJYZjhBa1lkVC93Q3Z1WC8wTTE5MG5wWHd0cnYvQUNNT3AvOEFYM0wvQU9obWdEN0IrRzMvQUNUanc5LzE0eC95cnFhNWI0YmY4azQ4UGY4QVhqSC9BQ3JxYUFDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnRHlINDk2Q0xyUWJIV28weTluS1laU092bHlmNE1CK2RkaDhNOWUvNFNId0hwdHk3N3JpRlBzOC8rK25INmpCL0d0cnhIbzhXditITlEwcVVmTGRRTkdENk5qNVQrQndmd3J4djRFYXhKWWExcXZoeTdPeDVCNXlJZTBpSGE0L0xINVVBZThVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUm11ZTE3eHo0YjhOcXcxTFZyZU9ZRGlCRzN5SC9nSTUvT2dEb2FLOFIxejQvcUMwZWhhUVc5Sjcxc0QvdmhlZjFyem5XUGlONHUxOWpGY2F4T2tiOEMzdFAzU24yd3ZKL0VtZ2RqNmQxZnhUb1dnZ25WTlZ0TFVqK0dTVWJ2KytldGNOcXZ4MThNV2U1YkNDOTFCeDBLUmlORCtMNFA2VjQxcEh3NThYYTh3bHR0R3VGVitmUHV2M1NuM3kzSi9BR3U3MHI5bisra3crcjYxRENPOGRwR1hQL2ZUWUg2VUFVOVQrUGV1M0JaZE8wMnl0RlBScEMwckQrUS9TdVIxRDRsK01kVFlyTHI5MUdHLzVaMnhFWC9vSXordGU0YVg4RnZCOWdBYmkxbnYzSFUzTXh4LzN5dUIvT3V4MC93NW91a29GMC9TYksyQTQvZFFLcC9QR2FBUGxDRHc5NHA4UVA1a1dsNnRmRnYrV2p4dXdQOEF3SnVLMzdMNE8rTmJvQW5UWXJWVDNudUVVL2tNbXZxSUFBWXBhQXVmUGRyOEFkZGsyL2E5WDArRUhyNWF2SVIrZ3JidHYyZTdVQWZhdkVVN0h1SWJWVi9tVFh0TkZBcm5sTUh3RThOcGp6dFExU1gvQUxhSXY4bHEvSDhFUEJxZmVodnBQOSs2YitsZWowVUFjQXZ3WjhFcjEweVZ2OTY1Zi9HcFI4SHZCQUFIOWpaK3M4bitOZDFSUUJ3YmZCendReC81QkxENlhFbitOUVA4RmZCYmppeXVVLzNicDY5RG9vQTh4bStCUGhLUWZ1NWRUaVAremNnL3pGWjAvd0N6OW83NThqVzlRai8zMGpmK2dyMStpZ0R3ZTcvWjh1MXliUHhEREo2Q2ExSy9xcFA4cXc3MzRHK0xyYlBrUHA5Mk8zbHpsVC80OEJYMHBSUU81OGtYdnczOFlhY1NadkQxNHdYK09CUktQL0hTYXBRYTU0bThPeWJJdFIxWFQySDhEU1BHUCsrVzQvU3ZzVEZRejJsdmRJVXVJSXBrUEJXUkF3UDUwQmMrWjlOK00vakt4MmlXN3Q3NUIydVlCay84Q1hGZGxwWDdRTVJ3dXI2SEl2ckphU2h2L0hXeC9PdS8xTDRZK0RkVkxOTm9WdEhJMzhkdG1FLytPa1Z4V3EvQUhUWnR6YVZxOTFiSHNsd2dsWDh4ZzBBZGJwWHhZOEc2c1ZWTldTMmxQL0xPN1V4SDh6eCt0ZGpCY1EzTVN5d1NwTEczUjBZTUQrSXI1bzFmNExlTHRNVm50NExmVVloM3RwY05qL2NiQi9JbXVTU2J4RDRTdk1LK282Uk9EMCtlSFA0ZERRRmo3SW9yNXQwVDQ0ZUo5TjJwcUNXMnB4ZHpJdmx5Zjk5THgrWXIwblFmalo0WDFVckhmUE5wY3gvNStSbVBQKytPUHpBb0ZZOUpvcUMxdmJXK2dXZTB1WXJpRnVWa2ljTXAvRVZQUUFVVVVVQUZGRkZBQlJSUlFBVTJSMWpqWjNZS3FnbGlldzcwNnVKK0srdkhRdkFGODBibGJpN3hhUlk2NWZxZndVTlFCNVg0TFIvSGZ4cHVOYWxCZTJ0NVd2T2V5cjhzUS9rZndyNktyeW40RTZGOWg4S1hHcnlKaVRVSnNJY2Y4c2srVWZydS9LdlZxQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FROUsrRnRkL3dDUmgxUC9BSys1Zi9RelgzU2VsZkMydS84QUl3Nm4vd0JmY3Y4QTZHYUFQc0g0YmY4QUpPUEQzL1hqSC9LdXBybHZodC95VGp3OS93QmVNZjhBS3Vwb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQTlLK2RmR3NiZUF2alJiNnpFcFcxbmxTODQ3cXhLeWorWi9FVjlGVjVUOGRkQiszK0ZiZlZvMHpKcDB2emtmODhud3AvSTdUUUI2b2pySWl1akJsWVpCQjRJcDFjUjhKOWRPdWVBTEV5UHV1TFBOcExrODVUN3AvRlN0ZHZRQVVVVVVBRkZGRkFCUlZUVXRVc05JczN2TlJ1NGJXM1RySks0VWY4QTYvYXZJZkZQeDR0NGc5dDRhc3pPL1Q3WGNncWcvd0IxT3AvSEg0MEFleFhWNWJXTnM5emQzRVVFQ0RMU1N1RlZmcVRYbW5pVDQ0NkRwbStIUjRwTlV1Qnh2WDkzQ1A4QWdSNVA0RDhhOFJ2TlQ4VGVPZFVXT2VXOTFTNkp5a0Vha3FuMFFjS1BmOWE3N3czOENkVXZkayt2M2lXRVI1TUVPSkpTUGMvZFg5YUJuSytJZmlsNHI4UmxvcEw4MmRzL0F0N01lV0NQUXQ5NXZ6L0NtYUQ4TXZGbmlFaVdEVEh0NEg1TnhlSHlnZmZCK1p2eXI2SThQZkQ3dzE0WjJ0cCtteG00SC9MeE4rOGxKOWR4NmZoaXVub0M1NDlvWHdEMHkzQ3lhNXFVMTQvVXcyNDhxUFAxNVkvcFhvK2plRXRBOFBvRjB2U3JXMkkvNWFMR0M1K3JISlA1MXRVVUNEQW9veldCckhqYncxb0lJMURXYk9LUWY4c2hJR2YvQUw1WEpvQTM2SzhuMVQ0OTZCYkZsMDdUNzIrWWRHWUNGRCtKeWYwcmk5VCtPL2lTN0pGaFoyTml2WTdUSzM1bkEvU2dMSDBabW9wN21DMWpNazgwY1NEcXpzRkg1bXZrdlVQaUo0dTFOaXR4NGd2QnUvNVp3dUloK1M0TlU0TkI4UzY2NGtqMHpWYjFtUER2SEkrZitCTnhRT3g5U1huanZ3cFljWEhpRFRsUG90d3JuOGx6V0hkZkdQd1RiOExxanpuL0FLWTI3dC9RVjRyWi9DRHhyZGdOL1pDMjZudlBPaS9vQ1RXN2EvQVh4TEtBYmpVTk5nOVFHZHoraTBBZHpQOEFIandyR1AzVnRxa3g5b0ZVZnExWjB2N1FPa2cvdXREMUIvZHBJMS9xYXpiYjludVlqTno0alJmYUswSi9td3JRaS9aOTAwSDk5cnQ2Mys1Q2kvenpRR2hXZjlvT0hQeWVIcGNmN1Z5di93QVRUUDhBaG9UL0FLbDMvd0FtL3dEN0d0aFBnRDRjQStmVk5XWS83OFkvOWtxWC9oUXZoZkgvQUIrNnIvMytULzRtZ05EREg3UWc3K0hXL0M2SC93QVRVOGY3UWRsL3kxOFAzUS8zTGhEL0FEQXJVYjRDZUdEOTIvMVpmKzJxSC8yU3EwdjdQK2huL1ZheHFhLzd3amIvQU5sRkFhRDRQajk0ZmZIbmFWcWNmMEViZnlhdEtENDRlRHBUaDViNkQvcnBhbitoTmM3TCt6M2JFSHl2RVV5K20rMVZ2NU1LeTdqOW43VkZKK3phN1p5ZW5td09uOGlhQTBQVHJYNHArQ3J2QVRYN1pDZTBvYVAvQU5DQXJlcy9FR2phZ1FMTFZiRzRKNkNLNFJqK1FOZlBkMzhEdkdFQlBralQ3a2Y5TTdqYm4vdm9Dc0MrK0d2akRUOG1idzlkTUIvRkR0bEgvanBKb0ErdGMwVjhkcHFuaWZ3OUlGVzgxZlRtWCtGbmtqSDVOeFhRYWQ4WVBHZGlBRzFLTzhRZHJtRld6K0l3YUFzZlVsRmVHYVorMEZLTUxxMmdxM3JKYVRZLzhkWWYrelYydWxmR0x3ZHFaVlh2M3NaRC9EZVJsQi8zMXlQMW9FZDkxcUM2czdhOWhNTjNieFR4SHFrcUJsUDRHa3M3KzAxQ0VUV2QxRGN4SCtPR1FPUHpGV0tBUFBOYitESGhQVmd6MjF2SnBzNTZOYU5oYy83aHlQeXhYbWV2ZkE3eEZwcGVUU3BvZFVoSElWVDVVdVA5MG5CL0ExOUgwVUFmSEVOeDRoOEg2a1JHOS9wTjJweVVJYU1uNmc4Tit0ZWplSHZqeHFscVVoMSt4anZZeHdaN2ZFY28rcS9kUDZWN3BxV2thZnJGc2JiVXJLQzZoUDhBQk5HR0ErbWVuNFY1ZjRrK0JHbFhnYWJRTHVUVDVlb2dsekpFZnAvRXY2L1NnWjNQaHp4NTRjOFVoVjAzVVl6Y0VjMjB2N3VVZjhCUFg4TTEwbGZJbmlMd040ajhKUytacUZoSXNLbkszY0IzeC9YY1B1L2ppdDN3djhZUEVuaDh4eFhjdjlxMlE0OHU1Yjk0Qi9zeWRmenpRRmo2ZW9yalBDdnhPOE9lS2lrTU56OWt2bS81ZGJraFdKLzJUMGI4SzdPZ1FVVVVVQUZlQS9HL1ZKdFk4V2FaNGF0RHVhQUFsUi96MWxJQy9rQVB6cjNxZWVPMnQ1SjVtQ3h4cVhkajJBR1NmeXI1NytITU1ualg0djNuaUM0UW1HQjN2TU56Z2s3WWwvQWMvd0RBYUFQZWRFMHlMUnRFc3RNZ0FFZHJDc0srK0JqTlg2S0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQVE5SytGdGQvNUdIVS93RHI3bC85RE5mZEo2VjhMYTcvQU1qRHFmOEExOXkvK2htZ0Q3QitHMy9KT1BEMy9YakgvS3Vwcmx2aHQveVRqdzkvMTR4L3lycWFBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0FxanJPbVE2em90N3BzNHpGZFF0RTNIVEl4bjhPdFhxS0FQQWZnbHFjK2krTDlVOE5YaEtOT0crUTlwb2pnajhWeitRcjM2dm5mNGt3eWVDL2kzWitJYmRTSXAzUzg0N3NQbGtYOFIvT3ZvUzNuanViYUtlRmcwVXFCMFlkQ3BHUWZ5b0dTVVVWd3ZqVDRwYUo0UjMycXQ5dTFNRGkxaGI3aC93QnR1aS9UaysxQWp0Ym01Z3M3ZDdpNW1TR0ZCbDVKR0NxbzlTVFhrZmkvNDVXVm1YdFBEVUszc3c0TjNLQ0lWUDhBc2pxLzZENjE1UjRpOFllSS9IT29KRmR5eVNxNzRnc2JaVHNCN1lVY3NmYzVQMHJ1dkNId092TDN5N3p4TksxcEFlUmFRc0RLMys4M0lYNkRKK2xBenoyZTU4VGVQTmFBZHJ6VmIxdnVvb3lzWTlnUGxRZmxYcDNoYjREc3dTNThUM21PL3dCanRXLzlDay9vdjUxN0RvMmc2WDRmc2haNlZZdzJzQTZyR3ZMSDFKNmsrNXJSb0M1bjZSb1dsNkRaaTAwcXdndElSMVdKTWJ2Y25xVDdtdENpcTE3cUZucHRxOTFlM1VOdEFneTBrcmhWSDRtZ1Jab0p4WGt2aVQ0NjZQWTc0TkN0bjFLWWNlYytZNFFmeCtadnlIMXJ5VHhEOFJ2RkhpVGNsNXFja1ZzM0gyZTEvZFJuMk9PVy9FbWdkajZMMTc0aitGdkR1NUwzVllubkgvTHZiL3ZaUHlYcCtPSzh4MXo0L1hVaGFQUTlKU0ZlZ212RzNOOWRpOEQ4elhDZUgvaHQ0cDhSaFpMVFRIaHRtNSswWFI4cEQ3alBMZmdLOVIwSDRCNmRBRmsxM1VwcnQrOE5zUEtUOCtXUDZVQWVTYXg0NDhVZUluS1gyc1hVaXVjQ0NFK1doOWdpZGYxcXhvL3czOFc2MEE5cm9zOFVUYytiYzRoVSsvellKL0t2cHpSdkNXZ2VIMUEwclNyVzJZZnhxbVhQMVk1Si9PdG5GQVhQQjlLL1ovdkhDdnErdHd4RHZIYVJGei8zMDJCK2xkcHBud1c4SDJHMHoyczk4NDZtNW1KQi93Q0FyZ1Y2SlJRSXpOUDhPNkxwS2dhZnBObGE0NkdLQlZQNWdaclR3S0tLQUNpanBTWkZBQzBVaElBeWVCNzFDOTViUi82eTRoWC9BSG5Bb0Fub3FnMnQ2U24zOVRzbCt0d2cvclRQK0VpMFQvb01hZjhBK0JTZjQwQWFWRlp3OFFhSzMzZFhzRDlMbFA4QUdwazFUVDVQOVhmV3ovN3N5bit0QUZ1aW1KTEhKOXgxYjZFR241b0FLTUQwcE1qMUZMUUF5U0dPWkNrc2F5SWVxdU1nL25YT2FuOFBQQ1dyNU4xb05sdlA4Y1VmbE4rYTRycHFLQVBKOVQrQW1nWElMYWRmM3RrL1lNUktuNUhuOWE0ZlYvZ1o0bnNNdHA4OW5xS2RnamVVL3dDVGNmclgwaFJRRno0NnVkTDhTZUVybnpacmJVZEtsVThTcUdqSC9mUzhIODY2blJQalA0czByYWx6UERxVUkvaHVrdzJQOTljSDg4MTlOU1JwTEdZNUVWa1lZS3NNZy9oWEdhMzhLZkNHdDduZlRGdEp6L3kyc3o1Ui9JZktmeEZBN21Eb1B4MDhQYWh0ajFhQzQweVU5WFllYkYvMzBveVB4SDQxNlBwMnJhZnE5dUxqVHIyQzZoUDhjTWdZZnAwcndyWGZnTHF0cnZsMFBVSWIxQjBobi9kU2ZnMzNUK2xlZVhGbDRrOEY2aUdsaXY4QVNib0hpUlNZOTMwWUhERDhUUUI5aVVWODdlSGZqbnJtbmxJdGJ0NDlTZ0hIbUxpS1lmOEFzcmZrSzlmOE5mRVR3MzRwMngyTitzZDBSL3g2M0g3dVQ4QWVHL0FtZ1IxRElycVZkUXlrWUlJeUNLODc4VS9Cdnc3cnhrdUxGUDdLdkc1MzI2ankyUDhBdFI5UHl4WG8yYUtBUGt2eFQ4T3ZFWGhKbWt2TFR6ck5UeGQyK1dqK3A3citQNTFyZUV2aTc0ZzhOK1hiM1VoMVN3WGp5cDNQbUlQOWwrdjRISXI2ZFpWZFNyQUVFWUlJNjE1bjR2OEFneG9tdUNTNjBqYnBkOGVjUnJtRno3cDIrcTQraG9IYzZid3I0OTBEeGZDUDdQdXd0MEJsN1NiNVpWL0R1UGNaRmRQWHgvcjNoZlgvQUFYcUtEVUxlVzFrVnN3WFVMSFl4OVVjZEQ3Y0d2UWZCbnh2dkxEeTdMeE9qM2R1UGxGNUdQM3FmN3cvaitvd2ZyUUZqMEg0dzY3L0FHTjRBdW9vMzIzRit3dFk4SG5EY3VmKytRZnpyUDhBZ2ZvUTAzd1kycFNKdG0xS1V5QS85TTErVlIvNkVmeHJndmlwcjhYamp4ZG8yazZKY3BjMjJ4RmplTTVWcFpTTS9rQU1qdHpYMEJwbGhEcFdsMnVuMjR4RGJSTEVnOWxHUDZVQVc2S0tLQkJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFJZWxmQzJ1L3dESXc2bi9BTmZjdi9vWnI3cFBTdmhiWGY4QWtZZFQvd0N2dVgvME0wQWZZUHcyL3dDU2NlSHYrdkdQK1ZkVFhMZkRiL2tuSGg3L0FLOFkvd0NWZFRRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUhtZnh2MFArMC9CSTFDTk16YWJLSmYrMmJmSy84QVEvaFI4TVBHZGlQaGxIUHF0N0hicnBSTnRMSksyUGxIS2ZVN1NBQU9lSzFQaU40MjBMdzdvMXpwOStQdGQxZHd0R3RsR2ZtWldCR1dQOEk5L3dBcStZYkcwdk5SdUl0UHNvWnJpYVZoc2dqQllzMk1aeC9XZ1o2ZDQ0K005L3JIbTZmNGU4eXhzVDhyWEo0bWxIdC9jSDYvU3VkOEcvRFRYUEdVaTNBVTJlbk1jdGVUS1R2NTUyRHE1OStudlhwUGdYNEsyMWlJOVI4VGhMcTZIekpaS2N4Ui93QzhmNHo3ZFByWHNDSXNhS2lLRlZSZ0FEQUFvQTVyd240RTBQd2ZiN2RPdHQxeXd4SmR5NGFWL3dBZXc5aGdWMDFGTWxsamhpYVdWMVNOQnVabU9BQjZrMENIMVUxTFZMRFNMTjd6VWJ1RzF0MCs5Sks0VWY4QTYvYXZMdkdIeHYwL1R2TXMvRGthMzkwT0RjdmtRSWZidS80Y2U5ZUs2bHJHdStNTldScnllNTFDOGtPSW9sVXRqMlJCd1B3b0hZOWI4VS9IaUtNeVczaG0wRXJjajdaZEtRdjFWT3AvSEgwcnlMVU5WMTd4ZHFhZmE3aTcxSzdjL3U0Z0MrUDkxQndQd0ZlaitFL2dacUYvc3VmRWM1c1lEejltaElhWnZZbm92Nm42VjdUb0hoYlJmREZ0NUdrV0VWdUNNTTRHWGY4QTNtUEpvQThNOE0vQTdXOVRDVDYxT3VtVzU1OG9BU1RFZlRvdjRrL1N2WC9Ebnc0OE1lR1FyMmVuSkxjai9sNXVmM2tuNEU4RDhBSzZ5aWdRVVVWRGRYZHZaVzdYRjFQRkJDdkxTU09GVWZpYUFKcUs4NzF2NDBlRTlLM0piVFRhbk1QNGJSUGx6N3UyQitXYTg1MW40NytJTHdzbWwyZHJwOFpQRE1QT2svTTRINlVBZlJKWUtNazRIclhQNnA0NjhMNk1TTDdYTEtOeDFqV1FPLzhBM3l1VFh5M3FIaVR4SDRsbjhxODFPL3ZuWThRQjJJL0JGNC9TdGJTdmhkNHgxVUJvZEZsdDQyNTMzUkVJL0k4L3BRT3g2NXFYeDM4TldwSzJWdGZYeEhRckdJMVA0c2MvcFhMWDM3UU9wT1NOUDBPMGhIWTNFelNIOGxBL25ScG43UDhBcU1wVTZwcmR2QU9wVzJpTWgrbVd3UDUxMXRoOEN2Q3RxQWJxVy92V0hYZk5zVS9nb0ZBYUhsMTk4WnZHbDNrTGYyOXFwN1FXeWo5V3lhd2JqeDU0c3Z5Vms4UmFpK2Y0WTVpUDBXdnBTeStHL2cvVDlwZzhQMlJZZnhTSjVoLzhlSnJvYlhUckt5VUxhMmR2QUIwRVVTci9BQ0ZBSHlHSVBGR3FIaUxXN3ZQK3pNK2FzSjRFOFczUFR3M3FiWjd2QVIvNkZYMTdSUUZ6NUxUNFhlTXBPbmhxNC80RjVZL20xU2o0VGVOQ1ArUmRmL3Z1SC80cXZxL0ZGQVhQazV2aFQ0MFQvbVhKRDlHaVAvczFRU2ZEYnhoRHkzaG05NC91UnEzOGpYMXhpakZBWFBqNS9DL2l5eCtZNkxyTU9PNndTakg1VXhkYThVNlV3eHFPczJwSFpwSlYvd0RRcSt4S1JsVmxLc0FRZXhHYUF1Zko5bjhVdkdkbXdNZmlDYVgybUNTL3pGZEZaZkhmeFZiWUYxYmFkZGp1V2lhTW44VmJINlY3emUrR05DMUVFWGVqMkV4UFV2YnFUK2VNMXpsOThJZkJWN2svMlFMZGovRmJTdEgrZ09LQU9Qc1AyZ3JWOERVZEJualBkcmVkWEg1TUJYWGFaOFlQQm1vZ0J0VE5tNS9odTRtVDllUit0YzFxSDdQK2tTNU9uYXplMng3TE1peXIvUS9yWEg2bDhDL0ZGb0MxbFBZM3k5Z3NoamI4bUdQMW9BK2hiTFZMRFVvdk5zYjIzdW8vNzBFcXVQME5XNitQcjd3eDRuOE15K2ZjNlhxTml5bmllTldBSC9BMDQvV3RiUi9pdjR3MG5hRTFacnlKZitXZDRvbC84ZSs5K3RBV1BxdWl2RjlFK1A4QWF2dGoxelNKWVQzbXMyM3Ivd0I4TnlQd0pyMGpRdkcvaHp4SmhkTDFXQ1dVL3dETEZqc2tIL0FUZzBDT2dxQzZzN2ErdDJndTRJcDRYR0dqbFFNcC9BMVBSUUI1ZjRrK0NIaC9WZDgya3UrbFhCNUN4amZDVC91SHArQkgwcng3eEw4Ti9FdmhZdE5jMlJ1TFJEa1hkcmwwSHVmNGwvRWZqWDFqUmpOQVhQbDN3dDhYUEVuaHpaRE5PTlRzUng1TjB4TEFmN0w5UitPUlh0M2hQNG4rSGZGZXlDSzQreDM3Zjh1bHlRckUvd0N5ZWpmaHo3Vlg4VS9DWHczNGxNazhjSjA2K2ZuN1JhZ0FNZjhBYVRvZjBQdlhodml2NGFlSXZDZStlZTMrMVdLblAydTJCWlYvM2gxWDhlUGVnWjlYVVY4eWVFUGkvcjNoenk3YStZNnBwNjRHeVovM3FEL1pmdjhBUnMvaFh2WGhmeHRvZmkrMk1tbDNZTXFqTWx2Sjhzc2YxWCtveUtCR3pmV0ZwcVZwSmFYdHRGY1c4Z3c4VXFobFlmUTE0bjQxK0I3eCtaZmVGV0xMeXphZkszSS82NXNmNU4rZGU2VVVBZkdlblgybytGdkVNTjVIRDVOL1pTNTh1NGkrNjNRaGxQNC8wcjZOOERmRlRTZkZvanM3amJZYXNSajdPN2ZMS2Y4QXBtM2Y2ZGZyV3Q0dzhBNkw0enRzWDBQbFhpcmlLOGlBRWlleC92RDJQNlY4NWVML0FBSnJYZ3E4SDJ5UHpMUXQrNXZZYzdHUFlIdXJleC9BbWdaOWJVVjRCNEIrTTl4cDVpMDN4TzczRnJ3cVgyTXlSLzcvQVBlSHYxK3RlODJ0M2IzMXJGZFdzMGMwRXFoa2tqYmNyRDFCb0VUVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQ0hwWHd0cnYvSXc2bi8xOXkvK2htdnVrOUsrRnRkLzVHTFUvd0RyN2wvOUROQUgyRDhOditTY2VIdit2R1ArVmRUWG5YdzE4V2FTZEkwTHd2NXJqVTAwcUtmYVZ3cEJHY0E5empuSHBYb3RBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJUSlpvNElYbG1kWTQwVXN6c2NCUU9wSjdDZ0IvU3ZJL2lKOFlJTklNdWsrSEhqdUw4WldXNjRhT0EraS8zbS9RZS9TdVorSS94ZWwxVXphUDRjbWFLd09VbXZGNGVjZHduOTFmZnFmWWRjajRlZkN1OThXTkhxR28rWmFhTURrTmpEM0hzbm92KzErV2FCbUQ0YThKNi80LzFtVm9USkp1ZmRkWDl3U1ZVbjFQOFRldy9RVjlJZUR2QW1qK0RMTHk3R0x6THQxeE5keUFlWkovZ1BZY2ZXdHZUTkxzZEcwK0t4MDYyanRyV0lZU09NWUEvd0FUN21ybEFnb3FPYWFLM2hlYWFSSTRrVXM3dXdBVURxU1QwRmVKK08valljeTZkNFViamxYMUJsLzlGZy8raEg4QjNvQTlEOFkvRVBSUEJzQlc3bTgrK1laanM0U0RJZmMvM1I3bjhNMTg4ZUwvQUloYTU0eGxaYnlmeUxET1Vzb1NSR1BUZC9mUDEvQUNxR2llSHRkOFo2dThWaERMZDNEdHVubmtZN1V6L0U3bi93RFg2Q3ZmL0JQd2wwZnd2NWQ1ZWhkUjFRYytiSXY3dUkvN0NuK1o1K2xBenlyd2I4SU5iOFNpTzgxRGRwbW5OZ2hwRi9leUQvWlE5QjduOGpYdlhobndab2ZoTzE4clM3SkVrSXhKY1A4QU5MSjlXUFA0RGl0K2lnUVVVVnh2aXY0bStIUENtK0dlNSsxWHkvOEFMcGJZWmdmOW85Ri9IbjJvQTdLdVo4UitQdkRmaFpXWFVkUmorMEFjVzBQN3lVLzhCSFQ4Y1Y0TjRuK0wvaVh4QUpJTGFZYVhaTng1VnNmbllmN1VuWDhzVmdlSHZCZmlMeFhMdTB6VDVaWW1iNTdtWDVJZ2ZkejEvREpvSFk3M3hGOGVOVXZOOE9nMk1kakVlQlBQKzhrUDBYN28vV3ZON3EvMTd4WnFBRnhQZmFyZHNmbGorYVFqNktPRi9JVjdSNGMrQStuV3dTZnhCZXZlUzlUYjIrWTR4N0Z2dk4rbGVwYVZvbW1hSmFpMjB5d3Q3U0lmd3dvRno5VDFQNDBBZlBHaGZCUHhScXdXVytFR2x3SC9BSjduZkpqL0FIRjZmaVJYcE9pZkEvd3pwMjE5UWE0MU9VZFJLK3lQL3ZsY2ZxVFhwdlNpZ1Z5aHAyaTZYcEVJaTA3VDdhMFFER0lZZ21mcmpyVitpaWdBb296V1ZxSGlYUTlKei9hR3JXVnNSMmxuVlQrV2MwQWF0RmNGZmZHUHdWWmNKcWIzVER0YlFPMzZrQWZyWFBYbngvMFNNa1dla2FoUDd5Rkl4L00wQWV2VVY0TmNmdEIzaHo5bThQMjYraGx1V1A4QUphenBmajE0bWNueXRPMHlQL2dMdC83TUtBc2ZSVkZmTk1ueHc4WlA5MDZlbis3YW4rclZIL3d1enhyL0FNL0ZsLzRDRC9HZ2RqNmFvcjVtWDQyK05BZVpyRSt4dFA4QTdLck1YeDE4WEo5K0RUSkI3MjdqK1RVQlkra0tLK2ZZUDJnTmJUL2o0MGJUNVA4QWNrZFA4YTFiWDlvT0xQOEFwZmgrVUQxaHVRZi9BRUlDZ1ZqMjJpdk1iUDQ2K0U1OW91STlSdFNldStBTUIrS2sxMGxoOFNmQjJwRUxCNGdzd3gvaG1ZeEgvd0FmQW9BNnFpb29MbUM2aUV0dk5ITEdlalJzR0g1aXBhQUVLZ2pCSEZjN3JQZ0x3dnIyV3Y4QVJiVnBUL3kxalh5My93Qytsd2E2T2lnRHhmV3ZnQmF5YnBORDFhU0J1ME4ydTlmKytoZ2o5YTgwMTc0YitLL0RqR1M2MHVTV0ZPUmNXbjcxUjc4REkvRUN2ck9qRkE3bnlsNGYrS0hpdnc4VVNMVVd2TFpPUHM5NW1SUjdBL2VINTE2eDRjK09laDZpVWgxcUNUUzV6d1pEKzhoUC9BaHl2NGo4YTYzeEY4UGZEUGlZTTEvcHNhM0JIL0h4Qis3ay9NZGZ4elhrbmlUNEZhclk3NTlBdTF2NGh5SUpzUnlqNkg3cmZwUUI3M1ozMXJxRnNseFozRVZ4QTR5c2tUaGxQNGlyRmZIdHBxSGlUd1JxckxCSmU2VmVLZm5oZFNvYjZxUmhoK2Rlc2VGZmp2RktVdHZFOXA1TGNEN1phcVN2MVpPby9EUDBvQ3g3VlNFQmdRUmtHcW1tNnJZYXhaSmVhZGR3M1Z1LzNaSW5ERDZleDlxdVVDUE5mR0h3YjBUeEI1bDFwWVhTOVFia21OZjNNaC8yazdmVmNmalhoZXRlSGZFWGdiVm96ZHhUV2M2Tm1DN2djN1dQcWpqK1hCOXErdnFxMytuV2VxV1VsbmYyMFZ6YlNqRHh5cUdVMEJjOFg4RS9IQmxNZGg0ckdSd3E2aEd2VC9yb28vbVB5cjJ5MHU3ZS90WTdxMG5qbmdrWGNra2JCbFllb0lyd3J4djhFcml6OHkvOExGN2lFWlpyRjJ6SXYrNHgrOTlEejdtdUU4S2VOOWQ4RDM3TGF1M2tiOFhGamNBaENlL0hWRzl4K0lOQXo2MnFDOHM3YlVMU1MxdTRJNTdlVmRyeHlLR1ZoN2cxenZnN3g5bzNqTzAzV1V2bFhpTG1hMGxJRWllNC92TDdqOUs2bWdSOCsrUC9BSU5YR2xpWFZQRFNQY1dReTBsbm5kSkVQVlA3eSszVWU5Y2o0SStJV3ErQ3JzTEVUYzZhN1ptczNiQTl5aC9oYjlEM3I2d3J5LzRpZkNTMThSZWJxbWlySGE2c2ZtZVA3c2R3ZmY4QXV0L3RkKy9yUU03ZnczNG8wcnhYcGEzK2xYQWtUcEpHZUhpYis2dzdIK2ZhdG12ajNTdFgxM3dMNGhhVzNNdGxmUU41YzhFcThNUDdycjNIL3dDc0d2cFR3TjQvMHp4cnArNkVpRFVJbHpjV2pOOHkvd0Mwdjk1ZmY4NkFPdW9vb29FRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVWWHZyMjMwMnhudmJ1VllyZUJESkk3ZEZVREpOQUhHL0ZMeHFQQ1BodGt0bkExTzl6RmJEUEtESHpTZmhuajNJcjQrbFptbWNsaVNXSkpKeVR6WHRPblFYdnhmK0p6WGR5cnBwY0JET3BQRVZ1cCtXUC9lWTlmcVQycnlUV29vNHRlMUdPTkZSRXVwVlZWNkFCemdDZ0QwelhOSjFMUWRIOEllTTlQa1pSSlpXNmJ4L3l5bFJlQWZaaG44aUsraHZDZmlTMThWK0hMVFZyWDVmTlhFc2VlWTVCOTVUOUQrbUs1N3d0b2xwNGkrRG1rNlZlcm1DNDAyTlNRT1ZPT0dIdURnL2hYbVB3OTF1NytIWGo2NjhOYXkzbDJ0eEtJWkdiaFVrL3dDV2NvLzJXQkFQc1I2VURQb3FpaWlnUVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRlY3Nit0ZE1zWnIyOW5TQzJoVXZKSzV3RkFvQVc4dmJiVDdPVzd2SjQ0TGVGUzhra2pZVlFPNU5mTm54SCtKOTE0dG1mVDlPYVMzMFZEOTA4TmNZL2lmMFgwWDgvYXY4UmZpTmQrTkw3N0phbVNEUjRuL2RROUdtUFozSHI2TDIrdGQxOEwvaE9MWHlkZThSd1p1T0h0cktRY1IranVPN2VnN2QrZWdNelBocDhJbXZoRHJmaVdBcmFuRHdXTGpCazlHa0haZlJlL2ZqaXZlVVJZbzFSRkNvb3dxcU1BRDBGT29vRUZaSGlMeExwZmhmUzN2OVZ1VmhpSENMMWVSdjdxanVheC9IUHhCMHp3VlkvdlNMalVaRnpCYUkzek4vdE1mNFY5L3lyNXIxblhOYjhhNjhzOTI4dDNlU3RzZ2dpVWtLRDBSRjdELzlab0diUGpyNGs2cjR6bWFISnM5S1U1UzBSdnZZNkdRL3hIMjZEOWExdkFYd2oxRHhMNVdvNnQ1bGpwUnd5akdKWngvc2cvZFgvYVA0RHZYYi9EMzRPMitsZVZxdmlSRXVMOEVOSGFjTkhDZlZ2N3pmb1Bmclhyb0dPbEFGRFI5RjA3UWRQU3gwdTBqdHJaT2lJT3A5U2VwUHVhdjBWRGRYVUZsYlNYTjFOSERCR056eVNNRlZSNmttZ1JOWFBlS1BHdWgrRWJYemRVdXdKV0dZN2VQNXBaUG92cDduaXZML0FCdDhieWZNc1BDZzQrNjJvU3IvQU9pMVAvb1IvS3ZLZFAwdlhmR0dzdWxwRmM2amZTbmRMSXpGc2U3dWVBUHIrRkE3SFcrTHZqQnIzaU15VzFnemFYWUhqWkMvNzF4L3RQMitpL21hNTd3djRGMS94ZktEcHRtUmI3dm51NXNyRVBYbitJK3d6WHNQZy80STZicGdqdlBFTWk2aGRjTjluVVlnUSsvZC93QWVQYXZWNG9vNElsaWlqV09OQmhWUVlDajBBN1VBZWJlRmZndG9HaWhMalZmK0pyZURCL2VqRUtIMlR2OEFWcy9RVjZURkZIREdzY1NLaUtNS3FqQUE5aFQ2S0JCUlNPNm9oZDJDcW95U1RnQVZ3ZmlQNHUrRjlBOHlHSzVPbzNhOGVUWjRZQSs3L2RINi9TZ0R2YXA2anEybmFSYm1mVWI2M3RJaC9IUElFQittZXRmTzNpRDQyZUp0V0x4NmY1V2xXNTRIa2pmTGozZHVuNEFWeHRwcG5pRHhaZkY3YTJ2OVV1Q2ZtbE82VEgxYzhEODZCMlBlZForT1BoalQ5eVdDWE9wU0RwNVNiRVAvQUFKdjZDdUIxZjQ3ZUk3MGxkTnRMUFQwN05nelArYllINlZKb253STEyKzJ5YXRlMjJuUjkwVDk5SitoQ2o4elhvV2tmQlR3bHAyMXJxR2ZVWkIxTnpKOHAvNEN1QlFHaDRKZitMZkUrdlNlWGRheHFGeXpmOHNvNUdBLzc1VEZXZE4rSFhpN1ZpR3R0QXV3RzU4eWRSRVBybDhHdnF2VDlIMDNTby9MMC9UN1cwVEdNUVJLbjhoVjNBb0M1ODVXUHdJOFQzQUJ1N3ZUN1FkeHZhUnYwR1Axcm9yVDlueTNBVTN2aUNaejNXRzNDL3FTZjVWN1hSUUs1NWxiZkFyd2xDQjUwdXAzQjc3N25hUC9BQjBDdE9INFBlQjRoem81azk1TGlSdi9BR2F1Nm9vQTVGUGhmNEpqR0I0Y3NqL3ZBbitacVgvaFcvZ3ovb1c5Ti83OGl1cG9vQTVWdmhyNExicjRiMC84SXNWV2wrRkhnZVhyNGZ0MS93QngzWCtScnM2S0FQUFovZ3I0S216c3M3cUQvcmxkdi9VbXNhOCtBT2d5YzJlcWFsQWYrbW15UUQ5QWYxcjF1aWdEd1c5L1o5djBKK3dhOWJ5anNKNEdUOVFUWE02aDhHdkdka0daTENDOFVkN2E0VWsvZzJEWDFCUlFPNThjVGFkNGo4TXk3NUxUVk5NWUg3NFdTSWZtT0RXN3BYeFo4WmFaZ0xxeHZJaC9CZG9KTS84QUF1djYxOVVzcXNwVmdDcEdDRDBOYzFxL3c5OEs2M2szbWlXbm1IL2xyRW5sUCthNG9DNTV2cEg3UUtrcW10YUlWOVpiT1RJLzc0Ym45VFhvZWgvRW53cHI1VkxYVjRZNXowaHVUNVQvQUpOMS9DdUcxbjRBYWZNR2ZSdFhudG03UlhTaVZQOEF2b1lZZnJYbkd1ZkNueGJvZ2RuMDAzdHV2L0xXelBtajY3ZnZmcFFCOVZBZzR3ZXRMWHlGb25qWHhONFhsOHV3MU81aVZEaHJhYkxvUFlvM1Q4TVY2bDRkK1BrVGxJZkVXbW1Mc2Jtenl3L0ZEeitSUDBvQ3g3WFJXVm9uaVhSdkVWdjUyazZqQmRMakpDTjh5L1ZUeVB4RmF0QWpOMWpRTks4UVdodHRWc0lMdUk5Qkl1U3YwUFVINlY0NzRyK0JFa2UrNThNWFJkZXYyTzZibjZLLzlHL092ZEtLQVBqMjF2dkVuZ2JXbUVUM2VsM3lmZmljWURqM1U4TVBmbXZaZkIveHdzTlE4dXo4UnhwWVhKd291azVoYysvZFAxSHZYcEd1K0c5SjhTMkp0Tldzb3JtUCtFc01NaDlWYnFEOUs4TDhaZkJUVXRJOHk4OFB1K28yWXl4Z1ArdmpIdDJmOE1IMk5BejZHaW1qbmlTV0dSSkkzRzVYUmdRdzlRUjFwOWZKbmhQeDlyL2dxNU1WcktaTFFOaVd4dU03TTk4RHFoK240aXZvYndkOFE5RThaUWhMV1h5TDhMbVN6bUlEajNYKzhQY2ZqaWdSMXRjVDQzK0dtaitNWVduS2kwMVFENUx1TmVXOW5IOFEvVWRqWGJVVUFmSVd0YUI0ZzhCYTdHTGtTMmx6RzI2M3VvR08xOGQwYitZUFBxSzlqK0h2eGh0OVpNV2xlSW1qdHRRT0ZqdWVGam5Qb2Y3cmZvZTJPbGVsYTFvbW5lSU5NbDAvVTdWTGkyazZxdzVCN0VIcUNQVVY4My9FRDRYNmg0UGtlOHROOTVvekhpYkdYaDlwQVA4QTBMcDY0b0dmVUZGZlBQdzUrTHMrakdIU1BFVXNrK25jTEZkSExQQVBSdTdMK285eFgwRmIzRU4xYnh6MjhxU3d5S0dSMGJLc0QwSVBlZ1J5UGp6NGVhYjQxc2l6QVcycHhyaUM3VmVmOTF4L0V2OEFMdFh6ZGQyZXUrQmZFb1NUemJIVXJWdDBjaUhoaC9lVTlHVS8vV05mWWRjNTR3OEdhWjR6MGsyZDhteVpNbUM1UWZQQzNxUFVlbzcwRE1UNGRmRXEwOFpXb3RMclpiYXhFdVpJYy9MS0IvR250NmpxUHB6WGZWOGY2N29XdGVCZkVTd1hCZTN1b1c4MjN1WVNRcmdIaDBQOU8zUTE3NThOZmlaQjR2dGhwK29HT0RXb2x5VkhDM0NqK05QZjFYdDlLQVBSS0tLS0JCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVjRkOGF2R0V0N2R4ZUR0TExTTVhVM1lqT1M3bjdrWDZnbjhLOUo4ZStMb2ZCM2htZS9KVnJ0LzNWckVmNDVDT1B3SFUvU3ZNZmd4NFNtMVhWSnZHV3JicFNzamZaakp5WkpUOStUOE1rRDNKOUtBUFN2aDk0UGk4SGVGNGJSZ3JYMDJKYnVRZnhTSHNQWlJ3UHo3MThnNjcvQU1qRHFmOEExOXkvK2htdnVrOUsrRnRkL3dDUmgxUC9BSys1Zi9RelFCOWcvRGIvQUpKeDRlLzY4WS81VnlIeHI4Ri8ycnBBOFEyVVdieXhURTZxT1pJTzUrcThuNlpyci9odC93QWs0OFBmOWVNZjhxNmQwV1JHUjFES3d3UVJrRVVBZWUvQ1B4cC93azNoc1dWNUx1MVBUd0k1U3g1bFQrRi82SDNIdlhvbGZOMnVXZDM4SS9pYkRxRmlqTnBreEx4SjJlRW41NHZxdmIvZ0pyNkkwKy90dFUwKzN2ck9VUzI5eEdKSTNIZFNNaWdDelJSUlFBVVVVVUFGRkZGQUJSUlRYZFkwWjNZS3FqSlluQUFvQWp1N3VDeHRKYnE2bFNHQ0pTOGtqbkFWUjFKTmZNbnhKK0l0eDR6MUQ3SlpsNHRHaGY4QWRSY2d6Ti9mY2Z5SGI2MWQrS254SWJ4UmR0cE9seWthTkEzek9EajdTdy9pUCt3T3c3OWZTdW4rRW53eDJDRHhMcnNIejhQWldzZys3NlNNRDMvdWp0MTlLQmxyNFZmQ3dXQ3dlSWRmZ3pkbkQydHE0LzFQbzdEKzk2RHQ5ZW5zZEZGQWdyeno0ai9FNjE4SVFOWVdPeTUxbVJjckdUbFlBZWpQL1JlLzBxdDhUdmlmRjRXaGJTdEpkSmRaa1g1ajFXMlU5MjlXOUIrSjkvQ3ZEL2g3V1BHMnZtMnROODF4SzNtWEZ6S1NRZ0o1ZHovVHFlMUF5TzBzOWM4YmVJakhGNTEvcVYwMjUzYzl2N3pIb3FqOGgwRmZSL2dMNGNhYjRMdFJNMjI2MWFSY1MzUlg3dnFxRCtGZjFQZjByVDhIZUM5TDhHYVVMU3hUZk0rRFBjdVBubWIzOUI2RHRYUjBBRkZGZVgvRVA0dVd2aHd5NlhvaGl1OVZHVmtrUHpSMjU5Lzd6ZjdQYnY2VUNPcThYK09kSDhHMlhtMzgyKzVjWmh0WXptU1Q4T3c5enhYemY0dzhlNjE0enVqOXNsOHF5VnN4V2NSUGxyNkUvd0I1dmMvZ0JXYmIydXVlTXRmS1JMY2FqcVZ5MjVtWTVPUFZqMFZSK0FGZS93RGdQNFNhYjRaRVYvcW5sMytyRGtNVnpGQWY5Z0hxZjlvL2hpZ1o1MTRIK0RlcGE4SXRRMXd5YWZwellaWXNZbm1IMFAzQjdubjI3MTc3b3VoYVo0ZTA5YkhTck9LMnQxNTJvT1dQcXg2ays1clJvb0VGRkZjRjR5K0syaCtGZk10WW5Hb2FrdkgyYUZ1RVArMjNSZnAxOXFBTzZrbGpoamFTVjFSRkdXWmpnQWVwTmVZK0t2alpvbWtiN2JSay90VzdHUnZWdHNDbjNiK0wvZ1A1MTR4NHA4ZWVJUEdFNUYvZEZiWXQ4bG5CbFloNmNkV1B1YzEwSGhQNE42LzRnQ1hPb2oreXJJNE9abHpLNC8yVTdmVnNmU2daejNpUHg1NGs4VnlGTlF2NVBzN0g1YlNES1IrdzJqbGo5YzFyZUd2aEg0bzhRTEhOSmJMcHRtM0lsdXhoaVA4QVpRY244Y1Y3ejRZK0huaHp3b2l0WldLeVhZSE4zY1llVS9RL3cvaGl1cTZVQmM4NDhQZkJid3hvNFNXK2pmVmJrY2xybmlNSDJRY2ZubXZRcmUyZ3RJRmd0NFk0WWtHRlNOUXFnZXdIRlMwVUNDaW1TU3h4SVhrZFVRZFdZNEEvR3VQMXI0cWVFTkVMcEpxeVhNeTlZck1HWS9tUGxING1nRHM2TTRydzNWZjJnWDVUUjlFQTlKTHlYLzJWZjhhNG5WZmk3NHoxSUVIVlJaeG5vdHBHSThmOEM1YjlhQjJQcVo1RWpVczdCVkhVc2NDc2ErOFllSE5OQisyYTdwMEpIWnJoYy9sbk5mS2lwNGw4U3k4THEycU94N0NTWFA4QVN0bXgrRlBqUzhBWk5DZUJUM25kSS8wem45S0FzZTZYUHhmOEUyd1AvRTQ4MGp0REJJLzY3Y1ZsUy9IYndqSG5aSHFjdis3YmdmellWd0ZwOEIvRkU0QnVMelRMYjI4eDVEK2lpdGFEOW55N09QdEhpR0ZmWHk3VW4rYlVCb2JjbngvMEVIOTNwT3BPUGZ5eC93Q3pWRi93MEZwUC9RRHYvd0R2NUgvalVDZnM5MlkvMW5pSzViL2R0bEg5YWwvNFo5MHZ2cnQ5L3dCK2tvRFFldjdRT2prL05vbW9BZXp4bit0VzRmajU0WmIvQUZ0aHFrZjBqUnYvQUdhczl2MmZOT1AzTmZ2QjlZVU5WcHYyZTF4KzQ4U1BuL3BwYUQralVCb2RWYmZHendYT1FIdXJ1RC9ycmF0LzdMbXRpeitKZmcyOWJiRjRoc2xKNkNaakdULzMwQlhsVS83UCtzcmsyK3RXRW5vSkluVCtXYXhMejRLK003WFBsMjFuZEQvcGpjakovQmdLQVBwSzExT3d2Z0RhWHR0Y0E5REZLci95TldjaXZrSzc4RCtMTkhKa20wRFVZZHZXU0dJc0IrS1pvc2ZHM2l2UkhFZHZybW9RbFR4RkxJV0gvZkw1b0N4OWZVVjg1YVg4ZHZFMXB0WFVMV3h2MDduWVlYUDRya2ZwWGRhUDhkdkR0NnlwcVZ0ZDZjNTZzVjgxQitLOC9wUUt4Nm5SV1pwUGlMUnRkaUVtbDZuYTNhOXhGSUNSOVIxSDQxcDBBWWV1K0Q5QThTSVJxdWwyOXcrTUNYYnRrWDZPTUg5YThwOFIvQVJodm04T2Fqa2RSYlhuOGc0SDh4K05lNVVVQWZIV282UDRoOEc2bXJYZHZlYWJkSWYzYzZNVnovdXVwd2Z6cnZmQy93QWNkWTAwcGI2OUNOU3R4eDV5WVNaUjcvd3QrbjFyNkJ1N0sxdjdaN2E4dDRyaUJ4aG81VURLZnFEWGxQaXI0R2FaZmI3bnc3UC9BR2ZPZWZzOG1XaGI2ZDEvVWUxQXp2OEF3MzR5MEx4WGIrYnBOOGtyZ1plQnZsbFQ2cWVmeDZlOWIxZkhtcjZCNGc4R2FuSDl1dDdpd3VFYk1OeEd4Q3NmVkhIQituWDJyMFh3ZjhjYjJ6OHV6OFRSRzdnR0ZGNUV1SlZIKzB2UnZxTUg2MEJZOStvcWhwT3RhYnJ0Z2w3cGQ1RmRXNzlIamJPRDZFZFFmWTgxZm9FY1g0eitHbWllTUkybWtqK3lhbGo1YnlGUnVQczQ2T1ByejcxODllSmZDR3YrQmRUak4yanhnUG0ydnJkaUVZam9WWWNxM3NjSDYxOWMxV3Y5UHROVHM1Yk8rdG9yaTJsRzE0cFZES3crbEFIalBnUDQxOHhhYjRyY0FuQ3BxQUdCL3dCdEFPbis4UHhIZXZiSXBZNTRrbGlkWGpjQmxaVGtNRDBJUGNWOCsrUHZnM2RhT0pkVDhPTEpkV0krYVMxKzlMQ081WCsrdjZqM3JudkFueEwxVHdaTXRzKzY4MGxqODlxemN4K3BqUFkrM1ErMUF6Nm1wc2thVFJ0SElpdWpncXlzTWdnOVFSNlZuYUQ0ZzB6eExwa2VvYVZkTFBBL0J4d3lOM1ZoMUJIcFduUUk4QytKSHdnZlR4TnJQaHFGbnRCbDU3SmVXaTlXajlWLzJlbzdlbGMzOE8vaVplK0RyaExPN01sMW9ydDgwSU9XaHovRkgvVmVoOWpYMURYamZ4TytFb3Z2TzF6dzNBRnUrWHVMSkJnVGVySU96ZW83L1hxRFBXdE8xS3oxZlQ0YjZ3dUV1TFdaZDBjaUhJSS96MjdWYXI1VDhCZkVEVVBBK3BGQ0huMHlWdjhBU0xRbkJCN3N1ZWpEOWVocjZmMG5WckhYTk1nMURUcmhKN2FaZHlPdjZnK2hIY2RxQkdkNHM4SjZiNHcwWjlQMUNQa1phR1pSODhML0FONWY2am9hK1h0ZTBMV2ZBbmlRVzg3UEJkUU1KYmE2aEpBY0E4T2gvbU8zUTE5ZjF6M2pId2hwL2pMUkhzTDFkc2k1YTN1QU10Qy9xUGIxSGNVQVlQdzErSTBIakd3K3gzakpGck1DWmxRY0NaZjc2LzFIYjZWMzlmSHVvYWZyWGdUeFQ1VWpQYTZoWnVIaW1qNk1Pekw2cVIvVUd2cEg0ZStPN1h4cm8yODdJZFNnQVc2dHdlaC92TC9zbjlPbEF6c2FLS0tCQlJSUlFBVVVVVUFGTmtkWW8ya2RncUtDV1pqZ0FEdWFkWGtQeHM4YS93Qm42Y3ZocXhsLzBxOFhkZEZlcVE5bCtyZnkrdEFIRjYxZVhueGUrSlVOaFl1NDB5RWxJbUhTT0VINTVUN3R4ai9nSXI2STA3VDdYU3RPdDdDemlXSzJ0NHhIR2c3QVZ4UHdvOEZmOElwNGNGemR4QmRVdndKSjhqbU5mNFkvd3prKzU5cTlBb0FROUsrRnRkLzVHSFUvK3Z1WC93QkROZmRKNlY4TGE3L3lNT3AvOWZjdi9vWm9BK3dmaHQveVRqdzkvd0JlTWY4QUt1cHJsdmh0L3dBazQ4UGY5ZU1mOHE2bWdEbHZpQjRSajhZK0Y1ckViVnZJL3dCN2FTSCtHUWRzK2hIQit0ZWJmQlR4ZExZM3MvZy9WQzBiYjJhMVdUZ280Ky9GL01qM0JyM0t2Q1BqUDRVbTBmVjdmeGpwTzZMZkl2MmhvK3Njdys1SitPQUQ3Z2V0QUh1OUZjMzRHOFZ3K01QREZ2cVNCVXVCKzd1WWdmdVNqcitCNmoyTmRKUUFVVVVVQUZGRkZBQlhoUHhoK0l4bmVid3RvOHY3cFR0dnAwUDNqL3p5QjlQNzM1ZXRkVjhXdmlGL3dqT25mMlJwc3dHclhhY3VwNXQ0enh1LzNqeUIrSjdWNUw4TlBBVXZqVFdqTGRCbDBtMVlHNWs1ekllb2pCOVQzUFllNUZBem9maEg4Ti83YW5qOFE2eEJuVG9temF3dU9MaHdmdkVmM0FmelBzSytoZWxSd1FSVzBFY0VFYXh4UnFFUkZHQXFnWUFBOUtrb0VGZWEvRkQ0bHgrRkxadEwweDFmV1prem5xTFpUL0VmOXIwSDRuanJmK0pYeENnOEdhWjVGc1VsMWU1VStSRWVSR1ArZWpEMEhZZHorTmZQR2g2SnEvamZ4TDlsZ1o1N3U1Y3l6M0VwSkNEUHpPNS96bm9LQmovRFhodlZ2SEhpSDdMYkY1SlpHTXR6ZFM1WVJnbmwyUGNuc081cjZqOEsrRmROOElhTW1uYWRHY2ZlbGxiNzh6OTJZLzA2Q2s4SitGTk84SWFMSHAxZ21UOTZhWmg4OHo5MmIrZzdEaXQyZ1FVak9xSVdaZ3FnWkpKd0FLWlBQRmF3U1R6eUpGRkdwWjNjNENnZFNUWHpwOFMvaW5ONGxlWFNOR2Q0dElCMnlTamhyci9CUGJ2MzlLQU5mNGtmR0I3a3phTjRZbktROHBQZm9jRi9WWXoySCsxMzdldGNENEw4QzZyNDF2ekhhTDVObkczNys4a0h5SjdEKzgzdCtlSzJQaDE4TWJ2eGhNdC9lNzdiUmtibVFjTk9SMVZQYjFiOHVlbjBucHVtV1drYWZEWTZmYngyOXJDdTFJMEdBQi9qNzk2Qm1aNFY4STZUNFEwMFdlbVFZTFlNczc4eVN0NnNmNmRCVzlSUlFJS3pkYjE3VFBEdW5QZjZyZHgyMXV2R1c2c2ZSUjFKOWhYTGVPL2lmcGZnNk5yV0xiZTZzeS9MYkszRWZvWkQySHQxUDYxODc2cnJPdStOOWRTUzZlYSt2WlcyUXdSS1NGLzJVUWRCL2ttZ0RzZkczeGoxWHhBWkxMUnZNMDNUamxTd09KNVI3a2ZkSHNPZmV1ZThJL0QzWGZHTWdrczRQSXNkMkh2SmdRbnZ0N3NmcCtKcjB6d1A4RW9iY1I2aDRwMnp5OE10Z3B5aWY5ZEQvRWZZY2ZXdlpJb1k0SWtpaGpXT05CdFZFR0FvOUFPMUF6ai9BQWg4TXRBOElxazBNUDJ2VUFPYnU0QUxBLzdJNktQcHo3MTJkRkZBZ29yay9GWHhFOFBlRWxaTDI3ODI4QTR0TGZEeUg2am9vK3VLOFM4VWZHVHhGcnBlR3dZYVRabkkyd05tVmgvdFNkdndBb0E5NDhSZU4vRDNoWmYrSnBxTVVjdU1pQlBubGIvZ0k1L092SnZFUHg3dkppMFBoL1RWdDA2QzR1L25mNmhBY0Q4U2E4KzhQK0NQRW5pMmJ6TlBzWlpJM09YdTV5VmpQdVhQM3Z3elhybmgzNERhWmFiSnRmdnBMNlFjbUNETWNYMEorOGYwb0dlTjZqci9BSWs4WFhZaHZMMisxR1ZqOHR1bVdINFJyeCtsZEpvdndiOFc2c0ZlYTFpMDJFL3hYYjRiL3ZoY244OFY5SDZWb1dsYUhiaURTOVB0N1NQMGhqQzUrcDZuOGEwS0F1ZVJhUDhBQVBScmRWZlZ0U3U3eCtwU0hFS2ZUdXgvTVYzR2wvRC9BTUthTnRObm9kbXJqL2xwSW5tTitiWnJwYVFrRHJRSUZSVVVLcWhWSEFBR0FLV3NUVWZHSGh6U00vYjlic1lDT3F0T3BiOGh6WEszM3hzOEcyakVRM04xZUVmOCs5dWNmbTJCUUI2TFJYalYxKzBIcHlFaTAwQzdsSFl5ekpIL0FDM1Zqei90QmFveFAyZlFiTkIyOHlkMi9rQlFGajMyaXZuSnZqejRwTHNWczlLVUhvUEtjNC84ZjVxSnZqcjR0SnlJZE1IdDluYi9BT0tvSFkra3FLK2NFK08vaXRmdlcybHY5WUhIL3M5V28vajlyNmtlYnBHbXVQOEFaTWkvMU5BckgwTFJYaHRyKzBJNDR1L0RnUHZEZGYwSzF1V2Z4NzhPVEFDNnNOUnRtN25Zc2dINU5uOUtBUFZxcGFobyttNnJHWTcreHRycFNNWW1pRC96cm5OUCtLWGd2VWRvajEyM2ljL3dYQWFJL3dEandGZFJhMzFwZXgrWmFYTU53bjk2Snc0L1NnRGg5VitEWGc3VWd4aXNwYkNRL3dBVnBLVkgvZkp5djZWd1dzL0FMVVlOejZOcTBOeW81RWQwbmx0OU53eVA1Vjc3UlFCOGdhdDRTOFRlRlovT3Z0TXZMUW9mbHVZc2xSOUpGNmZwVzVvUHhlOFdhTHRTUzhYVXJjZjhzN3diamoyY1liODgxOVJNb1lFRVpCNml1TThRL0N6d3I0aDN5U2FldHBjdC93QXQ3UDhBZHRuM0ErVS9pS0IzTVh3OThidkR1cTdJdFRTWFNyZzhabCtlSW4yY2RQeEFyMG0zdVlMdUJKN2VhT2FGeGxaSTJES3c5aU90Zk8vaVQ0SGE3cFllZlI1MDFTM0hQbDQ4dVlENmRHL0FqNlZ4T21hNzRpOEdhaTZXZHpkNmRPcC9lVzBnSVUvNzBiY0g2NC9HZ0Q3RG9yeHZ3cjhkck81S1czaVcxK3h5SGo3VkFDMFI5MlhxdjRaSDByMXl5djdUVXJWTHF5dVlyaTNrR1ZraWNNcC9FVUNFdjlQdE5VczVMUyt0b3JpM2tHSGpsVU1wL0ExNHg0eStCb0FlODhLeWU1c0ozL1JIUDhtL092Y0tLQVBqelR0VjhRZUNOYmMyMGx4cDE5RWRzME1pNERlenFlR0grUWE5NThEZkY3VFBFcGlzTlVDYWZxallWUXpmdXBqL0FMTEhvZjhBWlA0RTExUGlyd1ZvdmkrejhuVTdZR1pSaUs1ajRsaStoOVBZOFY4NmVOdmh0ckhneVZwcEYrMmFZVDhsNUd2QTlBNC9oUDZlOUF6NnNvcjV5OEJmR0crMEV4YWRyeGx2ZE5HRldiNzAwQS85blgyUFBwbnBYMEhwMnBXZXJXTVY3WVhNZHhiU2pja2tiWkJIK2UxQWkxWGwzeEQrRWRwNGhFdXFhSXNkcnF4eXp4L2RqdUQ3L3dCMXZmdjM5YTlSb29BK1F0RTEzWHZBSGlHUm9CSmJYTVRiTG0wbUJDeUFmd3VQNUVmZ2ErbHZCbmpqUy9HbW0rZlp0NVYxR0I5b3RYUHp4SCtxK2gvclZUeDM4UE5OOGEyTzVndHRxY2E0Z3UxWGtmN0xqK0pmMUhhdm5LV0x4QjhQdkZJQk1sanFWc2NxeThySXZxT3pJZjhBT0RRUGMrdjZLNHY0Zi9FT3g4YTZmdElXMzFTRlFiaTJ6LzQrbnF2NmpvZlU5cFFJOGsrS1h3c1hXVmwxM1FZUU5UQUxYRnN2QXVSNmovYi9BUFF2clhsM2dEeDdlK0NOV0ljU1M2Yk0rTHExN2c5TjZnOUdIcDM2SHRqNnNyeHo0cy9ESCswRm04UjZIQi9waWpkZDIwYS82NGQzVWYzL0FGSGY2OVFaNnhwdXBXbXI2ZEJxRmhPczlyT2dlT1JUd1IvajdkcXQxOHVmRFg0aHorRGRTK3pYYlBMbzF3Mzc2TWNtRnY4QW5vby9tTzQ5eFgwOWJYRU4zYlJYRnZLa3NNcWgwZERrTXA1QkJvRWN2NC84RFdualhSVEMyMkcvZ0JhMXVNZmRiKzZmOWs5L3o3VjgxV0Y3clBnVHhWNXFLMXRxTmxJVWxpZm93N3EzcXBIOUNLK3dxODMrS3Z3OFh4VHBwMVBUb2dOWXRVK1VEL2w0UWM3RDdqK0UvaDNvR2RaNFQ4VVdQaTdRWWRUc1RnTjhzc1RINW9uSFZUL2ozR0RXNVh5WDRFOFozZmdqeENMakR2WnlueTd5Mzdzb1BVRHN5OXZ4RmZWbGpmVzJwV01GN1p6Sk5iVG9KSTVFUERLZWhvRVdLS0tLQUNpaWlnREg4VStJYlh3dDRkdTlXdXpsWVYrUk04eU9lRlVmVTE0bDhNZkQxMzQ1OFozWGl6VzE4MjNnbjgwbGg4c3MvVlZIK3lvd2NleWlvL2lGcnQzOFJmSGRyNGEwVnZNdExlVXhSa2ZkZVQrT1EvN0tnSEhzRDYxN3I0ZDBLMDhOYUZhNlRaTGlHM1RHNGpsMjZsajdrNU5BelVvb29vRUllbGZDMnUvOGpEcWYvWDNML3dDaG12dWs5SytGdGQvNUdIVS8rdnVYL3dCRE5BSDJEOE52K1NjZUh2OEFyeGovQUpWMU5jdDhOdjhBa25IaDcvcnhqL2xYVTBBRlU5VjB5MTFqUzduVHIyTVNXMXpHWTVGOWovWHZWeWlnRDV3OExhamQvQ2o0azNHa2FuSWY3T25jUlRPZnVzaC8xY3crbmY4QTRGNlY5SEt3WlF5a0VIa0VkNjgyK01YZ3YvaEl2RDM5cVdjVzdVdFBVc0FCa3l4ZFdUM0krOFBvUjNxdjhHUEduOXVhRi9ZZDVMdXZ0UFFlV3pIbVdIb3ArcThBL2hRTTlTb29vb0VGYzk0MDhXV25nN3c5TnFWeGg1ZnVXOEdlWlpEMEgwN2srZ3JkdUxpSzF0NUxpZVJZNFlsTHU3SEFWUU1rbXZsUHgvNHd1UEhIaWN5d2lRMlVUZVRZd0Fja0UvZXgvZVk0L1FVQVV0TTA3V1BpRjR3OHJ6RExlM2toa25uWWZMR3ZkajZBRGdENkN2cXJ3L29WajRiMFcyMHZUNDlrRUM0eWVybnV6SHVTZWE1cjRZK0IwOEhlSHcxd2luVmJzQjdwK3V6MGpCOUIrcHo3VjNGQUJYTitOdkdGbjRNMEdTL3VNU1hEL0piVytjR1YvVDZEcVQySDRWcjZ0cXRub21sWE9wWDh3aXRyZEM4am4wOUI2azlBUFd2bEh4ZjRwdjhBeHY0a2E5bFI5cFBsV2xxdnplV3BQQ2dkMko2K3AvQ2dDcVRyWGpqeFRuNTd6VkwrWG9PQVAvaVZVZmtCWDA3NEc4RldYZ3ZSRnRJTVMzY3VHdXJqR0RJL3Q2S093L3FheHZoZjhQby9DR2xmYkwxRmJXYnBSNXJkZkpYcUl4L1U5ejlLOUJvR0ZSenp4V3R2SlBQSXNjVWFsM2R6Z0tCeVNUNlU5M1ZFTE1RcWdaSkp3QUsrY2ZpcDhTMjhTM0w2Tm84cEdrUk5pU1JUL3dBZlRBLytnRHQ2OWZTZ1JCOFRmaWJMNHJ1SDB2UzVHajBXTnVUakRYSkg4Ui8yZlFmaWZTcC9obDhMWlBFcng2dnJVYng2UURtS004TmRIK2llL2Z0NjB2d3QrR0xlSkpVMXJXWWl1a0kyWTRteURkTVAvWkIzUGZwNjE5R1J4cEZHc2NhaFVVQlZWUmdBRG9BS0JqWUlJcmFCSVlJMGppalVLaUlNQlFPZ0E3Q3BLS1pMTEhERThzcnFrYUFzek1jQlFPcEo3Q2dROGtBWlBTdkdQaUw4WWx0R20wand2TXJ6aktUWDR3Vmo5Ukg2bi9hNkR0bXVmK0pYeFpsMXRwZEc4UHl0RnB2S1RYSzhOY2VvWDBUOVQ5S3hQaDc4TXI3eGxNdDNjNzdUUmtQelQ0K2FZaitHUCtyZEI3bWdaaStHUENPdGVOOVdlS3lSbkc3ZGMzY3hKU1BQVXNlN0gwNm45YStrdkJuZ0hSL0JkcHRzNC9PdkhYRTE1S0J2ZjJIOTFmWWZyVzVwR2o2Zm9XbXhhZnB0c2x2YlJEQ29nL1VudVQzSjVxOVFJS0tPbGVWK08vakpZYUUwdW5hRjVWL3FBeXJUWnpEQ2ZxUHZON0RqMU5BSGZhLzRsMGp3eFlHODFhOFMzajVDQTh0SWZSVkhKTmVEK01malJxK3RHUzAwTVBwbGljanpNano1QjllaWZoejcxeFgvQUJVUGpyWC9BUGw1MVRVcHZ4MnIvSkZINEN2Wi9CbndTc05PMlhuaVZrdjdvWUl0Vko4bEQ3OTNQMTQ5alFNOGs4TWVCUEVQakdmekxHMVlXN05tUzl1Q1ZqejMrYnF4K21hOXY4Sy9Ccncvb1hsM0dvTC9BR3Jlcmc3cDF4RXAvd0JsT24vZldhOUZpaGpnaVdLR05ZNDBHRlJBQUFQUUFkS2ZRSzQxVVZGQ29vVlZHQUFNQVU2c2ZYdkZHaStHYlh6OVcxQ0cyQkh5b3h5Ny93QzZvNU5lUCtKUGoxY3piNFBEbGdJVTZDNnV4dWI2cWc0SDRrL1NnRDNLNXVyZXp0Mm51WjQ0WVVHV2trWUtvL0Uxd091L0dqd3BwTzZPMW1sMU9jZncycS9Kbi9mT0IrV2E4Qm11dkUvamZVZGtqMytyM0pQRWFndUUvd0NBajVWSDVWM0doZkFyWDcvWkxxOTFCcHNSNUtMKzlsL0lmS1B6TkF4TlkrTzNpSzhMSnBkcmE2ZkgyWWd6U2ZyZ2ZwWEZYZmlIeFQ0cW44cWZVZFMxRjJQRU1aWmgrQ0lNRDhxOS93QkYrRFBoSFNsVnJpMGsxR1ljN3J0OHJuMlFZWDg4MTNGbnAxbHA4UWlzcldDM2pBd0ZoakNEOUtBUGx2VGZoVDR6MUw1bzlGZTNVL3gzVHJGK2hPNzlLNnV4K0FPdFRFRy8xZXl0eDNFU05LZjEyaXZvS2lnTG5qOXIrei9wQ1krMTYxZnplb2pSSXgvSTFzUS9BL3dkRVBuaXZwdit1bDBmNkFWNlJSMm9FZk0yZytHZEh1UGpiY2VINTdNUzZYSGNYRWF3TTdkRlVsZWM1Nis5ZTBENFYrQ1Y2ZUg3ZjhYYy93RHMxZVhlSFA4QWs1Qzgvd0N2eTcvOUFOZlFWQXpqRytFL2dkaHpvRVA0U3lEL0FObXFuUDhBQm53VE45M1RaWXYrdWR5NC9tVFhmMFVDUExMbjREZUY1UWZzOTFxZHVmYVpYSDZyV0ZlL3MrRGFUWWVJVG4rN2NXd1A2cVIvS3ZjS0tBUG1uVVBnaDR2dEFUYkxaWHEra1UrMC9rNEEvV3VWdXZEbmlud3pKNTAybWFuWUZUeExHakJmKytsNC9XdnNDa0tnZ2dqZzBEdWZMR2tmRnJ4anBSQ2pWZnRzUzlZN3hCTC9BT1BjTit0ZWdhSDhmclNRckhybWt5d0U5WnJSdk1YL0FMNU9EK1dhOUgxandMNFkxMEU2aG90cEk1LzVhb214eC93SmNHdk90YytBVmxMdmswUFZaYmR1ME4wUE1YL3ZvWUkvV2dEMG5RL0dYaDd4SUIvWldxMjg4aEdURnUyeUQ2cWNIOUszYStUZGUrSFBpdnd3eG51ZE5sa2hqNUYxWmt5S3Z2a2ZNdjRnVmQ4T2ZGdnhUb0JTTjdzYWphcng1TjVsaUI2Qi92RDhjL1NnTEgxTFdScjNoZlJ2RTFyOW4xYXdodVZIM1hZWWRQOEFkWWNpdVM4TWZHUHczcnpKQmVTSFNydHVObHl3OHRqN1NkUHp4WG9hc3JxR1ZnUVJrRUhyUUk4QjhXZkF5L3N0OTE0YnVEZXdqSit5ekVMS3YrNjNSdnh3ZnJYbjJqK0lQRVhnalZYRm5QY1dNNk5pYTFsUTdXOW5RL3o0UG9hK3dLNS94TjRMMFB4YmFtTFZMTlhsQXhIY0o4c3NmMGIraHlQYWdkemtmQm54bDBqWGpIWmF3RTB6VUc0RE0zN21VK3pIN3A5aitacjAwRUVaSFN2bUR4cDhKOWE4S2lTN3RnZFIwd1pKbWlUNTR4L3RwNmU0NCtsSGdqNHJheDRVTWRwZEZ0UTBvY2VUSS96eEQvcG14LzhBUVR4OUtBUHFDbVN4Unp4UEZMR3NrYmdxeXNNaGdlb0k3MWxlSGZFK2srS2ROVyswcTZXWk9qb2VIalBveTlRYTJLQkhodmovQU9DNVFTNnA0VWlKSDNwTk9IODRqLzdLZnc5Szg2OEllTnRZOEQ2bXpXck0xdXpZdWJLWElWeU92SFZXSHIrZWErdDY4NitJZndzc2ZGa1QzK25DTzAxa0RQbVl3ay9zK08vKzExOWMwRE9uOEtlTHRLOFlhV0wzVFpzbGNDYUIrSklXOUdIOGowTmIxZkh0bmU2OTRFOFNsNC9Oc2RSdG0yeVJPT0dIOTFoMFpULzljVjlKK0JQSCtuZU50TzNSbFlOUmhBKzBXaGJsZjlwZlZUNjl1aG9BNit1YjhaZUM5TThaNlNiUzlYWk9tVGIzS0Q1NG05UjZqMUhldWtvb0VmSU9xYVhydncrOFVKSEl6MnQ5Yk41a0Z4RjkyUmY3eWs5VlBRZy9RMTlEL0R2NGgybmpYVGpITHNnMWFCUjU5dUR3dy92cDZyL0kvaFd0NHc4SDZkNHkwWjdHK1RiS3VXdDdoUjg4TCtvOVI2anVLK1liK3gxMzRmZUt3ak0xcnFGbysrS1pQdXlMMlpjOVZQUWcrNE5BOXo2L29ya1BBSGp1ejhiYVA1cWhZZFFnQUYxYkEvZFA5NWZWVDI5T2xkZlFJOEYrTC93MkZrOHZpYlJZTVc3RXRmUUlPSXovQU05RkhwNmp0MTlhb2ZDUDRqSFFycFBEK3JUZjhTMmQ4VzhybmkzY25vVC9BSENmeVBzYStoM1JaWTJqZFF5TUNHVmhrRWVocjVsK0tmdytid2pxbjI2d2lKMGE3YytYam55SFAvTE0rMzkzOHUxQXo2Y29yeUg0T2ZFSTZyYko0YjFXWW0rZ1QvUlpYUE0wWS9oUCswby9NZlExNjlRSThKK00vd0FQL3M4a25pclM0djNibk4vRW8rNmYrZW85ajBiOC9XczM0T2VQam8yb0w0ZTFLYkduM1QvNk03SGlHVTl2WlcvUS9Xdm9XYUdPNGdlR2FOWklwRkt1akRJWUhnZ2l2bGI0a2VDSlBCbmlFeHhLeDB5Nnk5cEo2RHVoUHF2OHNHZ1o5V1VWNXQ4SS9IWjhUNktkTjFDYmRxdGlvREZqek5IMEQrNUhRL2dlOWVrMENDdk9QaTk0MS80UnJ3OS9aMW5MdDFQVUZLS1FlWW91alA3SHNQZlBwWGRhdnFscm9tazNXcFgwbmwyMXRHWkpHOWgySHVlZzl6WHo1NFcweTcrSy93QVI3alY5VVFqVG9IRXN5SDdvUUg5M0NQNit3UHJRQjNYd1g4RS8yTm81MSsraTIzdCtnOGxXSE1VSFVmaTNYNllyMWFrVlFpaFZBQUF3QUIwcGFBQ2lpaWdCRDByNFcxMy9BSkdIVS84QXI3bC85RE5mZEo2VjhMYTcvd0FqRHFmL0FGOXkvd0RvWm9BK3dmaHQvd0FrNDhQZjllTWY4cTZtdVcrRzMvSk9QRDMvQUY0eC93QXE2bWdBb29vb0FLK2MvRzJrWGZ3eCtJbHJyK2tJVnNwNURORWc0VUUvNnlFK3hCeVBZKzFmUmxZSGpQd3hiZUx2RE4xcGMrRmtZYjRKU1A4QVZ5ajdyZjBQc1RRQm9hTHE5cHIyald1cVdVbSszdVl3Nm51UFVIM0J5RDlLdjE0RjhJUEU5eDRiOFIzUGc3V014TE5NeXhLNS93QlZjRHF2MGJISHVCNjE2MzQxOFV3ZUVQREZ6cWNvRFNnZVhieEUvd0NzbFAzUjlPNTlnYUFQTlBqZDQzS0wvd0FJcFlTOHVBOTh5bm9PcXgvajFQdGdkNm8vQlB3UDlzdS8rRXAxQ0xNRURGYkpXSDM1QndaUG9PUVBmUHBYbi9oclJOUThlZU1VdG5sZDVibVF6M2R3ZVNxWnk3ZlhzUGNpdnJMVDdDMjB2VDdleHM0bGl0b0VFY2FMMFZSMG9HV2FLSzh0K01manIrd2RJL3NQVDVpdXBYeUh6SFU4d3c5Q2ZZdDBING1nUjU5OFhmSHA4U2F1ZEkwK1hPbDJUbkxLZUo1UndXLzNSeUIrSjlLNlg0TWZEL2FzZmlyVkl2bVAvSGhFNDZEL0FKNmtlL1JmejdpdUcrR1BnZHZHUGlBRzVRalNyTWg3ay8zei9ER1ByMzl2clgxTEhHa1VheHhxcUlvQ3FxakFBSFFBVURIVVVWNWY4Vy9pSC93amxnZEYwdVVEVmJwUG5rVTgyOFo3L3dDOGVjZW5YMG9FY3g4WVBpUjlwZWJ3eG8wMzdsU1Z2cmhEOTgvODhsUHAvZVA0ZXRjMThNUGh6SjR2dnZ0K29JeWFOYnRoK3h1R0g4QVBwNm44UHBrZUF2Qk4zNDIxNFc0THgyTU9IdTdnZndyL0FIUWY3eDdmaWErcWRPMCsxMHJUb0xDeGdTQzJnUUpIR2c0VUNnWlBEREZid3BEREdzY1NLRlJFR0FvSFFBZWxQb3BydXNhRjNZS3FqSkpPQUJRSWJOTkZiUVBQUElrY1VhbG5kemhWQTZrbnNLK2NQaWI4VDV2RkUwbWs2VEkwV2pJMkdmbzEwUjNQb25vTy9VK2xTZkZQNG1QNGt1Sk5GMGVWbDBlTnNTU0tjZmFtSC9zZ1BRZCt2cFUzd3QrRnphKzhXdWEzRVJwU25kQkEzQnVTTzUvMlA1L1NnWkg4TS9oWEo0amFQV05iamVMU1FkMFVKeUd1djZoUGZ2MjQ1cjZKZ2dodFlJNElJa2lpalVLaUl1RlVEb0FCMEZPUkZqUlVSUXFxQUFvR0FCVHFCQlZYVXRTc3RJc0piN1VMbU8zdFlobDVKRGdEL1BwVkR4TjRvMHZ3bnBMNmhxYyt4QnhIR3ZMeXQvZFVkei9Mdlh6SDR5OGNhdjQ0MU5XbjNSMnF2aTJzWWlTcTU0SFQ3em4xL0tnRHBQSC9BTVhMN3hHWmROMFl5V1dsY3F6L0FIWmJnZS85MWZZYyt2cFdkNEYrRnVxK0wyanU3amRZNlJuL0FJK0dYNXBSNlJxZXYrOGVQclhhL0QzNE5CQkZxM2lxSExjUEZwNTZEME12cWY4QVovUDByMnRFV05GUkZDcW93QUJnQWVsQXpKOE8rR05JOExhZUxMU3JSSVU2dS9WNUQ2czNVbXRpaXZML0FCejhZdE4wQXk2Zm93ajFEVWg4ck9HL2N3bjNJKzhmWWZpUlFJOUExalhOTjBDeGE5MVM4aXRiZGY0cEd4aytnSFVuMkZlSmVMdmpuZVhaa3RQRE1CdEllbjJ1ZFFaVy93QjFlaS9qay9TdlBacmp4TDQvMThCamM2bmZ5ZmRSUjhzYSt3KzZpL2xYcm5nLzRHMmxvSTd2eFBLTHVmaGhaeE1SRXZzeDZ2OEFvUHJRTThsMGp3NzRsOGNhaTgxcGIzTjlLemZ2YnVaanNIKzg3ZnlINVY2LzRaK0JPbVdZUzQ4UVhiWDgzVTI4T1k0aDdFL2ViOUI3VjZ4YTJ0dlpXeVc5ckRIREJHTUpIR29WVkhzQlUxQVhLbW42Wlk2VmFyYTZmWndXc0M5STRVQ2o5S3QwVVVDQ2lpaWdBb29vb0FLTzFGSGFnRDU5OE9mOG5JWG4vWDVkL3dEb0JyNkNyNTk4T2Y4QUp5RjUvd0JmbDMvNkFhK2dxQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0F4WEllSlBocDRZOFQ3cExxd1dDNmIvbDV0Y1J2bjN4dzM0ZzExOUZBSHpaNHArQzJ2Nkx2bjBvalZyUURPSTEyektQZFA0dncvS3VmOE0rUC9Fbmd5ZnlMVzRkcmRHdzlqZEFsQjZqQjVRL1RIMHI2enJsL0ZYZ0RRUEYwYkhVTFFKZFl3dDNEOGtxL2ozSHNjMER1WlBnLzRzYUQ0b01kck0vOW5hazNIMmVkaHRjLzdEOUQ5RGcrMWQ5WHkzNHkrRld1K0ZOOTFHdjlvYWF2UDJpQlR1UWY3YWRSOVJrZlNydmdyNHY2djRjTVZwcWhrMVBUQmdBTzJab2gvc3NmdkQyUDVpZ0Q2WElCNjE1WDQ2K0RlbjYySmRRMEVSMkdvbkxORGpFTXgrbjhCOXh4Nmp2WGY2QjRqMHJ4TnB5MzJsWGFUeEhoZ09HUStqTDFCK3RhdEFqNDl0N254QjREOFJrcDUrbmFsQWNPakRobDlDT2pxZnk5SytndkFIeFIwN3hmR2xuZEJMUFZ3T1lDM3l5K3BqSjYvd0M3MUh2MXJmOEFGbmd6U1BHT24vWnRSaHhLZ1BrM01mRWtSOWo2ZW9QQnI1cDhXK0M5WjhDNnFpM1c0eEZ0MXJldzVDdVIwd2Vxc1BUOHMwRFByZWl2Ry9odDhYbHZ6RG92aVdaVXV6aElMNWpoWmZSWDdCdmZvZlk5ZlpLQkhJK092QUduZU50TzJ5NHQ5UWlVL1o3dFZ5Vi8yVzlWOXZ4RmZOZHpiYTc0RDhUaFdNbGpxVm8yNUhVNUREMUI2TXAvK3NhK3dxNWp4dDRKMC94cHBCdHJvQ0s2akJOdGNxdVdpYitxbnVQNjBES1h3KytJVmw0MTAzYTJ5MzFTQlI5b3RzOWY5dFBWVCtuUTEybGZIdHpiYTU0QzhVaFdMMmVwV2I3a2RUbFdIWWorOHJEL0FBTmZTZmdEeDNaZU50SEVpN1lkUmdBRjFiWis2Zjd5K3FudDZkS0FPdnJsdkhYZ2l5OGE2TWJhWXJEZVJaYTJ1Y1pNYmVoOVZQY2Y0VjFORkFqNC90Ym5YUGgvNHRMQld0dFJzbjJ5UnQ5MlJlNFA5NUdIZjZIclgxSDRTOFZXSGkvUW90U3NXd1Q4czBMSDVvWDdxZjZIdUs1ejRuL0Q2UHhmcFgydXlSVjFtMVErUzNUemw2K1d4L2tleCtwcndyd1Y0dXZ2QXZpVDdSc2tOdVc4cTl0VHdXVUhuanM2ODQvRWQ2Qm4xclZIV05JczlkMG00MHpVSWhMYlhDRkhYdjdFZWhCNUJxVFRkUnRkVzA2MzFDeW1XYTJ1RUVrYnIwSU5XcUJIeUo0bDBEVS9BZmlzMnhsa1NXQnhOYVhTOGIxejhyajM3RWV1YStqdmg5NDBnOGFlSFV1dmxTL2d4SGR3aitGLzd3LzJUMUg0anRUUGlMNEtpOForSFdnakNycU52bVMwbFBHRzdxVC9BSFc2ZmtlMWZPM2cvd0FUWDNnWHhXdDBZNUZWR01GN2JIZ3NtZm1YSDk0SGtlNDk2Qm4xeldCNHg4TFd2aS93NWNhWGM0VjJHK0NYSE1VZys2dy9rZlVFMXIyTjdiYWxZd1h0cEtzdHZPZ2tqa1U4TXA1QnF4UUkrUGJHODFid0w0dVdZSVlkUTArWXBKRTNSaC9FcDlWWWZ6QnI2dzBEVzdUeEZvZHJxMWsrNkM0VGNBZXFudXA5d2NqOEs4ditOM2drWGxpUEZGakgvcEZzb1M4VlI5K0xzLzFYdjdIMnJ6ZndaOFJkUThIYVZxdGhBcGxXNWpMVzJUeEJOMDM0OU1kdlVDZ1oxL3hmOFZYSGlMeEJiK0R0R3pNc2N5ck1xZjhBTFdjL2RUNkxubjMrbGVzK0NmQ3NIaER3emJhWkZ0YWJIbVhFb0grc2xQM2o5T3c5Z0s4MitDZmcxbjh6eGRxU3M4c3BaYlB6T1NjbjU1VDdrNUFQMVBldmE2QkJSUlJRQVVVVVVBSWVsZkMydS84QUl3Nm4vd0JmY3Y4QTZHYSs2VDByNFcxMy9rWWRULzYrNWY4QTBNMEFmWVB3Mi81Sng0ZS82OFkvNVYxTmN0OE52K1NjZUh2K3ZHUCtWZFRRQVVVVVVBRkZGRkFIaWZ4dThIdWpSZUw5T1VwSkVWUzhNZkJHQ05rdjFCd0Qvd0FCOUs4MThaZU90UjhaalRoZllSTE9BSVZVOFBKL0hKK09COU9mV3Zkdmk5NG9qOFArREo3Uk5qWG1wQTIwU01BY0tSODdZOWgrcEZlT2ZDZndoL3dsSGl4SmJtUGRwMm40bm56MGRzL0luNGtaUHNwb0dldy9DUHdiL3dBSXg0WkY1ZHhiZFMxRUxMS0NPWTAvZ1Q5Y24zUHRYb1ZBNEZGQWpLOFI2OWFlR3RCdTlXdlcvZFFKa0xubDI2S285eWVLK1VKNWRXOGNlTFM1SG42bHFNK0ZVZEJub1BaVkg2Q3UxK05IakwrM05mR2lXY21iSFRtSWtJUEVrL1EvZ280K3VhNjc0SStDeFphZTNpZStpLzBtNlVwYUJoeWtYZHZxeEg1RDNvR2VpK0V2RFZwNFQ4TzIybFdvRGVXTjBzdU9aWkQ5NWo5VCtRd0szS0tpdWJtR3p0WmJtNGtXS0dKQzhqdDBWUU1rbWdSei9qanhmYStEZkRzdW9UQlpMaC8zZHRBVC9yWkNPQjlCMUo5SytYN08wMWZ4djRxRVNzMXpxTi9NV2VSdWc5V1Bvb0g2QUN0RHg5NHduOGFlSkh1d1hGbEZtS3poL3VwbnJqKzgzVS9nTzFlNWZDandHUENlaWZiYjZMR3IzcWd5NTZ3cDFFZjE3bjMrbEF6cVBDbmhpeDhKYURCcGRrdVFuelN5a1lhVnoxWS81NEdCVzNSUlFJSzhHK01IeEkrMXlUZUdOR20vY0tkbDlPaCsrZThTbjBIOFI3OVBXdW4rTG54RFBoNnhPaWFYTmpWYnBNeVNLZWJlTTkvOTQ5dlRyNlY1SjhPL0F0eDQxMXpaSUhqMHkzSWE3bUhVK2lLZjd4L1FjK2xBelorRm53M2J4VGRycTJxUkVhTkEvQ0hqN1M0L2gvM1IzUGZwNjE5SlJ4cEZHc2NhS2lLQUZWUmdBRG9BS2lzN08zMCt6aHRMU0ZJYmVGQWtjYURBVlIwQXFlZ1FWejNqRHhqcHZnM1IydmI1OTByNVczdDFQenpONkQwSHFlZ3AzaTd4YnAvZy9SSDFHK2JjeCtXQ0JUODB6OWxIOVQyRmZMMnJhcnJmajN4UUpwVmU1dnJweEhCYnhENVVYc2lqc0IzUDFKb0FYVzljMXp4NzRqV2FjUGMzY3plWGJXc0lKVkFlaUlQNW52MU5lN2ZEajRXV3ZoV09QVTlVQ1hPc3NNZzlVdHM5bDlXOVcvS3J2dzYrSEZwNE1zaGMzR3k0MWlaY1N6NDRqSDl4UGIxUFUvcFhlVURDcW1wYW5aYVBZUzMybzNNZHRheERMeVNIQUgrSjlxei9BQlI0cTB2d2pwTGFocWMyMGZkaWlYbDVXL3VxUDhnVjh5K0xmR2V0ZVBOWFR6Zy9rNzl0cll3NVpWSjRISDhUbjEvTEFvRWRINCsrTHQvNGpNdW5hTVpMSFNqbFdmTzJXY2U1L2hYMkhQcjZWVThDL0NqVlBGZmwzdDV2MC9TZW9sWmYza3cvMkZQYi9hUEhwbXU1K0h2d2FoczFpMVh4UkVzMXp3MFZpZVVpOUMvOTV2Ym9QZXZZd0FvQUFBQTZBVURNbncvNFowbnd4cDYyZWxXYVFKL0czVjVENnMzVW10ZWlpZ1FVVVVVQUZGRkZBQlJSUlFBVVVVVUFGSGFpanRRQjgrK0hQK1RrTHovcjh1Ly9BRUExOUJWOCsrSFArVGtMei9yOHUvOEEwQTE5QlVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFJUUNNRVY1ZDQ1K0RlbmE3NXQvb1FqMC9VVDh6UkFZaG1QdUI5MCs0L0VWNmxSUUI4Z1F6K0kvaC80aU8zejlPMUNIN3lNUGxrWDNIUjFOZS8rQWZpbHB2aTlFc3JyWlphdUJ6QVQ4czNxWXlldis3MUh2WFIrS1BDT2tlTHRPTm5xbHZ1SzVNVXljU1JIMVUvMDZIdlh6VjR5OENheDRGMUZXbExTMmpQbTJ2b3NxQ1IwQi91di9rR2daOVpWUzFYU2JIVzlPbXNOUnRvN2kybUdIamNjZlVlaEhZOXE4bCtHL3hnRjIwR2krSnBsV2M0U0MvYmdTZWl5ZWpmN1hROStldnM5QWo1YytJZncxdlBCdHlicTMzM1dqU3RoSmlNdEVUMFNUK2g2SDYxMWZ3ditMQnRURG9QaU80SnQrRXRiMlE4cDJDU0gwOUc3ZEQ2MTdsZFd0dmZXc3RyZFFwTkJLcFNTTnhsV0I2Z2l2bXY0bC9EU2J3amN0cU9uSTgyaXl0d1R5YmNuK0Z2VmZRL2dmY0dmVElJSXlPbExYZy93bitLQnRYZzhONjlQbUFrUjJkMUlmOEFWbnRHNTlPd1BicDZWN3hRSTVMeDk0RnN2RzJqbUY5c09vUWd0YTNPUHVuKzYzcXA3ajhhK2E3TzcxdndGNHIzcXJXdXBXVWhTU04vdXNPNm4xVWp2OUNLK3dhODgrS1B3OGo4WGFZYjZ4UlYxbTFUOTJlbm5wL3p6UDhBUTlqN0dnWjB2aEh4WFllTU5DaTFLeWJheCtXYUVuNW9aTzZuK2g3aXQ2dmtqd1Y0dXZ2QTNpTVhLcElZR1BsWGxxZUM2Zzg4SG95bk9QeEhldnEzVGRSdGRXMDYzdjdHWlpyYTRRUEc2OUNEUUl0VjRwOFovaDk1c2N2aXJTNGYzaUROL0VnKzh2OEF6MUE5UjBQdHoyTmUxMDEwV1JHUjFES3d3VllaQkhwUUI4NS9CL3g5L1lHcGpROVNteHBsNC83cDJQRUVwLzhBWlc3K2h3Zld2bzZ2bHY0b2VCbThINi81dHJHZjdKdlNXdHoyalA4QUZHZnAxSHQ5SzlXK0QvanIvaEl0SE9qNmhOblU3RkFBekhtYUxvRzl5T2gvQTk2Qm5wMWVGL0c3d1I1Y24vQ1Y2ZkZoR0lTL1ZSMFBSWlA1QS9nYTkwcUM4czROUXNwN082aldXQ2RESElqRGhsSXdSUUk4TytDSGpZMjl5ZkN0OUwrNmxKZXhaajkxK3JSL2p5Ujc1OWE5NHI1RjhYZUhyendQNHZrc2tra1R5WEU5bmNEZ3NtY28yZlVFWVB1SytrL0FYaXlMeGg0V3Q5UUJVWFMvdXJxTWZ3eWpyK0I0STlqUU5uU1RSUnp3dkRLaXZHNmxXVmhrTUR3UWErVFBpRDRTZndmNHBuc1FyZllwY3kyam52R1QwK3Fuajh2V3ZyYXVHK0tmaEQvaEsvQ2NwdDR3Mm8yV1o3YkhWc0Q1ay80RVAxQW9FTytGZmlpSHhMNE10Z0ZqanVyRlZ0cDRrR0FObytWZ093STUrdWE3ZXZsTDRaK0xENFQ4WFFTeXlGYkM2eEJkQTlBcFBEZjhCSno5Q2ErckFRUUNEa0gwb0FXaWlpZ0Fvb29vQVE5SytGdGQvd0NSaDFQL0FLKzVmL1F6WDNTZWxmQzJ1LzhBSXc2bi93QmZjdjhBNkdhQVBzSDRiZjhBSk9QRDMvWGpIL0t1cHJsdmh0L3lUanc5L3dCZU1mOEFLdXBvQUtLS0tBQ2tZaFZKSkFBN21scmdmaTc0cFBoendaTkRCSnR2ZFJ6YlFrSGxWSStkaDlCeDlTS0FQRGZpUjRvYnhkNHl1TGlGbWV6Z1AyYTBVZDFCNUk5MmJKL0t2b1A0YytGUjRUOElXMXBJZ0Y3TisvdWpqbnpHSFQvZ0l3UHdyeEQ0TytGdjdmOEFHQ1hzMGU2eTB6RTc1SEJrL3dDV2EvbUMzL0FhK25LQnNLNDc0bGVMaDRSOEp6WEVMQVg5eis0dFIvdGtjdC93RVpQMXhYWTE4c2ZGVHhYL0FNSlI0eG44bVRkcDlqbTN0OEhoc0g1My9FajhnS0JHZjRDOEt5K012RmtGaSs4MnFuenJ5VFBQbGc4OCtySGo4U2ErdElvbzRJVWlpUlVqUlFxcW93RkE0QUZjSjhKZkNQOEF3alBoS09lNGoyNmhxR0o1ODlVWEh5SitBT2ZxVFhmVUFGZUkvSER4dGdEd3BZeThrQ1MrWlQyNnJILzdNZnc5YTlQOForSjdmd2w0WXV0VW13MGlqWkJHZitXa3ArNnY5VDdBMTh0Nk5wbXBlTnZGc2RvSkdsdkw2WXlUVHR6dEdjdTU5Z1A2Q2dhTzgrQy9nZjhBdGpWUCtFaTFDTE5sWlBpM1JoeExNTy8wWCtlUFN2b2VxT2o2VGFhSHBGcnBsakhzdHJhTUlnK25jKzVQSit0WHFCQlhOZU9QRjFyNE44T3k2aEx0ZTRiOTNiUUUvd0Nza1BRZlFkVDdDdWhubml0cmVTZWFSWTRvMUx1N0hBVlFNa212bEQ0Z2VNWnZHdmlaN2xDLzJHSE1WbkZqK0RQM3NmM200UDVDZ0NocHRocS9qcnhZSUZjejM5OUtYbG1mb28vaWMraWdkdm9LK3EvRFhoMng4TGFGYjZWWUppT0lmTTVIelNPZXJON2svd0NGY3Y4QUN2d0tQQ1doZmFieUlEVnIwQnB5ZXNTOVJHUHAxUHY5SzcrZ1lWbTY5cnRoNGMwZTQxVFVadkx0NFZ5ZlZqMlZSM0pQQUZYcDU0cmFDU2VhUlk0bzFMdTdIQVVBWkpKOUsrVy9pVDQ4bThaNjN0Z1prMG0xWWkyajZiejBNakQxUGIwSDFOQWpMOFQrSk5WOGVlSmhjU1J1OGtqK1ZhV2tmemVXcFBDcjZrOXozUHRYdnZ3MCtITUhnNndGM2VLa3VzenIrOWtISWhYL0FKNXFmNW51ZmFzajRTZkRqK3dyVk5lMWVIL2lhVHBtR0p4L3g3b1IzLzJ6MzlCeDYxNnRRTUs1enhsNHkwN3dabzV2Ynh2TW1mSzI5c3B3OHplZzlBTzU3VS94ajR1c1BCMmh5YWhldHVrUHkyOENuNXBuN0FlM2Nuc0srWUwyKzE3NGcrS1VadzEzcUYwMnlLSk9GUmY3cWorRlIxSlAxTkFoMnA2cHIzeEI4VHE4aXZkWDF3MnlDM2krN0d2OTFSMlVkeWZxYTk5K0hmd3lzdkI5dXQ3ZCtYZGF5Ni9OTmpLd2c5VlQrcmRUN0NydncvOEFoOVkrQ2RPejh0eHFreWdYRnpqL0FNY1QwVWZyMU5kblFNS0tLS0JCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGSGFpanRRQjgrK0hQK1RrTHovcjh1L3dEMEExOUJWOCsrSFA4QWs1Qzgvd0N2eTcvOUFOZlFWQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVlcxRFQ3VFZiR2F5dnJlTzR0cGwyeVJTRElZVlpvb0ErVS9pVjRPdHZCbmlOYlMwdXZPdHJpTXpSeHZ5OFM1eHRZOS9ZK2c1OSt1K0YveFhmVG1oMEx4Rk9Xc3poTGE4a09URDZLNTdyNkh0MzQ2VUlrVDRqZkhOeTZpYlRvcHlTQ01xWUllQUQ3TTMvb1ZSZkUvNFl5ZUdKbjFmU1VhVFJwR3k2ZFRhc1QwUHFoN0h0MFBhZ1o5SXFReWdnNUI1QkZSWFZyQmUyc3R0Y3hKTEJLcFNTTnhsV1U5UVJYaFB3bStKeHNKSWZEdXV6LzZJeENXbHpJZjlVZXlNZjd2b2UzVHBYdmxBajVkK0pmdzdtOEc2aDlxdEZlWFJyaHNST2VUQ3gvNVpzZjVIdVBjVjMzd2grSkp2MGk4TmF6UG02UWJiTzRjOHlxUCtXWlA5NERwNmozSFByR3FhWmFhenBseHA5L0NzMXJjSVVrUnU0L29lNE5mSzNqYndmZmVCZkVRZ0x5RzNadk5zcnBlQ3dCOVIwZGVNL2dlOUF6NjFvcmdQaGQ0K1h4aG81dGIxMUdyMmlnVGpwNXE5QklCNzkvUS9VVjM5QWp4SDQwZkQvS3llSzlMaHdSL3gvd0FTRHFQK2VvSC9BS0YrZlkxZy9CN3g2ZEIxTWFEcU11Tk52SlAzVHVlSUpUL0pXNysvUGMxOUZTUnBORTBjaWhrY0ZXVmhrRUhxRFh5ejhUZkJEZUR2RUorem8zOWxYWkwycmYzUDcwWlBxTzN0ajNvR2ZWRkZlYmZDSHh3ZkUyaG5UTDZYZHFsZ2dCWmp6TkYwVi9xT2gvQTk2OUpvRVl2aXJ3M1orSy9EMXpwVjRNQ1JjeHlBY3hTRDdyRDZIOU0xOHIyODJyZUJQR0FmSGs2anAwK0dYczQ3ajNWbC9RaXZzS3ZJUGpkNExGL3BxK0pyS1A4QTBtelVKZEtvNWVIczMxVW44ajdVRFI2WjRlMXkwOFNhRmFhclpObUc0VGR0enloN3FmY0hJclRyNTArQ3ZqTCt4OWRPZzNrdUxIVUd6Q1dQRWMrT1B3WWNmVUN2b3VnUjU5OFcvQjMvQUFrM2hkcnExaTNhanA0TXNXMGN1bjhhZmlPUjdpdkhmaFA0di80UmZ4WEhGUEpqVHRSMnd6WlBDTm41SC9BbkgwYjJyNmpyNWErSzNoTC9BSVJmeGRLMEVlM1Q3L2RQQmdjS1NmblQ4Q2MvUmhRTkgxTFJYQ2ZDZnhZZkUvaENOTGlUZGYyR0xlZlBWZ0I4ai9pUDFCcnU2Qkh5L3dERjN3bVBEZmk1N2kzajIyR281bmlBNksvOGEvbWMvUnE5ZCtEM2lyL2hJZkNLV2R4SnV2dE54QkpucXlZK1J2eUdQcXRhZnhMOEwvOEFDVmVEYnEzaWpEWHR2L3BGcWNjNzFIM2YrQkRJL0VWNEI4TlBFNThMZU5MVzRsWXJaM0orelhJUFpXUEJQMGJCL09nWjlYMFVnT1JtbG9FRkZGRkFDSHBYd3Rydi9JdzZuLzE5eS84QW9acjdwUFN2aGJYZitSaDFQL3I3bC84QVF6UUI5Zy9EYi9rbkhoNy9BSzhZL3dDVmRUWExmRGIvQUpKeDRlLzY4WS81VjFOQUJSUlJRQVY4dC9GdnhOL3drUGplNGppazNXZW5nMjBXT2hJUHp0K0xjZlJSWDBCNDg4US84SXY0TjFEVTFZQ2RVOHUzQjd5dHd2OEFQUDRWODQvRGp3NmZGSGppeHRaUVh0NG0rMDNKUGRGSU9EL3ZOZ2ZpYUJvOTkrRnZobi9oR2ZCTnJIS2dXOHUvOUp1UFVNdzRYOEZ3UHpydGFCMG9vRWNQOFZmRlAvQ00rQzdqeVpOdDllLzZOYjQ2Z2tmTTM0TG44U0s4TytGdmhVZUtQR1Z1azhlNndzd0xpNEI2TUFmbFg4VCtnTld2akI0bS90L3hyTmJReWJyUFRRYmVQQjRMNS9lTitmSC9BQUd2WVBoRDRZLzRSN3dWRFBOSHR2ZFJJdVpzamxWSStSZndYbjZrMERPL29vcmtQaVY0cS80UlB3ZGMzVU1nVzluL0FIRnFPKzloOTcvZ0l5ZndvRWVMZkdMeGQvd2tIaWs2ZGJTWnNOTUxSakI0ZVgrTnZ3KzZQb2ZXdlJ2Z3I0T0dqZUh6cmw1RmkrMUZRWXd3NWpoL2hIL0F2dkgyeFhqdnc5OEt2NHY4WDI5bklHYXppL2YzYkgvbm1EMEo5V1BINStsZldTSXNhS2lxRlZSZ0FEQUFvR3gxRkZaSGlmWDdid3g0ZHZOWHVqOGtDWlZPN3VlRlVmVTRGQWp5NzQ0ZU5Qczl1bmhheGt4Sk1CSmVzcDVWUDRVL0hxZllEMXJuL2d0NEovdGpWajRodm84MmRpK0xkV0hFazNyOUYvbVI2VndsbmJhcDQ1OFlMRnVNbW9hbGNGcEg3Sm5sbS8zVkEvSUFWOVo2SnBGcm9PaTJtbDJTYkxlMmpDTDZuMUo5eWNrL1dnWm9VVVZ4dnhKOGFKNE44TlBORVZPbzNPWXJSRC9leHk1SG92WDY0SGVnUjU1OGF2SGhsbGZ3cHBzdjd0Q0RmeUllcDZpTCtSUDREMXFqOEcvaC93RDJyZHA0azFTSE5qYnYvb2tiRGlhUUg3NTlWVTlQVS9TdU04RStGYnZ4eDRwUzBaNVBJM2VkZTNCNUtwbm5uKzh4NEgxSjdWOVgyVm5iNmRaUTJkcEVzVnZBZ2pqalVjS280QW9HVDFuYTdyZGo0ZDBlNDFUVVpoSGJ3TGsrckhzb0hjazhBVmZra1NLTnBKR1ZFVUZtWmpnQURxU2ErWHZpZjQ5azhZYTBZTFdSaG85b3hGdXYvUFZ1aGtQMTdlMzFvRVpIaVh4RnEzajd4T3M3eHlTU1N1SWJPMGorYllwUENqMUo3bnY5QlhlZkFhNXRyWHhKcTJuWE52R3Q4OFFNY2pENTFDTmgwL1VIOEs2bjRSL0RyK3diSk5lMVdIR3FYQ2Z1WTJITnZHZjVPZS9vT1BXdUo4VWcrQVBqZERxcUFwYVR6TGRISEFNY255eWo4OXhvR2ZSZEZJckIwREtRVkl5Q080cGFCQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUjJvbzdVQWZQdmh6L2s1QzgvNi9Mdi93QkFOZlFWZlB2aHovazVDOC82L0x2L0FOQU5mUVZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFWekh4QjF6L2hIdkErcDM2dGlieXZLaDk1SCtWZjU1L0N1bnJ3MzQ5NjI4MXhwWGg2M0paditQcVZGN3Nma2pIMSs5K2RBRno0QmFENVduYWpyMGd5MDdpMmlZOWRxOHNmeFkvcFhzVThFVnpCSkJQR2trVWlsWFJ4a01EMUJIY1ZrZUVkRVh3NzRUMDNTZ0FHdDRGRWhIZHp5eC83NkpyYm9BK1lmaWQ4T3BQQitvZmJiRkdmUmJsOFJucVlHUC9MTmo2ZWgvRHIxN3I0UC9FYzM2UmVHZFpuemRJdUxLZVE4eXFQK1daUDk0RHA2ajNIUHJPcDZiYWF4cHMrbjM4S3pXczZGSkVidVA4ZmV2bFR4cjRTdnZBdmlUN1A1a25rRStiWlhTOEZsQjQ1N01weG44RDNvR2ZXMVlQaS93clplTDlBbTAyN0FWeU4wRXdHVERJT2pEK283aXNMNFkrUEU4WTZKNVYweUxxMW9BdHdnNDh3ZHBBUFE5L1EvaFhkMENQaitHWFdmQUhqRGRnd2FqWVM0WlQ5MTE3ajNWaCtocjZvOE1lSXJQeFRvRnRxMWtmM2N5L01oT1dqY2ZlVSs0UDhBUTF4SHhnOENqeEJveDFtd2l6cWRpaExLbzVuaUhKWDZqa2o4UjNyeS93Q0ZIamMrRlBFSXRidVhHbFg3QkpzOUluNkxKL1ErMzBvR2ZUOVlQakR3dmErTHZEbHhwZHpoV1lib1pjY3hTRDdyZjBQc1RXNkNHQUk2R2xvRWZIdW1YK3FlQmZGeXorV1lyNndtS1RRazhPT2pJZllqdjlEWDFwbzJyV211YVBhNm5ZeWI3ZTVqRWlIdVBVSDNCeUQ3aXZJdmpsNE44eUdQeFRaUmZQR0JGZWhSMVhvci9oMFBzUjZWbWZBN3hnYlBVWlBERjVKaUc1Smx0Q3grN0lCOHlmOEFBZ00vVUgxb0dlL1V5YUtPZUY0WlVWNDNVcXlzTWhnUmdnMCtpZ1I4aytQUEM4dmczeGRQWlJsMXRtUG4yY2c2K1dUeHo2cWVQd0ZmUlB3NThXTDR1OEpXOTNJdysydy91YnRSL3dBOUFQdmZSaGcvbjZWbC9GM3dsL3drbmhKN20yajNhaHAyWjRzZFhUK05QeEF5UGRSWGozd2s4V2Y4STM0dmlnbmsyMkdvN1lKc25oVy9nZjhBTTQraDlxQm4xRlhGL0Uvd3Ivd2xYZzY0aWhUZGZXdWJpMjQ1TEFjci93QUNHUjljVjJsRkFqNVYrRnZpai9oR1BHbHM4ejdiSzh4YlhHVGdLQ2ZsWS9Sc2ZnVFgxVjFyNVgrS3ZoZ2VHL0cxeUlZOXRsZmY2VEFCd0JrL09vK2paL0FpdmRmaGY0bS80U2J3VFp5eXlCcnkxSDJhNDlTeTlHL0ZjSDg2QnM3T3ZsajRzZUdSNGQ4YlhKaWoyMlYvbTVoQUhBeWZuWDhHeitZcjZucnpyNHplSFA3YjhGUGVReGxyclRHKzBMZ2NtUHBJUHk1LzREUUpGLzRWK0pqNGw4RVdyVFB1dkxQL0FFVzRKUEpLajVXL0ZjSDY1cnRxK2EvZ3A0ai9BTEk4WkhUWlh4YmFtbmw4bmdTcmtvZng1SDRpdnBTZ0Fvb29vQVE5SytGdGQvNUdIVS8rdnVYL0FORE5mZEo2VjhMYTcveU1PcC85ZmN2L0FLR2FBUHNINGJmOGs0OFBmOWVNZjhxNm11VytHMy9KT1BEMy9YakgvS3Vwb0FLS0taTElrTVR5eU1GUkFXWmowQUhVMEFlRC9IdnhBWjlTc1BEOFQvSmJyOXBuQS92dGtLRDlCay9qWFEvQW53OTlpOE9YT3VTcGlYVUpOa1JJNThwQ1IrclovS3ZGOWF2cm54ajQwdXJtSUZwdFJ1OWtDOWNBa0tnL0FZL1d2clRSdE1oMGJSYkxUYmNBUldzS3hManZnWXovQUZvR1hxNTd4djRoWHd2NFExRFZNanpVajJRRDFsYmhmMU9md3JvYThIK1BuaUh6cjNUdkQ4TC9BQ3dxYnFjRCs4ZUVCK2czSDhSUUk4KzhCK0gzOFYrTmJHeGx6SkNaUFB1bVBlTmVXejlUZ2ZqWDF3cWhWQ2dBQWNBRHRYa1B3RzhQL1pkRXZOZWxURWw2L2t3a2ovbG1uVWo2c1QrVmV2MERZVjh4L0dMeFAvYjNqS1N6aGszV2VtWmdUQjRNbi9MUnZ6d3YvQWE5NThkZUkxOExlRDcvQUZNRWVlcWVYYmc5NVc0WDllZndyNXA4QitIWDhXZU03S3dsM1BBWDgrNlkvd0RQTmVXejlUZ2ZqUUNQZFBnNzRWL3NEd2dsOVBIdHZkVHhPK1J5c2Y4QUF2NUhQMU5laTAxRkNJRlVBS0JnQWRxZFFJSytlZmpoNHNPbzY1RjRldFpNMjFnZDgrRHcweEhBL3dDQWo5U2E5czhXZUlJZkMvaG0rMWFYQk1NWjh0RC9BQnlIaFYvRTRyNVo4TjZQZCtOUEdOdll5U004bDVPWmJtYnVGenVrYitmNGtVRFI3RDhEZkNJc2RKazhTWFVlTGk5Qmp0Z1I5MkVIay84QUFpUHlBOWE5ZnFLMXRvYk8waHRyZU1Sd3hJRVJGNktvR0FQeXFXZ1F5YWFPM2drbW1kVWlqVXU3c2NCUUJrazE4bWVPZkZOeDQyOFdTM2NZa2EzRGVSWlFnYzdNOGNmM21QUDRnZHE5YStPUGk3K3o5SGk4TzJrbUxtK0crNElQS3dnOVArQkVZK2dOY3I4RWZCNDFUV1g4UTNrZWJXd2JiYmdqaDV2WC9nSS9VajBvR2VyL0FBNThIUitEdkRFZHU2cWIrNHhMZHlEdStPRitpamo4ejNycjZLNXp4djRxZzhIK0diblVwTnJ6NDh1MmlKLzFrcDZENmR6N0NnUjV6OGJQSFJ0NGo0VjA2WEVzcWhyNTFQS29lUkg5VDFQdGoxckErRG5nSWExcUE4UTZsRHUwKzBmRnZHdzRtbEhmSGRWL1UvU3VMOE9hSnFQanZ4ZWxxMHJ2TmN5R2E3dUNNN0Z6bDNQOGg3a0N2ckhUTk90ZEkweTMwK3lpRVZ0YnhpT05CMkEvclFNdDE1TDhlTkJGNTRadE5ZalRNbGpOc2tJSFBsUHgramJUK0pyMXFzN1h0SmgxM1FiN1M1LzlYZFF0RVNleEk0UDRIQi9DZ1J6dnd0MTcrMy9BT255U1B1dUxaZnNzM3J1VGdIOFYybXV6cndUNEdhckxwZmliVmZEVjRTanlndXFIdExHZHJqOHYvUWE5N29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLTzFGSGFnRDU5OE9mOG5JWG4vWDVkLzhBb0JyNkNyNTk4T2Y4bklYbi9YNWQvd0RvQnI2Q29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUVKd0NTY0QxcjUwMExQeEErT01sK3dNbG5CT2JnY1pIbFJmTEdQeE8wL2pYcjN4TDE0K0h2QWVwWEtOdG5tVDdQQ2Y4QWJmNWMvZ01uOEs0NzRDYUVMWFFiL1duVEQza29oaUovNTV4LzRzVCtWQUhyOUZGRkFCWE8rTmZDVnA0eDhQVGFkY1lTWWZQYlQ0NWlrN0g2ZGlPNHJvcUtBUGtEVE5RMWJ3RDR3RTNsbUcrc1pUSE5BeDRkZjRrUHFDT2graHI2dTBMV3JUeERvdHJxdGkrNjN1RUREMVU5MVB1RGtINlY1bjhhL0JBMUxUditFbXNJczNkb21McFZITWtJL2krcS93QXMrbGNmOEdQR3AwVFhQN0N2WmNXR29QOEF1aXg0aW42RDhHNmZYRkF6Nk5yNWwrTHZnci9oR2ZFWDlvV2tRWFROUlpuUlZIRVVuVms5Z2VvL0VkcSttcXcvRjNodTI4VitHcnZTYmpDK2F1WXBNZjZ1UWNxMzRIOUNhQkhIZkJ2eG1mRUhoODZSZXk3dFEwNVFvWmp6TEQwVnZxUHVuOFBXdlRhK1FkQjFYVVBBdmpLTzVlTmt1TEtZeFhNSDk5YzRkZnk2ZStLK3RySzl0OVJzWUx5MWtFbHZPZ2tqY2RHVWpJTkEyTGUyY0dvV005bmRSaVNDZERISWpkR1VqQkZmSS9pUFJyM3dSNHhtc2trWkpyT1paYmFjY0VybmNqLzQrNE5mWHhZS0NTY0FkVFhpUHh5R2dhaloybDViNnBaTnE5cS9sdEFrb1o1SW02OEQrNmNINkUwQWoxTHdkNGpoOFZlRjdMVm9zQjVVMnpJUDRKQnd5L24raEZidGZNUHcwK0l5ZUNQdDhGN0JQY1dWd0JJa2NXTXJLT004bm9SMStncnRaUDJoTFFIOTE0ZHVISHExeXEveVUwQlk5b0l5Q0RYeWo4VFBDNThLK003cTNoUXBaWFArazJwSEdGWThxUDhBZE9SK1ZlaUwrMEpCbjV2RGN3SHRkai80bXVZK0lYeEMwUHgxb2NDTHA5NWFhbmF5N29XWUs2TXA0ZFNRY2pzUngxRkFIc2Z3MDhUbnhUNEx0YnFaOTE1Qi9vOXp6eVhVRDV2eEdEK05kZlh6WDhGUEVoMGp4aC9aa3o0dHRUWHl3Q2VCS3VTaC9FWkg1VjlLVUNQT2ZqTjRiR3RlQ3BMNkZNM1dtTjlvVWdjbVBvNC9Mbi9nTmVaL0JMeEYvWlBqQnRMbWt4YmFtbXdaUEFsWGxUK0kzRDhxK2o1b2tuaGVLVkE4YnFWWlQwSVBCRmZJUGlEVGJud2Q0MHVyT0ZtU1d3dVE5dS9US2dob3orV0tCbyt3YVpORWs4THhTb0hqZFNyS2VoQkdDS282RHE4T3ZhRFk2cEFSNWQxQ3NvQTdFamtmZ2NqOEswYUJIeDc0ZzB5NThIK003dXlpWmtsc0xrUGJ2MCtVSGRHZnl4WDFoNGYxZUxYL0FBL1k2ckJqWmRRckpnZndramtmZ2Npdkd2ajdvUGwzbW02OUVuRXFtMW5JSGNmTWhQNEZoK0ZiUHdGMTc3Vm9GN29rclprc3BmTmlCLzU1djFINE1ELzMxUU05ZW9vb29FSWVsZkMydS84QUl3Nm4vd0JmY3Y4QTZHYSs2VDByNFcxMy9rWWRULzYrNWY4QTBNMEFmWVB3Mi81Sng0ZS82OFkvNVYxTmN0OE52K1NjZUh2K3ZHUCtWZFRRQVZ4SHhaMXc2SjhQNzh4dVZudXdMV0lnOTMrOS93Q083cTdldkJQai9ySG02cnBXakkzeXdSTmN5QUgrSmp0WFA0SzM1MEFZSHdXMFFhcDQ4anUzVE1HblJHZm5wdlB5cC9NbjhLK21xOHIrQk9qZll2Q0Z4cWJyaVRVTGdsVGovbG1ueWo5ZHhyMVNnR05rZFk0MmQyQ29vSllrOEFWOGYrSWRSdVBGM2pTOHZJUVhrdnJyWmJyL0FMSk8yTWZsaXZvNzRxNjJkRStIMm95STIyYTVVV3NYMWZnLytPN3E4VytET2hqVnZIMEZ3NmJvTk9qYTViUFRkOTFQMU9md29HajZOMExTb2REMEd4MHUzQUVkckFzUXgzSUhKL0U1UDQxb1VWRmN6eDJ0ckxjVE1GaWlRdTdIc29HU2FCSGczeDY4US9hZFlzZEFoZk1kcW4yaWNEL25vM0NnL1Jjbi9nVmRIOENmRGdzdkQxenJzMGVKcjk5a0pJNlJJZjZ0ay9nSzhWdnJpNzhaZU1KWm93VGM2cGQ0akg5M2UyRkg0REg1VjljNlZwdHZvK2xXbW5XcTdZYmFKWWsrZ0dNLzFvR1hLS0tyM3Q1RHA5amNYbHcyMkdDTnBKRzlGVVpQNkNnUjRiOGVmRXYyalViTHc1QS95VzQrMFhJSGQySHlEOEJrL2lLMnZnUjRaRnBwRjE0aG5qL2ZYaDhtM0pIU0pUeVI5Vy85QkZlTGFoZlRlS1BGTTE1Y1NwREpxRjFrdkkyRmlETmdaUFlLTWZsWDFWNGUxTHc1RHB0bnBla2FyWVRSMjhTd3hwRmNJeHdCam9EUU0zNmd2cnlEVDdHZTh1WkJIQkJHMGtqbnNvR1NhbnptdkpQanI0bU5ob052b01ENG0xQTc1Z09vaFU5UHhiQS9BMENQR3RXdjlROGRlTkpMaEVMWFdvM0FqZ2kvdUtUaEYrZ0hYOGErcS9EV2hXM2hydzlaYVRhajVMZU1LVzd1M1ZtUHVUazE0djhBQW53djlyMVM2OFIzQ1pqdE13VzJSMWtJK1poOUZPUCtCZTFlKzBEWVY4di9BQmE4WUh4UDRxZTJ0NWQybmFjV2hoeDBkLzQzL01ZSHNQZXZaL2lyNHJQaGp3ZE45bmsyMzk2VGIyK0R5dVI4ei9nTS9pUlhpZndvOEpqeFI0dmllNGozV0ZoaWVmSTRZNStSUHhJeWZZR2dFZXgvQ1B3Yi93QUl4NFpXOHVvdHVwYWdGbGx6MWpUK0JQeU9UN24ycjBLaWlnUVVVVVVBZk92aitKL0Evd0FZYlhYb1Yyd1R5SmVjZER6dGxIOHorTmZROE1pVFFwTEd3WkhVTXBIY0hwWG1QeHowTCswZkIwZXFScG1YVFpkN0gvcGsvd0FyZnJ0UDRHdFg0UTY2ZGE4QTJrY2o3cml3SnRKTW5uQy9kUDhBM3lSK1ZBSGVVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVkcUtPMUFIejc0Yy93Q1RrTHovQUsvTHYvMEExOUJWOCsrSFArVGtMei9yOHUvL0FFQTE5QlVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZOZDFSR2QyQ3FCa2s5aFFCNFQ4ZDlaZSsxblN2RGxwbDNqSG5PZzd5T2RxRDhzLzhBZlFyMlR3M284ZWdlRzlQMHFJREZyQXNaSTd0ajVqK0p5Znhyd2p3Y2g4ZS9HcWZXSlFYdFlKWHV4bm9FVDVZaCtlMC9oWDBYUU1LS0tLQkJSUlJRQTEwV1JHUjFES3dJS2taQkhwWHlsOFIvQ0wrRHZGY2tFQ3N0aGNabnMzSDhLNTVYUHFwNCttSytyNjR2NG4rRXYrRXM4SXpSd3B1djdUTnhhOGNsZ09VLzRFT1ByaWdCZmhsNHYvNFM3d25GTk80T29XdUlMb2R5d0hEL0FQQWh6OWMxMmRmSzN3dDhWSHd0NHlnTTBoU3h2U0xhNUI0QzVQeXNmb3gvSW12ZnZISGp6VGZCT21pVzQvZjNzd1AyZTBVNFovY25zbzlmeW9BOHcrTzNoVVcxOWIrSnJXTUJMZ2lDN3gvZkErUnZ4SEg0Q3VmOEwvRnpVL0MzaEwreHJleml1Slk1R01FODduYkZHZWR1MGRjSE9PUndhb2x2R0h4WjE4Z2Jwd2g2QWxMYTFVL3kvVmpYcnZoVDRNYURvYXBjYXFvMVcrSE9aVnhDaC8yVTcvVTUvQ2daNUw5cStJZnhHa0lqYlVieUFubFkvd0J6YnIvSmZ6eWE2UFNmZ0ZxODRWOVUxUzFzd2VzZHVobFlmandLN3J4WjRqMStiVzdQd3o0RCt4ZmFCYm00dUp5VVpJVURiUXZjRG4ySjZWejk5NDErS1hoYTJrYlYvRDlsZHd4cVdhN1JEc0FIY2xHeCtnb0ExN0w0RStGYlpBMTVjYWhkTUI4eGFZUnIrU2dmenFscG1rL0J5NzFrYVBheFd0eGVGdGk3NVppcnQ2S3hPMG42ZGUxZWVhbDhYdkZHdVdkM3B0emMyVnZiWHErUzdSUkZUQ3BQekVFTVQweUQxNHpYYlczZy93Q0czaUhTSXZEdWc2MVpuV284T3Q3R2QwenNPV09Nakl4bmdIajhLQU96VDRhZkQrNkx4eGFOWk95L2VFVXpaWDY0YmlzM1VQZ2Q0UnUxYjdNTDJ5YzlERk9XQS9CODE1aHJlbTZIOE85WVM0OE8rSzVwZGRzcEI1MEJnK1IrZm1SblhqcDFCeitCcjBMd3Q4UnZFeitMN1RSUEZlangyUzZrcGUwZU5DdU9NZ1ozRU1EakhxRGoxb0E0WHhOOEdOZjhQbzE5cE0vOXBRUmZQKzZCU2RNZHd1ZWNmN0p6N1YwWHd1K0s5MWMzOE9nZUk1ekswcDJXdDQvM3QzWkg5YzltNjU0UHJYc21vWGYyTzNWMUFabmxqalZUMzNNQi9Jay9oWHpoOFp0SnQ5RThmK2ZwK0ltdTRGdTJWT05rdTRqZDdaS2cvWE5BSDAxWGhIeDkwRVIzbW02L0VtQktwdFp5QjNIeklUK0c0ZmxYcW5nM3hkcDNpN1JJcnV5bkRUb3FyY3d0dzhiNDV5UFE5ajBOUWZFZlF2OEFoSVBBbXFXaUx1blNJendmNzZmTVB6d1IrTkFqamZnTHJ2MnZ3N2U2TEsrWkxHWHpJd1QvQU1zNU1uOUdEZm1LOWNyNVkrRW10LzJQOFFiQU01V0MrQnRYNXg5N2xjLzhDQS9PdnFlZ0djdDhSdEQvQU9FZzhDYXBab29hZFl2UGcvMzArWWZuZ2o4YThBK0V1dC8yTjhRZFAzTnRndmMya21mOXY3di9BSThCK2RmVTdBTXBCR1FlbzlhK1FmRitseWVHZkhHcFdVT1UrelhSa2dQK3lUdlQ5Q0tCbyt2Nkt6dEIxTk5hMEN3MU9NamJkUUpMeDJKR1NQenpXalFJUTlLK0Z0ZC81R0hVL3dEcjdsLzlETmZZZmpqeG5aZUM5RWE4bnhMZFNaVzF0ODRNci8wVWR6WHhoZVhNbDFmWEZ4SnQ4eVdWcEcyakF5U1NjVUFmWmZ3MmRUOE8vRDZiaHVGaEVTTTg0eFhWMTh3cnFldStDTDN3MTRudFVZMlYxcGR2RUFXUGx5cXEvUEczb2U0L1AxcjZKOE8rSUxEeFBvc0dxYWRMdmhsSElQM28yN3F3N0VVQWFwNlY4amVQOVViWFBIdXIzVVpMZzNCZ2g5d255S1B6SDYxOVRlSTlVVFJmRG1wYWs1eDltdG5rSHVRT0IrSndLK1dmaC9wamEzNCswYTJrRzhHNEUwdmZJVDV5ZnpINjBEUjlTZUd0SlRRdkRXbmFZZy80OXJkSTI5Mng4eC9FNXJWb0hTZzlLQkhnL3dBZjlZTW1vYVZvcU54RWpYVWdCN3Q4cS9vRy9PdWgrQStqQzA4S1hlcXVNU1gxd1ZVLzlNNCtCLzQ4V3J5SDRrYXNkYitJT3IzS0hjaVRmWjRzZWlBS1AxQlA0MTlPZUU5SkdoK0ZOTDB6YVZhM3RrVndmNzJNdCtwTkF6WnJ6NzR5NjUvWkhnQzVnamZiUHFEaTFYQjUybmwvL0hRUitOZWcxODgvSG5XVGQrS0xMU0ViTWRsQjVqai9BRzVQL3NRUHpvRVUvZ2ZvWDlwK05IMUdSY3c2YkNYQi93Q21qL0t2NmJqWDBsWG12d1IwWCt6ZkFxM3pyaVhVWm1uejMyRDVWL2tUK05kTDQ3OFZ4ZUR2Qzl4cVRCWHVDUkZiUk1mdnlIcG4ySEpQc0tBTTN4NzhTdE44RlEvWndvdTlWa1hkSGJLMkFvN001N0Q5VCt0ZlAydWVNL0Uvaks3OG02dTdpWlpEaU95dFFRbjBDTHkzNDVxTFE5RjFqNGdlS3pBa3JUWGR5eG11Ym1Ua0l1ZVhiK1FIMEFyNlo4SitDTkc4SDJLdzZmYktiZ2o5N2RTRE1zaDl6MkhzT0tCbnp0WmZDbnhyZnhoMDBPU0pTTWo3UktrWi9Jbk5RNmw4TXZHR2xJWmJqUXAzUk9TOXVWbHgvd0I4bk5mV2VLTVVCYytVdkRQeEw4VGVGWmxpUzdlNnRFT0d0THNsZ1BZRS9NcC96aXMveGg0a3VQR25pdWJVaEM2K2RzaXQ0Q2NsVkhDcjlTU2Z4TmZRL2pqNGJhUjR3dFpKUkdscHFvWDkzZG91Q1QyRGdmZUg2anRYemNFMUR3YjRzaisxV3FDKzAyNVZ6REtNcXhVNUgxQjZnKzROQUgxVjRPOFBwNFg4SzJHa3JndkRIbVZoL0ZJZVdQNW10MnMzUU5hdGZFV2gybXEyVFpndVl3NEI2cWU2bjNCeUt6ZkhuaUVlR1BCdW82a3JBVHJINWR1TTlaRzRYOHV2NFVDUEFQaTM0bS80U0x4dFBIQys2ejA4RzJoeDBKSDMySDFiai9nSXIyNzRXK0Z4NFo4RjJ5U3hoYjI3L3dCSnVUM0JZZkt2NExnZm5YZ253MThPbnhONDZzcmVkZk10b0crMVhKYm5jcW5PRC92TmdmblgxaFFOaFJSUlFJS0tLS0FLZXE2ZkRxMmszZW4zQXpGY3hORS8wWVlyd3I0TWFoUDRmOGRhbDRadkNWYWNNaFUvODlvaWY1cnUvS3ZvR3ZubjRwMjh2aEg0cDJQaVMxWENUbU82NDZGMElWeCtLNC9NMERQb2Fpb2JPNml2Yk9HNmhiZEZNaXlJZlZTTWlwcUJCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGSGFpanRRQjgrK0hQK1RrTHovcjh1LzhBMEExOUJWOCsrSFArVGtMei9yOHUvd0QwQTE5QlVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGY1Y4VnRkL3NMNGY2ZzBiYmJpN0F0SXZxL0JQNEx1cnRhOEMrT0dweTZ0NHMwdncxWjVkNGdwS0R2TktRcWo4Qi82RlFCMDN3STBIN0Q0V3VkWWtYRW1vVFlRa2Y4c2t5QitiYmorVmVyMW42SHBjV2lhSFk2WkNBSTdXRlloanZnY244VGsxb1VBRkZGRkFCUlJSUUFVVVVVQWZMbnhiOExqdzU0em1raGoyMldvZzNFV09nWW41MS9QbjZOVlR3eG9lci9BQkw4V0pGZFhjcmhJMU56ZFB5WTRsRzBBZTV4Z0QxeWZXdlgvanBZUTNIZ1NPOGFMZE5hM2NaUi93QzZySGEzNEhqOGhWRDRCUld3OE1hcExHVisyTmViWkRqa0tFRzM4T1dvR2VtNkpvbW4rSHRLaDAzVExkWUxhSWNBZFdQZG1QY24xcmhQaVg0M3RvOVB2L0Mra1RYRXV1enFzT0xhTm1FTzhnSGN3NkVnL3JXMzR5OFM2cHBIaDBqVGJhTnRabG5pdFkways0cGtiYUpCbnF1Y2ZpUm1vdkJ2ZzI5MHZSZFFUWGJ0SmRUMUs3YTV1cDdSMlFzQ0JoZHdBUFk5TWRlS0JHVm9Yd3FsOE4zTWsraGE1THBzandMREpJSVZtTXhISlpnNHdvei9BQXIySFd1eThRZUc3WHhOcFVXbmFsSksxdXMwY3NxUm5hSnRoenRiL1pKNmdWYzAzU05QMGVKNHRQdEk3ZEhPNTlnKzhmVW51YXUwQVlsMTRUMFc3dExheWV3dDFzb0pCSjltU0pWUnlPZ1lBY2dIbkhmSE5hTUdtMk5xeXRCWlc4VEtNS1k0bFVqNllGV3MxVHVOVzArMU9KcnlGVy91N3dUK1E1b0F4cFBoL3dDRlpiaTdubTBPMGxsdTVHbG1lVk54Wm01UFhwK0ZKNHU4SGFMNGwwWkxmVWQxdWxtQzhGeEUrdzIvR01nOU1ZSFE4Y1ZvblU3dTZ5Tk8wK1JsL3dDZTF6bUZQd0JHNC9rQjcxeXZpbnhKb1hodFBQOEFFdW9pL3ZSODhPbXdqNWM5ajVlZi9Ibko5cUFHYUJKZGFYNGNpdlBFdXBpWFM5SUx0QmV5QWhyc1pJU1JnZWVBY0FkV1BQVEdmR1ptdnZpcjhTdjNhUEdseTRVZC9zOXVuYys0SDZ0VDljOFNlSnZpcHIwTmhhMnpHTGRtQ3hoUHlSanB2ZHZYL2FQQTdWN3A4UHZBTnA0STB0bDNMUHFWd0FibTVBNE9PaXI2S1AxNm1nWjRUcVduZUlmaEo0eGptZ2w0NU1FNEg3dTZpenlyRCtZN0hrZGpYMFI0VDhVMkhqSHcvRnFWbWNGdmtuZ1k1YUorNm4raDdpbmVMZkM5bDR1MENmVEx4Y2J2bWhsQSthS1FkR0grZVJrVjg5K0R0ZHYvQUlaK1BwckhVd1V0eko5bXZvKzJNL0xJUHBuSVBjRTBBWUhpclRaZkMvamZVTFNMTWJXbDM1a0I5RnlIUWo4eCtWZldPaTZrbXNhSlk2bEhqWmRRSktBTzI0QWtmZ2NpdkIvanhwYXcrSmRPMWVMQmp2YmJZektjZ3NoNFA0cXcvS3UvK0NXcS93Qm9lQUk3Vm16SllUdkFSL3NuNWwvUnYwb0E5SXI1OStQbWovWnZFV25hdWk0VzdnTUxrZjM0emtmK090K2xmUVZlYi9HN1N2dC9nQjdwVnpKWVRwTUQ2S1R0Yi8wSVVDSS9nZHE1di9BdjJKMnkrbjNEUkFkOWpmT3Y4eVB3cnRmRXZpT3c4SzZKTnFtb3liWW8rRlJmdlNPZWlxTzVQLzE2OEgrQzNpYTA4UDZuckthaGNyQlp2Wi9hR1pqeG1NOXZVNGM4ZDZpdTduV3ZqUDQzUzNnRDIrbVFIS2dqSzIwWGQyN0YyLzhBcmRBYUJqdEQwcldQakQ0MWsxVFUyYUxUSUdBbEtuNVkwemtReCs1N242bjBGZVJhdkJGYjYzZnd4THRqanVaRVJjOUFHSUFyN2QwUFE3RHc3bzF2cG1uUWlLM2hHQjZzZTdNZTVKNUpyNG4xMy9rWWRULzYrNWYvQUVNMENQcTN3dm9GaDRsK0QyamFYcU1XK0NXd2o1SDNrYkhES2V4RmVVNlhxR3MvQnZ4dEpZM3l2TnBrNUJrQ2o1WjQ4NEVxZjdRN2o4UFExN1Y4TnY4QWtuSGg3L3J4ai9sVW5qYndkWmVNOUNleHVRSTdoTXZiWEFHVEUvcjdnOUNPNG9BNWI0dStJYmFiNFcrZFlYQ1RRYXBKRkhGSWg0Wk03ai82RFhFZkFQVGZ0SGluVWRSWk1yYTJvalUralNOL2dwL092UDhBVzAxclJBL2hmVkM4Y2RuY05LSUc1VlhJeHVVLzNTT2ZUdjF6VE5QOFRhcHBPalhlbWFmY3RhdzNjZ2U0ZUk3WGNBWUM3dXk5ZW5yUU0rbzlhK0lIaGJRSldoMURXYmRKMTZ3eGt5T0Q2RUxuSDQxemMveHM4SUczbkVOMWRHVUl4ajNXcmdNMk9CbnR6WGpmaG40WWVKdkZFSzNWdGFwYldiOHJjWGJGRmIzVVlMTjljWXJxcFBnQnJpeEZvOVkwOTVNZmRLT29QNDRvQTRYd1RwN2E5NDkwaTJtRy93QTY3V1diUGNLZk1iK1g2MTllMThoNjU0VjhTZUNMNktXOXQ1clJnMllidTNjbENmOEFaY2REN0hCcjFQd0I4WjRYdFdzUEZ0eXNVc1NaanZpcHhLQi9DNEErOTdqcjllb0RQYUNRQmtuQTlhK1FQRk4vSjRsOGNhbGRSWlkzZDQwY1ArN25ZbjZBVjdmci93QVpmQ3gwVy9oMCs3bW11M2dkSWNXN0JTNUJBNVBTdkVQQkYxcHRoNHowbTgxZWJ5cksybUUwamxTM0tnbGVCL3RZb0JIMW5wR254NlRvOW5wOFFBanRvVWlHUDlrWXJ3VDQ4YXk5MzRydE5KVmo1VmxBSkdYdDVrbmYvdmtDdmFOTDhiK0dOWklXdzF5eGxrUFNQelFySC9nTFlOZk9ueGJMbjRtYXp1Nmd4N2ZwNVl4UUNQWXZndDRjajBud1ZIcVRvUHRXcG56bVlqa1Jna0lQeTUvR3ZTYXh2Q0tvdmczUkZpeHNGaEJqSCs0SzJhQkJSUlJRQVY0dDhlL0RzYjJkajRpaGpBbGpjV3R3UVB2S2NsQ2ZvY2o4YTlwcm0vSGZoMmJ4VjRQdmRJdG5pUzRtMkdOcGM3UVZjSG5IUFFHZ0R4MzRVL0VuVFBDbWozdW02MUxPc1JuRXRzWTRpK053K2NjZE9RRCtKcXY4V3ZpRnAvaTZEVGJMUjVaWHRJbWFhWXZHVXkvUlJnK2d5ZnhxNm43UCt0RmZuMXV3VnZSWTNJcXJlZkFieExBaGEydnRPdWY5bmM4WlA1akZBenEvZ0xwdHJiNkhmYWlab1d2THFYWjVZY0YwalRwa2RSa2tuOEJYc0ZmSVdyZUVQRlBoT2I3UmVhZGVXbmxuaTZnSktqL2dhSGo4Y1YxUGhYNDBhL29ycERxcC90YXk2ZnZDQk1vOW4vaS9IOHhRQjlLVVZpZUdmRm1rZUxkUCsxNlZkQ1FMZ1NSTjhza1I5R1h0L0kxdDBDQ2lpaWdBcnpqNDFhRi9hdmdWNzJOTXo2YklMZ2V1dy9LNC9JZy84QnIwZW9MMjBodjdHZXp1RjNRenh0SElwN3FSZy96b0E0SDRMNjZOVzhDUldjajV1Tk5jMjdBOWRuVkQrUngvd0d2UmErZXZoUGR5K0ZQaWJmOEFodTdjcXM1ZTJPVHdaSXlTaC9GYy9uWDBMUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSMm9vN1VBZlB2aHovazVDOC82L0x2L3dCQU5mUVZmUHZoei9rNUM4LzYvTHYvQU5BTmZRVkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUVjOHlXOEVrMGpCWTQxTE14N0FESk5mUFh3OGlrOGJmRis2OFFYQ2xvWUhlODU2QS9jaUg0RG4vQUlEWHBueGYxNyt4ZkFGM0ZHMjI0dnlMU1BCNUFiN3gvd0MrUWZ6Rlp2d04wTCt6dkJzbXBTSmlYVXBpNC82NXA4cS9ydVA0MERQVDZLS0tCQlJSUlFBVVVVVUFGRkZJektpbG1JQUF5U2UxQUhCZkdQVkxiVC9oM2V3VG9za2w2eTI4S04vZUp6dS9BQW12QS9CM2pEVS9CV3JDL3MwOHlDY2JKb0pNaEpsQjdIc1FlNDZkK3RkWDhhdkZ0ajRnMW15c3RNdTB1Yld4UnpKSkdjcVpXT0NBZStBbzVIclhxK2crQXRIbitIZWxhSnErbngzQVNBU1B1R0hTUi9tWWhoeURrNC9DZ1pGb3Z4UDhHK0tMZElybTVodFoyeHV0dFFBWEI5bVB5bjhEWFZSV1Z0UEVIc3IyWll6eXBodU55NDlnY2pGZVJhMzhBTXUwbWhheGhUMGh2VXpqL2dhLzFGY28vd0FJdkh1bU1UYVc2TUIvRmFYd1RQNFpXZ0Q2TSt3WEdPTlZ2ZjhBdm1JLyt5VWphZkpqTDZwZWJlL3pJdjhBSlJYemwvd2hueFFVYlJiNnpnZW1vZjhBMmRBK0dIeEYxRGk0dFo4SHI5cDFBRWZsdU5BSHVlcGFsNFMwM0oxYldiYks5VXVyMHVmd1RjZjVWeW1wZkdYd2RvNnNtajJrdDdLT0FZSVJFaC80RTJEK2hyaTlQK0FuaUNiQnZOUTArMFh1RTNTTitnQS9XdXowajREK0hyUWg5VHZMelVHSDhJUGtvZndYbjlhQVBQOEFXdmk3NHU4U1NteDB0UHNLeUhhSWJGQzh6ZjhBQXNaL0lDclhobjRMNi9yYzR1OWZsZlRyZHp1Y09kOXhKK0hSZnFTVDdWN3hvL2h2UnRBaUVlbGFiYldpNHdURkdBeCtyZFRXcFFGekc4T2VGZEg4SzJIMlBTYlJZVlBMeUhsNUQ2czNVL3lyWm9vb0VGZUsvSGp3dWoydHI0bHQ0eDVrUkZ2ZFlIM2tQM0dQME9SK05lMVZsZUpkSmoxM3d6cVdseWdFWE51OFl6MmJIeW44RGcvaFFCNEhmYWczaXI0SHhQTXhrdmZEMTVIRzdIa21GaHRVbjhDQi93QUJyVCtBR3ArVnJ1cmFXellFOEN6b0QvZVJzSDlHSDVWdy9oSFZiZlQ0OWUwclU1dkl0dFMwK1NCaXdKQ3pyOHlaeC90WkdmZXJId3IxTCt6ZmlQbzhqSEN6TzF1Ly9BMUlINjRvR2ZWMVpmaVBURTFudzFxV25NTS9hTGFTTWV4STRQNTRyVUhJb1BTZ1I4VTZkWlM2aHFWcllJVVNhNGxTRUdRNFZXWWdjL2pYMXY0UThKMkhnN1E0OU9zaHVmNzA4N0Q1cG43c2Y1QWRoWHkxNGx0SmZEL2pQVTRNanpMUzlkMEsremIxeCtHSyt2Yks1UzlzYmU2ak9VbWlXUlQ3RUEvMW9HeVk5SytGdGQvNUdIVS8rdnVYL3dCRE5mZEo2VjhMYTcveU1PcC85ZmN2L29ab0VmWG53OXVJYmI0YStIbm1sU05mc01ZeTdCUjA5NjZPUFZMQ1k0aXZiWnowd3N5bit0ZkhGcyt2ZkVUVnRIMEN6NU1GdWxyYnhGeUk0MVFaWjI5TzVKeFZpLzhBaFo0NjBpNWFJNkJleTQ2U1dnODFUNzVYK3VLQU94K04xNmJyNGl5UTVHTFcxaWkvRWd2L0FPelZaK0R2Z1NEeEpxY3VyNm5FSk5Pc1hDcEV3eXMwdlhCOVZVWUpIY2tWNXhjV0dvMkpSTlN0cm1HYkFEZWZHeW44elh0SGdUNGsrRlBCdmdQVDdLNm1ua3ZXTWtzOFVFSllxek1lcE9CMHgzb0dlM0JRb0FBQUE0NHBhODYwYjR5NkJyV3BXOWpEWWFza2x4SXNTTzF1R1hKT0JrZ25BcjBXZ1JWMUhUclRWckNheHZyZU9lMm1VckpHNHlDUDg5KzFmUEdxL0JUeEpINGh1cmJTNG9wTk5EWmh1WnBndnlua0FqcVNPaDRyNlJvb0ErZllQMmY5Y2RRYmpXdE9pUG9rY2ovcnhSUCt6L3JpS1RiNnpwMGg5SGprVDlmbXI2Q29vQzU4cWF0OEtQR09sSVpKTktOM0V2TyswY1MvK085ZjBya0ovUEU3SmMrYjV5WVZsbHp1WEhZNTVGZlhQakR4aHB2ZzNTRGZYN0Y1SHlzRnVoK2VadlFlZzlUMnI1MXZwL0ZYeFc4UW1hRFQvUGRQbFZJVUNSd0w2TTV4bjZrNTlCUU05RDhGZkYzUU5FOEM2ZFk2ckpkTmZXcW1BeFF3bHlWVS9LYzhBY1lIWHRWNC9IL3c5NXVCcFdxN1BYYkhuOHQzOWE1clR2Z0Jxc3NZYlV0WXRiY24vbG5CRzBwSDRuQS9TdFZ2MmZMWFo4dmlHNDMrOXN1UDUwQm9kWnBYeGo4SGFtNnh2ZlMyTWpjQVhrUlFmOTlESy9yWGVSeUpMR3NrYks2T0F5c3B5Q0QwSU5mUDkvOEFBSFdvZWRQMWV4dUJuN3N5TkVmMDNDdmEvQzJqUDRmOEw2YnBNcy9ueVdrQ3hOSjJKSHA3ZW50UUkxNktLS0FDaWlpZ0JHVldVcXdCQkdDQ090ZWErTS9nNW8ydnBKZGFTc2VtYWljbjkydUlaRC90S09uMUg1R3ZTNktBUGtEL0FJcUg0ZmVKd2YzdGhxTnVmcXNpL3dBblEvNXdhK2tmQVBqdXk4YmFUNXFoWU5RZ0FGMWJaKzZmN3krcW50NmREVXZqbndSWStOTkdhMm1DeDNzWUp0Ym5ITWJlaDlWUGNmMXI1cTB6VU5ZK0gvakh6UWhpdnJLVXh6d2svTEl2OFNuMUJHQ0Q5RFFQYyt2cUtvYUxxOXJyMmpXbXFXVDc3ZTVqRWlIdVBVSDNCeUQ5S3YwQ0NpaWlnRDU5K01kaE40YjhmNmI0bXN3UWJqWkxrRC9sdEVSa2ZpdTM5YTk0MDIraDFUVExXL3R6bUc1aVdWRG5zd3lQNTF4WHhoMEU2ejRDdXBvMDNUNmVSZHBnYzRYNzQvNzVKL0txSHdPMXorMHZCajZkSStadE5tTVlCUDhBeXpiNWsvOEFaaCtGQUhwMUZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVWRxS08xQUh6NzRjLzVPUXZQK3Z5Ny93RFFEWDBGWHo3NGMvNU9RdlArdnk3L0FQUURYMEZRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSVU4zY3hXVnBOZFR1RWhoUnBIWTlsQXlUUUI0SjhadFFtOFErTzlOOE5XUkxOQUZqMmovbnRLUi9KZHY1MTd0cGRoRHBXbFdtbjI2aFliYUpZa0E5RkdLOEUrRmR0TDR2OEFpbGYrSkx0ZHlRRjdvNTZDUnppTWZnTS9rSytocUFDaWlpZ0Fvb29vQUtLS0tBQ3ZuNzR3L0VPZS93QlFuOE5hWE9Vc1lEc3U1RU9ETS9kTS93QjBkL1Urd3IyN3hGcUowZnczcVdwTGpkYTIwa296NmhTUit1SytWL0JHaWY4QUNWZU9OUHNMc21TT2FWcGJrazhzcWdzK2ZyMC9HZ2FNdlJiTTN2aURUckoxUDcrNmhqSUk3TTYvMHI2anRmaURvakJoZWk1MDFWbGtpV1c3aEt4T1Vjb1NzZ3l2VlQxSU5lR2FvcTIveDRJS2hVVFdvc0tCZ0FaWEEvTEZlOGVEbFg3THJOazZnckJxOTBtMWhrWVovTUg2UFFETjYxMUN6dmszMmwxQmNKMTNSU0J4K2hxelhQM1hnand4ZHR2bDBLeDM5UzBjUWpKL0ZjVlc4RHhwWjJlcTZXZ0twWWFuUEZHaEpPMUdJa1VjODlIRkFqcWNEMG9vb29BS0tLS0FDaWlpZ0Fvb29vQUtROUtXa1BRMEFmSVhpYlNwaDQvMVhTclNJeVROcUVrY1VhL3hGbXlBUHpyS3RwWjlIMWlHWjRuanVMTzRWMmpjYldESXdKVWc5RHhpdTIxYjk3OGUzRWYvQUVHNGgrSUs1L2thOU4rTGZ3K2gxN1NwdGMwNkFMcTFxaGVRSVA4QWo0akhVSDFZRGtIOFBTZ1ozZmgzeERZZUo5RmcxVFRwZDhNbzVVL2VqYnVyRHNSV3JYekw4SHZGcjZCNHNqMDZhVC9pWDZtd2lZRThKTC9BMzQvZFAxSHBYMDFRSStZL2pWcC8yUDRpM0VvWEMzZHZGTVBjNEtuOVZyM0Q0WjN4MUQ0ZGFKTXpibVczRVI5dGhLL3lBcnpMOW9PeTJhcG9sOEIvcklaWVNmOEFkWldIL29ScnEvZ1ZkK2Y0Q2VBbm0ydkpFL0E0WWZ6b0dlbW5wWHd0cnY4QXlNT3Avd0RYM0wvNkdhKzZUMHI0VzEzL0FKR0hVLzhBcjdsLzlETkFqM3o5bm53blBwK21YM2lDOXRERzk2Rmp0WGNjbUlja2owQk9QcnRyMm00bmh0YmVTNHVKRmpoaVV1N3NjQlZISkpOYzM4Ti8rU2NlSHY4QXJ4ai9BSlZTK0pHbmF4cjFocDJnYWJISUxUVUxvSmYzQ2Y4QUxLRmZtT2ZyajlNZDZBT1BtajFyNHlhaElJWnBOTjhIVzhwVkgyL3ZMdGgzd2Y4QTlTKzU2ZDdvZnc2OEsrSDQxRnBwRnU4d0hNOXdvbGtQdmx1bjRZRmRCcDloYmFYcDhGalp4TEZiUUlJNDBYb0FLczBBUnh3eFJERWNhSVBSVkFxU2lpZ0Fvb29vQUtodTdxR3hzNXJ1NGtFY0VNYlNTT2VpcUJrbjhxbXJ6bjQyYW5McC93QVBaWVl5Ujlzbmp0M2JIQVhsano3N2NVQWVZMkZwcVB4bCtJVTF6Y3ZKRHBrSExZLzVZd1orVkYvMjIveFBhdm9mU3RJc05FMDZLdzAyMWp0cmFJWVdOQitwOVQ3bm11TStEbWhwcEhnQzB1Q21MalVDYnFRa2M0UENEL3ZrRDh6WG9GQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZlTC9IYndta3RsQjRudFkvM3NKRUYzaitKRDl4ajlEeC93SWVsZTBWbmEvcGNXdDZCZjZaTW9aTG1CNC9vU09EK0J3YUFQSHZnSjRrWVBmZUhKM3l1UHRWc0NlblFPby84ZFA1MTdsWHh6NGExeTU4SitKclhWSTRoSkxhU01za1ROdEQ4RldYUGJ2WDAzNFArSU9pZU1vY1dVcGh2VlhNbG5OZ1NMN2pzdzl4UU5uVjBVVVVDSTU0WTdpM2tobFVQSElwUjFQUWdqQkZmUFh3NW1sOEUvRjI3OFB6c1ZodUhleitidVI4MFIvRWYraFY5RTE0RjhjTk1sMGp4WnBmaVd6eXJUQlFXSGFhSWdxZnhYSDVHZ1o3N1JXZm9lcVJhM29kbHFjR1BMdW9WbEFIYkk1SDRISS9DdENnUVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZIYWlqdFFCOCsrSFA4QWs1Qzgvd0N2eTcvOUFOZlFWZlB2aHovazVDOC82L0x2L3dCQU5mUVZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRmVkL0dqWFA3SjhCeTJzYjRuMUdRV3k0UE8zN3puOGhqOGE5RXI1NitMTjFONHIrSmRoNGF0R0xDQXBiQUE4Q1NRZ3Nmd1hINVVBZDc4Rk5DL3Nyd01sODY0bTFLUXpuaitBZktuNkRQNDE2UlVGbGFSV0ZoYjJjQzdZWUkxaVFlaXFNRCtWVDBBRkZGSVNGQkpJQUhVbWdCSkpFaWpaNUdWRVVaWm1PQUI2bXZMUEZIeHcwYlNwWHR0R2dPcXpMd1pRMnlFSDJicTM0REh2WEEvRkw0bFRlSkw2YlI5TG1LYU5DeFYyVTQrMU1PcFArd093NzlUMnFYd0w4SEw3eEZCRnFXdFN5MkdudUEwY2FnZWRNUFhuaFI3bm4yb0dWN3o0NGVNYmh5MERXRnFuWlk3YmQrckUveW9zL2poNHd0M0RUdFlYYWQxa3R0dWZ4VWorVmV5NmY4TGZCdW5SQkUwTzNtWWRaTGpNckg4U2FOUStGdmd6VVl5cjZIYndzZWtsdm1KaCtJTkFIQVhYeGgwenhUNFMxYlNkU3RYMDI5dUxPUkluRGI0bmZhY0RPTXJrOGNqOGE0WDRUNmxEcHZ4SDB1U2Rnc2MrKzN5ZXhkY0wrdUIrTmJuanI0T1h2aDJDWFV0R2xrdjhBVDR4dWtqWWZ2b2g2OGNNQjZqbjJyeTlXWkdWMFlxd0lLc3B3UWV4RkFIb1B4VFJ0SCtMVnhlaFNBWHQ3eGZmQVhQNm9hOXgwU1pJZkcyc1FJMzduVWJlRFVvUFJ2bDh0OGY4QWZLZm5YenA0dThWLzhKZGFhVmRYcTdkV3RZbXRyaHdQbG5RY3Evc2VXQkg0aXZYUEN1cnphaDRFMER4SmJJODk1b0JlMHZZWXhscExmQVZ3QjNJVVJ1QjMybjFvQTlicmxyTW5UZmlKcUZ1M0VlcVdrZDFHVHdESkYrN2NEMU8weG11aXNyMjIxR3lodkxPZEo3ZVpROGNrWnlyQTl4V0I0eWhsZ3RiUFhyV05wTGpSNXZ0REl2V1NFamJLby80QVNSN3FLQkhUVVZGYlhNTjVheFhOdklzc0V5QjQzVTVES1JrRWZoVXRBQlJSUlFBVVVVVUFGRkZGQUJTTVFGSlBBSFdscmwvaUZyeStIZkErcDNvYkU3UkdHRDNrZjVWL0xrL2hRQjRQNFJ6NGgrTmtGMHVXVjlSbHVzLzdLN2lEL0t2cDg4cjByd0g0QmFJWjlaMUhXWFg5M2F4QzNqSjdzL0ovSlFQKytxOS9vR3o1QzhiYVovd2puanZWYk8ySGxpM3V2TWdBL2hCdzZmbGtmbFhxbW9mSDYyaGlqVFR0SGt1WmRpNzVKNVBLVGRqbkFBSjY1cksrTkhnblV6NGkvd0NFaHM0bnVyZTg4dUY0NGtKZU9RRGFvd09vYmpCOWVLdCtFL2dTSjdXTzY4VFhjc1R1TWl6dG1BSy83ejg4K3cvT2dEaC9HL3hIdmZITnBhUVhtbld0dDlsbE1pUEM3RW5Jd1FjL2grVmRsOENmRW1tNmQvYU9rWDE1SGJ6M1V5U1d5eUhBa08zQkFQVFBBNDcxMkZ6OER2QjgwQlNGTDYzZkhFaVhKWS9rMlJYai9qdjRiYW40SmNYQmY3WnBramJVdWxYQlZ1eXV2WStoNkg5S0FQcWc5SytGdGQvNUdIVS8rdnVYL3dCRE5mUm53YitJRStzeHQ0ZDFXWXlYa0VlKzJtYzVhV01kVko3c3ZIUGNmU3ZuUFhmK1JoMVAvcjdsL3dEUXpRSSt3Zmh0L3dBazQ4UGY5ZU1mOHE2bXVXK0czL0pPUEQzL0FGNHgvd0FxNm1nQW9vb29BS0tLS0FDaWlpZ0FxRzZ0TGErdDJ0N3UzaXVJVys5SEtnZFQ5UWVLbW9vQVJVVkVDSW9WVkdBQU1BQ2xvb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0E0anhmOEx0QThWcEpQNUlzZFJia1hkdW9CWS83YTlHL243MTgrZUl2Qyt2ZUFkYWlGenZoZFgzV3Q3YnNRcmtkMWJzZlVkZnFLK3VxejlhMFhUL0VHbHphZHFWdXM5dEtPVlBVSHNRZXhIWTBBZWVmREw0cUo0ajh2UnRhZEl0V0F4RkwwVzV4L0ovYnYyOUs5VHI1TThiK0RkUThDYThzUmtrYTJkdk1zN3RmbExBSDFIUjE0L1FpdmRQaGI0OUhpL1JqYlhycU5Yc3dCTU9ubXIya0E5K2g5RDlhQm5mMXhYeFcwSTY3NEF2MGpUZGNXZ0YzRHh6bE9TUHhYY0s3V211aXlJeU9vWldHQ0NNZ2lnUjVWOENOZUY5NFd1ZEhkeVpOUGwzUmduL2xrL0kvSnQxZXIxODYrRDNQZ0w0MlhHa1NzVXRKNVh0TW51ai9BRFJIODlvL0UxOUZVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSMm9vN1VBZlB2aHovazVDOC82L0x2OEE5QU5mUVZmUHZoei9BSk9RdlA4QXI4dS8vUURYMEZRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBRmJVYjZIVGROdWI2NGJiRGJ4Tks1OWxHVC9BQ3J3WDRQV1UvaWI0aGFqNG12RkxHRGZNU1JrZWJLVGdmZ3U3OUs3ZjQzNjcvWm5nb2FkRzRFdXBTaUwzOHRmbWY4QWtCK05YUGc1b2Y4QVkvZ0szbmtUYlBxRG02ZlBYQjRRZjk4Z2ZuUUI2QlJSUlFBVjUvOEFHSHhHK2crQjVvYmVRcGRhZy8yVkNEeXFrWmMvOTg4ZmlLOUFyd2Y5b080YzMraFcyZmtXT2FUSHVTby9wUUJ6bndoOEhSZUp2RXpYVjdFSDA3VGdzam9SOHNraCs0cDl1Q1Q5QlgwMkFBTUN2TVBnVGF4dytBNUoxQTh5ZTlrTEgvZEFVZnlyMCtnR0ZGRkZBQVJrWU5lYnlmQlR3eFA0Z3VkU25FN1c4ejcxc1ViWkdoUFhrYzRKNXhrWXIwaWlnRGlkYitHbmgrNThLWCtsNlhwTm5hVHpSSHlwa2pHOVhISy9NZWNaSFBQZXZJdmhGNG1md3Y0d20wYlVzd1c5OC9rU0svSGxUcVNGejZaT1ZQNFY5SjE0TjhhL0F6MjEwZkZXblJFd3lrQytWQjl4K2drK2g0Qjk4SHZRTTlYbThEK0haN2lTNEdubUNTVTduTnRQSkFHUGNrSXdHZmZGTUhnRHd3WDNTNldzNS82ZVpwSmgrVHNhNWo0VC9FTlBFdW1wcEdwVEFheGFwZ0ZqemNSaitJZjdRN2o4YTlNb0VSVzF0QloyMGR2YXd4d3dSamFrY2FoVlVlZ0E2VkxSUlFBVVVVVUFGRkZGQUJSUlJRQVY4N2ZHenhXTlo4UVE2QlpNWkxld2I5NkU1M3puakh2dEhIMUo5SzlKK0oveEJpOEk2U2JPeWtWdFp1a1BrcU9mSlhwNWpmMEhjK3dOZWRmQnZ3UkpyT3NEeE5xY2JOWjJzaGEzOHdFK2ZObjczdUZQT2U3ZlNnWjY1OFBQRFA4QXdpbmcyejArUUFYVER6cmtqL25vM0pINGNEOEs2bWdVVUNDaWlpZ0FxanJHbFd1dDZSZGFaZUlIdDdtTXh1UHIzSHVEeitGWHFpdWJpSzB0cGJpZHdrVVNsM2M5RlVESk5BSHlMNGZ1Si9EWGo2d2NzUkpaYWdzVWhIR1FIMk1QeEdmenJsZGZBWHhIcWc5THlZZitQbXVtdE4vaUh4M0FZbDV2OVRWbEhvSGx6L0kxek92NFBpVFZjZFB0azJQKyt6UU5uMkI4TnY4QWtuSGg3L3J4ai9sWFUxeTN3My81Sng0ZS93Q3ZHUDhBbFhVMENDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBTUh4aDRYdFBGM2gyNDB1NUFEc04wRXVPWXBCOTFoL1gxQk5mTCtpNm5xUGdQeG1seThiUjNOak1Zcm1IKyt1Y092NGprZmdhK3ZxOEErUEhod1dtc1dmaUNCTUpkanlKeUJ4NWlqS244VjQvd0NBMERSN3ZZM3NHbzJGdmUyemg0SjQxa2pZZDFJeUtzVjVYOEMvRUIxRHduTnBFclpsMDJYQ1pQOEF5eWZKVWZnZHcvS3ZWS0JIaEh4NDBhU3oxYlN2RWRybFhrL2NPdzdTSWQwWi9MUDVWN0Y0WjFpUHhCNFowN1ZvenhkUUxJUjZOajVoK0J5S3lQaVRvSjhSZUJOU3RFWGRQR24yaUgvZlQ1Z1B4R1IrTmNWOEE5ZCswNkpmYUpJMlh0SkJQRUQvQU04MzYva3cvV2dEMkdpaWlnQW9vb29BS0tLS0FDaWlpZ0FvN1VVZHFBUG4zdzUveWNoZWY5ZmwzLzZBYStncStmZkRuL0p5RjUvMStYZi9BS0FhK2dxQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0FvNlVWUzFqVW9kSDBlODFLNFlDSzFoYVZzOTlvemlnRHdUNGx6eWVOUGkxWmVIclppWW9HU3o0N014M1N0K0E0LzREWDBKQkJIYlc4Y0VLQklvMENJbzZCUU1BZmxYZ253VDB5WFhQR09xZUpid2IyZ0RIY2YrZTBwSlA1S0QrZGUvMEFGRkZGQUJYaVg3UVduTVlORTFKVk94SGt0M1BZRWdNdjhBSnZ5cjIydWQ4Y2VHMThWK0VyM1N1Qk02aDRHUDhNcThxZno0K2hvQTRQNEI2dkhONGN2OUlMRHpyYTQ4NEQxUndQOEEyWlQrZGV2VjhpZUZmRU4vNEQ4WExkbUJ3OER0QmQycmNGbHpobFB1Q01qM0ZmVldoNjVwL2lMU29kUzB5NFdlM2xIVWRWUGRXSFlqMG9HelJvb29vRUZGRkZBQlVkeGJ4WFZ2SmJ6eHJKRElwUjBjWkRBOEVFZWxTVWpNcUtXWWhWQXlTVGdBVUFmTlhqNzRmNmo0QzFaZGEwUjV4cHF5QjRaNHlkOW8yZUZZK25vZndQdjZKOFAvQUl2V1d2cEZwdXV2SFo2cDkxWlNkc1Z3ZmIrNjN0K1hwU2VLdmpUNGJzVW1zckMzT3RPUVVjREN3RWRDQ3hCM2ZnQ0srZmRSdVlMeS9tdUxheGpzb1pHeXR2RXpNaWV3TGM0b0dmYXVjMFY4cytHUGl2NG04TXdyYkNaTCswVVlXRzh5eFFmN0xBNUgwT1JYcWZoMzQ1YURxVExEcThFdWx6SGpleDh5RS84QUFnTWo4UitOQXJIcWRGWnRuNGgwYlVWVnJQVmJLNERkUExuVW44czVyUnlNWnp4UUF0Rlo5M3J1azJBWTNtcFdkdUY2K2JPcS93QXpYRzYxOFp2Q1dsb3kyMTFKcVU0SENXaVpYUHU1d0tBUFFxODQ4ZjhBeFgwL3d2SExZYWEwZDdxK01iVk9ZNEQ2dVIzL0FObnI2NHJ5cnhWOFlmRVBpRkh0clFqUzdKdUNsdXhNakQzazYva0JYQ1dWcTE5ZlEycXpReEdWd3ZtVHliRVhQZG1QUVVEc08xRFVielZ0UW12cis0ZTR1cG0zU1NPY2tuK2c5dTFUUmE5ckZ0RkhGRHExOUZIRU5zYUpjdXFvUFFBSEFyM2p3dDhHL0NRc1k3aTZ1djdibFAzcEVteERuMEFVL3dBeWE3UzE4QmVFN01BUStIZE5HTzdXNnNmMXpRRnp5RDRSZU52RXQvNHdnMG02MUNmVUxHU0p6SUpqdk1XMFpEQnVvNTQvR3ZvS3F0bnB0anA0SXNySzN0ZzNVUXhLbWZ5RldxQkdKNG84VjZWNFMwcHI3VTV3dmFPRlNESktmUlIzL2tLbDBEeEpwUGliVDF2ZEt2STdpTS9lVUhEeG4wWmVvTlUvRkhnblJQR0MydzFhM2QydG1MUnZHNVJzSHF1UnpnOGNlMVU5SStHbmhqUXIrTzkwMnptdDdsT2tpM01tU1BRODhqMlBGQUhYVnhQeFMwanhCcmZoQ1d5MEZveVdiTnpEbkR6UmorQlQwNjR5RDF4aXUyb29BK1FQQit0TDRWOFpXT3BYZHA1cTIwcFdXTjFJWkFmbFlnZjNsNTYxeUdzVHhUNjNxRTBUN281TG1SMFlEcUN4SU5ldi9ITFJyZlR2R2R2ZTI2aGY3UXQvTWxBR015S2RwUDRnajhxOFNrLzFqZlUwRFo5cC9EYi9BSkp4NGUvNjhZLzVWMU5jdDhOditTY2VIdjhBcnhqL0FKVjFOQWdvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBcml2aXhwUTFYNGNhcXUzZEpiSUxxUDJLSEovOEFIZDM1MTJ0VU5idGhlYUZmMnpjckxiU0lmeFVpZ0Q1NitCMm9tMDhmRzAzWVM5dFhUSHF5NFlmMXI2VXI1SitHZHcxdjhSUEQ4bWNadUFoLzRFcFgrdGZXbzVBb0d3SXlDTVo5cStkTkl6OFBmam05a3hNZGxQT1lldkhremNvZndiSDVHdm95dkQvajVvakxKcGZpQ0FGV0diV1Z4MlAzb3orZTZnUjdoUldGNE4xd2VJL0NPbTZya0Y1NFI1Z0hhUWNNUHpCcmRvQUtLS0tBQ2lpaWdBb29vb0FLTzFGSGFnRDU5OE9mOG5JWG4vWDVkLzhBb0JyNkNyNTk4T2Y4bklYbi9YNWQvd0RvQnI2Q29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ3ZLL2pycnYyRHdqQnBTUGlUVVpzUGcvOHNrK1p2MTIxNnBYenI0NmQvSFh4bnQ5RGhZdGJ3U0paOGRBQjg4cmZ6SC9BYUFQVWZoTG9QOWgrQUxIekVLM0Y3bTdsQkhQei9kSDRLRnJ1YVpGR2tNU3h4cUZSQUZWUjBBSFFVK2dBb29vb0FLS0tLQVBNUGlaOExFOFVidFgwY1J4YXVCKzhSanRTNUE2WlBadlE5K2g5YThQMC9WL0VuZ1RXSkV0NWJuVHJ0VGlhQ1JmbGZIOTVUd3c5L3dBalgxOHhDcVNTQUFNa212bGY0bWVNbjhZZUozOGcvd0RFdXN5WWJVS09YNTVmM3llZzlNZXRBMGRocGY3UUY1RWdYVmRFaG5JNnlXMHhqL0hhd0kvV3ZZdkRldU40aDBpUFVUcGw1WUxKeWtkMnFobUg5NEFFOGZYRmVlZkRUNFQyMmsyOEdzK0lMZFp0U1lCNHJhUVpXMjlNanUvOHZyelhyVkFnb29vb0FLcTZuWXJxZWxYZGc3dEd0ekM4SmRlcWhnUmtmblZxaWdEeG5RZmdGWlFPWDEzVkpMc0tjSkZhcjVTa2Y3Uk9UK0F4WFpSL0Nmd1JIRUUvc0dGdVB2UEk1Si9IZFhhVVVBZVlheDhEZkRGN0d4MDU3clRwdjRTa25tSitLdC9RaXZKUEZud3Y4UmVFdzl4SkNMMndYL2w2dGdTRkgrMHZWZjFIdlgxVlNGUXd3UmtIc2FBdWZFSXdPUng3aXQrRHdwcXR4NGNmWDBuczEwMUNWZVI3eFZLdVA0Q3ZYZDZESE9SWHNQeEkrRTJsM0ZsZDY3cER3YWJQQ2pUVHhOOHNFZ0F5VC9zSDZjSDA3MTRMYlJYTjVMRloyeVN5eVRTQVJ3b0NTem5nWUhyMm9HUWtidW95ZmZtckZwWVhtb1A1ZGxhVDNMRHRER1h4K1FyM2J3VjhFckswaGp2ZkZBRjNkRVoreEszN3FQMllqNzUvVDYxNjFhV05yWVFMQloyMFZ2Q293RWhRSW8vQVVCYytTVjhBK0wzVU12aHJVeUQwL2NWblgzaC9XZE56OXUwbSt0d09wbHQyQUg0NHhYMmJnZWxCVUVFRVpCN0dnTG54YnBlcjZobzl5TG5TNzZlMGxIOGNFaFg4Q0J3Zm9hOXIrSDN4bWwxQy90dEc4UnhxWjUzRVVON0V1QXpIZ0IxN1pQY2ZrSzlDMXY0ZmVGdkVDc2IzUjdiemoveTNoWHk1Qjc3bHhuOGMxeDloOERkSjA3eExhYWxGcWQwOXJieXJNTFdSRkpMS2NnRngyejdVQWVyVVVVVUNDaWlpZ0Fwa3NzY0VUeXl1cVJvQ3pNeHdGQTdrOWhUNjhLK1AxL2R4M21sV0tYY3Eyc3NMdkpBcmtLNURBQWtkL3dBYUFPTStLUGl5SHhiNHdhYXliZlkyaUMzdDN4L3JPY3MvMEo2ZXdGZVdTZ3JNNElJSVlnZy9XdmRQaEg4T1k5ZGxpOFI2bXlOWTI4K0liYkdUTEloSExkdG9QYnY5T3ZqbXVuUGlMVlArdnViL0FORE5BMmZWWHdiMUQrMXZoYnBYbXNyTmJoclpzY1kyTndENzR4WG9GZk0vd1YrSm1rK0ZMRFVOSzEyNWtndDNmN1JCSUVMcUd4aGx3T2NuQUkvR3ZWeDhhL0FyQmltclNOdDY0dFpQOEtCSG9ORlEybDFIZTJjTjFFSEVjeUNSUTZsVGdqSXlEMHFhZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ3FtcVNyQnBWM014d3FRT3hQMFVtcmRjcjhTTlNHbC9EeldyaklETmJHRlA5NS9rSC9vVkFIemY4T1ltbitJUGg1QjErMUl4L0FFbitWZlhLL2RIMHI1aStDOWdiejRqMnN1M0tXa0VzeDl1TmcvOUNyNmVvR3dyblBIbWhEeEg0SzFUVGxVR1pvVEpEN1NMOHkvcU1malhSMEdnUjR0OEF0ZTMyZXBhQktTR2ljWFVLbnNyWURqOENBZnhOZTAxODV2ajRlL0hYZC9xN0dlNHo3ZVROMS9CV1A2VjlHVUFGRkZGQUJSUlJRQVVVVVVBRkhhaWp0UUI4KytIUCtUa0x6L3I4dS8vQUVBMTlCVjgrK0hQK1RrTHovcjh1LzhBMEExOUJVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUdaNGgxYVBRdkQxL3FrcHdsckEwbjFJSEEvRTRyeGo0RjZUTHFQaUhWUEVsMkM3eGd4cTU3eXlIYzUvTCtkYi9BTWVkZSt4K0hMVFJZM0FlK2w4eVhCLzVaeDRQUDFiSDVWMVh3djBMK3dQQUduUU9tMmU0WDdWTm5ydWZuSDRMdEg0VURPeG9vb29FRkZGRkFCUlJSUUJ4M3hSMXA5RCtIMnB6d3VVbm1RVzhaSFVGenRKL0xOZUkvQjN3N0hybmppS2FkQTF0cDBmMmtxUndYQndnL1BuL0FJRFhwL3g1M2Y4QUNBd1l6aiswSTgvOTh2WE9mczkrWDUrdm5qek5zR1BwOC84QVdnWjduUlJSUUlLS3l2RXVzTm9IaHZVTldTMmE1YTBnYVVSTHh1eC9JZXZ0WEsrQVBpalllTVkvc2wyc2RscXkvd0RMRGZsWlI2b1QxOXgxK3RBSGYwVVVVQUZGRkZBQlJSUlFCNU44ZWRYdWJQd3pZNmRCdVdLL25JbWNkMVFiZ3Y0bkIvQ3Fud1A4R1JRYWVmRk43RnV1TGpLV2U0ZmNqNkZ4N3NjalBvUGV2VnRWMGZUdGJzemFhblpRWGR2dURlWE1tNFpIZjYxYWdnaXRiZU9DQ05Jb1kxQ29pRENxQjBBSFlVQVNVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRlFYdDVCcDlqUGVYVWdqdDRJMmtrYy93QUtnWkpyaDdqNHplQ1lZVEltcFN6dGppT0syY3NmekFGQUhmRWdESk9CWHl0OFUvRThYaWZ4clBOYXY1bGxhSUxhQmgwY0E1Wmg3RmljZlN0cnh6OFk3N3hKYXk2YnBFTDZmcDhnS3l1emZ2cFY5Q1J3bzlRTWsrdFNmQ2I0Y3phNXFFR3ZhcENVMHEzWVBDanIvd0FmTGpwZ2YzQWVjOXlNZXRBejJQNGQ2TEpvSGdMU3JHWmR0eDVmbXpEMGR5V0kvRE9Qd3I0KzEzL2tZZFQvQU92dVgvME0xOTBucFh3dHJ2OEF5TU9wL3dEWDNMLzZHYUJIcmMzd1pzdForSFdsZUlkS3V2c2Q0YkZaN3BKV0ppY0JDV1lZQkliZ2UxY0Q0RzBCZFY4WGFWcHpzV1M1dUVFbkg4QStadjBCcjZLMFJYYjREUXFuM2pvVFkvNzltdkdmaEN5TDhUdEdMOUNKUVByNVRZb0dmVkNnQlFBTURzQlMwVVVDQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLOFQrUG5pRUxiNmY0ZWljYm5iN1hPQjJBeUVINGtrL2hYcityNnJhYUpwTnpxVjlLSTdhMmpNanQ3RHNQYzlCN212a3pVYjNVdkhualI1bFF0ZTZqY0JJbyt5RG9xL1JSMStoTkEwZXQvQUxRbWcwelV0Y2xUQnVaQmJ3azkxVGxqOU54eCtCcjJXc3p3OW9zSGg3dy9ZNlRiRDkzYXhCTS93QjQ5Mi9FNVA0MXAwQ0NpaWlnRHhqNCs2RDV0aHB1dlJLZDBMbTFtWWYzVzVRL2cyZisrcTlDOEFhNy93QUpINEowelVHWU5NWWhIUDhBOWRFK1Z2NVovR3JYaS9RMThTZUZOUzBvZ2JwNFNJeWV6amxUK1lGZVUvQUxXMmpuMVh3L2NFcTNGMUVwN0VmTElQOEEwSDlhQm51TkZGRkFnb29vb0FLS0tLQUNqdFJSMm9BK2ZmRG4vSnlGNS8xK1hmOEE2QWErZ3ErZmZEbi9BQ2NoZWY4QVg1ZC8rZ0d2b0tnQW9vb29BS0tLS0FDaWlpZ0Fvb3JIOFZhMm5oM3d2cU9xdVFEYndNeUE5M3hoUitKSW9BOE04VE1mSC94dmgweENYdExlWmJVK2dqankwcC9FaGhYMFVvQ3FBQmdEZ0FkcThNK0F1aXRjWCtxK0lia2IyVWZabzNibkx0ODBoLzhBUVIrSnIzU2dBb29vb0FLS0tLQUNpaWlnRGpQaXBvejYzOFBkVGhoUXZOQW91WXdPcEtISi93REhkMWVMZkJyeERIb25qaU8zbmNMYjZsSDltM0hvSHpsRCtKeVB4RmZUYktIVXF3QkJHQ0NPRFh5dDhTZkJjM2czeEs1Z1JocHQweGxzNUJuNWVjbE05aXZiMndhQm8rcXFLOHArR3Z4WHRkWnRvZEoxNjRTRFZFQVNPZVFoVXVmVG5vSDl1L2IwcjFVRUhwUUlHVU1wVmdDQ01FSHZYaTNqajRLdkxjdnFuaE5saWtMYjJzV2JhQTNYTWJmdy9ROGVoRmUxVlQxUFZiRFI3R1M5MUc3aXRiYU1aYVNWc0Q2ZTU5aFFCODVSL0ViNGgrRVhGanFUekVwd0k5U3Q5elk5bjRKK3VUVTh2eDE4V09tRWgweU00KzhJV1A4QU5xenZpVjhRNVBHbCtsdmFCNGRJdG1KaVJ1R2xicHZZZHZZZHZxYTNmQy93UXU5YjBPMzFIVWRTZlQzbitkYmZ5TnpCT3hPU01FOWNmU2daeWVvL0U3eGxxZVJOcjF6RXAvaHRRSVIrYWpQNjE2aHBmeHQwalRQQ3RqRmZOZTZucTZXNmlZcEZzVm43NVpzRDhRRFdmZmZzK09NSFQvRUFQSEl1YmZ2OVZOUVd2N1B0NlpSOXMxKzNXUHY1RnV4YjlUaWdOREhUNDIrSUc4VlFhbE1FWFRFSlY5UGkrNlVQVTdqeVg5RDA3WTVyMy9ROWUwN3hIcGNlbzZYY3BQYnlkeDFVOTFZZGlQU3ZJZkYzd1cwclN2Q3IzMm02azBOelpvMGs4bDdKOGt5K25IM0Q2WTY1d2E4aTBYeERxM2gyOCsxYVRmeTJreCs4RVBEajBaVHczNGlnRDJ6WGZpSnEzaEw0dHlXZXJ6bHZEOGthYlkxakE4dEdBL2VBNHlTR0RaOXMrbGV1Vzl4RGQyOGR4YnlwTERJb1pKRWJLc0QwSVBjVjhuK0t2SFY5NHh0TFZkV3NyVDdaYTVDWGNJWkhLbnFyTGtnak9EN0dxbWcrTmZFWGhsZkwwblZKb0lTY21Gc1BIbi9kWUVEOEtBc2ZZRkdhK1hYK01mamFSZGk2bENoUGRMVk0vcURUTk51UGlUNHExS0NXMHVkYW5kWkFVbExOSEZHYzlTZUZBb0N4OVMwVTJNT0kxRWhCZkEzRWRDYWRRSUtLS0tBQ2lzbnhOclNlSHZEV282czRWdnNzRFNLcmRHYm9vUDFKQXI1ODFUNDJlTHRSZ2FLRjdPd0JHQzl0RVM0K2pNVGo4QlFCNkQ4YXZHZHZwK2d5ZUc3YVZXdjcwQVRxcDVpaHprNTlDMk1BZW1UWGxIZ240ZDZyNDRXNWx0SjRiYTJ0MlZIbW1ERUZqemhRT3BBNVAxRlErRnZCZXZlTzlVTHdySVlYZmRjYWhjWktqMU9UOTl2WWZwWDFCNGM4UDJQaGpRN2ZTdFBUYkRDT1dQM25ZOVdZOXlUUU00UHczOEQ5QzBtVkxqVlo1TlZuVTVDT3V5RUgvZEhKL0UxNmVpTEdpb2loVlVZQ2dZQUhwVHFLQkNIcFh3dHJ2L0l3Nm4vMTl5LytobXZ1azlLK0Z0ZC81R0hVL3dEcjdsLzlETkFIMTM0QnQwdS9oYm9sdEo5eVhUVWpiNkZTRC9Pdm12VHA1L0IvalczbG1RaVhTNzNFaStvUnNNUHl6WDAxOE4vK1NjZUh2K3ZHUCtWZVRmSER3ZzlqcTZlSmJTUC9BRWE3eEhjN1I5eVVjQmovQUx3NCtvOTZCbzkrdDU0cnEzam5nY1BGSW9kSFhveWtaQnJHMW54am9XZ2FyWmFicWQrbHZkWG4rcVZnY1l6Z0Vub296eGsxNWo4R3ZpRkUxdEY0VjFXWUpLbkZqSzU0ZGY4QW5rVDZqdDZqanRXOThZZkFzdmliU1k5VjA2SXlhallvUVkxNnpSZFNvOXdlUjY4anZRSTlOb3J3TDRkL0dFNlZCRm8vaVpwSkxWTUpEZTRMTkVQN3JqcVFQWHFPOWU1MkdvMldxV3FYVmhkUTNNRGpLeVF1R1UvaUtBTFZGSmtaeGtVeWFlSzNpYVdhUkk0MTZzN0JRUHhOQUdQL0FNSmhvUDhBd2s1OE9IVUl4cWdVSHlDQ09TTTdjOU4yT2NkYTNLK2MvaS9KNFl1dGJYVjlFMXFLVFZTeXJjUTI1TEJpdkFjT3ZDc0FBT3ZPQjNGUmVIZmpmNGcwbUpJTlRoaTFXRlJnUEl4amwvRmdDRCtJb0hZK2thSzhXay9hRHQvS1BsK0c3anpNY0I3cFF2NWhjL3BYTGF0OGN2Rk45dVd5aXM5T1U4QW9oa2NmaTNINlVDc2ZSRi9xVmpwZHY5b3Y3eUMxaC92elNCQitacDluZVcyb1drZDFaenh6MjhneWtzVEJsWWV4RmZHbXA2dnFPdFhadWRVdnA3dVkvd0FjemxzZlFkQVBZVjdkNE0rSjNnbnd4NFdzOUlTNTFFK1FwTHZKYUhMT3hMTVJnbkF5VGdVRHNleUhwWGsrby9HWWFINDZ2dEcxWFNYaTArM2s4c1RvU1pSeDk4cWVDcDl1M3JWcTYrT3ZoT0ZUNUVlbzNEZGdsdnQvVmlLOHUrSUh4R3N2R3FJa2ZoeUMzbGo0UzhsazNUQWVnMjRHUFk1b0EraTlHOFJhUDRndHhQcFdvMjkwaEdTSTNHNWZxdlVmaUsxSytJbzVKSVpCSkU3eHlEb3lNVkkvRWMxczJldmVKcnFlTzB0TlkxVjVKRHRTTmJ4OGsrZ3kxQVdQc0NhZUszaWFXYVJJNDE1TE93VUQ4VFZldzFiVHRWV1J0UHZyYTdXSnRybUNWWENuME9EeFh6WmEvRER4OTRnbFUzdHRQRWhQTW1vM1JPMzN4bGorbGUxZkR2NGZRK0JiRzVCdTJ1cnk3S21ad3UxQnR6Z0tQeFBKNisxQWp0YUtLS0FDaWlpZ0Fwa2tzY01UU1N1cVJvQ3pNeHdGQTZrbjBxaHJldjZYNGQwOXIzVmJ5SzJoWG9YUExIMFVkV1BzSytkdmlEOFZMN3hjWkxDd0QyZWpBOG9UaDU4ZDNJNkQvWi9QTkFFbnhVK0l2L0NWMzM5bWFiSVJvOXMrZC9UN1E0L2ovd0IwZHZ6OUs3YjRMK0EzMDYzL0FPRW0xT0VwZFhDYmJPTnhneHhucTVIcTNiMit0Yy84THZoVkpxY3NPdStJSUNsaXBEMjlySU1HYzltWWRrOXUvd0JPdjBBQUFBQU1BVURGb29vb0VGRkZGQUJYem5yb1B3LytPRWQrb01kbmNUaTQ0NmVWTDhzZy9CdDFmUmxlUWZIdlFmdGVnV090UnBsN09Vd3lrRC9sbkowejlHQS83Nm9BOWVVNVVFSEk5YVd1UitHZXZIeEQ0RDA2NmtmZGNRcDlubVBmZW5HVDlSZy9qWFhVQUZGRkZBQlJSUlFBVWRxS08xQUh6NzRjL3dDVGtMei9BSy9Mdi8wQTE5QlY4KytIUCtUa0x6L3I4dS8vQUVBMTlCVUFGRkZGQUJSUlJRQVVVVVVBRmVPZkgzWFJiNlBwMmlSdjgxekliaVlEcnNUcCtiSC9BTWRyMk92blBVUi93c0g0NkxiS2Q5bEJjQ0wxSGxROHQrYkFqOGFBUFkvaDFvUC9BQWp2Z2JUTE4xMnp2RjU4L3dEMTBmNWorWEEvQ3Vwb0hBb29BS0tLS0FDaWlpZ0Fvb29vQUs4RitNM2ltWFhOYXR2QitrcjU1aW1YemdneVpKendzWSttZWZjK3hyMHo0aStNVThIZUdKTGxDclg5eG1HMGpQZHlQdkgyVWMva085ZWZmQlR3ZEpjenllTU5VRFNPek10bVpPU3pINzh2MTZnZmpRQnh2aWI0UmVKZkQ4S3p3d2YybmJiQVpHdFZKYU00NUJUcVFEM0dmb0t5ZEkrSVhpenc2b3Q3UFdKMWpUanlMZ0NSVjlzT01pdnJlc3ZVZkRlaTZ1UzJvYVZaWFRIcTBzQ3MzNTR6UU81ODZUZkdqeHJKR1ZGL2F4ZjdTV3E1L1hOYzRaUEUzampVbEJiVU5YdXM4RGx3bi9zcWozNHI2Y2krSHZoR0dRT25oM1R0dzZaaEIvblcvYTJkdFl3K1RhVzhVRVE2SkVnUmZ5RkFYUEp2aC84QUJxUFM1NHRWOFNlWFBkb1EwVm12elJ4bnNXUDhSSHAwSHZYc0ZGRkFncHNraVJSdEpJNm9pQXN6TWNBQWRTVFRxOEcrS1hqNjQ4UmFpUENIaHN2UEUwZ2luZUhrM0VtZjlXdit5RDFQZkhvT1FETjhiK0xOUitKdmlXRHczNGRWNU5QV1RFWUdRSjJIV1YvUkIyejllcEZldCtIZmh4b09pK0dWMGk0c2JlLzMvUGNTenhCaksvcnowQTZBZGhVSHc0OEF3ZUM5STN6QkpkV3VWQnVaaHp0SFVScWY3by9VOCtsZHZRQndGMThHZkJWeTVaZE9tZ0o3UTNMcVB5eVJYbm54VStHT25lR05EdGRWMEtHWVF4eWVYZGlTVXlIRFkydHowR2VEOVJYMEZWYlVMQzIxWFQ3aXd2SWhMYlhFWmprUTkxTkFIaDN3UDhVV2tkeEw0YXYxaURTTVpyS1IxR1MzOFNaL1Vmalh2T0JYeVo0MDhINmo0RThRQ0l0S2Jabjh5eXZGeU53QnlPUjBjY1ovT3ZWZkFQeG1zNzZDTFRmRTBxMjE2dUZXOFBFVTMrOS9jYjlEN1VEUFg2S1pGTkhORXNzVWl2R3d5cnFjZ2oyTlBvRUZGTWtsamlqYVNSMVJGR1daamdBZTVyeWJ4NzhackxUb0pkTzhOU3BkM3h5clhZNWloLzNmNzdmb1Awb0F5dmpuNHhqa0VYaGF5a0RGV0UxNlY3RWNwSDlmNGorRlEvQmZ3SFphblpYT3U2ellRM1VMT0lyTkowM0w4djNud2V2T0FQb2E0THdaNFExTHg1NGhLYjVmczRmekwyOGZuYUNjbms5WFBZZmowcjZxMDdUN1hTdE90N0N5aUVWdGJ4aU9OQjJBb0dUd3d4VzhTeFF4cEhHb3dxSW9BQTlnS2ZSUlFJS0tLS0FFUFN2aGJYZitSaDFQL3I3bC93RFF6WDNTZWxmQzJ1LzhqRHFmL1gzTC93Q2htZ0Q3QitHMy9KT1BEMy9YakgvS3QvVXRPdE5YMDY0MCsraFdhMXVFS1NSc09DRC9BSjYxZ2ZEYi9rbkhoNy9yeGovbFhVMEFmTEhqNzRjNmo0THZXdUloSmM2UXpaaXVnT1kvUlpNZEQ3OUQ5ZUszZkNIeHMxUFI0WTdMWFlXMUsxUUJWblZzVG9QY25oL3h3ZmV2b2VXR09lSm9wbzFramNZWkhHUVI2RUhyWG1IaVQ0SDZEcWp2Y2FSTEpwVTdIUGxvTjhKUCs2ZVYvQTQ5cUJuSitKNC9odDQzZDlSc05kajBUVlpQbWtGeEN5SklmVjE2Wi8ybFA1MTV2Y1IzL2hpK3pZYTNiczJlSjlMdmR3UDEyNEkvRVYyMTU4Q3ZGZHU1RnJQcDkwbllpWm95ZndJL3JWZUg0SStNNVhBa2lzSVIvZWU2ei9JVUFjMS93bnZpN1p0LzRTUFVzZjhBWGM1L09zaSsxVFVOVGZmZjM5MWR0Nnp6TS84QU0xN1BvdndBakIzNjVyRE54L3FySk52UCs4MmY1VlMxVDluKytSMmJTZGFnbFRzbDFHVWI4MXlQMG9BODcwSHd6YjZ2dGU3OFI2TnBjUGY3VGNBeVk5a0g5U0s5TzBTMytFZmhTMmMzZXEydXRYVHB0WjVZak54NktnQkMvd0EvZXVWbCtDWGpSR3drRmpLUFZidkEvVVZQYmZBenhkT3dFNzZkYkwzTFRsLzBDMEFSK0l2Ri9nTTcwMER3UmFPNTZUM2FsRkh2NWFubjhTSzRheDA2L3dCZjFRVzJtMkxUM01weUliZVBBWDhPaWozTmUyYUo4QXJDRmxrMXZWWnJySC9MSzJYeWxQMVk1UDVZcjFIUmZEMmtlSGJUN05wTmhEYVJIN3dqWGx2ZGoxSit0QUhqK25mQUI1dElqZlVkYWEzMUJ1V2poaUVrYWUyVGdrKzQ0cXZKK3o1cUliOTE0Z3RHWDFlMllIOUdyM3VpZ1Z6d20zL1o4dWl3KzArSVlWWHY1VnFTZjFhdW4wbjRHZUdMRjFlK2t1OVJZSGxaWDJJZitBcmorZGVuMFVBZUQvRmY0WFEyRnUyditIclZZN2FOUUx1MGlYQVFEanpGQTdmM2grUHJYa2xucFY3cVVOeEpaMjdYUDJkZDhxUi9NNnAvZTI5U3ZxUjByN1NaUTZsV0FLa1lJSTYxODlmRUx3YmUvRDd4QkQ0cDhORjRiSHpkNDJEUDJXUS93a2Q0MjZmcDZVRE9iOE0vRlB4UDRaUklJN29YdG12QXQ3dkxoZlpXKzh2MDZlMWVuNlA4ZTlEdVFGMVhUN3l5ZnUwWTg1UDB3ZjBOV2RHMDN3WDhXdEZPb1hHbVJXK3FKaGJyN08zbHl4djY1SDNsUFVFZy9tS3dkVS9aKytkbTBuWE1MMlM3aHpqL0FJRXVQNVVBZWdXM3hUOEUzUUJYeEJiSWZTWU5HZjhBeDRDckVueEg4R3hMdWJ4SnAyUDltWU4vS3ZFN2o0SGVNSWppSnRQbkhxdHdWL1FyVUNmQlR4cXpZTnRacDdtN0g5QlFCNjFxSHhvOEdXU0V3M3M5NncvaHRyZGpuOFd3UDFyZ2RkK1BlcFhLdEZvZW14V1lQQW51RDVqL0FGQ2pBSDQ1cUN5K0FldnpNRGZhcFlXNjl4R0hsUDhBSVYyMmlmQXp3MXA1V1RVcGJyVTVCMVdSdkxqUC9BVjVQNG1nTkR3K0tEeE40ODFyS0M4MVc5WTRMc2NpTWU1UHlvUHlGZEg4TTdEU3JQNGpEUy9FOWlEZEk3UlFKTWNvbHdwNk1PaHoyN1p4Nml2cE93MDJ5MHUxVzFzTFNHMmdYcEhDZ1ZSK0FyeDM0M2VEbVJvdkYybXF5U1JsVXZESHdSZy9KTDlRY0FuNkh0UUI3WU9CeFJYSC9EanhnbmpEd3ZGY1NNUDdRdDhRM2FEajV3T0crakRuOHgycnNLQkJSUlJRQVVVVVVBRlpmaVRTSTlmOE9haHBVdU50MUEwWUo3TVI4cC9BNHJVb29BOEcrQkdzU1dPdDZyNGN1dmxlVWVjaW50SWgydVB5d2Z3cjNtdm5YeG9qZUJQalZCcmNTbGJhNGxTOE9PTXEzeXpEK1ovR3ZvaU9SWllsa1JneU1BVkk3ZzlEUUE2aWlpZ0Fvb29vQUtPMUZIYWdENTk4T2Y4QUp5RjUvd0JmbDMvNkFhK2dxK2ZmRG4vSnlGNS8xK1hmL29CcjZDb0FLS0tLQUNpaWlnQW9vb29Bd2ZHbXVEdzU0UDFQVk4ySklZU0l2ZVJ2bFg5U1B5cnkvd0NBV2hzUnFuaUNkU1dZaTFpWTkvNHBEK2UwZm5Vbng5MTBwYmFab0VSeTByRzZsVWR3dnlvUHhKSi9DdlIvQW1oZjhJNzRMMHpUU3UyVklRODNIUG1OOHpmcWNmaFFCMGRGRkZBQlJSUlFBVVVVVUFGUnp6eFcwRWs4enJIRkdwZDNZOEtBTWttcEs4WitOdmpSb1lGOEthZTVNOXdGYThLZFFoUHl4L1Z1cDlzZXRBSEpYVWw1OFlmaWFzTUxTUjZWRGtLMy9QSzNCNWIvQUhuUDh4NlY5R1dkcEJZV1VOcGF4TEZCQWdqalJSd3FnWUFyai9oaDRMSGhId3luMm1NRFZMekV0MDNkZjdxZlJSK3BOZHZRQVVVVVVBRkZGRkFCUlJYbTN4VCtJNmVGYkU2WnBzaW5XYmhNNTZpMlEveG4zUFlmajI1QU1iNHVmRWhyTVNlR05EbEp2SkJzdTVvdVRFRC9BTXMxeC9HZS9wbkhVMXFmQ240Ymp3emFMcStxeEQrMTUwd3FFZjhBSHNoL2hIKzBlNS9EMXJHK0VudzRlTm8vRld2Uk0xekorOHM0WmVTdWVmTmJQOFI3WjZkZXZUMmVnQW9vb29BS0tLS0FNL1d0RTA3eEJwa3VuYW5hcGNXMG5WVzZnOWlEMUJIcUs4RjhXZkJMV05Ma2U0MEJ2N1R0T1NJU1FzNkQweDBmOE9mYXZvcWlnRDQ3dHRYOFRlRXBqRERlYWxwVGc4d3NXakdmOTF1RCtWYlAvQzIvRy9sN1A3ZWIvZThpTFA1N2ErcGJpMHQ3dVB5N21DS1pQN3NpQmgrdFpmOEF3aVBoemR1L3NMVGQzWFAyVlA4QUNnZHo1V3VkWThUK0xwaEJOZWFscWpFOFFxV2tYUDhBdXJ3UHlydXZDZndSMWZVNUV1TmZmK3piVGcrU3BEVHVQVDBUOGNuMnI2RHQ3UzN0SS9MdG9Jb1UvdXhvRkg2Vk5RRnlobzJpNmZvR21SYWZwbHFsdmJSOUZRZFQzSlBjbjFOWDZLS0JCUlJSUUFVVVVVQUllbGZDMnUvOGpEcWYvWDNML3dDaG12dWs5SytGdGQvNUdIVS8rdnVYL3dCRE5BSDJEOE52K1NjZUh2OEFyeGovQUpWMU5jajhON2lFZUFQRHR1WlU4NDZmRzRqM0RjVjZaeDF4bnZYWFVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJVRjdaMitvV1UxbmR3cE5ieklVa2pjWkRLZW9OVDBVQWZOdXQ2VHEvd2Q4YXc2bnBoZVhUWm1JaVp6OHNpZFRESjdqcUQ3QSt0ZStlRy9FVmg0bzBTRFZOUGszUlNERElmdlJzT3FzT3hILzE2azE3UXJEeEhvOCtsNmpGNWx2TU9jY0ZUMlpUMklOZlB0aGVhejhHZkc4bHJkaDU5TW5JTGhSOHR4Rm5pUmZSMTlQdzZZb0dmU2xGVmRPMUMxMVhUNEwreW1TZTJuUVBISWg0WUdyVkFnb29vb0FLaHU3U0MvczVyUzZpV1dDWkNraU1PR1VqQkZUVVVBZk5sak5kL0I3NG5QQk8wamFYTmhYWWovV1c3SDVYL3dCNVRuOGo2MTlJUlNwUENrc2JoNDNVTXJLY2hnZWhGY044VmZCZi9DV2VHV2x0WTg2bllneTIrQnk0eDgwZjRnY2U0RmMzOEVmR2YyMndid3hmU0g3VGFLWHRTM1ZvdTYvVlQraDlxQm5zRkZGRkFnb29vb0FLS0tLQVBLdmpyb0l2dkNjR3J4cG1YVDVodklIL0FDeWY1VCtUYlQrZGIzd24xNyszZkFGaVpIM1hGbm0wbHllY3A5MC9pdTAxMU90YVpEcldpM3VtVGo5MWRRdEUzdGtZelhoL3dTMUtiUmZHT3FlR3J3N1htRFlVL3dEUGFJa0VmaXBQNVVEUGZxS0tLQkJSUlJRQVVkcUtPMUFIejc0Yy93Q1RrTHovQUsvTHYvMEExOUJWOCsrSFArVGtMei9yOHUvL0FFQTE5QlVBRkZGRkFCUlJSUUFVSGdVVnpYai9BRjRlSFBCT3AzNnNCT0lqSEFQV1IvbFgrZWZ3b0E4WWlQOEF3c0g0N2J5TjlqQmNad2VSNU1IVDgySC9BSTlYMFpYakh3QzBIeXRQMUxYWlZ5MHppMmhZOWRxOHNmeFlqL3Ztdlo2QUNpaWlnQW9vb29BS0tLQ2NESm9Bd2ZHSGllMjhKZUc3blZiakRNZzJ3eFovMXNoKzZ2OEFqN0ExNDc4SmZERno0cjhUM1BpL1dzelJ3emwwTGppYTRQT2Zvbkg0NEhhcVhqVFY3ejRvL0VLMjBIU0gzV052STBVTEQ3cHgvckpqN0FEQTloNzE3N29tajJlZ2FOYTZYWXg3TGUzakNMNm4xSjl5ZVQ5YUJtaFJSUlFJS0tLS0FDaWl1ZjhBR1BpMnc4SGFGSnFGNGQwaHlsdkFwK2FaOGNBZTNxZXdvQXpQaUo0OHR2QldqWlFwTHFsd0NMV0EvcTdmN0kvVThWNXA4TXZBZDE0czFSdkYzaVhmUGJQS1pZbG02M1VtZnZuL0FHQjJIZkhvT2FIZzd3dnFueFQ4VlQrSU5mWmpweVNmdlNPQklSMGhUMFVkL3dERTE5RlF3eDI4TWNNS0xIRkdvVkVVWUNnY0FBZGhRTWVCZ1lGRkZGQWdvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tRa0FFazRBcnpEeHI4WnRLMElTMldpN05TMUJjaG5EZnVJajdzUHZIMkg1MEFlZzZ2ck9uYUhZUGU2bmVSV3R1blY1RGpKOUFPcFBzT2ErSHRXdUk3bldiNjRpSk1jdHhJNmtqQndXSkZleDZUNEw4WWZFL1VZOVgxKzZtdDdBbkt6VExqNWM5SVkrZ0h1ZVByWGplcDJxV21yWHRzak1VaG5ralV0MUlERWMvbFFCN0xMNEM4VDNuaGp3LzRxMEcrbG5taTA2RlV0NGo1Y3NDcVArV1pIM2gxSkhVNTcxdStFUGpiTGJ5cnB2aStGa2RHMkc4U1BES2YrbWlkajdqOHE5RitHLzhBeVRqdzkvMTR4L3lwbmkvNGQ2RjR3aUwzY0hrWHdHRXZJQUJJUHIyWWV4L0RGQUhTMlY5YTZqYVIzVmxjUlhGdklNcExFd1pXSHNSVml2bTI1MHJ4eDhJYjlydXprTStsczN6U0lwZTNrSC9UUk9xSDM0K3ByMUx3WDhXTkU4VStYYVhMRFR0VGJBOGlWdmtrUCt3L1EvUTRQMW9BOUFvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BSzUzeHA0UXNmR1dneWFmZEFKTXVYdHJnRExRdjYvVHNSM0g0VjBWRkFIenI0SDhWNmo4TS9FOC9odnhFclI2ZTB1SkFlUkF4NlNyNm9lLzU5UWEraUk1RWxqV1NOMWRHQVpXVTVCQjZFR3VKK0pIZ0NEeG5wUG1XNFNQVjdaU2JhVThCeDE4dGo2SDE3SG4xcmdQaFY0L24wSysvNFJEeEdYZ1JKREZiUE53WUh6L3FtejJKNkh0MDZFVURQZDZLS0tCQlJSUlFBVjg5ZkU3UUx2d0w0MnRmRmVpcjVWdlBONXE3UjhzYzQ1WlQvQUxMakp4N3RYMExXVDRtMEMwOFQrSDd2U2J3ZnU1MHdyNDVqWWNxdzl3Y0dnQlBEUGlDMThUK0g3VFZyUS91NTArWk04eHVPR1UrNE9SV3ZYeno4TXRmdXZBbmphNjhLNjBmS3Q3aWJ5bTNINVk1dWlzUDlsaGdaOTFyNkdvQUtLS0tBQ2lpaWdBcjUzK0pVRW5ndjR0V2ZpRzJYRVZ3eVhuSEFMS1FzcS9pT2YrQlY5RVY1bjhiOUMvdFB3VU5SalRkTnBzb2xKLzZadDhyL0FORCtGQUhwRnZQSGMyMFU4TEJvcEVEb3c3cVJrSDhxa3J6NzRPYTZkWThCVzhFajdwOVBjMnI1UE8wY29mOEF2a2dmaFhvTkFCUlJSUUFVZHFLTzFBSHo3NGMvNU9RdlArdnk3LzhBUURYMEZYejc0Yy81T1F2UCt2eTcvd0RRRFgwRlFBVVVVVUFGRkZGQUJYaDN4ODF0cEp0SzhQUUVzeHpkU29EMUorV01mK2hWN2lUZ1pyNXowVmYrRmcvSE9TOWI1N0tDZHArUng1VVdGUWZpZHY1bWdEM0h3aG9pK0hQQ2VtNlVCODBFSUVoOVhQTEgvdm9tdHVnZEtLQUNpaWlnQW9vb29BSzh2K012amIrd2REL3NXeWwyNmhxQ0VPd1BNVVBSajdFOUIrUHBYZjY3ck5wNGUwUzcxVytmYmIyeUYyOVdQWlI3azRBK3RlQ2VCOUd2UGliOFFibnhEcktiN0sza0VzeW43cFlmNnVFZXdBQlBzUGVnRHZ2ZzU0Si80Ui9RZjdZdll0dW82Z2dJVmh6RkQxVmZxZUNmd0hhdlRxQU1VVUFGRkZGQUJSUlZlK3ZyYlRiR2E5dkprZ3RvRUx5U09jQlZIZWdDcnIydTJIaHpSN2pWTlJtRWR2Q3VUNnNleXFPNUo0QXI1OXNyVFd2alA0MmU1dVM5dnBsdWNPUWNyYnhaNFJmVjJ4MS9Ib0FLZHJPcTZ4OFl2R3NXbmFhcnc2WkN4TVljZkxFblF5eWY3UjdENkFkelh2bmh2dzdZZUZ0RWcwdlQ0OXNVWXl6SDcwakhxekh1VFFNdDZacHRubytuUVdGaEFrRnRBZ1NPTmVnSDlUNzk2dDBVVUNDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaXE5N2ZXdW5Xa2wzZTNFVnZieGpMeXlzRlZSN2swQVdLNXp4VjQzMFB3aGErWnFWMFBQWVpqdFkvbWxrK2k5aDduQXJ6THhmOGJKcm1ZNlo0UGhkM2tPd1hqeEZtWS85TWs3L0FGSS9DcXZoWDRPYXBydDEvYS9qRzVuakVwM3RibDh6eS83N2Z3L1FjL1NnREsxUHhiNHorS2wrK2xhTGJTVytuazRlR0ZzS0Y5WnBQNmRQWTE2SDRLK0Rta2VIakhlYXRzMVBVVndWM0wrNWlQOEFzcWVwOXorUXJ2OEFTOUowL1JiR095MDIwaXRiYVA3c2NhNEgxUHFmYzgxZG9BVEFBQUE0cjRXMTMva1lkVC82KzVmL0FFTTE5MG5wWHd0cnYvSXc2bi8xOXkvK2htZ0Q3QitHMy9KT1BEMy9BRjR4L3dBcTZtdVcrRzMvQUNUanc5LzE0eC95cnFhQUd5UnBORzBjaUs2TU1NckRJSTlDSzhsOFovQkt3MUx6TDN3MnlXRjBjczFxMmZKYyszOXcvVGoyRmV1VVVBZk8raGZFZnhUOFA5UUdqZUtMTzR1YmFQZ0pPZjN5TDZvL1IxK3AvRVY3ZjRkOFU2UDRwc1B0ZWszaVRLUHZ4bmg0ejZNdlVWTHJ2aDNTdkVtbnRaYXJaeDNFSjVYY1BtUStxbnFwOXhYaUhpTDRWK0l2QnQ5L2JQaEs4dWJtS0xMQVJIRnhFUFFnY1NMK0gxRkF6NkRvcnh2d2I4YjRMaGtzUEZVWXRad2RvdlkxSWpKLzIxNm9mZnA5SzlnZ3VJYnFCSjRKVWxpY2JrZEdES3c5UVIxb0VTVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFWNVo4V1BodVBFTnErdDZSQ1A3VmdUOTdFdi9MeWc3Zjc0N2V2VDByMU9pZ0R5UDRSL0VnNnJFbmh6V3BqL0FHaEV1TGFhUTh6cVA0VC9BTFl4K0k5d2E5Y3J4RDR0ZkR5VzFuZnhkb0N0RzZNSmJ1S0hoa1lIUG5Kai93QWUvUDFyci9oajhRNHZHR21DenZYVk5adGsvZXFPQk12L0FEMFgrbzdIMk5BSG9GRkZGQUJSUlJRQjQvOEFHN3daOXUwOVBFMWpGL3BObXUyN0NEbDR1emZWZjVIMnJwUGhWNHovQU9FczhNaUs2azNhbllnUlhHVHk0L2hrL0VEbjNCcnVaWWttaWVLUkZlTjFLc3JESVlIcURYemZmUVhYd2Y4QWlkSGNRQ1J0TG0rWlFQOEFscmJzZm1UL0FIbFBUNkQxb0dmU2RGUVdkM0JmMmNOM2F5ckxCTWdramRlaktSa0dwNkJCUlJSUUFWVzFDeWgxSFRibXh1RkRRM0VUUk9QOWxoZy96cXpSUUI4OS9CKytuOE0vRVBVZkRWMnhIMmpkQ1FlUDNzUkpCL0ZjL3BYMEpYejM4WExTYnd0OFN0UDhTMmk0RndVdUJqZ0dXTWdNUHhYYitacjN5eHZJZFJzTGU5dDIzUTNFYXlvZlZXR1IvT2dDeFJSUlFBVWRxS08xQUh6NzRjLzVPUXZQK3Z5Ny93RFFEWDBGWHo3NGMvNU9RdlArdnk3L0FQUURYMEZRQVVVVVVBRkZGRkFISmZFclhUNGU4QjZsZG8rMmVSUHM4SCsrL3dBdjZESi9DdU0rQW1nL1pkRHZ0YmtURFhjbmtSRTlmTFRyK2JFL2xXUjhlTlprdk5XMHJ3NWFuZXlEejNRZDVIK1ZCK1dmKytxOWk4TTZQSG9IaG5UdEtqSEZyQXFFK3JZK1kvaWNtZ0RWb29vb0FLS0tLQUNpaXVGK0tQalFlRWZEVExheUFhcGVaaXRnT3FmM3BQd0hUM0lvQTgzK0szaVc1OFgrSzdid2pvdVpvb0p4R3dVOFMzQjQ1LzJVR2Z4M2VsZXplRWZEVnI0VDhPV3VsV3VHOHNicFpNY3l5SDd6SC9QUUN2T1BnbDRMTnJhdDRxdjR5WjdsU2xtSDZyR2Z2UDhBVnZYMCt0ZXgwQUZGRkZBQlJSUlFBMTNTTkdkMlZVVUVsbU9BQjZtdm5qeDM0djFENGtlSTRmRFBoeFhrc0JMdFRid0xoeDFrYjBSZW96OWZTdEw0cWZFQ2ZYYjcvaEVQRGhlZEhrRVZ4SkR5WjN6L0FLcGZVWjZudjA2QTEzM3cyK0g4UGd6U3ZOdUFrbXIzS2o3UktPUWc2K1dwOUIzOVQrRkF6VDhFZURMTHdYb2EyVnZpUzVrdzl6Y0VZTXIvQU5GSFFEL0UxMDFGRkFnb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvckg4UStLTkg4TDJKdTlXdkVnVCtCT3J5SDBWUnlUWGlHdmZFcnhSNCt2em92aGF6dUxhMms0Mncvd0N1a1gxZHh3aS9RL2lhQVBTUEdueFgwWHdxWkxTM0kxSFUxNDhpRi9salArMjNiNkRKcnl5MjB2eHY4WDc5YnE3bE1HbHEyVmtjRmJlUC9ybW44WjkvMUZkcjRMK0NWbHAzbFgzaVIwdnJyaGhhci9xVVArMS9mUDZleHIxdU9OSW8xampSVVJRRlZWR0FCNkFVRE9VOElmRHpRdkI4U3ZhUWVmZkVZZThtQU1oK25aUjdEOWE2MmlpZ1FVVVVVQUllbGZDMnUvOEFJdzZuL3dCZmN2OEE2R2ErNlQwcjRXMTMva1lkVC82KzVmOEEwTTBBZllQdzIvNUp4NGUvNjhZLzVWMU5jdDhOditTY2VIdit2R1ArVmRUUUFVVVVVQUZGRkZBSEQrTS9oZm9maTBQYytYOWkxTWppN2dVZk1mOEFiWG8zOC9ldkpBL2puNFBYMjF2MzJsTy9BeVh0cGZwM2piOHZ4cjZUcUs0dG9MdTNlQzVoU2FHUWJYamtVTXJEMElQV2dEa1BCdnhOMFB4ZXF3UnlmWTlTeDgxbk93M0gvY1BSaCt2dFhhVjR2NHkrQ0VVanZxSGhTUVc4d08vN0ZJMkZ6LzB6YnFwOWp4N2lzYnczOFdkZjhKWHY5aStMclM0dUk0anRMU0xpNGlIcnp4SVBmOVRRTStnYUt6ZEUxL1MvRVZndDdwVjdGY3dIcVVQS24wWWRWUHNhMHFCQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBSXlxNmxXQUtrWUlJNjE4OS9FUHdaZmVBTmZoOFZlRzJhR3k4M2NOblAyYVEvd2tkNDI1R1BmSHBYMExVRjVaMjkvWnpXbDNDazF2TWhTU054a01wNmcwQWM3NEY4YTJmalhRMXVvZ0lyeUxDWFZ2bm1OL1VlcW5zZjhLNm12bTNYZEkxZjRQZU5JZFUwcG5rMHlaaUlpNU8yUk9waGs5eDJQNDlqWHZmaHJ4SFllS2RFZzFUVDVOMFVnd3lINzBianFyRHNSL3dEWG9BMTZLS0tBQ3VRK0kvZzlQR0hoZVczalZmN1F0OHpXam4rK0J5djBZY2ZsNlYxOUZBSGlmd1I4WVBHOHZoRFVtWkpJeXoyWWs2akJPK0w2ZzVJLzRGNlY3WlhnZnhnOE1YSGh6eEZiZU1kSEpoV2FaV2xaQi9xcmdkSCtqWTU5d2ZXdlhQQm5pZTM4WGVHYlhWSU1MSXcyVHhBLzZ1UWZlWCtvOWlLQU9nb29vb0FLS0tLQVBQUGpOb1ExZndIUGN4b0d1Tk9jWEsrdTNvNC83NU9md3FENEo2Nk5VOEVMWU8rNmZUWlRENytXZm1RL3FSK0ZlaVhWdkZlV3MxdE91NktaR2pkZlZTTUVma2ErZGZBR3J4ZkRuNGo2cnBlcjNBZ3NjU1c4c2pnNEJRN28yd1BVZitoVUFmU0ZGZVRhdjhlZEJ0Q3k2WlkzZCtSMGRnSVUvd0RIdWYwcmxaUGpONDExdVF4YUhvOENaNEhrVzBseTM1OVAwb0N4OUJaSHJRVFh6M3MrTSt0RXVUcWNBUDhBdFIydy9MZy9wUVBodjhVTDQ3cm5WbVhQWHpkVGNuL3gwVUFQOE9mOG5JWG4vWDVkL3dEb0JyNkJ6WHpzdndSOFpDZjdTTlNzRm5Za21RWE1tL0o2L050elVwK0Z2eEt0ZWJmVjFZais1cWNnL21LQm4wSmtldExYenlkSitNbWtqZEhQcVU2cjJTNlNZZmtUbWxIeFIrSkhoNWdOWjB2ekZIVTNkZzBXZitCTGdmcFFGajZGcHJzcUlXWWdLQmtrbm9LOGMwbjlvQ3dtS3JxdWp6d0h2SmF5Q1ZmeU9EV240eitLR2dYbmdEVW0wVFZJNWIyZU1XNlJjcEl1L2duYWNIZ1o1b0VjTjRRRGVQZmpaTnJFaWxyV0NacnNaN0ltRmlINTdUK2RmUmRlVC9BalFoWmVGN3JWNUV4SmZ6Yll5Uno1U2NEODIzR3ZXS0FDaWlpZ0Fvb29vQXIzdDdiNmRZejNsM0tzVnZBaGtrZHVpcUJrbXZuU3dndlBqRDhUSHViaFpFMHVIRE9wUCtxdHdmbFFmN1RIcjlUNlYwWHhxOFlTWGwzRjRQMHBtbFptVTNZajVMdVQ4a1g1NEovRDNyMFg0ZStENC9CdmhpS3pZS2I2Yjk3ZHlEK0p5T2dQb280SC93QmVnWjFNTVVjRUtReElxUnhxRlJGR0FvSEFBcDlGRkFnb29vb0FLOGcrTGZ4SU9uSko0YTBTWW0vbEcyNm5qUE1JUDhDNC9qUDZBK3ByWitLUHhHajhKNmVkTzA2UlcxbTRUNWU0dDBQOGJlL29QeDZDdWErRXZ3NWRwSS9GbXZ4czg3bnpiT0dibHNubnpuejNQYlAxOUtBTnI0VWZEWWVITFZkYTFlRWYydk12N3VOdWZzeUh0L3ZudjZkUFd2VWFLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0s0L3hqOFI5RDhIeHRGY1RmYWRRSXlsbkFRWC9BT0JIb28rdjRBMEFkYkxMSEJFMHNzaXh4b01zem5BVWVwUGF2SWZHZnh1dGJQekxId3dpM2x6bmFieHhtSlQvQUxJNnVmMCt0Y2JOZStPUGpEcUJoZ2o4alNsZkJWU1Z0b3Y5NXVydDdmb0s5WThGL0N2UlBDWVM2a1FYK3BnWiswektNSWY5aGY0ZnJ5ZmVnWjV0NGY4QWhoNGw4Y1g0MXJ4WmVYTnZCTHptWTVua1gwVlR4R3Y0ZmhYdCtnK0c5SjhNMkFzOUpzNDdlTCtJZ1paejZzeDVKK3RhdEZBZ29vb29BS0tLS0FDaWlpZ0JEMHI0VzEzL0FKR0hVLzhBcjdsLzlETmZkSjZWOExhNy93QWpEcWYvQUY5eS93RG9ab0Erd2ZodC93QWs0OFBmOWVNZjhxNm11VytHMy9KT1BEMy9BRjR4L3dBcTZtZ0Fvb29vQUtLS0tBQ2lpaWdBckU4U2VFOUc4VjJYMmJWck5aZHYrcmxYNVpJejZxM1VmeXJib29BK2RkYStIM2l6NGRhZzJzZUdydWU1dEU1TXNBL2VLdnBKSDBaZmNBajJGZGo0TCtOZW5hcUk3THhDcWFmZUg1UmNEL1VTSDNQOEIrdkh2WHJOZWVlTlBoSm92aWZ6THV5QzZicWJjbVdKZjNjaC93QnRQNmpCK3RBejBGSFdSRmRHREt3eUNEa0VVNnZtNnoxdnh0OElyOWJIVUlUUHBoYkNSU01XZ2NmOU1uL2hQdCtsZXorRWZpRG9YakdFQ3l1UEt2UU12WnpFQ1JmY2YzaDdqOUtCSFZVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUdicnVoMlBpUFI3alM5UmhFbHZPdUQ2cWV6S2V4QjVCcjU5c2J2V2ZnejQ0ZTF1Zzl4cGs1QmNLTUxjUlo0ZGZSMTlQdzZFVjlLVnp2alB3aFkrTXRDZlQ3c0JKVitlM3VBTXRDL3FQYnNSM0ZBR3hwMm8ydXJhZGIzOWpNczF0T2dlT1JlaEJxMVh6cDRKOFY2ajhNZkU4L2h6eENySnA3U1lrQjVFTEhwS25xaDcvQUo5UWEraVk1RW1pV1NObGRIQVpXVTVCQjZFR2dCMUZGRkFGRFd0SXROZDBhNjB5OWozMjl6R1VjZHg2RWU0T0NQcFhnUGduVnJ2NFlmRVM1MERWMzIyTnhJSVpuUEM1UCtybUhzYzgreFBwWDBiWGwzeG44Ri8yNW9YOXQyY1c2KzA5Q1pGVWN5dzlXSDFYbGgrTkFIcU5GZWFmQjN4b1BFUGg3K3k3eVhkcVducUZKWTVNc1hSVzl5UHVuNkQxcnR0ZjhSNlY0WjA1cjdWcnRMZUljS0R5em4rNnE5U2ZwUUJxMXhuaXY0bitIZkNqUEJOY0c3dmwvd0NYVzJ3ekEvN1I2TCtKcnlyWHZpWDRvOGVhZ2RHOEwybHhiVzhuR3lEL0FGOGkrcnVPRVg2WStwcm8vQ1h3THRiY0pkK0o1eGRTbjV2c2NMRVJnLzdUY0ZqOU1ENjBBYzFkL0VUeDc0OHUzc3ZEdHBOYXdFNEsyUXl3SCszS2Z1L2hpdExSUGdUcU45TDlxOFNhdjVUT2R6eDI1ODJSajd1M0dmenIzQ3lzTFRUYlZMV3h0b2JhQkJoWTRrQ3FQd0ZXS0FPTjBmNFdlRU5GMnRGcE1keEt2L0xXN0psWS9ueCtsZGZGREZCR3NjTWFSb3ZBVkZBQS9BVStpZ0Fvb29vQUtLS0tBQ2tJQkdDTWc5cVdpZ0RtdFk4QWVGdGMzTmZhTGF0SWYrV3NhK1cvMTNMaXZNZkUvd0FCblZ4TjRadlFVeDgxdmV2em4vWmNEK2Y1MTduUlFCODNRNnA4UnZoYXFRM1VNajZYR2NLa3ErZGI0OUZjY3A5TWl2U1BDdnhtOFA2Nlk3YlVNNlZldGdBVE5tSno3UDIvNEZpdlI1STBsUmtrVldSaGdxd3lDUGNWNXI0cytDK2g2NEpMalNkdWxYclpPSTF6QzU5MDdmVmNmU2daNldyQmxES1FRUmtFZDZXdm02MDF2eHY4STc5TExVWVd1Tk1MWVdLUmkwTGovcGsvOEo5djByMnZ3ajQ2MFh4bGFlWnA4K3k1UVpsdEpjQ1NQOE80OXh4UUk2YXVZOGVlTFlmQjNobWZVRHRlNmY4QWRXc1IvamtQVDhCMVAwOTY2V1NSSW8ya2tZS2lnbG1ZNEFBNmsxODRhM2UzbnhkK0pjT24yRHN1bVFrcEUvYU9FSDU1VDd0eGovZ0k5YUFOcjRNK0VwdFcxU2J4anEyNlhiSTMyWnBPc2twKy9KK0dTQjdrK2xlNzFWMDNUN2JTZE50N0N6aUVWdGJ4aU9OQjJVVmFvQUtLS0tBQ3VQOEFpRDQ2dGZCV2ltUWJaZFNuQlcxdHozUGRtLzJSK3ZTdEx4ZDRzc1BCK2h5YWpmTnViN3NFQ25EVFAyVWYxUFlWNGY0UzhOYXI4VnZGbHhyMnV1MzlteHlEelNNZ1BqcERINkFkejJ6Nm1nQzk4TmZBdDM0eDFkL0Z2aVhmUGF0S1pJMWwvd0NYcVRQVWorNE9tTytNZEJYdjRBQXdLWkJCRmEyOGNFRWF4eFJxRVJFR0FxZ1lBQTdDcEtBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vcENRb0pKd0JRQXRVZFgxblR0QzA5NzdVN3VLMnQwNnZJMk1uMEE2ayt3cnozeHI4WnRLMEh6TExSaEhxVit1UXpodjNFUjkySDNqN0Q4eFhCYVQ0TDhZL0ZEVUUxYlhidVczc1R5czA2NCtYMGhqNkFlNXdQclFCbytLUGpCckhpTzhHaitEclc0aFdVN0ZtVk4xeEwvdWorQWUvWDZWZjhIZkJKcEpCcVhpNlZwSkdPL3dDeEpKbkovd0NtajlTZllIOFRYcHZoZndab25oR3o4blM3UlZsWVlsdUgrYVdUNnQ2ZXc0cm9LQUliUzB0N0MxanRiU0NPQ0NNYlVqalVLcWoyQXFhaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQVE5SytGdGQvNUdIVS93RHI3bC85RE5mZEo2VjhMYTcvQU1qRHFmOEExOXkvK2htZ0Q3QitHMy9KT1BEMy9YakgvS3Vwcmx2aHQveVRqdzkvMTR4L3lycWFBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BclgxaGFhblp5V2w5YlJYRnZLTVBIS29aVCtGZUxlTHZncGMyY3gxUHdmUElHak84V2J5WWRELzB6ZjhBb2Z6cjNLaWdEd2Z3cjhaZFQwVzYvc254bGJUdjVSMk5jZVh0bmovNjZKeHUrbzUrdGUyYVpxMWhyVmpIZTZiZHhYVnRKOTJTSnNqNmV4OWp6V1A0cThENkg0dnR0bXBXbzg5UmlPNmkrV1dQNkh1UFk1RmVLYW40VDhaL0N1K2ZWTkd1cExqVDg1ZWFGU1ZLK2swZjllbnVLQm4wZlJYbWZndjR4NlI0aE1WbnF3VFROUWJnRm4vY3luL1pZOUQ3SDh6WHBnSVBTZ1FVVVVVQUZGRkZBQlJSUlFBVVVVVUFjUjhTUEFNSGpUU044QVNQVnJaU2JhVThidldOai9kUDZIbjFyejc0VitQcDlBMUQvaEQvQUJHWGdSWkRGYnZOd2JlVFArcWIvWko2SHNUNkVWN3hYbHZ4WitHNDhSV3I2M3BNSS90YUJQM2thai9qNVFkdjk4ZHZYcDZVQWVwVVY1RjhJL2lPZFVpajhONjFLUnFFUzdiYWFROHpxUDREL3RqOVFQVVY2N1FBVWpBTXBCQUlQVUdscnpyNG1mRXVId2piTnAybmxKdGFsVElCNVczVS93QWJlL29QeFBGQUhsbmlxQ1g0WGZFOFh1aVNRbUpoNThjRzdJVkh5R2ljRGtEUFQyeDZWUG9YaEx4UjhWOVgvdHJXcnFTSFR5Y2ZhR1hBSy8zSVU2WTkrbjFOYWZ3KytHTjE0b3V2K0VsOFdHYVMybWJ6VWhtSjMzUlA4VDl3bm9PL3NPdnZjVVVjRUtSUW9zY2FBS3FJTUJRT2dBN1VETXJ3NzRZMGp3dHB3c3RKdEZoVHE3OVhrUHF6ZFNhMktLS0JCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQlcxRFRyUFZMS1d6dnJhSzR0cFJoNDVGeURYaGZqSDRVNm40V3UvN2U4SHpYTFJRc1pQSmpZbWEzOTFQOGErM1g2MTc3UlFCODJhNThZZFUxN3dTZEZsZ0VWL013anVibUxnU3hkd0Y2aG1QQjdZNmRlUFUvaFI0Sy80Ulh3NExtOGkyNnBmQVNUZ2ptTmY0WS93Nm4zUHRXSjhTdmhORnF5eTYxNGVoV0hVaDg4MXNueXJjZTYvM1gvUS9YbXFud3crS01zczBmaHZ4Tkl5WGFueTdlNm00TEVjZVhKbm8zWUU5ZWg1Nmd6MmFpaWlnUVZuYTVyZGg0ZDBpNDFQVVpoRmJRcmtucVdQWlFPNUo0QXExZVhsdnA5bk5lWGN5UTI4S0Y1SkhPQXFqcVRYenJyMnNheDhZUEdjT2xhVWp4YVpFeE1TdVBsalRvMDBudjZENkR1YUFHVzhHdC9Hanh1MDBwZTMweTMrOFJ5dHRGbmhSNnlOait2UVY5RWFWcGRub3VtVytuV0VDdzIwQ0JFUmV3L3FmVTk2cCtHZkRWaDRVMFNIUzlQanhHbkx5SDcwcm5xekgxUC9BTmF0aWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tyM3Q5YTZkYVNYZDdjUlc5dkVOenl5c0ZWUjdrMTR2NHYrTmsxektkTThJUU96dTJ3WGp4NVpqLzB6VHY4QVUvbFFCNmQ0cThiNkg0UXRmTTFPNkFtWVpqdG8vbWxrK2k5aDduQXJ4UFUvRnZqUDRxWDc2Vm90ckpiNmVUaDRZV3dvSHJOSi9UOURXcDRXK0RtcWE3ZGYydjR4dVo0eEtkN1FHUXRQTC92dC9EOUJ6OUs5dDB2U05QMFN4U3kwMjBpdGJaUHV4eExnZlUrcDl6UU00RHdWOEhOSjhQR0s5MWJacVdvcmdxR1g5ekVmOWxUMVB1ZnlGZWxnQWRCUzBVQ0NpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBRVBTdmhiWGYrUmgxUC9yN2wvd0RRelgzU2VsZkMydS84akRxZi9YM0wvd0NobWdEN0IrRzMvSk9QRDMvWGpIL0t1cHJsdmh0L3lUanc5LzE0eC95cnFhQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2tJRERCQUlOTFJRQjVoNDArRE9rNjk1dDVveFRUYjlza29GL2NTbjNVZmRQdVB5TmNCcFhqTHhsOExyOU5LMXkwbHVMRWNKRE8yUnQ5WXBlZVBia2V3cjZPcWpxMmo2ZHJsZzlscWRwRmRXejlVa1hJSHVEMUI5eHpRQm1lRi9HdWgrTHJYemRMdWdaVkdaTGFUNVpZL3F2cDdqSXJvYStmZkdYd3F2UENVdjl1K0dOVFpJWVR2V09TY1J6UmY3amtnTVBicjlhdmVFUGpvME1RdGZGTUx5N1I4dDdicDh4L3dCOVBYM0g1VURQZEtLOHNsK1BYaFpXeEhaNnJJUFh5VUg4M3A4SHg0OEtTSEV0dnFjUHUwQ3NQMFkwQ1BVS0s1VFNmaVY0UjFxUlk3WFdyZFpXNlIzR1lXUDBEQVpycWxaWFVNcEJCR1FRZXRBQzBVVVVBRkZGRkFIaVB4YStIY2x0Ty9pM1FFZU9SRzgyOGloNEtrYytjbU80NzQrdnJYVy9ERDRpUitMOU4reDN6b21zMnlqekY2Q2RmK2VpL3dCUjJQc2E5QVpReWxTQVFSZ2cxODkvRVh3YmQrQU5ldC9GWGh4ekJaTk1DQW4vQUM3U24rSEhkRzU0K285S0JucDN4SThmUStDOUhDd0ZKTld1UVJiUkhrTDZ5TVBRZnFlUFd2T2ZoajhQWi9FMThmRmZpWGZQYnZKNXNNYzNKdW56OTlzL3daNkR2OUJ6bCtEdkQrby9GWHhuY2EzcmpGckNKd1p5TWhXL3V3cDZESFgyOXpYMGRGRWtFU1JSSXFSb29WVlVZQ2dkQUJRQThBQVlIU2lpaWdRVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVjVSOFZmaGt1dVF5Njlvc0lHcVJqZFBDbkgybFIzSCsyUDE2ZGNWNnZSUUI1TjhKUGlPMnRRcDRlMW1VLzJsQ3YranpPZWJoQjJQOEF0ajlSN2cxNnU3ckdoZDJDcW95U1RnQVY0WDhYZkE4dWpYNitNZEJEd0JaQkpkQ0xnd3laNGxYMEJPTSsvUGMxamVKL2lycXZpL3cvcCtnV0Z0SkZkM0tpTzk4cnJPK2NCRUEvaFBVL2wwNmd5eDQvOFpYL0FNUlBFRVBoZncycnkyUG03VjJjZmFYSDhaUGFOZXY2K2xlditCdkJWbDRLMFJiU0VpVzdsdzkxYzR3Wkc5dlJSMkg5VFdYOE5QaDdENE4wdjdSZEtrbXNYS2p6NUJ5STE2K1dwOUIzUGMrd0ZkNVFJS0tLS0FDaWlpZ0Fvb29vQUtLS3lQRUhpZlNQQzlnYnZWcnhJRS9nWHE4aDlGVWNrMEFhOWNCNHorSytpZUZoSmEyN0RVTlVYajdQRTN5eG4vYmJvUG9NbjZWNXZyM3hLOFVlUGRRT2krRmJTNXRyZVQ1ZGtKL2ZTTDZ1NDRSZm9meHJxdkJmd1NzdE84dSs4U3NsOWRmZUZxcFBrb2Y5cnU1L1Q2MERPS3R0TDhiL0FCZnYwdXJ5VXdhV3JmTEk2bGJlUC9ybW5WejcvclhzdmhENGQ2RjRPaUQya1BuM3hHSHZKZ0RJZllkbEhzUDFycTQ0MGhqV09ORlJFRzFWVVlBSG9CVHFCQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUllbGZDMnUvOGpEcWYvWDNMLzZHYSs2VDByNFcxMy9rWWRUL0FPdnVYLzBNMEFmWVB3Mi81Sng0ZS82OFkvNVYxTmNIOFB2RUdrV25nM3c1cGx6cVZyRGV0cDBVaXd5U0JXWlRrREdldlN1N3lDTTU0b0FXaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpbXlTSkZHMGtqcWlLQ3pNeHdBQjFKTmVMZU92allrSmswN3dxVmtjZks5KzY1VWY5Y3dldis4ZVBRR2dEMDd4SjR4MFB3cGJlZHExOGtUa2ZKQ3Z6U3lmN3FqbjhlbGVLK0pmanByTitYZzBLM1RUb0R4NTBnRWt4SC9vSy9yWGwxNWUzT29YY2wzZTNFdHhjU0hMeXlzV1p2cVRYWmVGZmhUNGo4VHFseVlScDlnM0l1TGtFRng2cW5VL1U0RkF6a05RMUsrMWE0TStvM2s5M0tlZDg4aGMvcjBwbHJaWGQrK3l6dFo3bC9TR05uUDZDdnBYUVBnMTRWMFpVZTZnZlZMa2RYdXpsTSt5RGdmam11OXRyUzNzNFZodG9JNFlsNkpHZ1VEOEJRRno1SmkrSC9pK2RReWVHOVN3ZW02SGIvUEZSM1BnZnhYWm9YbjhPNmtxRHF3dHl3SDVacjdBeFJpZ0xueEZKRThUbUtXTmtjZFVkY0VmZ2E2SHczNDc4UStGWlZPbTZoSjVBUE50TVM4VGY4QlBUNmpGZlZHc2VITkgxK0F3NnJwMXZkcGpBTWlBc1BvM1VmZ2E4ZThZL0F4NEVlODhMU3ZLQmtteG5iNXYrQU9ldjBiODZBdWRuNEgrTEdrK0syU3l1d05QMVU4Q0YyeWtwLzJHNy9ROC9XdlFxK0pab1pyUzVlR2FPU0dlSnRySTRLc2pEc1IxQkZlNGZDNzRzUGRTUTZCNGpuek0yRXRiMXo5ODlrYyt2bzNmb2Vlb0ZqMnFpaWlnUVY4Ny9FYlhMejRnK083WHd2b3plWmEyODNrcGo3cnkvd0FjaC8yVkdSK0I5YTlTK0tQaXcrRmZCOHoyNzdiKzh6YjIzcXBJNWY4QTRDT2ZyaXVVK0JuaEVXbW1UZUpidVA4QWYzWU1kcnU2ckVEeTMvQWorZzk2Qm5wZmhydy9aK0dOQnRkSnNsL2RRcnk1R0RJeCs4eDl5YTFxS0tCQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFSWE50RGVXc3R0Y1JyTERLaFNSR0dReWtZSU5mTmx4YVA4SS9pbkJPOFBuNmNHTHhNeTVKZ2ZnNFA5OWVudmozcjZZcmgvaXA0U0hpcndqTDVFZTdVTExNOXNRT1d3UG1UOFIrb0ZBSFoyMXhGZDIwVnhBNnlReW9IUjFPUXlrWkJINFZMWGtYd004Vm5VTkhtOE8zTW1ackVlWmI1Nm1FbnAvd0FCSi9JaXZYYUFDaWlpZ0FvcHJ1a2FNN3NGVlJrc1RnQVY1NzRoK012aGZSSGVHMmxrMU81WGdwYVlLQSs3bmo4czBBZWlVeVdhT0NKcFpwRmpqUVpaM09BbzlTVDByNTYxTDQ5K0lMaG1HbjZkWTJrWlBIbWJwV0g0NUEvU3VOOFIrUGZFZmlxRllOVXZ5MXV2UGtSS0k0eWZVZ2ZlL0dnZGoxcnhuOGJyV3lNbGo0WFZMeTQrNmJ4d2ZLVS83STZ1ZjArdGMxNGYrR0hpWHh4ZmpXdkZkM2MyMEV2elptNW5rWDBWVHhHdjFINFZ6bnc5OFhhQjRWdnhjYXBvQnZKOTJVdlZrM1BDUDltTnVQeEJ6WDBkNGU4VjZMNG90ZlAwaS9pbndNdkhuRHAvdktlUlFCTG9QaHZTZkROZ3RucE5sSGJ4L3dBUkF5em4xWnVwUDFyVm9vb0VGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFJZWxmQzJ1LzhqRHFmL1gzTC82R2ErNlQwcjRXMTMva1lkVC9BT3Z1WC8wTTBBZTZXbndqajhZK0Q5RDFlSFZwTGU4ZlRZRTh1YUlQRmhWd0FNWUkvV3N0dkMzeFI4REVuVExpNXViVk9jV2MzblI0L3dDdWJjajhCWHNQdzIvNUp4NGUvd0N2R1A4QWxYVTBBZUM2WDhkOVgwK1lXdmlIUlVsZGVHTVdZSlI3bEc0L2xYb09pZkZ2d2hyVzFQN1IreFR0eDVWNnZsLytQZmRQNTExT3E2RnBXdHdHSFU5UHRydENQK1cwWVlqNkhxUHdyejNXdmdWNGN2dHo2WlBkYWJJZjRWYnpZLzhBdmx1ZjFvQTlPaG5pdUlsbGhrU1NOaGtPakJnZnhGU1Y4OFMvREg0ZytFSld1UEQxKzA2RG4vUXB6R3hIdkczQituTlNXdnhpOFkrSEp4YStKTkxXWXJ3ZlBoYTNsL1BHMC9sUUI5QjBWNXhvdnhzOEthbnRTOGtuMHlZOVJjcGxNLzc2NUg1NHJ2YkhVckxVN2NUMk4zQmN3bm84TWdjZnBRQmFvb29vQUtLS0tBQ3FXcTZ0WTZKcHMyb2FqY3BiMnNJeThqbjlCNm4wRk0xcldyRHcvcFUrcGFsY0xEYlFqTE1lcFBZQWR5ZXdyNWM4ZCtQTlE4YTZwNWtwYURUNG1QMmExQjRYL2FiMVkrdmJvUGNBMC9pRDhUNy9BTVlUUFoydSswMFpUOHNPY05ON3lmOEF4UFFkODF5V2g2RHFmaVRVMDAvU3JWN2k0Yms0NFZCL2VZOUZIdld2NEo4QzZuNDExTHlyVWVUWlJFZmFMdGx5c1k5Qi9lYjIvT3Zwend6NFcwcnducGEyR2wyNFJlc2tqY3ZLMzk1ajNQNkR0UU01SHdUOElkSjhOaU84MU1SNmxxWTUzT3Y3cUkvN0NucWY5bzgvU3ZTS0tLQkJSUlJRQVVVVVVBRkZGRkFIQS9FYjRhMm5qR3phOHRBbHZyTVMvdTV1Z2xBL2dmOEFvZW8rbkZmTXQ1WjNPbjNrMW5lUXZEY1F1VWtpY1lLa2RqWDJ4WG5ueE0rR3NQaSswKzM2ZXFRNjFDdUVZOExPby9nYjM5RDIrbEF6bnZoVDhVaGZMRDRlMStmRjJNSmFYVWgvMXc3SXgvdmVoNy9YcjdKMnI0bHVMZWV5dXBMZTRpa2h1SW1LU1J1TnJJdzZnanNhOWk4SWZHaDdidzNlV1d1TzBsL2JXek5aM0pHZlBZRDVVZjhBMnM0NTc5K2VvRmpOOGZYVS93QVFQaXpiZUg3UnliYTJrK3lLVjZEdk0vNFl4L3dFVjlCMmRwQllXVUZwYklJNElJMWpqUWRsQXdCWGlId0cwVjdyVWRVOFIzSUxzbitqeHV3NnUzelNINjlQenIzYWdRVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBZk9QaVNGL2huOFlZdFV0MUtXRThuMmtLdlF4T2NTcCtCeWZ5cjZMaWtTYUpKSTJESTZobFlkQ0QwTmVaZkhIUUJxWGc1TlVqVE0ybXk3MlAvQUV5YjVXL1hhZndOYVh3ZzE0NjE0QnRZNVgzWEZneHRKTW5uQzhxZisrU1B5b0E3NnVQOGFmRWJSZkJrSmp1SCswNmd5NWpzNGlOM3NXUDhJOXorQU5jWjhSZmpFbW50TnBIaG1SWkxzRXBOZWpESkVlNFRzemUvUWU5ZUR6enkzTThseGNTdkxMSXhlU1NSc3N4N2trOWFCMk9sOFdmRURYdkY4ckM5dVREWmsvTFp3RXJHUHIvZVB1ZnlGYzdaMlYxcUYzSGFXVnZMY1hFaHdrVVNsbWI2QVYyM2d6NFU2MzRxTWQxT3JhZHBqYy9hSlUrZVFmN0NIcjlUZ2ZXdm9Md3Y0TTBUd2phZVRwZHFGa1lZa3VKUG1saytyZjBHQlFCNGZwSHdNOFRYOGF5WDA5bnB5bitDUmpJLzVMd1B6cmJrL1o2dUJFVEY0amlNbU9BOW1RUHpEMTdyUlFGejVROFRmREx4TjRYRHkzRm45cXRGNU56YVpkUVA5b1kzTCtJL0d1VnM3eTVzTHFPN3M3aVNDNGpPVWxoZmF3K2hGZmJKQVBXdk92R253ajBieEtzdDNwNnBwdXBuTGVaR3Y3dVEvd0Myby9tT2ZyUUZ6bC9BZnhyTXNrV20rS2lxazRXUFVGR0JuL3BvTzMrOE9QVURyWHRhT3NpSzZNR1Zoa0VISUlyNHkxclJOUjhQYXBMcDJwMjdRWE1mVUhrTU96S2U0UHJYby93cytLRGFGSkZvZXVUazZXeDJ3VHR5YlkraC93QmorWDA2QVdQb2lpa1IxZEE2TUdVaklJT1FSUzBDQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQVE5SytGdGQvNUdIVS8rdnVYL3dCRE5mZEo2VjhMYTcveU1PcC85ZmN2L29ab0Erd2ZodC95VGp3OS93QmVNZjhBS3Vwcmx2aHQvd0FrNDhQZjllTWY4cTZtZ0Fvb29vQUtyM2RoYWFoQ1lieTJodUlpTUZKVURqOGpWaWlnRHp6Vy9neDRTMVFNOXJiUzZiT2VqV2o0WFA4QXVISS9MRmNEZS9CYnhWb1Z3YnJ3M3F5VHNweXZseU5iUy84QXhKL092b0dpZ0Q1M2krSXZ4RzhHU0xEcjFsSmNRcngvcDBCR2ZwS3ZCK3ZOZGpvdng0MEM4MkpxdHBjNmU1NnVCNTBmNWpuOUs5VWtpamxqYU9SRmRHR0NyRElQNFZ4MnQvQ3J3aHJiUEpKcGkya3pkWmJNK1VjL1FmS2Z4RkFIUTZUNGkwYlhZaEpwZXAydDJ2cEZLQ1I5UjFINDFINGo4UzZYNFcwcDlRMVM0RVVRNFJCeThqZjNWSGMxODQrUHZCMm1lQ05RalRUdkVodWIzT2ZzMnpFMFE5UzZuQStod1RYSTZocXVvNnE4VGFoZlhGMjBTYkl6UElYS3I2RE5BN0c5NDQ4ZGFqNDIxUHpyak1GbEVUOW10RmJJUWVwOVdQcitBcVR3RjRDdnZHMnFiRjNRYWRDUjlwdWNkUDhBWlgxWS9wMU5YZmgvOE5OUThaWEMzVSsrMDBkVDg5d1I4MHVPcXg1Ni93QzkwSHVhK2w5SjBpeDBQVFlkUDA2M1MzdG9SaFVYK1o5U2U1NzBBSm8rajJHZzZaRHAybTI2d1cwSXdxcjM5U1QzSjdtcjFGRkFncHJ5SkdoZDJDcW95U3h3QUs1enhoNDQwandaWWVkZnk3N2h3Zkp0WXlESktmcDJIdWVLOEx1OVQ4Yi9BQmMxRjRMV0p4WUszTU1iRkxlSWY3Ykg3eCt1ZllDZ0QyclVmaWg0TTAyWXd6YTdieVNLY0ZZQTB1UHhVRWZyVXVtL0Vud2Zxc2l4VzJ2MmdsYm9reE1SUC9mWUdhNEhTUDJmN1JZVmJXZGFua2xJNWpzMENLdjRzQ1QrUXArcGZzL2FlOFRmMlpyZDFFK09GdW8xa1UvWGJ0TkF6MlJYVjFES3daU01nZzVCcGErZXJiVHZpVDhMNWZNdG9uMURTMU9YamlKbWhJLzNmdko5UUs5WThGZkVIU1BHbHJpM2I3UGZ4ak0xbklmblgzSDk1ZmNmamlnUjF0RkZGQUJSUlJRQjU1OFNQaG5iZUw3WTMxZ0V0OWFpWEN5SGhad09pUDhBMGJ0OUsrYTc2eHV0TnZacks5Z2t0N21GdHNrVWd3eW12dGV1TzhkZkR6VFBHdGxtUUMyMUtOY1FYYUxrai9aWWZ4TDdkdTFBN25rM3dyK0o5dDRZZ1hROVhpVk5QZVV1bDBpOHhNeDUzanV2djFIdU9uME5CUERkUUpQYnlwTERJb1pKRVlNckE5Q0NPb3I0ODhSK0dkVjhLNm0xanF0c1luNU1jZzVTVWYza2J1UDFIZXRyd1I4UjlYOEZ6Q0tNbTYweG16Slp1M0E5U2gvaFA2SHVPOUFIMWJSV0g0WThXYVI0dDAwWG1sM0FmR0JMRTNFa1I5R1h0OWVoN1Z1VUNDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS1IzVkVMdXdWUU1razRBRkFGTFdiS0RVdEZ2cks1S2lDNGdlTnl4d0FDcEdUWHlOWStJZFcwVFROUzBpeHZURmIzakJiaG9qeTRUSTRic0NEempxSzc3NHBmRkZ0ZWtsMFBSSml1bHFkczg2bkJ1VDZEL1kvOUMrblh6clE5RDFEeEhxME9tNlpibWE0bFAwVkY3c3g3QWV0QXlEVGROdk5YMUNHdzArMmU0dXBqdGppakhKL3dBOWVncjZHOERmQjdTOUJTSysxcEk5UTFNWVlLM01NSi93QmtmeEVlcC9BQ3VoOEMrQWRPOEZhZHRpQW4xQ1ZSOW91MlhsdjlsZjdxajAvT3V1b0M0Z0FBd09sTFJVYzh5Vzl2Sk5JMjJPTlM3SDBBR1RRSW82enIraytIclVYT3I2aGIyY0pPRmFad054OUFPcFAwck4wcjRnZUU5YXVCYjJHdldjazU2Uk0vbHMzMERZSnFyb25obUsvdlc4UzY5YkxjYXBjak1NY3k3bHNvZjRZMEI0RFk1WTlTU2ExZFk4S2FGcjFvMXRxV2wyczZIb1RHQXkrNFljZy9TZ0Raem1pdk1ibGZFWHd5YjdSQkpjNjc0VlgvQUZrTWgzWE5rdnFyZnhxUGY5T3RkOW91dDZmNGgwdUxVZE11VXVMYVVjTXZVSHVDT3hIb2FBTVh4ejRIc1BHdWtHM21BaXZZZ1RiWFFHVEczb2ZWVDNIOWErVzliMFRVUER1clRhYnFVQmh1WVR5T29ZZG1VOTFQclgyZFhLK09QQXVuZU5kSzhpNC9jM2tRSnRycFJsb3o2SDFVOXgvV2daNUQ4TVBpbzJnbUxSTmRsWjlMSkN3M0RISnR2WStxZnkrbGZRMGNpVFJySkU2dWpBTXJLY2dnOUNEWHh0NGc4UDZsNFoxYVRUdFRnTVU2Y3FSeXNpOW1VOXdmL3dCZGR6OE1QaWZONFpuajBqVjVXazBaMndqbmsycFBjZjdIcU8zVWR4UUI5SlVVMk9SSlkxa2pkWFJnR1ZsT1FRZWhCcDFBZ29vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FROUsrRnRkLzVHSFUvK3Z1WC9BTkROZmRKNlY4TGE3L3lNT3AvOWZjdi9BS0dhQVBzSDRiZjhrNDhQZjllTWY4cTZtdVcrRzMvSk9QRDMvWGpIL0t1cG9BS0tLS0FDaWlpZ0Fvb3JnZkdmeFgwVHdxSHRZR0dvYW1PUHM4TGZMR2Y5dHVnK25Kb0E3YSt2N1RUYk9XN3ZiaUszdDRodWVTVmdxcVBxYThOOGMvR3lhN0VtbitGdDhFUFJyOXhoMi82NXFmdWozUFBzSzg1OFVlTXRhOFgzZm5hcGRGbzFPWXJhUDVZby9vdnI3bm1tK0dQQ0dzK0xyNzdQcFZxWFJUaVc0ZjVZb3Y4QWViMTloelFPeGpFeTNNK1NaSnBwWDZuTE03SDlTVFhzbmdINEx5WEJpMVB4VkdZNHVHajAvT0diM2tJNkQvWkhQcjZWMzNnajRZYVA0UFJibGdMM1ZNZk5kU3I5ejFFYS93QUk5K3Z2WGMwQmNqaGdpdG9FaGdqU09LTlFxSWlnQlFPZ0FIUVZKUldYcnZpTFN2RGRnMTdxMTVIYlFqcHVPV2MraXFPV1BzS0JHcFhsL2o3NHYySGg0VGFkb3BqdmRUSHl0Sm5NTUI5ei9FM3NQeE5jZHJuajd4VDhSNzZUUmZDZGxjVzlrZUpHUTRrWmZXUitpTDdBOCtwcnN2QS93YzAzdzg4Vi9yRFI2anFLNFpWMi91WVQvc2cvZVB1ZnlGQXpqdkNQdzAxanh2cUgvQ1JlTHA3aGJhWTd3am5FMXdPMys0bnArZ0hXdmR0UDA2ejBteGlzckMyaXQ3YUlZU09OY0FWYW9vRUZGRkZBQlhKNi93REQ3UjladWwxRzNFbW1heEcyK0xVTEk3SkEzcXc2TVBYUFd1c29vQTU3U2RVMUswa1RUZkVVY1MzWDNZYjJFWWh1dncvZ2YvWlA0RTl1aHBrc1VjMFpqbFJYUTlWWVpCcDlBQlJSUlFBVVVVVUFabXUrSDlNOFNhYTlocXRxbHhBM0l6d3lIKzhwNmcrNHI1ejhlZkN6VS9DTFNYdHJ2dnRJem56d1BuaEhwSUIyL3dCb2NldUsrbjZhNkxJaFIxREt3d1FSa0VVQWZHV2phM3FQaC9VbzlRMHU2ZTJ1VS9pWG93OUdIUWoyTmZTWHcrK0p0aDR5aFd6dUFscHJDTGxyZmQ4c29IVm95ZXYwNmozNjF4dnhGK0RnSW0xZnd0RGc4dk5wNjlENm1MLzRuOHZTdkZJcFo3UzVTV0o1SVo0WDNLeWtxeU1EMUhjRVVEM1B0cWl2S3ZobDhWWS9FSWowYlhKRWoxYjdzVTMzVnVmYjJmMjc5dlN2VmFCQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVjREOFd2aWIvYU1rM2h6UTUvOURRbGJ1NWpiL1hFZFVVLzNSM1BmcDA2Ni93QVh2aVViUlp2RE9pVC9BT2tNTnQ3Y0lmOEFWZy84czFQOTQ5ejJISFhwNGpwMm5YZXJhaEJwOWhBMDkxT3dTT05lNS9vUGZzS0JvbTBUUkwveERxMEdtYWJBWmJtWTRBNkJSM1pqMlVkelgxTjRIOEQ2ZjRLMGdXOXVCTGVTZ0c1dWlQbWtiMEhvbzdEK3RRZkQvd0FCMmZnclNObnl6YWxPQWJxNUE2bis2dm9vL1hyWFlVQUZGRkZBZ29vb29BS0tLS0FFWlF5bFdBSVBCQnJ5UHhKb21wZkRUVnBQRlhoYU15YVBLMmRTMHNFN0ZIOTlSMkhYbitIM0hBOWRwcm9zaU1qcUdWaGdxd3lDUFEwQVpmaDN4RnAzaWpSb2RUMDJYZkRKd3luaG8yN3F3N0VWclY0ZHJsaHFId2Y4VkRYZEZqZVh3M2ZPRnViUUhpTS8zZmJ2dFA4QXdFMTdGbzJzV092YVZiNmxwMHdtdHAxM0l3NmoxQkhZZzhFVUFabmpId2RwM2pMUjJzcjFka3laYTN1Rkh6d3Q2ajFIcU85ZkttdmFGZmVHOVp1TkwxR1BaY1FOakkrNjY5bVU5d1JYMmJYbkh4ZjhHTDRqOE9IVXJTTE9wYWVwZGRvNWtpNnNuOVI3ajNvR2ptZmdsNDVhUWY4QUNLNmpMa29wYXdkajJIV1A4T285c2pzSzl0cjRuc3IyNDA2K3Q3MjBsTWR4Qklzc1Rqc3c1QnI2KzhKK0lyYnhWNGJzOVd0c0R6VXhKSG4vQUZjZzRaVDlEK21LQVp0VVVVVUNDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBcm5mRlhqWFJQQjlxSmRVdWNTdU14VzhZM1N5ZlJmVDNPQlhMZkVQNHNXZmhoWk5OMGt4M2VyNHczT1k3YytyWTZ0L3Mvbml2blhVTlJ2Tld2NXI3VUxtUzR1Wmp1a2xrT1NmOEI3ZEJRT3g2VHIvd0FjL0VGL0l5YVBCQnBzSFFNd0VzcEh1VHdQd0ZjZGNlUGZGdDA1YVh4SHFXVDJXYllQeVhGYi9oSDRSYS80bmhTN3VOdW1XRGpLeXpxUzhnOVZUMDl6ajhhOUpzL2dMNGFpaXhkWG1wWEVuZGhLc1kvSUNnRHgyeStJM2pHeGtWb3ZFTjYyRG5iTXdsVS9nd3J6Kzd1SmJtOG5ubFlHU1dSbllnWXlTY212cHZVUGdGb2NxazZmcWwvYXYyODNiS3Y1WUIvV3ZtZS90RGFhbGRXeGNNWVpuakxBWXpoaU0vcFFCOWwvRGIva25IaDcvcnhqL2xYVTF5M3cyLzVKeDRlLzY4WS81VjFOQWdvb3JQMWpYTk0wQ3lhODFXOWh0WUIvRkkyTW4wQTZrK3dvQTBLd2ZFM2pIUlBDVnI1MnEzaXh1d3pIQW56U3lmUmY2bml2SXZGM3h6dXJvU1dmaG1BMjBSNE41T3VaRC91cjBYNm5KOWhYa04zZDNGOWN5WFYzUEpQUEljdkxLNVptK3BOQTdIb1BqSDR3NjM0aTh5MDAwdHBlbk5rRlkyL2ZTRC9hY2RCN0wrWnJ6eUMzbXU3aU9DM2hrbW1rYkNSeHFXWmlmUURyWGMrRC9oUnIzaWt4M0U2SFR0T2JuejUwTzV4L3NKMVAxT0I5YTk5OEtlQk5DOElXNFhUclVHNUl4SmRTL05LLzQ5aDdEQW9BOHI4Ri9BK2U0TWQ3NHFab0l1R1d4aWI1Mi8zMkhUNkRuM3IyL1Q5T3M5S3NvN093dG9yYTJpR0VpaVhhb3ExUlFJS2JKSWtVYlNTT3FJb3l6TWNBRDFKcmovRjN4SzBQd21UYlBJYjNVendsbGJIYytlMjQvd0FQOC9RVnhuL0NOZU9QaVpJSnZFbHdkRDBRbksyRVFPOXg3cWY1dC8zelFCb2VLZmpGQkhjblNmQ05xMnJhazUyTElpbG93ZjhBWkE1Yy9UQTk2eWRIK0UrdWVLTlFYV2ZIbW96RjI1Rm9qZ3ZqKzZTUGxRZXkvblhwdmh2d2RvZmhTMThuU3JKSW5Jdzg3Zk5KSi92TWVmdzZWdlVBVWRLMGJUdERzVXN0TXM0clczVG9rYTQ1OVQzSjl6VjZpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0NGcnUzVzdXMWFlTVhEb1hXSXVONVVjRWdkY1ZOV2RxK2hhZHJ0dXNWL2JpVFlkMGNnSldTSnY3eU9PVlB1RFhOeWFwclBnb2dheTB1cTZFRGorMGxUTTlxUCtteWo3Ni83YWpJN2p2UUIydGVXL0V6NFZRK0lrbDFqUlkwaDFjRGRKRVBsVzYrdm8vdjM3K3RlbVd0MWIzMXJGZFdzMGMwRXFobzVJMkRLd1BjRVZOUUI4U1NSejJseTBjaVNRend2aGxZRldSZ2Z6QkJyNkErRm54VEd0Q0xRdGVtQTFJRGJiM0xkTGtmM1cvMi93RDBMNjFvZkU3NFl3K0tiZDlWMHBFaTFtTmVSMEZ5by9oYi9hOUQrQjl2bStTT2EwdVdqa1dTR2VGOE1yQXF5TUQrWUlOQTl6N2JvcnlmNFdmRkVhOGtXaGE1TUJxaWpFRTdjQzVBN0gvYkg2OWV1YTlZb0VGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVjV2OFZQaUl2aFhULzdNMDJVSFdibE9DT2ZzNkgrTSs1N0Q4ZTFhL2oveDdaZUN0SkxaU2JVNWxJdHJiUFgvQUcyOUZINjlCWHkxcU9vM1dxNmhjYWhmVHROY3p1WGtrYnVmNkRzQjJGQTBSSWsxMWNCRVdTYWVWOEFETE03RS9xU1RYMHo4TVBoMUY0UTA3N2Rmb3I2emNyKzhicUlGL3dDZWFuK1o3bjJGWUh3ZitIUDluUXgrSmRZZ3hlU0xtemhjY3dvZjR5UDd4SFQwSHVlUFlhQVlVVVVVQ0NpaWlnQW9vb29BS0tLS0FDaWlpZ0NycVduV21yNmRjYWZmUXJOYlhDRkpJMjZFR3ZETlB2ZFIrREhqVjlOdm1sbjhOM3pGMGZHY0RwdkgrMnZBWWR4ejZWNzdXRDR2OEsyUGkvUVpkTnZCdGI3OE13R1doa0hSaC9VZHhRQnRXODhWMWJ4M0VFaXlSU0tIUjBPUXlua0VIMHFTdkQvaDM0b3Z2QkhpRi9BL2ljK1ZEdjIya3pINVVKUEFCUDhBeXpic2V4NCtudUZBSHkxOFV2QmIrRS9FMGt0dkVScGQ4eGx0MkE0UTlXai9BQVBJOWo3VlU4Qi9FRFVQQkY4NWlUN1RwODVCbnRXYkdTUDRsUFp2MFBmMUgwOXJ1aGFkNGowbWJUZFR0MW10cGV4NEtuc3luc1I2MTgrK0svZ3ZyMml5dk5wQ25WYkxxQkdBSmxIdXZmNmo4cUJucitoL0Zid2pyYW9CcWFXYzdkWWIzOTBRZnFmbFA1MTJNTnhEY3hpU0NXT1ZEMFpHREQ5SytLTG0zbXRKbWd1b1pJSlY0TWN5RkdINEhtcExTK3ZOUGNQWlhVOXMzckJJeWZ5TkFXUHRmSW9yNVEwLzRwZU05T3dJOWJsbVVmdzNLTEtQMUdhNmV6K1BuaUtFQmJ2VGRPdVFPcFVQR1QrcEZBV1BvaWl2RW9QMmhJaUI5bzhPU0E5ekZkQS96VVZjSDdRV2s3ZWREMURQcDVrZitOQWoyR2l2RXJyOW9TTGFSYWVIWkMzWXpYSUEvSUthNURXL2pQNHMxZEdpdDVvTk5pUEdMUkR2L3dDKzJ5ZnlBb0hZK2dkZThYYUY0WmkzNnRxVUZ1eEdWakozU045RkhOZU8rT1BqWkxxTnMxaDRZV2ExaWNZa3ZKQnRrSTlFSDhQMVBQcGpyWGtFMDBrOHpUVHlOSks1eTBrakZtWSs1UEpycHRCK0hmaW54RTBiV21sVFIyN24vajR1UjVVWUhyenlmd0JvQ3h6Y01NOTVjcERESEpOUEsrMVVRRm1kajJIY212ZS9oMzhIb2RNOHJWdkVzYVRYd3cwVm1jTkhDZXhic3plM1FlNXJxUEFudzEwdndaQ0p6aTcxVmx4SmR1dU51ZXFvUDRSK3A3K2xkdlFGd3hpaWlpZ1FoNlY4TGE3L0FNakRxZjhBMTl5LytobXZ1azlLK0Z0ZC93Q1JoMVAvQUsrNWYvUXpRQjlnL0RiL0FKSng0ZS82OFkvNVZ2NmpxZGxwTm05NXFGMURiVzZETFNTdUZBcnc4L0ZhWHdqNEowRFJkT3NGbHY4QSt5NEpXbm5QN3RBeW5HRkhMSDhoWGx1dCtJZFg4UjNuMnJWcithNmtIM1E1K1ZQWlZIQS9BVURzZXcrTGZqdEZIdnRmQzl2NXJkUHR0eXVGK3FwMVAxT1BwWGpPcmF6cVd1M3pYbXFYczEzY0grT1ZzNEhvQjBBOWhWM3c3NFIxenhWYytUcE5pOHlnNGVadmxpVDZ1ZVB3R1RYdC9oTDRKYVJwT3k1MTExMVM3R0Q1V0NJRVArNzFmOGVQYWdEeHZ3dDRDMS94ZElwMDYwSzJ1Y05kemZMRXYwUDhSOWhtdmVQQ0h3ajBId3lZN3E2WCswdFJYQjg2ZGZrUS93Q3duUWZVNU5kOUZGSERHc2NTS2thakNxb3dBUFFDbjBDdUZGQk9CbXVUMUR4UmZhaFBKcC9oT3pqdnJoU1ZsdnBpVnRMYzk4c09aR0g5MWZ4SW9BMmRkOFE2VjRiMDlyN1ZyeU8yZ0hRc2VXUG9vNmsrd3J6NlhWZkdueERieTlDaGs4UGFBL0J2N2tZdUpsLzJGN0Q2Zm5YUmFUOFByU1BVQnEvaUc1azEzV0J5czkwdjd1SDJqais2by9XdXhBQUdCUUJ5bmhUNGQ2RDRTeE5hd0c0dno5Kzl1Zm5rSjc0N0wrRmRaUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJTRlF3SUlCQjRJTkxSUUJ3VjlwV29lQnJxWFZ2RGtEM09qU01aTDdSMDZ4K3N0dU94N2xPaDdWMStrYXZZNjdwY0dvNmRjTFBhekxsSFgrUkhZanVEVjZ1QjFyU0w3d2ZxYy9pWHczYnROWnluZnFta3g5SlIzbWlIYVFkeC9GUUIzMWVZZkZINFpKNG1nZlY5SWpWTllpWDUwSEF1bEhZL3dDMTZIOEQyeDZCbzJzMkd2NlZCcVdtM0N6MnN5NVZsN2VvSTdFZENLdjBBZkVoRTFwY2tFU1F6eFAwNVZrWUg4d1FhK2lmaGI4VDA4Undwb3VzU3F1cnhyaU9VOEM1VWY4QXM0N2p2MUhlbWZGUDRZTDRnaWsxdlJZbFhWa0daWVY0RjBvSC9vWTdIdjBQYXZua0dhMHVReW1TR2VKK0NNcXlNRCtZSU5BOXo3Ym9yeVg0YS9GcUhXRWgwZnhCTWtPcERDUTNMRUtseDdIMGY5RDI5Szlhb0VGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVkS0FDdUIrSVh4TXNQQjF1MXBiYkxyV0hYNUlNL0xGbm8wbm9QUWRUOU9hNS93Q0kzeGZoMHZ6dEk4TnlwTmZjckxlRERKQWZSZXpOK2c5elhnY3NzOTVjdkxOSkpOUE0rNW5ZbG1kaWVwN2ttZ2RpZlZkVnZkYTFLYlVOUnVYdUxxWTVlUnorUUhvQjJIYXZWdmhUOExudnBZUEVPdlcrMjBVaDdTMWtITXA3T3cvdTl3Ty9YcDEwUGh0OEh6RzBPdGVLTGY1aGg0TlBjZEQyYVFldit6K2ZwWHRnQUF3T2xBWEZvb29vRUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBY2Y0L3dEQVZsNDIwcll4V0RVWUZQMmE1eDAvMlc5VlA2ZFJXTDRPOFY2cm9lazNtbWVOYlM2dDVkS0NBMy9sdEpITEV4Mmhpd0hPTzdlbkp4elhwVklWREFnaklQVUdnQ0sxdTdlK3RZcnExbWptZ2xVUEhKR3daV0I3Z2lwcWh0TE8yc0xaYmEwZ2lnZ1RKV09KUXFqSnljQWU1SnAwOHF3UVBLd2RsUlN4Q0tXWWdlZ0hKK2dvQWd2dE1zTlRpOHEvc3JlNmovdXpSQngrb3JrTlIrRUhnelVNbit5emF1ZjRyV1ZvL3dCTWtWMTlqcWRqcWNKbXNycUtkQWNFeHRuYWZRanFEN0dyZEFIalYvOEFzKzZmSms2ZnJ0MUNleTNFS3lqOHh0TmN6ZWZBWHhKQ0MxcmY2YmNEc0N6eGsvbXBINjE5RjBVQmMrWEp2ZzU0M2h6alRJWlI2eDNTSCtaRlZEOEt2RzRPUDdBbS93Qy9zZjhBOFZYMWRSZ1VEdWZMZHY4QUIzeHZPUm5TNG9SNnkzS0QrUk5kTnBYd0IxU1YxYlZ0WXRyZVBxVnRrTXJmVExZQS9XdmZxS0F1Y2Q0YStHUGhud3c2VFc5bDlwdTEvd0NYbTZQbU9EN2RsL0FWMk5JU0ZCSk9BTzljNXJVMnU2b2xwRDRhdUxPSzB1RkxUYW96Q1h5bHlNQ05Cd3pIbms4REZBald1ZFdzclMrdDdHV1lHN3VEKzdoUUZuSTd0Z2RGSGRqeFY2c25RL0R0am9NTGlEekpybVk3cmk3dUczelR0NnN4L1FkQjJGYTFBQlJSUlFBaDZWOExhNy95TU9wLzlmY3Yvb1pyN3BQU3ZoYlhmK1JoMVA4QTYrNWYvUXpRQjZEY2VGZGI4VVhtaXc2UnA4cyszUmJJUExqYkdueUg3ekhnZno5cTlNOEtmQXpUYkRaZGVJcC83UW42L1pvOHJDcDkrNy9vUGF1MCtHMy9BQ1RqdzkvMTR4L3lycWFBSWJhMXQ3TzNTM3RZSTRZWXhoSTQxQ3FvOWdLbW9vb0FLS0tLQUlMeXpndjdaN2E1VGZDLzNreVFHSG9jZHZhcElZWXJlSklvWTBqalFiVlJGQUNqMEFIU24wVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBZWQ2N3BHbytDZFVuOFRlR2Jkcml3bWJmcXVrcDBmMW1pSFp4M0hldXgwSFg5TjhTYVZGcVdsM0t6MjhnNmpobFBkV0hZajByVHJ6THhKNFMxZnd2cXN2aW53T28zdjhBTmY2Vi93QXM3a2QyVmV6ZXc1OVBRZ0hwdGVZZkVyNFZRK0poSnEyanFrR3NBWmREd2x6OWZSdlJ2ejlhNkx3YjhRdEc4WXc3TGQvczJvSVAzdGxNY1NLUjF4L2VIdVB4eFhXMEFmRTk1WlhXbjNjdHBlMjhsdmNSTnRraWxYYXluM0ZlaGVEdmpGclBoMk9PeTFKVHFlbnB3b2RzVFJqL0FHVy9pSHMzNTE3ZjR0OEI2SjR4dDl1b1creTZWY1JYY1B5eUorUGNleDRyd254UDhIdkVtZ05KTlp4ZjJyWkRrU1d5L3ZBUDlxUHIrV2FCbnVYaDc0aitGL0VnVmJUVTQ0cmh2K1hlNVBsU1o5QUR3ZndKcnE4aXZpSjQyamthS1JHVjFPR1JoZ2o2ZzlLM2RJOGJlSnRDMmpUdGF1NDQxNlJPL21KLzN5MmFBc2ZZRkZmUFdrZkh2VzdYYW1xYWJhWHFkM2lKaGY4QXF2NkN1NzBuNDMrRk5RMnJlRzUwNlE5ZlBqM0lQK0JMbWdSNlZSVkRUZGMwcldJeEpwdW8ydDJwR2YzTXF2ajZnZEt2NUZBQlJSUlFBVVUxNUVqUm5kMVZGR1N6SEFIMU5lZWVLZmpINGQwQVNRV0xqVmIwY0JMZGg1YW4vYWs2ZmxrMEFkN2ZYMXJwdG5MZVh0eEhiMjhRM1BKSXdWVkh1YStmL2lGOFlMbld4THBYaDk1YmJUamxaTG43c2s0OUIzVmYxUHQwcmlmRlhqWFcvR0YxNXVwM1A3bFRtSzFpeXNVZjBIYys1eWFiNFY4SGF4NHcxRDdOcGx2KzdVanpybVRpT0llNTlmWWMwRHNaT242ZmQ2cmZRMk5oYlNYRnpNZHNjVVl5VC9nUGZvSytpdmgzOEtMVHd3c1dwNnNJN3JXTVpVZFk3ZjJYMWIvYS9LdWg4RmVBZEo4RjJPeTFYenIyUVludkpCODcrdy91cjdEOGMxWjhZZUw3SHdocFAycTVCbXVaVDVkcmFSL2ZuazdBRDA2WlBiNjRvQVBGWGloZEFnZ3RiU0g3WHJOODNsV05tRHpJL3dEZWIwUmVwUHBXOWIrZDltaSswRkRQc0htR1BPM2RqbkdlMmE0M3dWNFp2NHJtYnhQNGxLeTYvZkxqWjFXemk3Uko2ZTVydHFCQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBR0RySGhIVGRYbisxano3SFVBUGx2YktReFRENmtjTVBaZ1JYTzNMZkVYdzZTWVBzUGllelhzNmkydVFQdytWdnlyMENpZ0R6S1A0MGFYWnpmWnZFT2phdG85eU9xelFibC9QZy9wWFEyWHhMOEczKzN5dkVGbWhQYVpqRWYvSGdLNk85MCt6MUdIeWIyMWh1WXY3azBZY2ZrYTR6VS9nNzRNMUlzeTZjOW01L2l0SlNuL2p2SS9TZ0RyYmZYTkt2RGkyMUt6bXowOHU0UnY1R3Jva1J1aktmb2E4VnYvd0JudTJiY2RQMTZWUDdxM051ci9xcEg4cXg1UGdSNG5oLzQ5dFpzR1h0KzhsalA2Q2dEMytXNWdnUXZMTkhHbzZsbkFBL091WTFuNGxlRXREUmpjYXpielNBZjZtMWJ6blB0aGVCK0pGZVFENEVlS3AzL0FIK29hYVA5cHBaSC93RFphM05LL1orQ3VyYXRyaFpBZVk3U0hibi9BSUUzK0ZBeksxMzRpZUlmaVJxS2VHL0RkckphV2x5ZHI4L3ZIVHV6c09FUURxQjE2WjdWN2o0ZTBhSHc5NGZzZEp0em1PMWhXTU5qRzRqcWZ4T1RWZnc1NFMwWHdwYUczMGl5U0hkL3JKRDgwa24rOHg1TmJkQWdvb29vQUtLS0tBRVBTdmhiWGY4QWtZZFQvd0N2dVgvME0xOTBucFh3dHJ2L0FDTU9wLzhBWDNML0FPaG1nRDdCK0czL0FDVGp3OS8xNHgveXJxYTViNGJmOGs0OFBmOEFYakgvQUNycWFBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FDaWlpZ0R6bngxOExMWHhET2RZMGFZYWJyaUhlSlVKVkpXSGRzY3EzKzBPZlhOY2xwZnhVOFNlRHI5ZEg4YjZiTk1FNEZ3b0FsMit2OEFka0h1TUd2YzZ6dFowSFMvRU5pMW5xdGxGZFFIb3NpOHFmVlQxQjl4UUJXMER4Ym9maWFBUzZUcU1Od2NmTkhuYkluMVU4aXRxdkRQRVB3T3ZyRzUrM2VFdFJmY256SkJOSVVrVS83TWcvcmo2MWoyL3dBUy9IM2dxNFd6OFFXcjNDTHh0djQ5ckVlMHE4SDY4MEFlNTYxNFYwTHhDbTNWZEt0Ym80d0hkQnZIMFljajg2ODkxYjRDYUZkYm4welVMdXhjOUZmRXlmcmcvclZ2UnZqbDRhdjlxYWxGZGFaS2Vwa1R6SS8rK2w1L1N1OTB6WDlJMW1JU2FicVZwZEtmK2VNb1lqNmpxS0FQbjNWL2dmNHAwL0xXVFdtcFI5UjVUK1cvL2ZMZjBKcmhkVDBEV05FY3JxZW1YZG9SM2xpSVgvdnJwK3RmWnVSU1BHa2lGSFZXVThGV0dRZndvSGMrSkkzZUtRU1JPeU9Pam9jRWZpSzZQVHZpRjR1MHNBVzJ2M3UwZEZsY1NqL3gvTmZSK3FmRFh3aHErNXJuUTdaSkQveTB0d1ltK3VWeFhJMy9BTUE5QW1KTmxxV29XcDlHS3lnZm1BZjFvQzU1NUY4YlBHa1l3OXpaUys3Mmd6K2hGTXVQalI0MW5RcXQ5YXdaN3hXcTUvWE5kWEorejVOdVBsZUlVMi83ZHFjL28xUGcvWjhPOGZhUEVKMi85TXJYbjlXb0RROG0xYnhMcm11bi9pYWF0ZDNhNXpza2xPei9BTDVISDZWVTAvVGIzVmJwYlhUN1NhNm5QU09GQ3gvVG9QclgwVnBYd084S1dMSzkzOXMxQngxRTB1MUQvd0FCUUQrZGQ5cG1qNmJvMXNMZlRiRzN0SWY3a01ZVUg2NDYwQmM4VThJZkF1ZVl4M2ZpaWZ5WStvc29HeXgvMzNIQStnL092YnRPMHl5MGl4aXN0UHRZcmEyaUdFamlYYUIvOWYzcVdlNGd0WUhtdUpvNG9rR1dlUmdxcVBjbnBYbGZpWDR2aTR1eG92Z3EyYlU5U21PeExnSm1OVC9zZy9lK3B3bzk2QkhYK05QSFduZURySWVibTUxR2JpMnNvemw1U2VCMDZEUGY4c21zVHdiNFAxRzcxYi9oTC9HQkUyc3lEL1JiVWo1TEpPd0E3Ti9MNjAvd1I4T20wcTdQaUR4SmNIVXZFVTN6TkxJMjlZUFpjOVQyejI2REE2K2hVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFoNlY4TGE3L3dBakRxZi9BRjl5L3dEb1pyN3BQU3ZoYlhmK1JoMVAvcjdsL3dEUXpRQjlnL0RiL2tuSGg3L3J4ai9sWFUxOHphR3VyRFFkUEVQaWZYSUkvczZiWW9ya0tpREhRRGJ3SzBNYTMvME4zaUgvQU1DeC93REUwQWZSTkZmTzJOYi9BT2h1OFEvK0JZLytKb3hyZi9RM2VJZi9BQUxIL3dBVFFCOUUwVjg3WTF2L0FLRzd4RC80RmovNG1qR3Qvd0RRM2VJZi9Bc2YvRTBBZlJORmZPMk5iLzZHN3hEL0FPQlkvd0RpYU1hMy93QkRkNGgvOEN4LzhUUUI5RTBWODdZMXYvb2J2RVAvQUlGai93Q0pveHJmL1EzZUlmOEF3TEgvQU1UUUI5RTBWODdZMXY4QTZHN3hELzRGai80bWpHdC85RGQ0aC84QUFzZi9BQk5BSDBUUlh6dGpXLzhBb2J2RVAvZ1dQL2lhTWEzL0FORGQ0aC84Q3gvOFRRQjlFMFY4N1kxdi9vYnZFUDhBNEZqL0FPSm94cmYvQUVOM2lIL3dMSC94TkFIMFRSWHp0alcvK2h1OFEvOEFnV1AvQUltakd0LzlEZDRoL3dEQXNmOEF4TkFIMFRSWHp0alcvd0RvYnZFUC9nV1AvaWFNYTMvME4zaUgvd0FDeC84QUUwQWZSTkZmTzJOYi93Q2h1OFEvK0JZLytKb3hyZjhBME4zaUgvd0xIL3hOQUgwVFJYenRqVy8raHU4US93RGdXUDhBNG1qR3QvOEFRM2VJZi9Bc2YvRTBBZlJORmZPMk5iLzZHN3hEL3dDQlkvOEFpYU1hMy8wTjNpSC9BTUN4L3dERTBBZlJORmZPMk5iL0FPaHU4US8rQlkvK0pveHJmL1EzZUlmL0FBTEgvd0FUUUI5RTBWODdZMXYvQUtHN3hELzRGai80bWpHdC93RFEzZUlmL0FzZi9FMEFmUk5GZk8yTmIvNkc3eEQvQU9CWS93RGlhTWEzL3dCRGQ0aC84Q3gvOFRRQjlFMFY4N1kxdi9vYnZFUC9BSUZqL3dDSm94cmYvUTNlSWY4QXdMSC9BTVRRQjlFMFY4N1kxdjhBNkc3eEQvNEZqLzRtakd0LzlEZDRoLzhBQXNmL0FCTkFIMFRVRjFaMjE5QTBGM2J4VHhOMWpsUU1wL0ExOCs0MXYvb2J2RVAvQUlGai93Q0pveHJmL1EzZUlmOEF3TEgvQU1UUUI2THJmd1k4SmFxV2t0cmVYVFpqL0ZhUGhjLzdoeVB5eFhCYW44QmRiczVETm8rcTIxeVY1VVNCb0pQKytoa1ZYeHJmL1EzZUlmOEF3TEgvQU1UUmpXLytodThRL3dEZ1dQOEE0bWdDcUkvaTM0VSs2TllhSlA3dUxxUDh2bXF6YS9IUHhYcDdpTFVyQ3huWWRSTEU4RC96L3BTNDFzZjh6ZDRoL3dEQXNmOEF4TlZOUXM5UXU3YVFYZmlQV2JsUXBPMmVaSEg2cFFNNjJ5L2FDc25BRjlvTnpHZTVnbVZ4K3VLM3JYNDRlRUp3UE5lK3R5ZXZtV3BJSDRybXZscVFPSkhIblNjTWU5TitmL250SitkQUgxekg4WGZBN2ova05xbisvYnlqL3dCbHBKZmkvd0NCNHdjYTBILzNMZVUvK3kxOGovdlArZTBuNTBmdlArZTBuNTBBZlVGNzhkdkMxdUQ5bGcxQzdiL1poQ0Q4Mklya05XK1B1cTNBTWVrYVJiMnU3aFh1SE1yL0FJS01EUDUxNGQ4Ly9QYVQ4NjZyd05ienpYMXpKRHFWN2F5eG9Dc2x1NmhoejZrSEg0VUFkdlplRXZpQjhTYmhKOWF1Ym1Dd0ozZVplQW9nSCt4Q01aL0lEM3IybndoNEYwYndiYWVYWVFsN3B4aWE3bHdaSlB4N0QySDYxNDVqVy84QW9idkVQL2dXUC9pYU1hMy9BTkRkNGgvOEN4LzhUUUkraWFLK2RzYTMvd0JEZDRoLzhDeC84VFJqVy84QW9idkVQL2dXUC9pYUFQb21pdm5iR3QvOURkNGgvd0RBc2Y4QXhOR05iLzZHN3hEL0FPQlkvd0RpYUFQb21pdm5iR3QvOURkNGgvOEFBc2YvQUJOR05iLzZHN3hEL3dDQlkvOEFpYUFQb21pdm5iR3Qvd0RRM2VJZi9Bc2YvRTBZMXY4QTZHN3hELzRGai80bWdENkpvcjUyeHJmL0FFTjNpSC93TEgveE5HTmIvd0NodThRLytCWS8rSm9BK2lhSytkc2EzLzBOM2lIL0FNQ3gvd0RFMFkxdi9vYnZFUDhBNEZqL0FPSm9BK2lhSytkc2EzLzBOM2lIL3dBQ3gvOEFFMFkxdi9vYnZFUC9BSUZqL3dDSm9BK2lhSytkc2EzL0FORGQ0aC84Q3gvOFRSalcvd0RvYnZFUC9nV1AvaWFBUG9taXZuYkd0LzhBUTNlSWYvQXNmL0UwWTF2L0FLRzd4RC80RmovNG1nRDZKb3I1MnhyZi9RM2VJZjhBd0xIL0FNVFJqVy8raHU4US93RGdXUDhBNG1nRDZKb3I1MnhyZi9RM2VJZi9BQUxIL3dBVFJqVy8raHU4US84QWdXUC9BSW1nRDZKb3I1MnhyZjhBME4zaUgvd0xIL3hOR05iL0FPaHU4US8rQlkvK0pvQStpYUsrZHNhMy93QkRkNGgvOEN4LzhUUmpXLzhBb2J2RVAvZ1dQL2lhQVBvbWl2bmJHdC85RGQ0aC93REFzZjhBeE5HTmIvNkc3eEQvQU9CWS93RGlhQVBvbWl2bmJHdC85RGQ0aC84QUFzZi9BQk5HTmIvNkc3eEQvd0NCWS84QWlhQVBvbWl2bmJHdC93RFEzZUlmL0FzZi9FMFkxdjhBNkc3eEQvNEZqLzRtZ0Q2Sm9yNTJ4cmYvQUVOM2lIL3dMSC94TkdOYi93Q2h1OFEvK0JZLytKb0EraWFLK2RzYTMvME4zaUgvQU1DeC93REUwWTF2L29idkVQOEE0RmovQU9Kb0EraUQwcjRXMTMva1l0VC9BT3Z1WC8wTTE3Q28xdmNQK0t2OFE5Zitmc2YvQUJOZUozdTc3ZmM3cEhkdk5mTE1jbGprOG4zb0EvL1pcIlxyXG5cdF1cclxufSJdfQ==
